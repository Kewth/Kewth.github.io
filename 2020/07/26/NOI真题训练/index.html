<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="KIx9DF_OoeyQmEhcVAbjH5vg_i539tmILHmNH8lRDtw">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kewth.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="真题训练，不依靠外力做题，多写几个部分分，研究高效得分方法。 以下评测分数以 loj 提交为准（冒泡排序除外）。分数统计仅代表极限水平，并不代表真实水平，不供参考。 NOI2017 0 + 76 + 100 + 70 + 100 + 88 + 20 &#x3D; 454 集训队线 438 。 整数 看完题就有了一个压位的平方暴力的思路，码了码 WA 在了减法的情况，改对后得到了 56 分，本来对照数据表以为">
<meta property="og:type" content="article">
<meta property="og:title" content="NOI真题训练">
<meta property="og:url" content="https://kewth.github.io/2020/07/26/NOI%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/index.html">
<meta property="og:site_name" content="KeBlog">
<meta property="og:description" content="真题训练，不依靠外力做题，多写几个部分分，研究高效得分方法。 以下评测分数以 loj 提交为准（冒泡排序除外）。分数统计仅代表极限水平，并不代表真实水平，不供参考。 NOI2017 0 + 76 + 100 + 70 + 100 + 88 + 20 &#x3D; 454 集训队线 438 。 整数 看完题就有了一个压位的平方暴力的思路，码了码 WA 在了减法的情况，改对后得到了 56 分，本来对照数据表以为">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-26T13:59:33.000Z">
<meta property="article:modified_time" content="2021-03-29T08:01:49.978Z">
<meta property="article:author" content="Kewth">
<meta property="article:tag" content="noi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kewth.github.io/2020/07/26/NOI%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>NOI真题训练 | KeBlog</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="KeBlog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">KeBlog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">The OI Algorithm Blog of Kewth</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#noi2017"><span class="nav-number">1.</span> <span class="nav-text">NOI2017</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9A%AF%E8%9A%93%E6%8E%92%E9%98%9F"><span class="nav-number">1.2.</span> <span class="nav-text">蚯蚓排队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%B3%E6%B1%A0"><span class="nav-number">1.3.</span> <span class="nav-text">泳池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%88%8F"><span class="nav-number">1.4.</span> <span class="nav-text">游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%94%AC%E8%8F%9C"><span class="nav-number">1.5.</span> <span class="nav-text">蔬菜</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%BA%AB%E6%9C%AF"><span class="nav-number">1.6.</span> <span class="nav-text">分身术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noi2018"><span class="nav-number">2.</span> <span class="nav-text">NOI2018</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">归程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97"><span class="nav-number">2.3.</span> <span class="nav-text">你的名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB"><span class="nav-number">2.4.</span> <span class="nav-text">屠龙勇士</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%85%E6%8A%A5%E4%B8%AD%E5%BF%83"><span class="nav-number">2.5.</span> <span class="nav-text">情报中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="nav-number">2.6.</span> <span class="nav-text">多边形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noi2019"><span class="nav-number">3.</span> <span class="nav-text">NOI2019</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%AE%B6%E8%B7%AF%E7%BA%BF"><span class="nav-number">3.1.</span> <span class="nav-text">回家路线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="nav-number">3.2.</span> <span class="nav-text">机器人</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97"><span class="nav-number">3.3.</span> <span class="nav-text">序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B9%E8%B7%B3"><span class="nav-number">3.4.</span> <span class="nav-text">弹跳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%97%E4%B8%BB%E5%9C%B0"><span class="nav-number">3.5.</span> <span class="nav-text">斗主地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i-%E5%90%9B%E7%9A%84%E6%8E%A2%E9%99%A9"><span class="nav-number">3.6.</span> <span class="nav-text">I 君的探险</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#end"><span class="nav-number">4.</span> <span class="nav-text">End</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kewth"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Kewth</p>
  <div class="site-description" itemprop="description">HNFMS 退役 OIer</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Kewth" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Kewth" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Kewth.K.D@outlook.com" title="E-Mail → mailto:Kewth.K.D@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="qq:1344205350" title="QQ → qq:1344205350" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.luogu.org/space/show?uid=52232" title="Luogu → https:&#x2F;&#x2F;www.luogu.org&#x2F;space&#x2F;show?uid&#x3D;52232" rel="noopener" target="_blank"><i class="fas fa-code-branch fa-fw"></i>Luogu</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links | 友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="/" title="&#x2F;">欢迎互换友链呀</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daniel-yuan.github.io/" title="https:&#x2F;&#x2F;daniel-yuan.github.io&#x2F;" rel="noopener" target="_blank">Daniel_yuan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/lsq147/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lsq147&#x2F;" rel="noopener" target="_blank">xiaolilsq</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/imakf/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;imakf&#x2F;" rel="noopener" target="_blank">Imakf</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/evenbao" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;evenbao" rel="noopener" target="_blank">Even_bao</a>
        </li>
    </ul>
  </div>

        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kewth.github.io/2020/07/26/NOI%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 退役 OIer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NOI真题训练
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-26 21:59:33" itemprop="dateCreated datePublished" datetime="2020-07-26T21:59:33+08:00">2020-07-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-29 16:01:49" itemprop="dateModified" datetime="2021-03-29T16:01:49+08:00">2021-03-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>

</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>真题训练，不依靠外力做题，多写几个部分分，研究高效得分方法。</p>
<p>以下评测分数以 loj 提交为准（冒泡排序除外）。分数统计仅代表极限水平，并不代表真实水平，不供参考。</p>
<h2 id="noi2017">NOI2017</h2>
<p>0 + 76 + 100 + 70 + 100 + 88 + 20 = 454</p>
<p>集训队线 438 。</p>
<h3 id="整数">整数</h3>
<p>看完题就有了一个压位的平方暴力的思路，码了码 WA 在了减法的情况，改对后得到了 56 分，本来对照数据表以为只有 30 分左右。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read;</span><br><span class="line">    read.operator int(), read.operator int(), read.operator int();</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">32</span>;</span><br><span class="line">    ull FULL = (<span class="number">1llu</span> &lt;&lt; B) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> o = read;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ix = read, k = read;</span><br><span class="line">            <span class="keyword">if</span> (ix &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ull x = ull(ix);</span><br><span class="line">                x &lt;&lt;= k % B;</span><br><span class="line">                k /= B;</span><br><span class="line">                <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                    data[k] += x;</span><br><span class="line">                    x = data[k] &gt;&gt; B;</span><br><span class="line">                    data[k] &amp;= FULL;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ull x = ull(-ix);</span><br><span class="line">                x &lt;&lt;= k % B;</span><br><span class="line">                k /= B;</span><br><span class="line">                <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                    data[k] -= x;</span><br><span class="line">                    x = data[k] &gt;&gt; B;</span><br><span class="line">                    <span class="keyword">if</span> (x)</span><br><span class="line">                        x = (<span class="number">1llu</span> &lt;&lt; B) - x;</span><br><span class="line">                    data[k] &amp;= FULL;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = read;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, data[k / B] &gt;&gt; (k % B) &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冷静下来后发现可以类似于 odt 维护二进制位相同的连续段，把修改每一位拆开考虑就可以两个 <span class="math inline">\(\log\)</span> 维护，得到了 68 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = -- <span class="built_in">set</span>.upper_bound(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> k2 = *it &gt;&gt; <span class="number">1</span>, x = *it &amp; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (k == k2) <span class="keyword">return</span> it;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>.insert(k &lt;&lt; <span class="number">1</span> | x).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modi</span> <span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = find(k), q = p;</span><br><span class="line">	<span class="keyword">while</span> ((*q &amp; <span class="number">1</span>) == t) ++ q;</span><br><span class="line">	<span class="keyword">auto</span> r = find((*q &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> tmp = *p, tmq = *q;</span><br><span class="line">	<span class="built_in">set</span>.erase(p, r);</span><br><span class="line">	<span class="built_in">set</span>.insert(tmp ^ <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">set</span>.insert(tmq ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read;</span><br><span class="line">	read.operator int(), read.operator int(), read.operator int();</span><br><span class="line">	<span class="built_in">set</span>.insert(<span class="number">0</span> &lt;&lt; <span class="number">1</span> | <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> o = read;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read, off = read;</span><br><span class="line">			<span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">					<span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						modi(off + k, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				x = -x;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">					<span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						modi(off + k, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">auto</span> p = find(read);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p &amp; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后没什么思路了，感觉应该还是要压位，但是维护连续段后似乎难以直接压位？想到 <code>std::insert</code> 可以提供 <code>hint</code> 做到 <span class="math inline">\(O(1)\)</span> ，于是写了个带 <code>hint</code> 的版本，得了 76 分。（代码略）</p>
<p>然后发现两个 <span class="math inline">\(\log\)</span> 的瓶颈现在就只在 <code>find</code> 上，由于每次修改拆开后位置相隔很近，事实上 <code>find</code> 也可以给它来个 <code>hint</code> ，每次修改就只需要一次二分，剩下的在之前的基础上暴力跳就好了，复杂度理论上说应该是一个 <span class="math inline">\(\log\)</span> ，但是只有 84 分，本地测了一下最大的点要跑 2.7s 。</p>
<p><del>水讨论发现别人用这个方法直接过了，而且时间还不到 1s ，我 tm 又一次吃了常数的亏。</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>, maxk = <span class="number">30</span>;</span><br><span class="line">ull data[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">bool</span> hint;</span><br><span class="line"><span class="keyword">auto</span> set_hint = <span class="built_in">set</span>.end();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = hint ? set_hint : -- <span class="built_in">set</span>.upper_bound(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (hint) &#123;</span><br><span class="line">		<span class="keyword">while</span> (it != <span class="built_in">set</span>.end() <span class="keyword">and</span> (*it &gt;&gt; <span class="number">1</span>) &lt;= k) ++ it;</span><br><span class="line">		-- it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k2 = *it &gt;&gt; <span class="number">1</span>, x = *it &amp; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (k == k2) <span class="keyword">return</span> it;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">set</span>.insert(it, k &lt;&lt; <span class="number">1</span> | x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modi</span> <span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = find(k), q = p;</span><br><span class="line">	<span class="keyword">while</span> ((*q &amp; <span class="number">1</span>) == t) ++ q;</span><br><span class="line">	<span class="keyword">auto</span> r = find((*q &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> tmp = *p, tmq = *q;</span><br><span class="line">	<span class="built_in">set</span>.erase(p --, r);</span><br><span class="line">	set_hint = <span class="built_in">set</span>.insert(p, tmp ^ <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">set</span>.insert(set_hint, tmq ^ <span class="number">1</span>);</span><br><span class="line">	hint = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read;</span><br><span class="line">	read.operator int(), read.operator int(), read.operator int();</span><br><span class="line">	<span class="built_in">set</span>.insert(<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">set</span>.insert(<span class="number">0</span> &lt;&lt; <span class="number">1</span> | <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> o = read;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read, off = read;</span><br><span class="line">			<span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				hint = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">					<span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						modi(off + k, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				hint = <span class="number">0</span>;</span><br><span class="line">				x = -x;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">					<span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						modi(off + k, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">/* hint = 0; */</span></span><br><span class="line">			<span class="keyword">int</span> k = read;</span><br><span class="line">			<span class="keyword">auto</span> p = -- <span class="built_in">set</span>.upper_bound(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p &amp; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蚯蚓排队">蚯蚓排队</h3>
<p>刚开始有个启发式合并 + SAM 的想法，但是发现由于 SAM 只能在末尾加字符而不能加在开头，启发式合并是不可行的。</p>
<p>然后发现读错题了，原来询问是在所有串中询问，我还以为是对一个指定的蚯蚓队列进行询问。然后就想到了一个复杂度巨大的暴力，大概是 <span class="math inline">\(O(mk^2\log + cn + n\log + s\log)\)</span> ，预计 40 分，实际 56 分（全 1 的点复杂度瓶颈处少一个 <span class="math inline">\(\log\)</span> ）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> coe)</span> </span>&#123;</span><br><span class="line">	ull shit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = i, k = <span class="number">1</span>; x <span class="keyword">and</span> k &lt; Maxk; k ++, x = pre[x]) &#123;</span><br><span class="line">		shit += ull(a[x]) * po[k - <span class="number">1</span>];</span><br><span class="line">		ull now = shit;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = j, k2 = k + <span class="number">1</span>; y <span class="keyword">and</span> k2 &lt;= Maxk; k2 ++, y = nxt[y])</span><br><span class="line">			<span class="built_in">map</span>[now = now * base + ull(a[y])] += coe;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxk; i ++) po[i] = po[i - <span class="number">1</span>] * base;</span><br><span class="line">	<span class="keyword">int</span> n = read, q = read;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		++ <span class="built_in">map</span>[ull(a[i] = read)];</span><br><span class="line">	<span class="keyword">while</span> (q --) &#123;</span><br><span class="line">		<span class="keyword">int</span> o = read;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> i = read, j = read;</span><br><span class="line">			nxt[i] = j;</span><br><span class="line">			pre[j] = i;</span><br><span class="line">			force(i, j, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> i = read, j = nxt[i];</span><br><span class="line">			force(i, j, <span class="number">-1</span>);</span><br><span class="line">			nxt[i] = pre[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> len = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>)), K = read;</span><br><span class="line">			ull now = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">				now = now * base + ull(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			ll ans = <span class="built_in">map</span>[now];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = K + <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">				now = now * base + ull(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">				now -= ull(s[i - K] - <span class="string">&#x27;0&#x27;</span>) * po[K];</span><br><span class="line">				(ans *= <span class="built_in">map</span>[now]) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只会暴力，上面的算法主要问题是 map 太慢，用数组分摊给它优化一波：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ull B = <span class="number">24</span>, Bl = (<span class="number">1llu</span> &lt;&lt; B) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;ull, <span class="keyword">int</span>&gt; Map[<span class="number">1</span> &lt;&lt; B];</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">map</span> <span class="params">(ull x)</span> </span>&#123; <span class="keyword">return</span> Map[x &amp; Bl][x &gt;&gt; B]; &#125;</span><br></pre></td></tr></table></figure>
<p>本地测最慢跑了将近 3s ，交上去，它过了。。。过了。。。。了。。。</p>
<p>看了看题解，发现这个正解就是把 map 换成哈希表？不会吧不会吧。（不过为什么我完全没有想到用哈希表啊？）</p>
<p>说起来也是，这题 2G 的空间原来是这个意图。。。</p>
<h3 id="泳池">泳池</h3>
<p>显然问题要转换为求最大面积不超过 <span class="math inline">\(K\)</span> 的概率，设随机变量 <span class="math inline">\(H_i\)</span> 表示第 <span class="math inline">\(i\)</span> 列的安全高度，不难得到 <span class="math inline">\(H_i\)</span> 的分布。</p>
<p>一开始想的是 <span class="math inline">\(O(n!)\)</span> 枚举所有 <span class="math inline">\(H\)</span> 的相对大小顺序然后计算，很快发现可以 DP ，设 <span class="math inline">\(f_{n,m}\)</span> 表示考虑 <span class="math inline">\(n\)</span> 列，这 <span class="math inline">\(n\)</span> 列最小值不小于 <span class="math inline">\(m\)</span> 的满足条件的概率，转移枚举最左边的最小值的位置和值即可，这个 DP 不需要任何优化就可以得到 70 分。一开始以为它的复杂度是 <span class="math inline">\(O(n^3)\)</span> 甚至 <span class="math inline">\(O(n^4)\)</span> 级别，冷静分析发现有调和级数，实际上不超过 <span class="math inline">\(O(n^2\log^2)\)</span> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, ll q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (K &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	h[<span class="number">0</span>] = mod + <span class="number">1</span> - q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= K; x ++)</span><br><span class="line">		h[x] = h[x - <span class="number">1</span>] * q % mod;</span><br><span class="line">	<span class="built_in">std</span>::fill(f[<span class="number">0</span>], f[<span class="number">0</span>] + K + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; n ++) &#123;</span><br><span class="line">		<span class="built_in">std</span>::fill(f[n], f[n] + K + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; n * m &lt;= K; m ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = m; n * x &lt;= K; x ++)</span><br><span class="line">					(f[n][m] += h[x] * f[i - <span class="number">1</span>][x + <span class="number">1</span>] % mod * f[n - i][x]) %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[N][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉正解应该是 <span class="math inline">\(O(K^2 \log N)\)</span> 的复杂度，比如常系数齐次线性递推之类的。</p>
<p>或者这个转移看上去很能扯上卷积，正解可能可以用生成函数推导？</p>
<h3 id="游戏">游戏</h3>
<p>这道题学 2-sat 的时候做过了，题目的限制摆明了就是 2-sat ，只有形如 x 的地图不好处理，初看只能 <span class="math inline">\(O(3^d)\)</span> 枚举，但实际上只要随便枚举两种状态就能涵盖所有情况，因此带上个 <span class="math inline">\(O(2^d)\)</span> 就好了。</p>
<h3 id="蔬菜">蔬菜</h3>
<p><span class="math inline">\(x_i = 0\)</span> 的话显然把每个蔬菜的第一个拆出来然后全部排一遍序就行了，数据表上这个做法只有 20 分，但实际上直接这样做就有 44 分。。。i 了 i 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read, m = read, q = read;</span><br><span class="line">	<span class="keyword">int</span> pp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = read, s = read, c = read, x = read;</span><br><span class="line">		p[++ pp] = par(a, c - <span class="number">1</span>);</span><br><span class="line">		p[++ pp] = par(a + s, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + pp + <span class="number">1</span>);</span><br><span class="line">	p[<span class="number">0</span>] = par(<span class="number">0</span>, <span class="number">1000000000</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i ++) &#123;</span><br><span class="line">		ans[i] = ans[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!p[pp].second) -- pp;</span><br><span class="line">			-- p[pp].second;</span><br><span class="line">			ans[i] += p[pp].first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q --) &#123;</span><br><span class="line">		<span class="keyword">int</span> d = read;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[d]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步地，可以把每种蔬菜拆成 <span class="math inline">\(c\)</span> 个单位蔬菜，每个单位蔬菜可以用二元组 <span class="math inline">\((a, T)\)</span> 表示，其中 <span class="math inline">\(a\)</span> 是收益，<span class="math inline">\(T\)</span> 是该蔬菜消失的时间。那么把所有单位蔬菜排序然后暴力贪心，单位蔬菜的数量理论上来说是没有保证的，但神奇的事随便减减枝直接搞就能得到 <span class="math inline">\(p \le 10^3\)</span> 的所有 80 分部分分，结合之前 <span class="math inline">\(x_i = 0\)</span> 的做法可以得到 88 分。</p>
<p>有理有据的做法也是有的，理论上把所有单位蔬菜拿出来不现实，但考虑到需要做的是把单位蔬菜排序，不妨把来源相同的单位蔬菜绑定在一起，用堆维护起来。注意到来源相同的单位蔬菜 <span class="math inline">\(a\)</span> 相同，用 <span class="math inline">\(T\)</span> 最大的单位蔬菜代表这些来源相同的蔬菜。一个非常重要的性质是，如果单位蔬菜 <span class="math inline">\((a, T)\)</span> 无法加入当前答案，那么它永远无法被加入之后的任何一个答案。推广到一些来源相同的蔬菜，如果 <span class="math inline">\(T\)</span> 最大的单位蔬菜无法被加入到当前答案，那么这些来源相同的所有蔬菜都可以扔掉。</p>
<p>这样一来就可以做到 <span class="math inline">\(O((n + pm)\log + (pm)^2)\)</span> 的复杂度，瓶颈部分 <span class="math inline">\(O((np)^2)\)</span> 在于每次暴力添加一个蔬菜到当前答案集合，事实上这个完全可以用数据结构优化，但是感觉也拿不到 <span class="math inline">\(10^5\)</span> 的部分分，所以就写了暴力。</p>
<p>下面的代码是 80 分代码（没有处理 <span class="math inline">\(x_i = 0\)</span> 的部分分）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line">ll ans[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cai</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, c, x, t;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">las</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t) <span class="keyword">return</span> t;</span><br><span class="line">		<span class="keyword">return</span> x ? (c + x - <span class="number">1</span>) / x : <span class="number">1000000000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (cai a, cai b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a.a == b.a ? a.las() &lt; b.las() : a.a &lt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, tim[maxn], tp, minT;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="keyword">return</span> t &gt;= minT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	tim[++ tp] = t;</span><br><span class="line">	<span class="built_in">std</span>::sort(tim + <span class="number">1</span>, tim + tp + <span class="number">1</span>); <span class="comment">// 懒</span></span><br><span class="line">	minT = tp / M * M;</span><br><span class="line">	<span class="keyword">while</span> (minT &gt;= <span class="number">0</span> <span class="keyword">and</span> tim[minT] != minT / M) minT -= M;</span><br><span class="line">	minT = minT &gt;= <span class="number">0</span> ? tim[minT] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">int</span> n = read, m = read, q = read;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;cai&gt; qu;</span><br><span class="line">	M = m;</span><br><span class="line">	qu.push(&#123;<span class="number">0</span>, <span class="number">1000000000</span>, <span class="number">0</span>, <span class="number">1000000000</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = read, s = read, c = read, x = read;</span><br><span class="line">		cai tmp = &#123;a, c - <span class="number">1</span>, x, <span class="number">0</span>&#125;;</span><br><span class="line">		qu.push(tmp);</span><br><span class="line">		++ tmp.c;</span><br><span class="line">		qu.push(&#123;s + a, <span class="number">1</span>, <span class="number">0</span>, tmp.las()&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K * m; i ++) &#123;</span><br><span class="line">		cai tmp = qu.top();</span><br><span class="line">		qu.pop();</span><br><span class="line">		<span class="keyword">while</span> (tmp.c &lt;= <span class="number">0</span> <span class="keyword">or</span> !check(tmp.las()))</span><br><span class="line">			tmp = qu.top(), qu.pop();</span><br><span class="line">		ans[i] = ans[i - <span class="number">1</span>] + tmp.a;</span><br><span class="line">		add(tmp.las());</span><br><span class="line">		<span class="keyword">if</span> (tmp.c &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			-- tmp.c;</span><br><span class="line">			qu.push(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q --) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="keyword">int</span>(read) * m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分身术">分身术</h3>
<p>计算几何啥也不会，暴力求凸包，只能拿 20 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read, q = read;</span><br><span class="line">	ll ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(P[i].x, P[i].y);</span><br><span class="line">	<span class="keyword">while</span> (q --) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = read;</span><br><span class="line">		<span class="built_in">std</span>::fill(mark, mark + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) mark[<span class="number">1</span> + (ans + <span class="keyword">int</span>(read)) % n] = <span class="number">1</span>;</span><br><span class="line">		m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span> (!mark[i]) p[++ m] = P[i];</span><br><span class="line">		<span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, [] (point a, point b) &#123;</span><br><span class="line">					<span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">				&#125;);</span><br><span class="line">		<span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (p1 &gt;= <span class="number">2</span> <span class="keyword">and</span> cross(st1[p1] - st1[p1 - <span class="number">1</span>], p[i] - st1[p1]) &gt;= <span class="number">0</span>) -- p1;</span><br><span class="line">			st1[++ p1] = p[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, [] (point a, point b) &#123;</span><br><span class="line">					<span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &lt; b.x;</span><br><span class="line">				&#125;);</span><br><span class="line">		<span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (p2 &gt;= <span class="number">2</span> <span class="keyword">and</span> cross(st2[p2] - st2[p2 - <span class="number">1</span>], p[i] - st2[p2]) &lt;= <span class="number">0</span>) -- p2;</span><br><span class="line">			st2[++ p2] = p[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (p2) st1[++ p1] = st2[p2 --];</span><br><span class="line">		st1[p1 + <span class="number">1</span>] = st1[<span class="number">1</span>];</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= p1; i ++)</span><br><span class="line">			ans -= cross(st1[i] - st1[<span class="number">1</span>], st1[i + <span class="number">1</span>] - st1[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(k = 1\)</span> 似乎很有性质，预先求出凸包，如果删除的点不在凸包上可以忽略，否则能被新加入的点一定在一个三角形的区域内，而每个不在凸包的点至多属于两个不同的三角形区域，那么可以在每个三角形区域内再求一次凸包。</p>
<p>说是这么说，要实现感觉有点麻烦，咕咕咕。</p>
<p><del>听说这题的 idea 是 picks 出的。</del></p>
<h2 id="noi2018">NOI2018</h2>
<p>0 + 100 + 84 + 100 + 100 + 45 + 15 = 444</p>
<p>集训队线 452 。</p>
<h3 id="归程">归程</h3>
<p>如果允许离线，不难想到可以把边按 <span class="math inline">\(a\)</span> 排序，把询问按 <span class="math inline">\(p\)</span> 排序，预处理个最短路然后不断加边，用并查集维护每个点的答案，可以得到 65 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;return.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;return.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = read, m = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) G[u].clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = read, v = read, w = read, h = read;</span><br><span class="line">			G[u].push_back(&#123;v, w&#125;);</span><br><span class="line">			G[v].push_back(&#123;u, w&#125;);</span><br><span class="line">			e2[i] = &#123;u, v, h&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		dijkstra(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> q = read, K = read, H = read;</span><br><span class="line">		<span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> s = read, h = read;</span><br><span class="line">			qu[i] = &#123;s, h, i&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::sort(e2 + <span class="number">1</span>, e2 + m + <span class="number">1</span>, [] (Edge2 a, Edge2 b) &#123;</span><br><span class="line">					<span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">				&#125;);</span><br><span class="line">		<span class="built_in">std</span>::sort(qu + <span class="number">1</span>, qu + q + <span class="number">1</span>, [] (Query a, Query b) &#123;</span><br><span class="line">					<span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) fa[u] = u;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &lt;= m <span class="keyword">and</span> e2[j].h &gt; qu[i].h) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = find(e2[j].u), v = find(e2[j].v);</span><br><span class="line">				++ j;</span><br><span class="line">				<span class="keyword">if</span> (dis[u] &lt; dis[v]) fa[v] = u;</span><br><span class="line">				<span class="keyword">else</span> fa[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[qu[i].id] = dis[find(qu[i].s)];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强制在线似乎可以直接把加边的过程可持久化，来一手可持久化并查集？</p>
<p>太麻烦了没写，还可以用 kruskarl 重构树，对于询问倍增到重构树上的点，然后求个子树 min 即可，写的时候重构树的点数只开到了 n ，WA 了几次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200005</span>, maxm = <span class="number">400005</span>, maxk = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxk = <span class="number">19</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> v, w; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn + maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge2</span> &#123;</span> <span class="keyword">int</span> u, v, h; &#125; e2[maxm];</span><br><span class="line"><span class="keyword">int</span> fa[maxk][maxn + maxm], top[maxn + maxm], minh[maxn + maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> top[x] == x ? x : top[x] = find(top[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;par&gt; q;</span><br><span class="line">	<span class="built_in">std</span>::fill(dis, dis + n + <span class="number">1</span>, <span class="number">2000000000</span>);</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(par(<span class="number">0</span>, s));</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.top().second, d = -q.top().first;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (d &gt; dis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (Edge e : G[u])</span><br><span class="line">			<span class="keyword">if</span> (dis[u] + e.w &lt; dis[e.v]) &#123;</span><br><span class="line">				dis[e.v] = dis[u] + e.w;</span><br><span class="line">				q.push(par(-dis[e.v], e.v));</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;return.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;return.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = read, m = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) G[u].clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = read, v = read, w = read, h = read;</span><br><span class="line">			G[u].push_back(&#123;v, w&#125;);</span><br><span class="line">			G[v].push_back(&#123;u, w&#125;);</span><br><span class="line">			e2[i] = &#123;u, v, h&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		dijkstra(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::sort(e2 + <span class="number">1</span>, e2 + m + <span class="number">1</span>, [] (Edge2 a, Edge2 b) &#123;</span><br><span class="line">					<span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">				&#125;);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) top[u] = u, minh[u] = <span class="number">2000000000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> np = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = find(e2[i].u), v = find(e2[i].v);</span><br><span class="line">			<span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">			++ np;</span><br><span class="line">			fa[<span class="number">0</span>][u] = fa[<span class="number">0</span>][v] = np;</span><br><span class="line">			fa[<span class="number">0</span>][np] = <span class="number">0</span>;</span><br><span class="line">			top[u] = top[v] = top[np] = np;</span><br><span class="line">			minh[np] = e2[i].h;</span><br><span class="line">			dis[np] = <span class="built_in">std</span>::min(dis[u], dis[v]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = np; x; x --)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; Maxk; k ++)</span><br><span class="line">				fa[k][x] = fa[k - <span class="number">1</span>][fa[k - <span class="number">1</span>][x]];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> q = read, K = read, S = read, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (q --) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read, h = read;</span><br><span class="line">			<span class="keyword">if</span> (K) x = <span class="number">1</span> + (x + ans - <span class="number">1</span>) % n, h = (h + ans) % (S + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = Maxk - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">				<span class="keyword">if</span> (fa[k][x] <span class="keyword">and</span> minh[fa[k][x]] &gt; h)</span><br><span class="line">					x = fa[k][x];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans = dis[x]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序">冒泡排序</h3>
<p>稍加分析，不难发现一个排列 <span class="math inline">\(p\)</span> 是“好”的，当且仅当：</p>
<ul>
<li><span class="math inline">\(\forall j &lt; i \le p_i, p_j &lt; p_i\)</span></li>
<li><span class="math inline">\(\forall j &gt; i \ge p_i, p_j &gt; p_i\)</span></li>
</ul>
<p>直接拿这个写个状压 DP ，可以得到 44 分，代码略。</p>
<p>对于 <span class="math inline">\(q_i = i\)</span> 的情况，打个表不难发现就是卡特兰数，理论上结合上面做法可以得到 56 分，但实际上并没有这样的数据？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;inverse.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;inverse.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = read;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; maxn) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) read.<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line">			ll ans = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">				(ans *= <span class="number">4</span> * i - <span class="number">2</span>) %= mod;</span><br><span class="line">				(ans *= power(i + <span class="number">1</span>, <span class="number">-1</span>)) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">			-- ans;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) p[i] = read - <span class="number">1</span>;</span><br><span class="line">		g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); S ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">-1</span>, max = <span class="number">0</span>, X = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x ++)</span><br><span class="line">				<span class="keyword">if</span> (S &gt;&gt; x &amp; <span class="number">1</span>)</span><br><span class="line">					++ i, max = x;</span><br><span class="line">			<span class="keyword">while</span> (S &gt;&gt; X &amp; <span class="number">1</span>) ++ X;</span><br><span class="line">			f[S] = g[S] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x ++)</span><br><span class="line">				<span class="keyword">if</span> (S &gt;&gt; x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (x &lt;= i) ok &amp;= x &lt; X;</span><br><span class="line">					<span class="keyword">if</span> (x &gt;= i) ok &amp;= x == max;</span><br><span class="line">					<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">						f[S] += f[S ^ (<span class="number">1</span> &lt;&lt; x)];</span><br><span class="line">						<span class="keyword">if</span> (x == p[i]) g[S] += g[S ^ (<span class="number">1</span> &lt;&lt; x)];</span><br><span class="line">						<span class="keyword">if</span> (x &gt; p[i]) f[S] += g[S ^ (<span class="number">1</span> &lt;&lt; x)];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			f[S] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冷静下来，拿上面的性质进一步分析，发现一个排列是“好”的当且仅当它可以划分成两个上升子序列，也等价于最长下降子序列的长度不超过 2 。</p>
<p>这个性质就好用很多，比如可以直接证明不考虑字典序的答案确实是卡特兰数：</p>
<p>设计 DP <span class="math inline">\(f_{i, j}\)</span> 表示 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(i\)</span> 的排列，包含右端点的最大上升子段长度为 <span class="math inline">\(j\)</span> 的“好”排列数，转移新插入一个最大值，不难得到 <span class="math inline">\(f_{i, j} = \sum_{k \ge j-1} f_{i-1, k} = f_{i-1, j-1} + f_{i, j+1}\)</span> ，特别的是 <span class="math inline">\(f_{0,1}=1, f_{i,0}=0\)</span> 。这个时候稍有经验就会知道这个 DP 转移可以放在二维平面上，而 <span class="math inline">\(f_{i,0}=0\)</span> 的限制就是平面上的一条直线，不经过一条直线的路径数恰恰就是卡特兰数。</p>
<p>但是如果从小到大加数的话字典序的比较就难以压缩在状态里，不妨直接枚举 <span class="math inline">\(p, q\)</span> 的 lcp 以及 lcp 后面的一位，然后相当于确定了上述 DP 的一个初始状态，放在二维平面上利用折线法计算即可，可以得到 80 分，结合 <span class="math inline">\(p_i = i\)</span> 的情况理论上有 84 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ll _path (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[x + y] * ifac[x] % mod * ifac[y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">path</span> <span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span> </span>&#123;</span><br><span class="line">	ll tmp = _path(x1 - x0, y1 - y0) - _path(x1 - x0 - <span class="number">1</span>, y1 - y0 + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> tmp &lt; <span class="number">0</span> ? tmp + mod : tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;inverse.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;inverse.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	ifac[N] = power(fac[N], <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i --) ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) p[i] = read;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">set</span>.insert(i);</span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::max(p[i], x) + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">				<span class="keyword">if</span> (!vis[j]) &#123;</span><br><span class="line">					<span class="keyword">int</span> _m = <span class="built_in">std</span>::max(m, j);</span><br><span class="line">					<span class="built_in">set</span>.erase(j);</span><br><span class="line">					<span class="keyword">int</span> k = *<span class="built_in">set</span>.begin();</span><br><span class="line">					<span class="built_in">set</span>.insert(j);</span><br><span class="line">					<span class="keyword">if</span> (k &lt; x <span class="keyword">or</span> (k &lt; j <span class="keyword">and</span> j &lt; m)) <span class="keyword">continue</span>;</span><br><span class="line">					ans += path(_m, i, n, n);</span><br><span class="line">				&#125;</span><br><span class="line">			vis[p[i]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[i] &lt; x) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[i] &lt; m) x = p[i];</span><br><span class="line">			<span class="keyword">else</span> m = p[i];</span><br><span class="line">			<span class="built_in">set</span>.erase(p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans % mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法的瓶颈在于 <span class="math inline">\(O(n^2)\)</span> 枚举字典序的比较情况，再往下优化必然要用更巧妙的方式处理字典序比较，或者干脆抛弃从小到大加数的思路？</p>
<h3 id="你的名字">你的名字</h3>
<p><span class="math inline">\(l = 1, r = |S|\)</span> 的话，把 <span class="math inline">\(s\)</span> 建 SAM ，再把每个 <span class="math inline">\(t\)</span> 也建 SAM ，同时把 <span class="math inline">\(t\)</span> 放进 <span class="math inline">\(s\)</span> 的 SAM 里跑，得到 <span class="math inline">\(t\)</span> 的每个前缀在两个 SAM 里面分别对应的节点，然后在 <span class="math inline">\(t\)</span> 的 SAM 上跳 fail 算贡献即可，可以得到 68 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;name.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;name.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, las = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		las = insert(<span class="number">1</span>, las, s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	tpos[<span class="number">0</span>] = ++ cp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> q = read;</span><br><span class="line">	<span class="keyword">while</span> (q --) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> l = read, r = read, m = <span class="keyword">int</span>(<span class="built_in">strlen</span>(t + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (l != <span class="number">1</span> <span class="keyword">and</span> r != n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		cp = tpos[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">memset</span>(ch[cp], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[cp]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">			tpos[i] = insert(tpos[<span class="number">0</span>], tpos[i - <span class="number">1</span>], t[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="built_in">std</span>::fill(vis + tpos[<span class="number">0</span>], vis + cp + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = <span class="number">1</span>, le = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">while</span> (u <span class="keyword">and</span> !ch[u][x]) u = fa[u], le = len[u];</span><br><span class="line">			<span class="keyword">if</span> (u) u = ch[u][x], ++ le;</span><br><span class="line">			<span class="keyword">else</span> u = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> v = tpos[i], vlen = len[v], flen = vlen;</span><br><span class="line">			<span class="keyword">while</span> (!vis[v]) vis[v] = <span class="number">1</span>, v = fa[v], flen = len[v];</span><br><span class="line">			ans += vlen - <span class="built_in">std</span>::max(flen, le);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个做法推广到任意区间也不难，把 <span class="math inline">\(s\)</span> 的 SAM 节点的 right 集合处理出来，然后每次算贡献的时候查 right 集合在区间内最靠右的点然后得到实际匹配长度即可。但是 right 集合不能显式地建出来，一般有两种方式，一个是离线下来挂在对应位置然后 set 启发式合并，还有一种是线段树合并。后者唯一的缺点是空间开销较大，但是其他地方都很优秀，并且还能支持更多操作。</p>
<p>复杂度 <span class="math inline">\(O(n\log)\)</span> 级别，实现的细节比我想象中的要多，调了一段时间才过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>, maxd = <span class="number">2000005</span>, maxc = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxd];</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"><span class="keyword">int</span> ch[maxd][maxc], fa[maxd], len[maxd], cp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxd];</span><br><span class="line"><span class="keyword">int</span> spos[maxn], tpos[maxn];</span><br><span class="line"><span class="keyword">int</span> seg[maxd];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> lti, rti;</span><br><span class="line">	<span class="keyword">int</span> max;</span><br><span class="line">&#125; pool[maxn * <span class="number">60</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> self pool[now]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++ pp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">int</span> an, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!an) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!now) <span class="keyword">return</span> now = an, <span class="keyword">void</span>();</span><br><span class="line">	pool[newnode()] = self;</span><br><span class="line">	now = pp;</span><br><span class="line">	self.max = <span class="built_in">std</span>::max(self.max, pool[an].max);</span><br><span class="line">	<span class="keyword">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	merge(self.lti, pool[an].lti, L, M);</span><br><span class="line">	merge(self.rti, pool[an].rti, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lain</span> <span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) now = newnode();</span><br><span class="line">	self.max = <span class="built_in">std</span>::max(self.max, p);</span><br><span class="line">	<span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (p &lt;= M) lain(self.lti, L, M, p);</span><br><span class="line">	<span class="keyword">else</span> lain(self.rti, M + <span class="number">1</span>, R, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; L <span class="keyword">or</span> l &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= L <span class="keyword">and</span> R &lt;= r) <span class="keyword">return</span> self.max;</span><br><span class="line">	<span class="keyword">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max(query(self.lti, L, M, l, r), query(self.rti, M + <span class="number">1</span>, R, l, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now = ++ cp;</span><br><span class="line">	len[now] = len[pre] + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(ch[now], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[now]);</span><br><span class="line">	<span class="keyword">while</span> (pre <span class="keyword">and</span> !ch[pre][x]) ch[pre][x] = now, pre = fa[pre];</span><br><span class="line">	<span class="keyword">if</span> (pre) &#123;</span><br><span class="line">		<span class="keyword">int</span> preto = ch[pre][x];</span><br><span class="line">		<span class="keyword">if</span> (len[preto] == len[pre] + <span class="number">1</span>) fa[now] = preto;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> sp = ++ cp;</span><br><span class="line">			len[sp] = len[pre] + <span class="number">1</span>;</span><br><span class="line">			fa[sp] = fa[preto];</span><br><span class="line">			<span class="built_in">memcpy</span>(ch[sp], ch[preto], <span class="keyword">sizeof</span> ch[sp]);</span><br><span class="line">			<span class="keyword">while</span> (pre <span class="keyword">and</span> ch[pre][x] == preto) ch[pre][x] = sp, pre = fa[pre];</span><br><span class="line">			fa[now] = fa[preto] = sp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> fa[now] = rt;</span><br><span class="line">	<span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">		dfs(v, n);</span><br><span class="line">		merge(seg[u], seg[v], <span class="number">1</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;name.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;name.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, las = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		las = insert(<span class="number">1</span>, las, s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		lain(seg[las], <span class="number">1</span>, n, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cp; i ++)</span><br><span class="line">		G[fa[i]].push_back(i);</span><br><span class="line">	dfs(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">	tpos[<span class="number">0</span>] = ++ cp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> q = read;</span><br><span class="line">	<span class="keyword">while</span> (q --) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> l = read, r = read, m = <span class="keyword">int</span>(<span class="built_in">strlen</span>(t + <span class="number">1</span>));</span><br><span class="line">		cp = tpos[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">memset</span>(ch[cp], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[cp]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">			tpos[i] = insert(tpos[<span class="number">0</span>], tpos[i - <span class="number">1</span>], t[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="built_in">std</span>::fill(vis + tpos[<span class="number">0</span>], vis + cp + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = <span class="number">1</span>, le = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">while</span> (u <span class="keyword">and</span> !ch[u][x]) u = fa[u], le = len[u];</span><br><span class="line">			<span class="keyword">if</span> (u) u = ch[u][x], ++ le;</span><br><span class="line">			<span class="keyword">else</span> u = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> R = query(seg[u], <span class="number">1</span>, n, l, r);</span><br><span class="line">			<span class="keyword">while</span> (!R <span class="keyword">or</span> R - l + <span class="number">1</span> &lt;= len[fa[u]])</span><br><span class="line">				u = fa[u], le = len[u], R = query(seg[u], <span class="number">1</span>, n, l, r);</span><br><span class="line">			le = R ? <span class="built_in">std</span>::min(le, R - l + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> v = tpos[i], vlen = len[v], flen = vlen;</span><br><span class="line">			<span class="keyword">while</span> (!vis[v]) vis[v] = <span class="number">1</span>, v = fa[v], flen = len[v];</span><br><span class="line">			ans += vlen - <span class="built_in">std</span>::max(flen, le);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="屠龙勇士">屠龙勇士</h3>
<p>注意到每条龙使用的剑是完全确定的，所有限制都是同余方程，直接 exCRT/exgcd ，但是会爆 long long ，需要非常注意，在特定地方使用快速乘。</p>
<p>还要注意剑的攻击力可能相同，用 <code>std::multiset</code> 存储而不是 <code>std::set</code> 。</p>
<p>出题人的意图可能是要考察选手对代码细节的掌控？反正我是调了好久。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;dragon.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;dragon.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = read, s = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(p[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(aw[i]);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;ll&gt; <span class="built_in">set</span>;</span><br><span class="line">		<span class="keyword">while</span> (s --) <span class="built_in">set</span>.insert(read);</span><br><span class="line"></span><br><span class="line">		ll min = <span class="number">0</span>, B = <span class="number">0</span>, M = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> it = <span class="built_in">set</span>.upper_bound(a[i]);</span><br><span class="line">			<span class="keyword">if</span> (it != <span class="built_in">set</span>.begin()) -- it;</span><br><span class="line">			<span class="keyword">int</span> t = <span class="keyword">int</span>(*it);</span><br><span class="line">			<span class="built_in">set</span>.erase(it);</span><br><span class="line">			<span class="built_in">set</span>.insert(aw[i]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!p[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			ll x, y, g = exgcd(t, p[i], x, y);</span><br><span class="line">			<span class="keyword">if</span> (a[i] % g) <span class="keyword">goto</span> fail;</span><br><span class="line">			ll m = p[i] / g, b = mul(x, a[i] % p[i] / g, m);</span><br><span class="line">			<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b += m;</span><br><span class="line"></span><br><span class="line">			g = exgcd(m, M, x, y);</span><br><span class="line">			ll d = B - b;</span><br><span class="line">			<span class="keyword">if</span> (d % g) <span class="keyword">goto</span> fail;</span><br><span class="line">			d /= g;</span><br><span class="line">			M *= m / g;</span><br><span class="line">			B = (b + mul(mul(x, m, M), d, M)) % M;</span><br><span class="line">			<span class="keyword">if</span> (B &lt; <span class="number">0</span>) B += M;</span><br><span class="line"></span><br><span class="line">			min = <span class="built_in">std</span>::max(min, (a[i] + t - <span class="number">1</span>) / t);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (B &lt; min) &#123;</span><br><span class="line">			ll d = (min - B + M - <span class="number">1</span>) / M;</span><br><span class="line">			B += d * M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, B);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">fail:</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="情报中心">情报中心</h3>
<p>观察了下数据表，意识到这题要拿部分分必须从特殊性质下手。</p>
<p>暴力直接 <span class="math inline">\(O(n^3)\)</span> 该咋枚举咋枚举，15 分。</p>
<p>链的话可以正反来两次扫描线，由于每条边都是非负权值，算入一个的少了边的方案不会影响答案，15 分。</p>
<p><span class="math inline">\(c_i=0\)</span> 就只要考虑路径的代价，枚举每一条边，用 set 启发式合并求出经过每条边最小的两条路径，15 分。</p>
<p>剩下两个 <span class="math inline">\(S_1, S_2\)</span> 实在是写不动了。</p>
<p>大样例确实很给力，但是这部分分必须一个一个写，每个部分分的分值不高，太难受了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FORCE &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">305</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;maxn&gt; bs[maxn], bm[maxn];</span><br><span class="line">	<span class="function">ll <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; u ++) &#123;</span><br><span class="line">			bs[u] = bs[fa[u]];</span><br><span class="line">			bs[u].<span class="built_in">set</span>(si(u));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">			bm[i] = bs[ma[i]] ^ bs[mb[i]];</span><br><span class="line">		ll ans = -inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((bm[i] &amp; bm[j]).any()) &#123;</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;maxn&gt; b = bm[i] | bm[j];</span><br><span class="line">					ll now = - mc[i] - mc[j];</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">						<span class="keyword">if</span> (b.test(si(k)))</span><br><span class="line">							now += fw[k];</span><br><span class="line">					ans = <span class="built_in">std</span>::max(ans, now);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CHAIN &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve[maxn];</span><br><span class="line">	ll s[maxn];</span><br><span class="line">	ll bit[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> n, ll x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = p; k &lt;= n; k += k &amp; -k)</span><br><span class="line">			bit[k] = <span class="built_in">std</span>::max(bit[k], x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		ll res = -inf-inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = p; k; k -= k &amp; -k)</span><br><span class="line">			res = <span class="built_in">std</span>::max(res, bit[k]);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + fw[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ve[i].clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ma[i] &gt; mb[i]) <span class="built_in">std</span>::swap(ma[i], mb[i]);</span><br><span class="line">			<span class="comment">/* mc[i] += s[mb[i]] - s[ma[i]]; */</span></span><br><span class="line">			ve[mb[i]].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> R = <span class="number">1</span>; R &lt;= n; R ++)</span><br><span class="line">			<span class="built_in">std</span>::sort(ve[R].begin(), ve[R].end(), [] (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">						<span class="keyword">return</span> ma[i] &gt; ma[j];</span><br><span class="line">					&#125;);</span><br><span class="line">		<span class="built_in">std</span>::fill(bit, bit + n + <span class="number">1</span>, -inf-inf);</span><br><span class="line">		ll ans = -inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> R = <span class="number">1</span>; R &lt;= n; R ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i : ve[R]) &#123;</span><br><span class="line">				ans = <span class="built_in">std</span>::max(ans, -mc[i] + s[mb[i]] - s[ma[i]] + query(n - ma[i]));</span><br><span class="line">				modify(n - ma[i], n, -mc[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">std</span>::fill(bit, bit + n + <span class="number">1</span>, -inf-inf);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> R = n; R; R --)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i : ve[R]) &#123;</span><br><span class="line">				ans = <span class="built_in">std</span>::max(ans, -mc[i] - s[ma[i]] + query(mb[i] - <span class="number">1</span>));</span><br><span class="line">				modify(ma[i], n, -mc[i] + s[mb[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> C0 &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">20</span>, Maxk = <span class="number">18</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;ll&gt; a[maxn], b[maxn];</span><br><span class="line">	<span class="keyword">int</span> fa[maxk][maxn], deep[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (deep[x] &lt; deep[y]) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = Maxk - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">			<span class="keyword">if</span> (deep[fa[k][x]] &gt;= deep[y])</span><br><span class="line">				x = fa[k][x];</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = Maxk - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">			<span class="keyword">if</span> (fa[k][x] != fa[k][y])</span><br><span class="line">				x = fa[k][x], y = fa[k][y];</span><br><span class="line">		<span class="keyword">return</span> ::fa[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) &#123;</span><br><span class="line">			deep[u] = deep[::fa[u]] + <span class="number">1</span>;</span><br><span class="line">			fa[<span class="number">0</span>][u] = ::fa[u];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; Maxk; k ++) fa[k][u] = fa[k - <span class="number">1</span>][fa[k - <span class="number">1</span>][u]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = n; u; u --) a[u].clear(), b[u].clear();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			a[ma[i]].insert(mc[i]);</span><br><span class="line">			a[mb[i]].insert(mc[i]);</span><br><span class="line">			<span class="keyword">int</span> c = lca(ma[i], mb[i]);</span><br><span class="line">			b[c].insert(mc[i]);</span><br><span class="line">			b[c].insert(mc[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = n; u; u --) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[v].size() &gt; a[u].size()) <span class="built_in">std</span>::swap(a[u], a[v]);</span><br><span class="line">				<span class="keyword">for</span> (ll x : a[v]) a[u].insert(x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (ll x : b[u]) a[u].erase(a[u].find(x));</span><br><span class="line">			<span class="keyword">if</span> (a[u].size() &gt;= <span class="number">2</span>)</span><br><span class="line">				ans = <span class="built_in">std</span>::min(ans, *a[u].begin() + *(++a[u].begin()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		++ Case;</span><br><span class="line">		<span class="keyword">int</span> n = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) G[u].clear();</span><br><span class="line">		<span class="keyword">bool</span> _chain = <span class="number">1</span>, _c0 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a = read, b = read;</span><br><span class="line">			G[fa[b] = a].push_back(b);</span><br><span class="line">			read(fw[b]);</span><br><span class="line">			_chain &amp;= a == b - <span class="number">1</span>;</span><br><span class="line">			_c0 &amp;= fw[b] == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">			read(ma[i], mb[i], mc[i]);</span><br><span class="line">			<span class="keyword">if</span> (ma[i] == mb[i]) -- i, -- m;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans;</span><br><span class="line">		<span class="keyword">if</span> (_chain) ans = CHAIN::main(n, m);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (_c0) ans = C0::main(n, m);</span><br><span class="line">		<span class="keyword">else</span> ans = FORCE::main(n, m);</span><br><span class="line">		<span class="keyword">if</span> (ans == -inf) <span class="built_in">puts</span>(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了看知乎这题现场最高 45 分？</p>
<h3 id="多边形">多边形</h3>
<p>啊这，完全没有思路？想了几个小时都没想出 <span class="math inline">\(K=1\)</span> 的正确做法。认输了，写个爆搜，只有 15 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G[u].empty()) <span class="keyword">return</span> le[++ lp] = u, <span class="keyword">void</span>();</span><br><span class="line">	<span class="built_in">std</span>::sort(G[u].begin(), G[u].end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) dfs(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v : G[u])</span><br><span class="line">			<span class="keyword">if</span> (v == <span class="number">1</span>)</span><br><span class="line">				++ ans;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : G[u])</span><br><span class="line">		<span class="keyword">if</span> (!vis[v])</span><br><span class="line">			force(v, n - <span class="number">1</span>);</span><br><span class="line">	vis[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;polygon.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;polygon.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = read, m = read;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; u ++) G[fa[u] = read].push_back(u);</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; u ++) G[u].push_back(fa[u]);</span><br><span class="line">	<span class="keyword">if</span> (lp &lt;= m * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lp; j ++)</span><br><span class="line">				<span class="keyword">if</span> (j != i)</span><br><span class="line">					G[le[i]].push_back(le[j]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++) le[lp + i] = le[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= i + m; j ++) &#123;</span><br><span class="line">				G[le[i]].push_back(le[j]);</span><br><span class="line">				G[le[j]].push_back(le[i]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	force(<span class="number">1</span>, n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>妈的看来我树论完全不行啊，两道树题都没啥分，CSP 也吃了这个亏。</p>
<p>看了看别人写的题解发现 <span class="math inline">\(K=1\)</span> 竟然是一个被我毙掉的做法，<span class="math inline">\(O(2^3 n)\)</span> 的树形 DP ？</p>
<p>看了看知乎这题现场最高 50 分？（暴力 + <span class="math inline">\(K=1\)</span> ）。</p>
<h2 id="noi2019">NOI2019</h2>
<p>0 + 100 + 60 + 40 + 88 + 70 + 36 = 394</p>
<p>集训队线 477 。</p>
<h3 id="回家路线">回家路线</h3>
<p>不难想到对于路线设计一个 DP <span class="math inline">\(f_i\)</span> 表示使用到第 <span class="math inline">\(i\)</span> 条路线的最小代价。朴素转移要枚举起点上所有的路线。</p>
<p>考虑对于当前从 <span class="math inline">\(p\)</span> 开始的第 <span class="math inline">\(i\)</span> 条路径，如果从一个 <span class="math inline">\(q\)</span> 结束，代价为 <span class="math inline">\(t\)</span> 的路线转移，那么转移要最小化</p>
<p><span class="math display">\[A(p-q)^2 + B(p-q) + C + t\]</span></p>
<p>整理得到</p>
<p><span class="math display">\[(Ap^2 + Bp + C) + (Aq^2 - Bq + t) - (2Aq) p\]</span></p>
<p>第一个括号里面只与 <span class="math inline">\(p\)</span> 有关，后面两个括号只与 <span class="math inline">\(p, t\)</span> 有关，可以发现需要最小化的就是用斜率为 <span class="math inline">\(p\)</span> 的直线截 <span class="math inline">\((2Aq, Aq^2 - Bq + t)\)</span> 得到的截距。</p>
<p>那么用个凸包维护转移即可。</p>
<p>凸包里面要维护点的双端队列，我第一次写的时候在右移左端点的同时还左移了右端点，这么大的错竟然还能得 90 分？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">1005</span>, maxn = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxt = <span class="number">1000</span>, inf = <span class="number">2000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route</span> &#123;</span> <span class="keyword">int</span> s, t, p, q, id; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;;</span><br><span class="line">T <span class="keyword">operator</span> - (T a, T b) &#123; <span class="keyword">return</span> &#123;a.x - b.x, a.y - b.y&#125;; &#125;</span><br><span class="line"><span class="function">ll <span class="title">cross</span> <span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span> * a.x * b.y - <span class="number">1ll</span> * a.y * b.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hull</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; st;</span><br><span class="line">	<span class="keyword">size_t</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">q</span> <span class="params">(T p, <span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> p.y - k * p.x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &gt;= st.size()) <span class="keyword">return</span> inf;</span><br><span class="line">		<span class="keyword">while</span> (b + <span class="number">1</span> &lt; st.size() <span class="keyword">and</span> q(st[b + <span class="number">1</span>], k) &lt;= q(st[b], k))</span><br><span class="line">			++ b;</span><br><span class="line">		<span class="keyword">return</span> q(st[b], k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(T p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> sp = st.size();</span><br><span class="line">		<span class="keyword">if</span> (sp <span class="keyword">and</span> st[sp - <span class="number">1</span>].x == p.x <span class="keyword">and</span> st[sp - <span class="number">1</span>].y &lt; p.y) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (sp &gt;= b + <span class="number">2</span> <span class="keyword">and</span> cross(st[sp - <span class="number">1</span>] - st[sp - <span class="number">2</span>],</span><br><span class="line">					p - st[sp - <span class="number">1</span>]) &lt;= <span class="number">0</span>) st.pop_back(), -- sp;</span><br><span class="line">		st.push_back(p), ++ sp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;route&gt; qu[maxt], ad[maxt];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line">Hull h[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;route.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;route.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = read, m = read, A = read, B = read, C = read;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> s = read, t = read, p = read, q = read;</span><br><span class="line">		qu[p].push_back(&#123;s, t, p, q, i&#125;);</span><br><span class="line">		ad[q].push_back(&#123;s, t, p, q, i&#125;);</span><br><span class="line">		f[i] = inf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ans = inf;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= Maxt; t ++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (route r : ad[t]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r.s == <span class="number">1</span>) f[r.id] = A * r.p * r.p + B * r.p + C;</span><br><span class="line">			<span class="keyword">if</span> (f[r.id] &lt; inf)</span><br><span class="line">				h[r.t].add(&#123;<span class="number">2</span> * A * r.q, A * r.q * r.q - B * r.q + f[r.id]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (route r : qu[t]) &#123;</span><br><span class="line">			f[r.id] = h[r.s].query(r.p);</span><br><span class="line">			<span class="keyword">if</span> (f[r.id] &lt; inf) f[r.id] += A * r.p * r.p + B * r.p + C;</span><br><span class="line">			<span class="keyword">if</span> (r.t == n <span class="keyword">and</span> f[r.id] &lt; inf) ans = <span class="built_in">std</span>::min(ans, f[r.id] + r.q);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人">机器人</h3>
<p>不难想到设计一个区间 DP <span class="math inline">\(f_{l,r,m}\)</span> 表示只考虑区间 <span class="math inline">\([l, r]\)</span> ，所有值不超过 <span class="math inline">\(m\)</span> 的合法方案有多少。转移枚举最靠右的最大值的位置，注意这个位置的数量是 <span class="math inline">\(O(1)\)</span> 的，因此总复杂度 <span class="math inline">\(O(n^2B)\)</span> ，可以得到 50 分。代码略。</p>
<p>对于 <span class="math inline">\(A, B\)</span> 全部相等的情况，不难证明答案是关于 <span class="math inline">\(B - A + 1\)</span> 的 <span class="math inline">\(n\)</span> 次多项式。把 <span class="math inline">\(B - A + 1\)</span> 从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(n\)</span> 的答案都通过上述 DP 算出来再拉格朗日插值即可，结合上述做法可以得到 60 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++) f[i][i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= lim; x ++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; l ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (L[l] &lt;= x <span class="keyword">and</span> x &lt;= R[l]) ++ f[l][l];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> r = l + <span class="number">1</span>; r &lt;= n; r ++) &#123;</span><br><span class="line">				<span class="keyword">int</span> lm = (l + r - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, rm = (l + r + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = lm; i &lt;= rm; i ++)</span><br><span class="line">					<span class="keyword">if</span> (L[i] &lt;= x <span class="keyword">and</span> x &lt;= R[i])</span><br><span class="line">						(f[l][r] += f[l][i - <span class="number">1</span>] * f[i + <span class="number">1</span>][r]) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp[x] = f[<span class="number">1</span>][n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lage</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		ll now = tmp[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j ++)</span><br><span class="line">			<span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">				(now *= mod + W - j) %= mod;</span><br><span class="line">				(now *= power(mod + i - j, <span class="number">-1</span>)) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		res += now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;robot.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;robot.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = read, W = <span class="number">1000000000</span>, test = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(L[i], R[i]), test &amp;= L[i] == <span class="number">1</span> <span class="keyword">and</span> R[i] == W;</span><br><span class="line">	<span class="keyword">if</span> (test)</span><br><span class="line">		dp(n, n), <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lage(n, W));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		dp(n, <span class="number">10000</span>), <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tmp[<span class="number">10000</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列">序列</h3>
<p>第一眼不难想到一个 <span class="math inline">\(O(n^4)\)</span> 的 DP ，设 <span class="math inline">\(f_{i,j,k,p}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个，<span class="math inline">\(a,b,ab\)</span> 分别选了 <span class="math inline">\(j,k,p\)</span> 个，应该可以得到 28 分。</p>
<p>但不难发现如果确定了 <span class="math inline">\(L\)</span> 个 <span class="math inline">\(ab\)</span> 的选择，那么剩下的就是从大到小选，不妨假定 <span class="math inline">\(a\)</span> 单调不增，此时 DP 状态就没必要记录 <span class="math inline">\(j\)</span> 了，可以得到 40 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T = read;</span><br><span class="line">	<span class="keyword">while</span> (T --) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = read, K = read, L = read;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(p[i].first);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(p[i].second);</span><br><span class="line">		<span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="built_in">std</span>::greater&lt;par&gt;());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i <span class="keyword">and</span> j &lt;= L; j ++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j + k &lt;= i <span class="keyword">and</span> k &lt;= K - L; k ++) &#123;</span><br><span class="line">					<span class="keyword">int</span> a = i + L - j &lt;= K ? p[i].first : <span class="number">0</span>;</span><br><span class="line">					f[i][j][k] = f[i - <span class="number">1</span>][j][k] + a;</span><br><span class="line">					<span class="keyword">if</span> (j) chkmax(f[i][j][k], f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] + p[i].first + p[i].second);</span><br><span class="line">					<span class="keyword">if</span> (k) chkmax(f[i][j][k], f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] + a + p[i].second);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n][L][K - L]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更高的分就不会了，写了个假贪心，样例都过不了。</p>
<p>去年同步赛还写了这题 60 分，今年完全想不到 <span class="math inline">\(O(n^2)\)</span> 做法？</p>
<p>正解大概是个模拟费用流吧。</p>
<h3 id="弹跳">弹跳</h3>
<p>题目显然是个最短路模型，需要优化建图，直接用 KDTree 松弛即可，空间线性。但是矩形查询的复杂度是根号的？只能跑 88 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">70005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span> <span class="keyword">int</span> w, L[<span class="number">2</span>], R[<span class="number">2</span>]; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KDT</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> lti, rti;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">2</span>], min[<span class="number">2</span>], max[<span class="number">2</span>];</span><br><span class="line">&#125; pool[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> self pool[now]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lt pool[self.lti]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt pool[self.rti]</span></span><br><span class="line"><span class="keyword">int</span> tmp[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;path&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmp_d;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> pool[a].p[cmp_d] &lt; pool[b].p[cmp_d]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	cmp_d = d; <span class="comment">// <span class="doctag">XXX:</span> 卧槽，这都能忘？</span></span><br><span class="line">	<span class="built_in">std</span>::nth_element(tmp + l, tmp + mid, tmp + r + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">int</span> now = tmp[mid];</span><br><span class="line">	self.lti = build(l, mid - <span class="number">1</span>, d ^ <span class="number">1</span>);</span><br><span class="line">	self.rti = build(mid + <span class="number">1</span>, r, d ^ <span class="number">1</span>);</span><br><span class="line">	self.min[<span class="number">0</span>] = <span class="built_in">std</span>::min(&#123;self.p[<span class="number">0</span>], lt.min[<span class="number">0</span>], rt.min[<span class="number">0</span>]&#125;);</span><br><span class="line">	self.max[<span class="number">0</span>] = <span class="built_in">std</span>::max(&#123;self.p[<span class="number">0</span>], lt.max[<span class="number">0</span>], rt.max[<span class="number">0</span>]&#125;);</span><br><span class="line">	self.min[<span class="number">1</span>] = <span class="built_in">std</span>::min(&#123;self.p[<span class="number">1</span>], lt.min[<span class="number">1</span>], rt.min[<span class="number">1</span>]&#125;);</span><br><span class="line">	self.max[<span class="number">1</span>] = <span class="built_in">std</span>::max(&#123;self.p[<span class="number">1</span>], lt.max[<span class="number">1</span>], rt.max[<span class="number">1</span>]&#125;);</span><br><span class="line">	<span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;par&gt; q;</span><br><span class="line"><span class="keyword">int</span> N, TOT;</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">2</span>], R[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">void</span> _relax (<span class="keyword">int</span> u, <span class="keyword">int</span> di) &#123;</span><br><span class="line">	<span class="keyword">if</span> (di &lt; dis[u]) &#123;</span><br><span class="line">		dis[u] = di;</span><br><span class="line">		q.push(par(-di, u));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relax</span> <span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> di)</span> </span>&#123;</span><br><span class="line">	++ TOT;</span><br><span class="line">	<span class="keyword">if</span> (R[<span class="number">0</span>] &lt; self.min[<span class="number">0</span>] <span class="keyword">or</span> L[<span class="number">0</span>] &gt; self.max[<span class="number">0</span>] <span class="keyword">or</span></span><br><span class="line">			R[<span class="number">1</span>] &lt; self.min[<span class="number">1</span>] <span class="keyword">or</span> L[<span class="number">1</span>] &gt; self.max[<span class="number">1</span>]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (L[<span class="number">0</span>] &lt;= self.min[<span class="number">0</span>] <span class="keyword">and</span> self.max[<span class="number">0</span>] &lt;= R[<span class="number">0</span>] <span class="keyword">and</span></span><br><span class="line">			L[<span class="number">1</span>] &lt;= self.min[<span class="number">1</span>] <span class="keyword">and</span> self.max[<span class="number">1</span>] &lt;= R[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">return</span> _relax(now, di);</span><br><span class="line">	<span class="keyword">if</span> (L[<span class="number">0</span>] &lt;= self.p[<span class="number">0</span>] <span class="keyword">and</span> self.p[<span class="number">0</span>] &lt;= R[<span class="number">0</span>] <span class="keyword">and</span></span><br><span class="line">			L[<span class="number">1</span>] &lt;= self.p[<span class="number">1</span>] <span class="keyword">and</span> self.p[<span class="number">1</span>] &lt;= R[<span class="number">1</span>])</span><br><span class="line">		_relax(now + N, di);</span><br><span class="line">	relax(self.lti, di);</span><br><span class="line">	relax(self.rti, di);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;jump.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;jump.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	read(N);</span><br><span class="line">	<span class="keyword">int</span> M = read;</span><br><span class="line">	pool[<span class="number">0</span>].min[<span class="number">0</span>] = read;</span><br><span class="line">	pool[<span class="number">0</span>].min[<span class="number">1</span>] = read;</span><br><span class="line">	pool[<span class="number">0</span>].max[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	pool[<span class="number">0</span>].max[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">1</span>; now &lt;= N; now ++) &#123;</span><br><span class="line">		read(self.p[<span class="number">0</span>], self.p[<span class="number">1</span>]);</span><br><span class="line">		tmp[now] = now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> s = read, w = read, l = read, r = read, d = read, u = read;</span><br><span class="line">		G[s].push_back(&#123;w, &#123;l, d&#125;, &#123;r, u&#125;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> root = build(<span class="number">1</span>, N, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">std</span>::fill(dis, dis + N + N + <span class="number">1</span>, <span class="number">2000000000</span>);</span><br><span class="line">	q.push(par(dis[N + <span class="number">1</span>] = <span class="number">0</span>, N + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = q.top().second, d = q.top().first;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (d &gt; dis[now]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (now &gt; N) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = now - N;</span><br><span class="line">			<span class="keyword">for</span> (path p : G[u]) &#123;</span><br><span class="line">				L[<span class="number">0</span>] = p.L[<span class="number">0</span>];</span><br><span class="line">				L[<span class="number">1</span>] = p.L[<span class="number">1</span>];</span><br><span class="line">				R[<span class="number">0</span>] = p.R[<span class="number">0</span>];</span><br><span class="line">				R[<span class="number">1</span>] = p.R[<span class="number">1</span>];</span><br><span class="line">				<span class="comment">/* int bak = TOT; */</span></span><br><span class="line">				relax(root, dis[now] + p.w);</span><br><span class="line">				<span class="comment">/* debug(&quot;%d\n&quot;, TOT - bak); */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (self.lti) _relax(self.lti, dis[now]);</span><br><span class="line">			<span class="keyword">if</span> (self.rti) _relax(self.rti, dis[now]);</span><br><span class="line">			_relax(now + N, dis[now]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[N + i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斗主地">斗主地</h3>
<p>仔细分析洗牌的选牌概率，事实上这个洗牌就是在保证相对顺序的前提下的均匀随机打乱。</p>
<p>暴力计算出第 <span class="math inline">\(i\)</span> 个位置洗牌后到第 <span class="math inline">\(j\)</span> 个位置的概率构成的矩阵，然后作矩阵乘法，统计答案，可以得到 40 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mat <span class="title">make</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	mat a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">			a.x[i][j] = C(j - <span class="number">1</span>, i - <span class="number">1</span>) * C(N - j, x - i) % mod * iC(N, x) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">			a.x[i][j] = C(j - <span class="number">1</span>, i - x - <span class="number">1</span>) * C(N - j, N - i) % mod * iC(N, x) % mod;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;landlords.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;landlords.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	read(N);</span><br><span class="line">	<span class="keyword">int</span> m = read, t = read;</span><br><span class="line">	<span class="keyword">bool</span> same = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) read(A[i]), same &amp;= A[i] == A[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (N &gt; <span class="number">100</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	ifac[N] = power(fac[N], <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i --) ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line"></span><br><span class="line">	mat P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">			P.x[i][j] = i == j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (same) &#123;</span><br><span class="line">		mat B = make(A[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">while</span> (m) &#123;</span><br><span class="line">			<span class="keyword">if</span> (m &amp; <span class="number">1</span>) P *= B;</span><br><span class="line">			B *= B;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">			P *= make(A[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">			(ans[j] += P.x[i][j] * ll(t == <span class="number">1</span> ? i : i * i)) %= mod;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> q = read;</span><br><span class="line">	<span class="keyword">while</span> (q --)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="keyword">int</span>(read)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打个表找找规律，可以惊奇地发现 <span class="math inline">\(t=1\)</span> 时无论怎样洗牌，最后的答案序列始终是等差数列！由于该等差数列的和始终不变，只需要考虑维护它的公差。再找找规律，又可以惊奇地发现一个参数为 <span class="math inline">\(X\)</span> 的洗牌就是把公差乘上 <span class="math inline">\(\frac{\binom{N-2}{X}+\binom{N-2}{X-2}}{\binom{N}{X}}\)</span> ！结合上面的暴力做法可以得到 70 分。</p>
<p>以下代码只有 <span class="math inline">\(t=1\)</span> 的部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">	freopen(<span class="string">&quot;landlords.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;landlords.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	read(N);</span><br><span class="line">	<span class="keyword">int</span> m = read, t = read;</span><br><span class="line">	<span class="keyword">bool</span> same = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) read(A[i]), same &amp;= A[i] == A[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	ifac[N] = power(fac[N], <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i --) ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line">	ll coe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	ll d = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		(d *= C(N - <span class="number">2</span>, A[i]) + C(N - <span class="number">2</span>, A[i] - <span class="number">2</span>)) %= mod;</span><br><span class="line">		(d *= iC(N, A[i])) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ll rem = <span class="number">1ll</span> * N * (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">		ans[i] = i * d % mod, rem += mod - ans[i];</span><br><span class="line">	rem = rem % mod * power(N, <span class="number">-1</span>) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">		(ans[i] += rem) %= mod;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> q = read;</span><br><span class="line">	<span class="keyword">while</span> (q --)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="keyword">int</span>(read)] * coe % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以进一步做出猜想，<span class="math inline">\(t=2\)</span> 时无论怎么洗牌答案序列始终是二次多项式。但是探究一次洗牌对该二次多项式的影响就很诡异，远远不是一个乘积那么简单？</p>
<h3 id="i-君的探险">I 君的探险</h3>
<p>容易想到暴力修改每个点然后逐一验证每条边，操作实现得精细一点就可以得到 20 分。</p>
<p>接下来对于 A 部分，这个图是个匹配，容易想到二进制分组，对于每个二进制只修改一半的点，通过查询就可以直到每个点的匹配点在该二进制位对应的值。这个部分不卡交互次数的常数，顺手。结合上一个部分一共 36 分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FORCE &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">bool</span> las[maxn];</span><br><span class="line">	<span class="keyword">bool</span> link[maxn][maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">			modify(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">				<span class="keyword">if</span> (link[j][i] <span class="keyword">or</span> j == i)</span><br><span class="line">					las[j] ^= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">				<span class="keyword">bool</span> now = query(j);</span><br><span class="line">				<span class="keyword">if</span> (now != las[j])</span><br><span class="line">					link[i][j] = <span class="number">1</span>, report(i, j);</span><br><span class="line">				las[j] = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MATCH &#123;</span><br><span class="line">	<span class="keyword">int</span> match[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; k) &lt; n; k ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>) modify(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">				<span class="keyword">if</span> (query(i) != (i &gt;&gt; k &amp; <span class="number">1</span>))</span><br><span class="line">					match[i] |= <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>) modify(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">			<span class="keyword">if</span> (i &lt; match[i])</span><br><span class="line">				report(i, match[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">explore</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">10</span> == <span class="number">8</span>) MATCH::main(n, m);</span><br><span class="line">	<span class="keyword">else</span> FORCE::main(n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B 部分那个感觉可以来个二分什么的，因为对一个前缀进行修改操作，就可以直到一个后缀的父亲是否在这段前缀里头。</p>
<h2 id="end">End</h2>
<p>怎么说呢，感觉题目一年比一年难，分数线却一年比一年高。感觉完全不在线，拿不到分。况且今年的选手看起来强得离谱，感觉要去送了？</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/noi/" rel="tag"><i class="fa fa-tag"></i> noi</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/07/22/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/" rel="prev" title="拉格朗日反演">
                  <i class="fa fa-chevron-left"></i> 拉格朗日反演
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/07/27/%E5%A5%BD%E9%A2%98%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/" rel="next" title="好题题解整理（一）">
                  好题题解整理（一） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kewth</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  

<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5a2fdd60fe2f91777a6b',
      clientSecret: '9ddb762244fffc5caff2490a05e53dbca8ae4902',
      repo        : 'hexo-gitalk',
      owner       : 'Kewth',
      admin       : ['Kewth'],
      id          : 'a44f06c20b5ac633b3c170dbdf1ced42',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
