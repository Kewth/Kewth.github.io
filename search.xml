<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NOI2020</title>
    <url>/2020/08/05/NOI2020/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>士别三日，当刮目相待。</p>

</blockquote>
<a id="more"></a>
<p><a href="#noi2020">跳过瞎扯，进入正题</a></p>
<h2 id="备考期">备考期</h2>
<p>省选一结束就被搞过去准备学考。学考结束后又开始停课。</p>
<p>不过是最后一次了，只有一个月，就要迎来 NOI 了。</p>
<h3 id="part1">Part1</h3>
<p>07.14 - 07.16</p>
<p>主要是做了做 SNOI2020/ZJOI2020 的几道题，但没有什么具体的计划，效率很低。</p>
<h3 id="part2">Part2</h3>
<p>07.17 - 07.22</p>
<p>cy 把我拉去谈话，说要我先花一两周整理复习知识点，要复习后做到以下两点：</p>
<ul>
<li>具备做出每道题的可能（即考察的知识点都会）</li>
<li>只要能想到就能写出来</li>
</ul>
<p>我觉得挺有道理，但一两周感觉太多了，占了整个备考计划近一半的时间，于是列出详细的计划表，在计划里开了六天时间。</p>
<p>前两天用晚上时间拿 XMnid 整理出一张完整的知识点清单，之后照着复习巩固，本来是打算每个不熟练的地方至少做一道题，然而第六天的时候发现还剩一大半没复习，做计划的时候太高估了我的效率，加上三天两场的考试，总之进程相当不理想。于是只能临时做出调整，只做笔记列重点而不打题，刚好这天没有考试，花了一整天的时间算是都完整地过了一遍。</p>
<p>但是说实话我并不敢保证我的确做到了以上两点，我意识到会和熟练是两码事，学了就能会，但要熟练并不是连续做几道题就行的，要熟练掌握必须积累，得经常用或者经常看。</p>
<p>因此梳理知识点这个任务应该很早就开始进行的，至少得提前半年，可是我没有时间可以挥霍了。</p>
<h3 id="part3">Part3</h3>
<p>07.23 - 07.31</p>
<p>这个阶段做近三年 NOI 真题，我有个习惯，大考后不改题，所以近两年 NOI 虽然考过同步赛但是只是有个印象，不影响做题。</p>
<p>还是 cxm 说得对，去“刷”真题是对资源的浪费，一套规范的试题最有价值的或许并不是它的正解，而是它的部分分设定。毕竟 OI 不同于 ACM ，能 AC 的是少数，大多数情况下拿到更多的部分分才是关键。</p>
<p>我的计划不是刷题，而是“研究”真题，找出性价比最高的得分方式。</p>
<p>由于进度比预想中的快，中间中断了一会，去尝试了 cy 说的思维训练。结果后面的进度突然变慢，所幸在 7 月份还是完成了计划。</p>
<p>明显感觉到一年比一年难啊，但是分数线却一年比一年高，突然感觉希望渺茫了呢。</p>
<h3 id="part4">Part4</h3>
<p>08.01 - 08.06</p>
<p><del>这个阶段在 NOIWC2020 上划划水。</del></p>
<p>此时备考计划已经过半，对 NOI 已经有了一个初步的把握，是时候进行调整，减少刷题量，提升考试状态以及思维状态了。</p>
<p>搞搞 WC ，做做思维训练。</p>
<p>然而明显感觉到这段时间状态不在线，包括 WC 考试的时候也没有大考应有的状态，思维训练也是漫无目的四处翻翻，总而言之这个阶段进行地十分失败。</p>
<p>过得迷迷糊糊的，先是搞不清楚现在是上午还是下午，然后是上午忘记去吃中饭，再是下午跑到机房发现没人才意识到下午放假。。。</p>
<p>不过 WC 结果挺出乎意料的，最后凭借 T2 的 AC 拿了 rk11 ，算是涨了自信。</p>
<h3 id="part5">Part5</h3>
<p>08.07 - 08.11</p>
<p>这个阶段主要是两次 NOI 模拟。场地，时间安排等都和今年 NOI 一致，中间有一天 (08.09) 间隔，可以说除了题目和评测方式以外都和 NOI 一致。</p>
<p>第一次模拟结果还行，拿了和预期一致的分数，但是没有拿满 D2 应该拿的分数，最后还是 rk1 。</p>
<p>第二次模拟结果也还可以，因为写了假的树哈希比预期分数低了 10 分。D1T1 暴露了短板，我觉得非常难的一道题被秒了一片，而 D2 的考试历程像极了 NOIP2018 Day1 ，两小时 AK 后反复检查。最后因为以 5 分之差到了 rk2 。</p>
<p>两次模拟后都有已经毕业的学长给我们分析模拟赛的结果，告诉我只要稳定发挥就行了？<del>（cai 奶我说只要八成就可以了）</del></p>
<p>九号组内搞了 NOI 经验交流，经过有理有据的分析感觉今年分数线和去年应该相差不大（compu 大数据分析出来是 479），并且所有交流都表明拿满基础分只能够到银牌，不存在什么“暴力进队”的说法，必须要在保证好基础分拿满的前提下深入分析，完全发挥出自己的实力，才能博得一线希望（事实上从 19 年来看，仅仅是正常发挥仍然不够，需要一点“灵机一动”）。并且分数线咬得很紧很紧，不容半点失误。</p>
<p><img src="/images/noidata.png" /></p>
<p>另外还注意到一个事实，17 年到 19 年都有一道题目考察了较为冷门的算法（2-sat 输出方案，kruskal 重构树，kd-tree 优化建图），并且考冷门算法的题目都不难，基本上是只要会就能 AC 或者拿 85 分以上。今年很可能也一样，会是什么算法呢？</p>
<h3 id="part6">Part6</h3>
<p>08.12 - 08.15</p>
<p>最后四天。</p>
<p>以刷板题为主，要求能熟练打完各种基本的板子，排除掉卡在板子上的可能。</p>
<p>期间进行了最后一次以保持状态为主要目的的测试，D1 打得比较激进，D2 中规中矩地打。结果还行，如果不考虑 D1T1 没开 freopen 的话两场六题都是 rk1 。不过爆了 100 分还是 rk2 ？意料之外。</p>
<p>十五号还打了 APIO ，不知道排名怎么样。</p>
<p>搞颓废被 cy 骂了一顿，确实有点浮躁了，这很危险，需要调整。</p>
<h2 id="noi2020">NOI2020</h2>
<p>终于还是来了。</p>
<p>从新华都毕业以及两年半了，命运的安排让我再次回到母校。</p>
<p>东道主中的东道主，不允许失败。</p>
<h3 id="day-1">Day-1</h3>
<p><del>这天是当天晚上当天写完放 U 盘里的，结果我 U 盘落在自习室没带回来，拿回来之前先咕咕咕吧。。。</del> U 盘找不到了，还是重写吧。</p>
<p>下午去新华都，拿衣服和包的时候碰到了我初二语文老师，得到祝福 +1 。</p>
<p>路上又碰到初中的信息老师，得到祝福 +1 。</p>
<h3 id="day0">Day0</h3>
<p><del>这天是当天晚上当天写完放 U 盘里的，结果我 U 盘落在自习室没带回来，拿回来之前先咕咕咕吧。。。</del> U 盘找不到了，还是重写吧。</p>
<p>上午开幕式，看到一中的宣传片的时候莫名感到很感动？</p>
<p>下午笔试，感觉挺紧张的，中途遇到两三道好像超纲的题，凭直觉经验填了上去。写完后反复检查，最后结束的时候还有点忐忑，不过还好是 AK 了。后来知道我们整组全部都成功 AK ，感觉算是旗开得胜？</p>
<p>晚上谭老师送了我颗阿尔卑斯，得到祝福 +1 。</p>
<h3 id="day1">Day1</h3>
<p><del>这天是当天晚上当天写完放 U 盘里的，结果我 U 盘落在自习室没带回来，拿回来之前先咕咕咕吧。。。</del> U 盘找不到了，还是重写吧。</p>
<p>采用保守策略，开场先看题，看了 30min 大概会了 100 + 48 + 55 ，于是一路写过去，写完 T2 的 <span class="math inline">\(O(nm)\)</span> 做法后发现很好优化，冷静了一会就写出了 64 分做法，感觉离正解不远了，又思考了一会。思考了十几分钟发现还没有结果就跳过去写 T3 ，写完 55 分做法后又回来肝 T2 。</p>
<p>可惜最后也没有想出 T2 正解，还剩大概几十分钟的时候弃掉了，开始全面检查。结果一开始对拍电脑就。。。死机了？吓得我赶紧喊来工作人员。工作人员重启了一波，可惜没有加时。</p>
<p>然后我刚打开代码查看的时候电脑突然又死机了？再次叫来工作人员，提出了换机器的要求，被告知换机器比较麻烦，如果第三次仍然出现问题就安排换机器，但是得到了 5min 加时。</p>
<p>第三次果然没有问题了，有条不紊地对拍，没啥问题。考试结束后继续悠闲地通读代码，满以为这次检查就和笔试一样，啥错没有就是图个心安。结果万万没想到，读 T3 代码的时候猛然发现我把询问离线了下来，但数组只开了 <span class="math inline">\(10^5\)</span> ！大惊失色，慌忙点开文件修改，结果打开了 Emacs ，不知道怎么保存，手忙脚乱中一顿乱按保存退出，然后走出考场。</p>
<p>走出考场后，突然想到考试快结束的时候老师还广播说每年都有把文件改了几个字符最后 CE 爆零的，然后想到我用不熟悉的编辑器改完代码后都没有尝试去编译！卧槽不会今年我就是那个傻逼吧？想到这突然紧张起来，吃饭的时候一直在想这个问题，下午查成绩的时候，有些期待又有些害怕，不过最后还好是有惊无险，一分没挂。</p>
<p>满以为这个分数至少有压线水准了，结果现实比我想象的残酷许多，听说不少人切了 T2 ，216 分似乎并没能压线。</p>
<h3 id="day2">Day2</h3>
<p><del>这天是当天晚上当天写完放 U 盘里的，结果我 U 盘落在自习室没带回来，拿回来之前先咕咕咕吧。。。</del> U 盘找不到了，还是重写吧。</p>
<p>一进入考场就把 Day0 得到的棒棒糖拿了出来放桌上，企图得到祝福（昨天把这颗棒棒糖给忘了）。</p>
<p>鉴于昨天保守策略失败，并且现在已经处于劣势，于是今天决定采用激进的策略。顺序开题，T1 冥冥之中感觉是个可做的题，想了个贪心，理性分析了一波证明了正确性，然后又推广了一下好像就是正解了。写完后测了大样例就直接跳过，肝 T2 ，完全不会，肝 T3 ，卧槽弦图，还真考这玩意？然后一直想 T3 的完美消除序列的做法，结果只会长度相等的部分。回去肝 T2 想了个有理有据的做法，费好大劲写完后发现过不了最后两个大样例。有些自闭了，又回去肝 T3 的另一个部分分，写了一个有理有据的线性 DP ，结果也过不了大样例。最后在紧张的调试中结束了考试。</p>
<p>啥也没调出来，都死活过不了大样例，预计分 100 + 16 + 20 ，感觉要崩，况且今天没有任何的检查部分，万一再挂个分就凉凉了。</p>
<p>整场考试都很紧张，在座位上做了 5h ，没有喝水，没有吃东西，没有上厕所，但并没有感觉任何不适。</p>
<p>下午查分的时候万分紧张，一直在祈祷不要挂分，打开 pdf 的时候发现不但没有挂分，分数还变多了？竟然是 100 + 44 + 20 ？满心欢喜，又看了看 T2 的数据表格，理性分析了一会感觉我的做法在性质 4 里面绝对是没有问题的（虽然我感觉我的做法在所有数据范围下都没有问题 QwQ ）。</p>
<p>但是不知道自己排名，问了周围一圈人大家都说我稳了？</p>
<p>晚上贴了榜，的确是进了。并且拿到了梦寐以求的保送协议。</p>
<p>回寝后打扑克 414 ，和 <code>huwenbo</code> 手气不错，每局出炸已成常态，甚至有一局我抓了两个 414 ，打到不知道几点的时候把对面两个人打自闭了，就都回去睡了。</p>
<h3 id="day3">Day3</h3>
<p>上午和准时跑去看国家队答辩，结果来的时候几乎已经坐满了？<del>认真听完了整场答辩连一本论文集都没有白嫖到手，感觉血亏。</del></p>
<p>闭幕式，拿到了理想的牌牌。然后被初中的老师各种拉过去拍照，好像我是新华都第一个上清华的（事实上是新华都很年轻，我是新华都正式招生的第二届，第一届刚高考完不久录取通知书没发下来而已）。成功变成了没有感情的拍照机器。</p>
<p>闭幕式结束回去颓了颓，没啥劲，电脑手机一个都没在手上，只能看电视 QwQ ，还不如来学校。</p>
<!-- 牌牌.jpg -->
<h2 id="end">End</h2>
<p>最后的成绩是 100 + (100 + 64 + 52) + (100 + 44 + 20) = 480 ，排在全国 rk37 湖南 rk5 ，OI 生涯中唯一的一次 NOI ，已经非常令我满意了。</p>
<p>需要承认的是，这次成功有不少运气成分，Day2 激进策略的成功实在是典型，也很精彩，其实从选择激进策略的这一刻开始，就等于将自己的命运从某种意义上托付给了运气吧。</p>
<p>但也是没有办法的办法，毕竟没有退路了，何不搏一搏呢？</p>
<p>不过这也和平时的习惯是分不开的，平时的低错误率才是激进策略得以实施的基础。</p>
<p>不管怎么样，NOI2020 圆满结束，以后终于可以不带任何功利心地去学习 OI 了，也不需要追求效率了，或许这样的 OI 才是最令人向往的吧。</p>
<p><img src="/images/noi2020_1.png" /></p>
<p><img src="/images/noi2020_2.png" /></p>
<p>THU 冲冲冲！</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>搬迁</title>
    <url>/2019/10/10/%E6%90%AC%E8%BF%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>所谓博客，都是孤芳自赏。</p>

</blockquote>
<p><strong>由于 .github.io 实在太慢，搞了个<del>还是很慢的</del>镜像站：https://kewth.netlify.app/ 。</strong></p>
<p>没什么好说的，动态博客用烦了，搞了好多花里胡哨的东西，还是沉下心来，好好写博客，既然如此，就不打算做什么美化了，基本能用就行，勿喷。</p>
<p>如果公式渲染有问题，请右键公式，点击：math settings -&gt; math renderer -&gt; common html 。</p>
<p>还有日期为 2019.10.01 的都是旧博客直接搬的，并非真实日期，越早期的文章格式可能越屑。</p>
<p><del>可是我控制不住我记几啊，总感觉不顺眼，实在忍不住去折腾 QwQ</del></p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>IOI2021 集训队作业（二）</title>
    <url>/2020/10/20/IOI2021-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>有生之年。</p>
<a id="more"></a>
<hr />
<h2 id="chain-co.">135. Chain &amp; Co.</h2>
<p>在三维空间上给定 <span class="math inline">\(n\)</span> 个四条边都与轴线平行的矩形，称两个矩形是连接的，当且仅当一个矩形总是无法在不穿过另一个矩形的前提下平移到某个指定位置。把矩阵分为两组，使得两组非空且任意不同组的两个矩形都是连接的。</p>
<p>时间复杂度：<span class="math inline">\(O(n \log n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>首先矩形一定平行于某个轴平面，两个矩形连接的一个必要条件是它们平行的轴平面不同。那么所平行的轴平面相同的矩形必须分在同一组。由于轴平面只有三个，那么分组的方式只有三种，枚举三种情况，问题转换为判断两组矩形是否两两连接。</p>
<p>不妨假设一组矩形全部平行于 x-y 平面（称为 A 组，另一组为 B 组），那么 B 组的矩形在 x-y 平面上的投影总是一个线段。考虑 B 组的矩形的 z 轴坐标要满足什么限制，显然每个 B 组矩形的 z 轴坐标范围内要包含所有 A 组矩形的 z 轴坐标，这个很好判断，接下来的问题忽略 z 轴而转换为二维平面上的问题。</p>
<p>现在的问题是，对于每个线段，判断其是否与每个矩形都连接，这里线段和矩形连接当且仅当线段一个端点在矩形内另一个端点在矩形外。不妨假设这些线段都是平行于 x 轴的，同样地我们可以先考虑 y 轴上的限制，和 z 轴的判定类似，接下来问题可以进一步放到数轴上。在数轴上问题最终转换为有 C, D 两组线段判断是否存在一个 C 组线段完全包含一个 D 组线段，排个序双指针即可。</p>

</details>
<hr />
<h2 id="cow-confinement">145. Cow Confinement</h2>
<p>在平面上给定 <span class="math inline">\(f\)</span> 个矩形，<span class="math inline">\(n\)</span> 头牛和 <span class="math inline">\(m\)</span> 朵花的位置，对于每头牛求如果它只往 x, y 轴正方向走，不越过任何矩形的前提下有多少花是可以到达的。保证矩形两两之间没有交点且都与坐标轴平行。</p>
<p>时间复杂度：<span class="math inline">\(O((n + m + t) \log)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>很佩服官方题解，全文一句话也没有说，仅仅通过几张示意图就把核心思想描述地很清楚，剩下的部分就是简单的数据结构。</p>
<p>假设没有矩形的阻挡，那么问题就是查询矩形内的花的数量，但还可以这样描述，把花看做向 y 负方向的射线，把牛看做向 x 正方向的射线，那么牛能到的花的数量就对应于射线的交点数量。</p>
<p>考虑矩形的阻挡，如果牛的射线经过一个矩形，那么事实上的影响就是把当前射线分成两部分，经过矩形前是一个线段，经过矩形后是一个新的射线，新的射线沿着矩形边想 y 正方向移动。特别地，如果触碰到的矩形边是矩形内的话，就不会有新的射线。同理处理花的射线，但是注意到花的射线拆分后一个花可能对一头牛贡献多次。把花的射线拆分归则稍加修改即可。</p>
<p>爬两张官方题解的图，其中 A, B 分别是牛和花，蓝色的即牛对应的射线，红色的即花对应的射线。</p>
<p><img src="/images/ioi2021homework-1.png" /></p>
<p><img src="/images/ioi2021homework-2.png" /></p>
<p>总而言之，矩形的影响就是让经过它的射线发生“偏移”，最后转换的问题仍然是有若干横向射线，若干纵向射线，求每个横向射线与多少纵向射线有交点这样的问题。扫描线加树状数组即可。</p>

</details>
<hr />
<h2 id="money-for-nothing">255. Money for Nothing</h2>
<p>在二维平面上给定 <span class="math inline">\(n\)</span> 个白点和 <span class="math inline">\(m\)</span> 个黑点，求一个面积最大的矩形满足左下角是黑点右上角是白点。</p>
<p>时间复杂度：<span class="math inline">\(O((n + m) \log)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>不妨假设白点和黑点都是横纵坐标同时单调递减的（否则的话一定存在一个点可以完全替代另一个点）。</p>
<p>然后考虑对于每个白点求对应的最优的黑点，不难想到是最优黑点是单调的，因此决策单调分治处理即可。</p>
<p>特别地，有些白点压根没有合法的黑点与它构成矩形，这种情况需要稍加处理。</p>

</details>
<hr />
<h2 id="weather-report">293. Weather Report</h2>
<p>给所有长度为 <span class="math inline">\(n\)</span> 的四进制数一个二进制编码，要求编码之间两两没有前缀关系。以 <span class="math inline">\(\prod_{i=1}^n P_{a_i}\)</span> 的概率选中四进制数 <span class="math inline">\(a\)</span> ，其中 <span class="math inline">\(a_i\)</span> 表示 <span class="math inline">\(a\)</span> 的第 <span class="math inline">\(i\)</span> 个数位的值。<span class="math inline">\(P_0, P_1, P_2, P_3\)</span> 给定且和为 <span class="math inline">\(1\)</span> 。</p>
<p>最小化选中的四进制数的编码的长度的数学期望。</p>
<p>时间复杂度：<span class="math inline">\(O((\dfrac{n}{w}) n^4 \log n)\)</span></p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>把所有四进制数的编码建 Trie ，由于编码之间两两没有前缀关系，那么 Trie 的单词节点两两没有祖先关系。一个 Trie （即编码方式）的代价就是每个叶子的权值（对应的四进制数的出现概率）乘上其深度的和。</p>
<p>而最小化这个 Trie 的代价是很简单的，每次贪心选两个最小的叶子合并即可。</p>
<p>唯一的问题在于节点数 <span class="math inline">\(4^n\)</span> 太多，不过许多都是权值相同的，爆搜四种天气的数量，用组合数算一类权值的节点的数量，将它们作为整体应用到贪心算法即可。</p>
<p>这个最优编码就是 Huffman 编码，上文的 Trie 树就是 Huffman 树，上文的贪心算法就是构建 Huffman 树的一个常用算法。</p>
<p>事实上，由于需要记录一类权值的数量，而这个数量 <span class="math inline">\(t\)</span> 的值是 <span class="math inline">\(O(4^n)\)</span> 的（上确界应该是 <span class="math inline">\(\dfrac{n!}{(\frac{n}{4}!)^4}\)</span> ），因此这个数值的运算复杂度是 <span class="math inline">\(O(\dfrac{n}{w})\)</span> ，然后一类数量为 <span class="math inline">\(t\)</span> 的权值最多被重复取出 <span class="math inline">\(\log t\)</span> 次，也就是 <span class="math inline">\(O(n)\)</span> 次，这样算下来就得到了上述的复杂度上界（可能未必是上确界）。</p>
<p>如果数量 <span class="math inline">\(t\)</span> 用整数记录的话，有 <span class="math inline">\(n &lt; w\)</span> ，这个 <span class="math inline">\(n\)</span> 实际上是不大的。</p>

</details>
<hr />
<h2 id="correcting-curiosity">101. Correcting Curiosity</h2>
<p>给定两个不相等的非空串 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> ，要求找到两个串 <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> 使得在 Vim 内对 <span class="math inline">\(s\)</span> 执行 <code>s/A/B/g</code> 命令后得到的串恰为 <span class="math inline">\(t\)</span> ，并使得 <span class="math inline">\(|A| + |B|\)</span> 最小。</p>
<p>时间复杂度：<span class="math inline">\(O(|s|^2 + |t|)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>直接从 <span class="math inline">\(s\)</span> 的所有子串中枚举 <span class="math inline">\(A\)</span> ，不难发现只要确定了 <span class="math inline">\(A\)</span> 就可以唯一确定 <span class="math inline">\(B\)</span> ，然后在 <span class="math inline">\(s\)</span> 上模拟替换命令，这样的复杂度是三次方的。</p>
<p>预处理 <span class="math inline">\(s\)</span>, <span class="math inline">\(t\)</span> 的哈希值，就可以做到单次替换 <span class="math inline">\(O(1)\)</span> ，总复杂度就是平方了。</p>

</details>
<hr />
<h2 id="replicate-replicate-rfplicbte">102. Replicate Replicate Rfplicbte</h2>
<p>对于一个无限大的 01 矩阵，每一次变化定义为依次执行两个操作：</p>
<ol type="1">
<li>把每个位置变成操作前其相邻共九个位置的异或和。</li>
<li>选择至多一个位置将其取反。</li>
</ol>
<p>定义一个无限大的 01 矩阵的大小为，能包含所有 1 的子矩阵的面积的最小值。</p>
<p>现给出一个矩阵 <span class="math inline">\(A\)</span> ，大小为 <span class="math inline">\(n \times m\)</span> ，求一个大小最小的能通过若干次变化变成 <span class="math inline">\(A\)</span> 的矩阵。</p>
<p>时间复杂度：<span class="math inline">\(O(nm(n+m))\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>首先注意到，无论有没有二操作，每一次变化后，矩阵的“边界”都会想上下左右四个方向个扩展至少一格。</p>
<p>通过这一点，如果没有二操作，对于一个矩阵 <span class="math inline">\(A\)</span> ，我们可以唯一确定能一次变化到 <span class="math inline">\(A\)</span> 的矩阵 <span class="math inline">\(B\)</span> ，或判断不存在这样的 <span class="math inline">\(B\)</span> 。</p>
<p>具体方法就是递推，把 <span class="math inline">\(B\)</span> 的每个位置看做变量，<span class="math inline">\(A\)</span> 的每个位置就是异或方程，但是由于可以确定 <span class="math inline">\(B\)</span> 的边界至少向内缩一格，也就可以确定在 <span class="math inline">\(A\)</span> 的外侧的位置上 <span class="math inline">\(B\)</span> 都是 0 。</p>
<p>考虑如果有二操作，怎么找到二操作的执行位置。</p>
<p>假设我们逐行递推，那么每一行只有 <span class="math inline">\(n-2\)</span> 个变量但有 <span class="math inline">\(n\)</span> 个方程。找到第一个方程组无解的行，那么如果有二操作，二操作的执行位置一定在该行。同理我们可以确定列，进而得到二操作的位置，然后还原二操作再检验即可。</p>

</details>
<hr />
<h2 id="boys-and-girls">103. Boys and Girls</h2>
<p>求一个长为 <span class="math inline">\(n\)</span> 的由 01 构成的环，满足恰有 <span class="math inline">\(x\)</span> 个点的两侧有 0 ，恰有 <span class="math inline">\(y\)</span> 个点的两侧有 1 。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>注意到每个点的两侧有三种情况：全是 0 ，全是 1 ，一边 0 一边 1 ，设上述三种情况的点的数量分别为 <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> ，容易知道有 <span class="math inline">\(c = x + y - n\)</span>, <span class="math inline">\(a = x - c\)</span>, <span class="math inline">\(b = y - c\)</span> 。</p>
<p>我们把距离恰为 <span class="math inline">\(2\)</span> 的点连边，得到一个新的环，准确来说，如果 <span class="math inline">\(n\)</span> 是奇数，得到的是一个长为 <span class="math inline">\(n\)</span> 的环，否则得到的是两个长为 <span class="math inline">\(dfrac{n}{2}\)</span> 的环。</p>
<p>那么我们现在要做的就是在环上填 01 使得三种边的数量分别为 <span class="math inline">\(a, b, c\)</span> ，注意到 <span class="math inline">\(c\)</span> 必须是偶数，且 <span class="math inline">\(c\)</span> 为 <span class="math inline">\(0\)</span> 的时候必须有 <span class="math inline">\(ab = 0\)</span> 。假设只有一个环，就很容易构造一个解，两个环的话就把边集分成两个大小相等的部分，只要满足每个部分都合法即可。</p>

</details>
<hr />
<h2 id="knapsack-cryptosystem">Knapsack Cryptosystem</h2>
<p>Hellman-Knapsack Cryptosystem 这一密码系统的描述如下：</p>
<p>A 的密钥由长为 <span class="math inline">\(n\)</span> 的正整数序列 <span class="math inline">\(a\)</span> 和两个互质的正整数 <span class="math inline">\(r, q\)</span> 组成，满足 <span class="math inline">\(\forall i, a_i &gt; \sum_{j=1}^{i-1} a_j\)</span> 且 <span class="math inline">\(q &gt; \sum_{i=1}^n a_i\)</span> 。</p>
<p>A 的公钥是一个长为 <span class="math inline">\(n\)</span> 的正整数序列 <span class="math inline">\(b\)</span> ，其中 <span class="math inline">\(b_i = (a_i \cdot r) \bmod q\)</span> 。</p>
<p>需要传输给 A 的信息是一个长为 <span class="math inline">\(n\)</span> 的 01 序列 <span class="math inline">\(z\)</span> ，加密方式是计算 <span class="math inline">\(s = \sum_{i=1} z_i b_i\)</span> ，然后将 <span class="math inline">\(s\)</span> 传输给 A 。</p>
<p>（这样一来，仅知道公钥破译 <span class="math inline">\(z\)</span> 的难度远远比通过密钥计算 <span class="math inline">\(z\)</span> 的大）</p>
<p>现在你窃取到了 <span class="math inline">\(q\)</span> 的值和 <span class="math inline">\(s \bmod q\)</span> 的值，求出 <span class="math inline">\(z\)</span> （公钥也是已知的）。</p>
<p>时间复杂度：<span class="math inline">\(O(\sqrt[3]{q} \log q)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>首先注意到 <span class="math inline">\(n \le \log_2 q\)</span> ，如果 <span class="math inline">\(n\)</span> 非常小，不难想到直接枚举 <span class="math inline">\(z\)</span> 然后加以验证，这样的复杂度是 <span class="math inline">\(O(2^n)\)</span> 的。</p>
<p>上述做法很好加以优化，不难想到折半搜索，做到 <span class="math inline">\(O(n 2^{n/2})\)</span> 。</p>
<p>但如果 <span class="math inline">\(n\)</span> 非常大呢？注意到 <span class="math inline">\(n\)</span> 越大对 <span class="math inline">\(a\)</span> 的限制就越强，具体来说，这个限制是 <span class="math inline">\(a_1 2^{n-1} &lt; q\)</span> ，当 <span class="math inline">\(n\)</span> 很大的时候，<span class="math inline">\(a_1\)</span> 的可能的取值会很少，不妨枚举 <span class="math inline">\(a_1\)</span> ，进而通过 <span class="math inline">\(a_1\)</span> 和 <span class="math inline">\(b_1\)</span> 的值确定 <span class="math inline">\(r\)</span> （并不能唯一确定，枚举所有可能的 <span class="math inline">\(r\)</span> 即可）。知道 <span class="math inline">\(r\)</span> 后就可以还原整个密钥，进而得到 <span class="math inline">\(z\)</span> 。</p>
<p>得到 <span class="math inline">\(z\)</span> 的具体方法是，求出 <span class="math inline">\(t = (s \cdot r^{-1}) \bmod q)\)</span> ，那么 <span class="math inline">\(t = \sum_{i=1} z_i a_i\)</span> ，由于 <span class="math inline">\(a\)</span> 的性质特殊，可以直接确定 <span class="math inline">\(z\)</span> 。</p>
<p>这一做法的复杂度是 <span class="math inline">\(O(\dfrac{q}{2^n} n)\)</span> 。</p>
<p>综合两者，总复杂度是 <span class="math inline">\(O(\sqrt[3]q \log q)\)</span> 。</p>

</details>
<hr />
<h2 id="heavy-chain-clusterization">Heavy Chain Clusterization</h2>
<p>给定 <span class="math inline">\(n\)</span> 个长度至少为 <span class="math inline">\(k\)</span> 的串 <span class="math inline">\(s_i\)</span> ，要求将它们划分成若干集合，使得每个集合的串满足以下至少一个条件：</p>
<ol type="1">
<li>它们的最长公共前缀至少为 <span class="math inline">\(k\)</span> 。</li>
<li>它们的最长公共后缀至少为 <span class="math inline">\(k\)</span> 。</li>
</ol>
<p>在此基础上，最小化划分的集合的数量。</p>
<p>时间复杂度：<span class="math inline">\(O(n^2 + \sum_{i=1}^n |s_i|)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>每个 <span class="math inline">\(s_i\)</span> 可以抽象为一个二元组 <span class="math inline">\((x_i, y_i)\)</span> ，其中 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(y_i\)</span> 分别表示 <span class="math inline">\(s_i\)</span> 长为 <span class="math inline">\(k\)</span> 的前缀和后缀。</p>
<p>那么一个集合要满足的条件就是集合内二元组的 <span class="math inline">\(x\)</span> 均相同或 <span class="math inline">\(y\)</span> 均相同。</p>
<p>进一步把二元组抽象为连接两点的边，那么形成一个有 <span class="math inline">\(n\)</span> 条边的二分图，要求对边集进行划分，每个边集要满足的条件即：<strong>该边集存在一个公共点</strong>。</p>
<p>那么实际上我们可以用公共点来代表该边集，那么最小的边集划分实际上就是最小的点覆盖。对二分图求最小点覆盖是容易的。</p>

</details>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>IOI2021 集训队作业（一）</title>
    <url>/2020/10/19/IOI2021-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>有生之年。</p>
<a id="more"></a>
<hr />
<h2 id="rubiks-rectangle">233. Rubik's Rectangle</h2>
<p>给定一个 <span class="math inline">\(H \times W\)</span> 的网格，每个网格有个数字，每次操作可以翻转某行或某列，求一组合法操作使得该网格的数字排好序。</p>
<p>时间复杂度：<span class="math inline">\(O(HW(H+W))\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>不妨假设 n, m 都是偶数（如果是奇数那么中间的一行或列可以独立）。</p>
<p>可以发现可以把格子染色，每种颜色恰好四个格子，满足任意翻转操作后颜色矩阵不变。</p>
<p>不妨假设每个数字在正确的颜色位置上。考虑每个颜色内的四个点，可以发现如果这些点构成偶排列那么就总可以在不影响其他颜色的前提下把这四个点排好序，如果是奇排列则总是不能。称每个颜色的左上角的点为代表点，把颜色的排列奇偶性作为标记放到代表点上，对于代表点标记构成的 01 矩阵 A ，如果 A 是全 0 矩阵自然是有解的。</p>
<p>而每次翻转对 A 的影响就是讲某一行或某一列的 01 给全部反转，因此只要能通过这个操作把 A 弄成 01 矩阵就能得到解，这就是个很 simple 的贪心了。</p>

</details>
<details class="note info"><summary><p>数据</p>
</summary>
<p><del>这 spj 真难写。</del></p>
<p>不难想到如果随机选择一个排列放到网格上，那么极大的概率是无解。采用逆推的方式，从一个排好序的网格随机执行若干次操作得到一个打乱的网格，这样就可以保证数据有解。在此基础上加上一些扰动改变一些代表点的奇偶性即可得到强度较大的无解数据。</p>

</details>
<hr />
<h2 id="hiking-in-the-hills">234. Hiking in the Hills</h2>
<p>在三维空间上给定一个曲面，该曲面由 <span class="math inline">\(n\)</span> 个三角形构成，在曲面上给出两个点，求曲面上连接两点的一条折线使得折线上的最高的点的高度最小（高度指 z 轴坐标）。</p>
<p>保证任意直线 <span class="math inline">\(x=x_0, y=y_0\)</span> 与该曲面的交点至多只有一个。</p>
<p>时间复杂度：<span class="math inline">\(O(n \log n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>容易发现这条折线可以只走三角形端点，把三角形端点和起点终点拿出来建图然后把点按高度排序，用个并查集维护即可。</p>

</details>
<details class="note info"><summary><p>数据</p>
</summary>
<p><del>这 spj 真难写。</del></p>
<p>这题造数据比写标程难。先确定所有三角形端点，再构造三角形，把端点投影到 xy 平面上，那么构造三角形就是在平面上求一组三角剖分。</p>

</details>
<hr />
<h2 id="single-cut-of-failure">235. Single Cut of Failure</h2>
<p>有一个矩形，称一条端点落在矩形的不同的两条边的线段为合法线段。给定 <span class="math inline">\(n\)</span> 条合法线段，要求添加最少的合法线段使得每条给定的合法线段与至少一条添加的合法线段有交。</p>
<p>时间复杂度：<span class="math inline">\(O(n \log n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>比较降智的一点是，添加两条对角线总是满足条件的。那么我们只需要关注是否可以找到一条合法线段与所有给定线段有交。</p>
<p>把矩形的边展开为一个数轴，每个给定线段对应数轴上一段区间，那么目标是选两个点满足它们所在的区间的集合的不交并是全集。假设区间没有包含关系，排个序后枚举一个点双指针处理另一个点即可。对于有包含关系的区间，稍加特殊处理就可以合并为一个区间。</p>

</details>
<details class="note info"><summary><p>数据</p>
</summary>
<p><del>这 spj 真难写。</del></p>
<p>不难想到如果在矩形内随机给出 <span class="math inline">\(n\)</span> 条合法线段，那么有极大的概率不存在一条线段的解。不妨先确定最后需要添加的线段，然后给出 <span class="math inline">\(n\)</span> 条与之有交的合法线段。</p>

</details>
<hr />
<h2 id="bipartite-blanket">121. Bipartite Blanket</h2>
<p>给定一个二分图，左右分别 <span class="math inline">\(n, m\)</span> 个点，点有点权，称一个点集是合法的当且仅当存在一组匹配是该点集的父集，求有多少合法点集的点权和不小于 <span class="math inline">\(t\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(n 2^n + m 2^m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>对于点集 <span class="math inline">\(S\)</span> 考虑判断是否存在匹配覆盖了 <span class="math inline">\(S\)</span> 。如果 <span class="math inline">\(S\)</span> 只包含左边的点或者只包含右边的点，容易发现用 Hall 定理就能判断。否则设 <span class="math inline">\(S = X \cup Y, X \cap Y = \emptyset\)</span> ，其中 <span class="math inline">\(X, Y\)</span> 分别是左右边集。那么可以证 明，存在匹配覆盖 <span class="math inline">\(S\)</span> 当且仅当存在匹配覆盖 <span class="math inline">\(X\)</span> 且存在匹配覆盖 <span class="math inline">\(Y\)</span> 。</p>
<p>必要性很显然，证明充分性，假设已知一个覆盖 <span class="math inline">\(X\)</span> 的匹配和一个覆盖 <span class="math inline">\(Y\)</span> 的匹配，考虑取构造一个覆盖 <span class="math inline">\(S\)</span> 的匹配，首先把覆盖 <span class="math inline">\(X\)</span> 的匹配作为初始匹配，然后逐个加入 <span class="math inline">\(Y\)</span> 中的点和对应的匹配点，分类讨论不难得到一个简单的构造方法。</p>
<p>那么把两边的能被匹配覆盖的点集分别处理出来排个序然后双指针即可。</p>

</details>
<hr />
<h2 id="intellectual-property">122. Intellectual Property</h2>
<p>有三个三元组 <span class="math inline">\((1, 2, 3), (4, 5, 6), (7, 8, 9)\)</span> ，对数独定义若干操作：</p>
<ol type="1">
<li>选择两个数字 <span class="math inline">\(x, y\)</span> 并把所有 <span class="math inline">\(x\)</span> 变为 <span class="math inline">\(y\)</span> ，把所有 <span class="math inline">\(y\)</span> 变为 <span class="math inline">\(x\)</span> 。</li>
<li>选择同一三元组的两行交换。</li>
<li>交换两个三元组对应的行。</li>
<li>选择同一三元组的两列交换。</li>
<li>交换两个三元组对应的列。</li>
<li>沿左上-右下对角线翻折。</li>
</ol>
<p>给定 <span class="math inline">\(n\)</span> 个数独，对于每两个数独求出一组操作序列使得一个数独操作后与另一个相同或输出无解。</p>
<p>时间复杂度：<span class="math inline">\(O(1296 (9^2 n + n^2))\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>容易发现由于存在三元组的限制，行和列的置换数都是 <span class="math inline">\(1296\)</span> 而非 <span class="math inline">\(9!\)</span> 。对于两个待检查的数独 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> ，朴素的想法是在 <span class="math inline">\(a\)</span> 上枚举所有行的置换和所有列的置换然后比对，但是由于行列之间不影响，不难想到折半，在 <span class="math inline">\(a\)</span> 上枚举所有行的置换，然后在 <span class="math inline">\(b\)</span> 上枚举所有列的置换，在两边检查有没有相同的数独即可。</p>
<p>对角线翻折操作最多只进行一次，并且如果需要进行的话可以在任意时刻进行，因此如果需要这个操作不妨假定它在最后，额外检查一次即可。</p>

</details>
<hr />
<h2 id="gem-island">123. Gem Island</h2>
<p>以前做过，略。</p>
<hr />
<h2 id="j">134. J</h2>
<p>给定一个长为 <span class="math inline">\(L\)</span> 的表达式。表达式对向量和标量进行运算，有加法减法乘法取反自平方和折叠共六个运算，其中折叠是对一个向量求各个分量的和。表达式中会出现各种标量，但出现的向量仅有 <span class="math inline">\(X\)</span> 。给定 <span class="math inline">\(X\)</span> 求表达式的值。</p>
<p>特别地，每个子表达式中关于 <span class="math inline">\(X\)</span> 的复杂度不超过 <span class="math inline">\(X^K\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(|X| K + L K^2)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>直接把向量拿进去模拟运算的话瓶颈复杂度 <span class="math inline">\(O(L |X|)\)</span> 无法接受。但是注意到表达式中出现的向量仅有 <span class="math inline">\(X\)</span> ，并且折叠操作对加法有分配率，那么总可以用一个关于 <span class="math inline">\(X\)</span> 的多项式来表示一个表达式的值，并且题目中的限制保证了这个多项式的次数不超过 <span class="math inline">\(K\)</span> 。</p>

</details>
<hr />
<h2 id="tile-cutting">146. Tile Cutting</h2>
<p>对于一个 <span class="math inline">\(n \times m\)</span> 的网格矩形 <span class="math inline">\(M\)</span> ，称一个平行四边形 <span class="math inline">\(A\)</span> 被 <span class="math inline">\(M\)</span> 包裹当且仅当：</p>
<ol type="1">
<li><span class="math inline">\(AS\)</span> 的四个顶点分别落在 <span class="math inline">\(M\)</span> 的四条边上。</li>
<li><span class="math inline">\(AS\)</span> 的四个顶点恰好落在格点上。</li>
</ol>
<p>设 <span class="math inline">\(f(S)\)</span> 表示满足以下限制的二元组 <span class="math inline">\((M, A)\)</span> 的数目：</p>
<ol type="1">
<li><span class="math inline">\(A\)</span> 被 <span class="math inline">\(M\)</span> 包裹。</li>
<li><span class="math inline">\(A\)</span> 的面积恰为 <span class="math inline">\(S\)</span> 。</li>
</ol>
<p><span class="math inline">\(Q\)</span> 次询问，每次给定区间 <span class="math inline">\([l, r]\)</span> 求 <span class="math inline">\(S \in [l, r]\)</span> 时 <span class="math inline">\(f(S)\)</span> 的最大值。保证 <span class="math inline">\(r \le V\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O((V + Q) \log V)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>把面积关于平行四边形的位置的式子写出来，稍加整理，不难发现 <span class="math inline">\(f(S)\)</span> 就是满足 <span class="math inline">\(ab + cd = S\)</span> 的正整数四元组 <span class="math inline">\((a, b, c, d)\)</span> 的数量：</p>
<p><span class="math display">\[
f(S) = \sum_{x+y=S} \sum_{a,b} [ab = x] \sum_{c,d} [cd = y] = \sum_{x+y=S} d(x) d(y)
\]</span></p>
<p>FFT 即可。</p>

</details>
<hr />
<h2 id="fygon-2.0">153. Fygon 2.0</h2>
<p>给定一个 <span class="math inline">\(m\)</span> 层嵌套 <code>for</code> 循环，循环的左边界要么是前文出现过的循环变量要么是 <span class="math inline">\(1\)</span> ，右边界要么是前文出现过的循环变量要么是常数 <span class="math inline">\(n\)</span> 。求该循环最后的语句的执行次数的渐进复杂度 $C n^K% 。</p>
<p>时间复杂度：<span class="math inline">\(O(m^3 + m 2^m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>首先不难注意到一个 <code>for</code> 循环就是一个形如 <span class="math inline">\(l \le i \le r\)</span> 的不等式，最后的语句的运行次数实际上是满足所有不等式的循环变量组数。</p>
<p>按不等关系连边，显然 SCC 内的值要相同，缩点得到一张新图 <span class="math inline">\(G\)</span> 。不难想到 <span class="math inline">\(K\)</span> 就是 <span class="math inline">\(G\)</span> 的点数，接下来着重考虑计算渐进复杂度的常数。</p>
<p>由于渐进复杂度是在 <span class="math inline">\(n\)</span> 趋于正无穷时体现出来的，不妨假定 <span class="math inline">\(n\)</span> 为正无穷，那么每个变量的取值范围就是整个正整数域，不妨钦定 <span class="math inline">\(G\)</span> 内循环变量的取值是两两不同的，考虑每个变量随机取值，满足所有限制的概率。事实上这个概率就是我们要计算的系数 <span class="math inline">\(C\)</span> 。</p>
<p>由于我们只关心变量之间的大小关系，按变量从小到大得到排列 <span class="math inline">\(p\)</span> ，每个排列 <span class="math inline">\(p\)</span> 的出现概率都是 <span class="math inline">\(\dfrac{1}{K!}\)</span> 。假设合法的排列数量是 <span class="math inline">\(x\)</span> ，那么要计算的系数就是 <span class="math inline">\(\dfrac{x}{K!}\)</span> 。于是问题转换为求合法的排列数，也就是拓扑排序的方案数，用状压 DP 可以很好解决。</p>

</details>
<hr />
<h2 id="equal-numbers">173. Equal Numbers</h2>
<p>给定长为 <span class="math inline">\(n\)</span> 的值不超过 <span class="math inline">\(V\)</span> 的正整数数列 <span class="math inline">\(a\)</span> ，可以执行的操作是选择 <span class="math inline">\(i, x\)</span> 令 <span class="math inline">\(a_i \leftarrow x \times a_i\)</span> 。</p>
<p>对于每个 <span class="math inline">\(k \in [0, n]\)</span> 计算执行 <span class="math inline">\(k\)</span> 次操作能得到的数字种类数的最小值。</p>
<p>时间复杂度：<span class="math inline">\(O(n + V \log V)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>设 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(V\)</span> 的 lcm ，不难想到操作只有两种情况：</p>
<ol type="1">
<li>选 <span class="math inline">\(k\)</span> 个数修改为 <span class="math inline">\(X\)</span> 。</li>
<li>选 <span class="math inline">\(k\)</span> 个数修改为已经在数列中存在的数。</li>
</ol>
<p>分别考虑两种情况。对于情况 1 ，贪心从出现次数最少的数开始修改即可。对于情况 2 ，把能够修改的数拿出来按情况 1 的方法贪心即可。</p>

</details>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP 2020</title>
    <url>/2020/10/11/CSP-2020/</url>
    <content><![CDATA[<p>初赛到了考场才真实地认识到一个新的赛季又开始了，不过我已经精神退役了，所以考的比较佛。</p>
<a id="more"></a>
<h2 id="初赛">初赛</h2>
<p>10.09 才知道初赛日期是 10.11 ，没啥感觉，10.11 就跟过去裸考了。</p>
<p><del>湖南大学好热闹，但是没人和我面基。</del></p>
<p>不过碰到个小哥哥（应该是湖南大学的学生）问我这么多人是干啥，了解了一波情况后给我说了加油。</p>
<p>考试的时候那个字符串的题目把我整懵了，猜了几个结论糊弄过去。</p>
<p>考后发现 <code>nth_element</code> 那题还错了一个，看懂是个 <code>nth_element</code> 后就没仔细看实现了，没注意到它的实现有缺陷。</p>
<p>update: 膜拜我校高一选手初赛 AK ！</p>
<h2 id="复赛">复赛</h2>
<p>摸了一个月鱼，又跟过去裸考。</p>
<p>理论上来说 2:20 就要公布密码了，但是我们考场快到 2:30 才直到正确密码，原因是写密码的老师没分清 k 的大小写，以及 0 和 O 的区别，最后还漏掉了两边的括号。。。</p>
<p>看完 T1 暗暗问候了一下出题人就跳过去看 T2 ，一看这不送的嘛花十几分钟写完，并特意检查了 <code>unsigned long long</code> （去年因为这个挂了 5 分）。然后回去写 T1 ，反正迟早要写，长痛不如短痛。对着 T1 自闭了三四十分钟终于写完了，过了大样例，就没管了。</p>
<p>看到 T3 人傻了，我转换问题得到了一个子问题是“在 DAG 上统计每个点能到达的点的点权和”，众所周知这个问题没有高效解法，很懵逼，总感觉哪里不对，重新读了几遍题感觉也没读错，就跳过去看 T4 了。T4 很快发现可能出现的状态只有 <span class="math inline">\(n\)</span> 种，在这些状态中 DP 即可，瓶颈在于通过模拟来求出所有 <span class="math inline">\(n\)</span> 个状态，用平衡树会带个 <span class="math inline">\(\log\)</span> ，肯定跑不过去，但是看了眼数据范围发现至少也有 70 分，感觉还不错，就写了写然后继续回去看 T3 。</p>
<p>自闭了一会终于发现问题转换错了，实际上要解决的子问题是“在 DAG 上统计每个点能到达的点的点权乘上到达该点的路径数的和”，这个就简单很多，最后写了两个拓扑排序就过了大样例。</p>
<p>写 T3 的时候不知道为什么脑壳疼，而且有点困，期间不停在打哈欠。迷迷糊糊写完后就也没检查了，坐等考试结束。</p>
<p>我们考场那收卷效率是真的令人堪忧啊，由几个老师分工收卷，提前分配了哪个老师收哪些考生的卷。但是啊但是啊，不同老师收卷效率和收卷的考生数量都不同，所以导致几个老师收完了没事干，在旁边干看着最后一个没收完的老师，然而还有一堆考生坐着等着他收卷，好巧不巧我就是这些等着的考生中的最后一个。</p>
<p>晚上又去摸鱼，希望不要挂分吧。</p>
<hr />
<p>自测了一波，这里再次对 T1 出题人表示深切的问候。</p>
<p>T1 一个地方判错了，洛谷民间数据只过了一个点，理论得分下限是 0 。这种以分类讨论为核心的题目你大样例还不把分类的情况给全？</p>
<p>T2 我真是万万没有想到居然可以有 <span class="math inline">\(n = m = 0, k = 64\)</span> 这样的阴间数据，这个答案是 <span class="math inline">\(2^{64}\)</span> ，这波 <code>unsigned long long</code> 都存不下，这个神必操作可能又要卡我至少五分了。</p>
<p>然后听说 T1 直接 Day by Day 模拟有 80 分，这个做为 T1 把暴力分放到 80 本来没啥问题，可你这以分类讨论为核心的题，剩下 20 分你咋区分各种情况？区分个锤子，我估计像我这样少讨论一种情况的得分估计不如暴力模拟的 80 。</p>
<p>理论得分下限 0 + 60 + 100 + 70 = 230 ，可真牛批。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>csp</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro 使用 Deepin-wine 中文乱码问题</title>
    <url>/2020/10/09/Manjaro-%E4%BD%BF%E7%94%A8-Deepin-wine-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本来装好 deepin.com.qq.im 后就可以愉快使用了，但是在某次滚动更新后突然发现 QQ/TIM 都中文乱码，困惑了很久都没找到解决方案。</p>
<p>在失败和重新尝试的断断续续的反复循环中，今天终于解决了。</p>
<p>其实就是下载 simsun.ttc 和 simsun.ttf 放到 .deepinwine/Deepin-QQ/drive_c/windows/Fonts 里头。</p>
<p>可能还要写个 zh.reg ，像下面这样，然而 deepin-wine 自带的 deepin-regedit 用不了，把 /usr/lib/deepin-wine/wine 拷贝到 /usr/lib/i386-linux-gnu/deepin-wine/wine 后似乎就好一点，但还是用不了，因此我并没有注册，但好像也还可以。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REGEDIT4</span><br><span class="line">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]</span><br><span class="line">&quot;Arial&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Arial CE,238&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Arial CYR,204&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Arial Greek,161&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Arial TUR,162&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Courier New&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Courier New CE,238&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Courier New CYR,204&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Courier New Greek,161&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Courier New TUR,162&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;FixedSys&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Helv&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Helvetica&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;MS Sans Serif&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;MS Shell Dlg&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;MS Shell Dlg 2&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;System&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Tahoma&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Times&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Times New Roman CE,238&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Times New Roman CYR,204&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Times New Roman Greek,161&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Times New Roman TUR,162&quot;&#x3D;&quot;simsun&quot;</span><br><span class="line">&quot;Tms Rmn&quot;&#x3D;&quot;simsun&quot;</span><br></pre></td></tr></table></figure>
<p>不过还是有一点点小问题，某些地方仍然乱码（如个性签名），TIM 的效果要好很多。</p>
<p>回过头来看这不是蛮简单的嘛？为啥我搞了这么久？</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
  </entry>
  <entry>
    <title>Manjaro 连接 Wifi</title>
    <url>/2020/10/05/Manjaro-%E8%BF%9E%E6%8E%A5-Wifi/</url>
    <content><![CDATA[<p>购置了移动硬盘后马上把系统塞进去弄了个 "linux to go" ，回家直接用，美滋滋，然后就发现不会联网。</p>
<p><del>把联网的手机用 USB 共享网络就好了嘛</del></p>
<a id="more"></a>
<p>网上搜了一大堆不靠谱的东西，踩了无数个雷后终于在 Arch-wiki 上发现一个神必软件 NetworkManager 。</p>
<p>首先安装 <code>yay -S networkmanager</code> （一般会自带）。</p>
<p>然后执行 <code>nmcli</code> 就可以非常友好的列出各个连接设备以及它们的状态。</p>
<p>执行 <code>nmcli device wifi</code> 就可以扫描出附近所有无限网络以及测试它们的网速。</p>
<p>最后执行 <code>nmcli device wifi connect 无限网络名称 password 无线网络密码</code> 就可以连接了。</p>
<p>就是这么简单，当然如果桌面软件自带连接 wifi 功能就最好了（i3 没人权），拒绝折腾。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
  </entry>
  <entry>
    <title>NOI2020 题解报告</title>
    <url>/2020/09/03/NOI2020-%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>没有摘要。</p>
<a id="more"></a>
<h2 id="美食家">美食家</h2>
<h3 id="题目大意">题目大意</h3>
<p>给定一张 <span class="math inline">\(n\)</span> 点 <span class="math inline">\(m\)</span> 边的有向图，边有不超过 <span class="math inline">\(w\)</span> 的长度。现要求从点 <span class="math inline">\(1\)</span> 出发经过长度恰为 <span class="math inline">\(T\)</span> 的路径回到点 <span class="math inline">\(1\)</span> ，每到达一个点就会获得等于该点点权的愉悦值。特别地，有 <span class="math inline">\(k\)</span> 个美食节，形如“于时刻 <span class="math inline">\(t\)</span> 到达点 <span class="math inline">\(x\)</span> 会额外获得 <span class="math inline">\(y\)</span> 的愉悦值”。最大化获得的愉悦值总和。</p>
<h3 id="做法-1">做法 1</h3>
<p>考虑 <span class="math inline">\(k = 0\)</span> 的情况，也就是忽略美食节。</p>
<p>不难得到这样一个 DP ：设 <span class="math inline">\(f_{i,j}\)</span> 表示在时刻 <span class="math inline">\(i\)</span> 到达点 <span class="math inline">\(j\)</span> 的最大愉悦值，转移枚举 <span class="math inline">\(j\)</span> 的出边即可，复杂度 <span class="math inline">\(O(T(n+m))\)</span> 。</p>
<h3 id="做法-2">做法 2</h3>
<p>做法 1 的 DP 中转移与 <span class="math inline">\(i\)</span> 无关，可以想到把 <span class="math inline">\(f_i\)</span> 看做一个向量，用 max+ 矩阵描述转移，但是由于边有不等的长度，需要把连续 <span class="math inline">\(w\)</span> 个时刻的状态合并为一个向量，这样一来就可以用 max+ 矩阵描述转移，使用矩阵快速幂，复杂度 <span class="math inline">\(O(m + (wn)^3 \log T)\)</span> 。</p>
<h3 id="做法-3-正解">做法 3 （正解）</h3>
<p>现在考虑美食节，称有美食节的时刻为关键时刻，两个相邻的关键时刻之间是不受美食节影响的，可以套用矩阵快速幂的做法。那么就以关键时刻把时间轴分为 <span class="math inline">\(k+1\)</span> 段，每段用矩阵快速幂，在关键时刻把美食节的影响加到状态上即可。这里矩阵快速幂不能每次暴力矩阵乘矩阵，需要预处理矩阵乘积的幂次，然后用向量乘矩阵的方式处理每一段。复杂度 <span class="math inline">\(O(m + (wn)^3 \log T + k (wn)^2 \log T)\)</span> 。</p>
<h2 id="命运">命运</h2>
<h3 id="题目大意-1">题目大意</h3>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点的有根树和 <span class="math inline">\(m\)</span> 个点对，第 <span class="math inline">\(i\)</span> 个点对 <span class="math inline">\((x, y)\)</span> 满足 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(y\)</span> 的祖先。求有多少把边黑白染色的方案使得任意给定的点对都满足 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的路径上存在染黑的边。</p>
<h3 id="做法-1-1">做法 1</h3>
<p>容易想到树形 DP ，设 <span class="math inline">\(f_{u,i}\)</span> 表示考虑 <span class="math inline">\(u\)</span> 的子树，<span class="math inline">\(u\)</span> 向根一直走白边能走到深度 <span class="math inline">\(i\)</span> 的前提下的合法染色方案数。然后这个状态如果有一个点对可以从 <span class="math inline">\(u\)</span> 向上走白边完全经过，这个状态钦定为 0 。于是可以预处理出每个点 <span class="math inline">\(u\)</span> 的最小的有值的深度 <span class="math inline">\(a_u\)</span> ，设点 <span class="math inline">\(u\)</span> 的深度为 <span class="math inline">\(d_u\)</span> ，转移即</p>
<p><span class="math display">\[f_{u,i} = [a_u \le i \le d_u] \prod_{u \rightarrow v} (f_{v,i} + f_{v,d_v})\]</span></p>
<p>复杂度 <span class="math inline">\(O(nh)\)</span> ，其中 <span class="math inline">\(h\)</span> 是树高。</p>
<h3 id="做法-2-正解">做法 2 （正解）</h3>
<p>上述的转移看上去形式很优秀。</p>
<p>把 <span class="math inline">\(f_u\)</span> 看做一个一维向量，用线段树维护这个向量。观察转移可以发现需要对这个向量进行三个操作：</p>
<ol type="1">
<li>全局加一个数</li>
<li>两个向量点乘合并</li>
<li>保留一个区间的值</li>
<li>求点值</li>
</ol>
<p>操作 1 和操作 3 就是经典的区间加和区间乘，操作 2 是不那么平凡的线段树合并，这个合并是没法维护区间信息的，不过为什么要维护区间信息呢？由于查询操作只有点值查询，那么只有叶子维护信息就行了，非叶子节点只需要维护其他操作的懒标记，那么合并两个节点的时候先把标记下传然后就可以直接合并了。</p>
<h2 id="时代的眼泪">时代的眼泪</h2>
<h3 id="题目大意-2">题目大意</h3>
<p>给定一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的排列，<span class="math inline">\(q\)</span> 次询问，每次给定一个下标区间和一个值域区间求在给定区间内的元素的逆序对数。</p>
<h3 id="做法-1-2">做法 1</h3>
<p>如果值域区间是全集，那么问题就是区间逆序对，这是个比较经典的问题，有两种复杂度同样优秀的做法，一种是在线的序列分块，一种是莫队二次离线。</p>
<p>回顾一下序列分块的做法，设块大小为 <span class="math inline">\(B\)</span> 。</p>
<p>如果询问区间在一个块内，考虑差分，用块的一个前缀减另一个前缀，然后减去两部分之间的贡献，后者可以归并计算。</p>
<p>否则把询问区间分成三个部分 L, M, R 分别表示左端零散块，中间完整块，右端零散块。L, M, R 内部的贡献都可以预处理，对于它们之间的贡献分类讨论。</p>
<ul>
<li>LM, MR: 以 LM 为例，预处理 <span class="math inline">\(c_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个块中值不超过 <span class="math inline">\(j\)</span> 的数量，这样就可以 <span class="math inline">\(O(1)\)</span> 求出任意块区间的任意值域区间的数量，枚举 L 的每个元素算贡献即可。</li>
<li>LR: 预处理每个块的排序序列，就可以 <span class="math inline">\(O(B)\)</span> 扫描得到每个块的子序列的排序序列，得到两边的排序序列后归并即可。</li>
</ul>
<p>复杂度 <span class="math inline">\(O(\frac{n^2}{B} + n\log{n} + qB) = O(n\log{n} + q + n\sqrt{q})\)</span> 。</p>
<h3 id="做法-2-1">做法 2</h3>
<p>莫队的做法似乎难以向值域区间的限制推广，因此考虑序列分块。</p>
<p>先考虑询问的值域区间都是形如 <span class="math inline">\([1, r]\)</span> 的情况，不妨假定 <span class="math inline">\(r\)</span> 单调不降。</p>
<p>每次 <span class="math inline">\(r\)</span> 增加的时候，相当于新加入一个数，是可以简单地 <span class="math inline">\(O(B)\)</span> 维护对应块的每个前后缀的逆序对数的。</p>
<p>那么如果询问区间在一个块内，仍然可以用同样的方法处理。</p>
<p>否则同样把询问区间分为三部分 L, M, R 讨论，L, R 内部的贡献仍然是被预处理的，那么可以发现不同于做法 1 的部分仅有 MM 。</p>
<p>维护一个矩阵 <span class="math inline">\(f_{l,r}\)</span> 表示第 <span class="math inline">\(l\)</span> 个块到第 <span class="math inline">\(r\)</span> 个块之间的逆序对数，每次加入一个数的时候枚举 <span class="math inline">\(r\)</span> 相当于要做若干次区间加，每次询问只需要单点查。容易想到再次分块维护这个矩阵，但是注意到矩阵的每一行的长度只有 <span class="math inline">\(O(\frac{n}{B})\)</span> ，事实上修改的时候打标记然后查询的时候暴力扫描即可。</p>
<p>复杂度 <span class="math inline">\(O(\frac{n^2}{B} + nB + n\log{n} + qB + \frac{nq}{B}) = O((n + q) \sqrt{n} + n\log{n})\)</span> 。</p>
<h3 id="做法-3-正解-1">做法 3 （正解）</h3>
<p>现在考虑完整的问题。以下直接默认块大小为 <span class="math inline">\(B = \sqrt{n}\)</span> 。</p>
<p>如果询问区间在一个块内，每个块内把值离散化，处理 <span class="math inline">\(b_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 个位置到其所在的块的左端点中离散化后的值不超过 <span class="math inline">\(j\)</span> 的数量，<span class="math inline">\(b\)</span> 的大小是 <span class="math inline">\(O(n^{1.5})\)</span> 的。然后枚举的每个元素通过 <span class="math inline">\(b\)</span> 查询贡献即可。</p>
<p>否则还是分三个部分 L, M, R 分类讨论。</p>
<ul>
<li>LL, RR: 同询问区间在一个块内的情况。</li>
<li>LR: 同做法 1 （其实仍用上述做法也是可以的）。</li>
<li>MM: 设值域区间为 <span class="math inline">\([x, y]\)</span> 。先用做法 2 算出 <span class="math inline">\([1, y]\)</span> 和 <span class="math inline">\([1, x - 1]\)</span> 的答案，然后问题转换为求区间内有多少数对满足左边的值在 <span class="math inline">\([x, y]\)</span> 内且右边的值在 <span class="math inline">\([1, x - 1]\)</span> 内。这个问题怎么处理呢？我也暂时不会（咕咕咕）。</li>
<li>LM, MR: 同做法 1 。</li>
</ul>
<p>复杂度同做法 2 。</p>
<h2 id="制作菜品">制作菜品</h2>
<h3 id="题目大意-3">题目大意</h3>
<p>有 <span class="math inline">\(n\)</span> 种材料，第 <span class="math inline">\(i\)</span> 种材料有 <span class="math inline">\(a_i\)</span> 个。现要制作 <span class="math inline">\(m\)</span> 种菜，每种菜恰好使用 <span class="math inline">\(k\)</span> 个材料并且使用至多两种材料。求是否存在方案，如果存在则给出任意一个方案。</p>
<p>保证 <span class="math inline">\(\sum a_i = m \times k\)</span> 。</p>
<h3 id="做法-1-3">做法 1</h3>
<p>考虑 <span class="math inline">\(m \ge n - 1\)</span> 的情况，我们证明，每次把数量最少的材料和数量最多的材料放一起做菜并尽可能多地使用最少的那个材料，这样一定能得到一个合法的方案。</p>
<p>应用数学归纳法，<span class="math inline">\(n = 1\)</span> 时由于 <span class="math inline">\(a_1 = m \times k\)</span> ，此时必然有解。接下来假设 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n-1\)</span> 都是成立的。不妨假定 <span class="math inline">\(a\)</span> 是升序的。</p>
<p>如果 <span class="math inline">\(a_1 \ge k\)</span> ，把第一种材料拿 <span class="math inline">\(k\)</span> 个出来单独做菜，直到 <span class="math inline">\(a_1 &lt; k\)</span> 。此时 <span class="math inline">\(a_2\)</span> 到 <span class="math inline">\(a_n\)</span> 都是不小于 <span class="math inline">\(k\)</span> 的，由 <span class="math inline">\(\sum a_i = m \times k\)</span> 可以知道此时仍然有 <span class="math inline">\(m \ge n - 1\)</span> 。</p>
<p>如果 <span class="math inline">\(a_1 &lt; k\)</span> ，把第一种材料全部拿出来，和第 <span class="math inline">\(n\)</span> 个材料里拿 <span class="math inline">\(k - a_1\)</span> 个一起做一道菜，需要证明 <span class="math inline">\(a_n \ge k - a_1\)</span> ，否则做不成菜。反证法，如果 <span class="math inline">\(a_n &lt; k - a_1\)</span> ，那么任意 <span class="math inline">\(i\)</span> 都有 <span class="math inline">\(a_i &lt; k - a_1\)</span> ，求和后有</p>
<p><span class="math display">\[mk = \sum a_i &lt; (n-1)(k - a_1) + a_1 = k + (n-2)(k-a_1) \le (n-1)k\]</span></p>
<p>所以 <span class="math inline">\(m &lt; n - 1\)</span> ，与前提产生矛盾。</p>
<h3 id="做法-2-正解-1">做法 2 （正解）</h3>
<p>注意到 <span class="math inline">\(m &lt; n - 1\)</span> 的时候必有 <span class="math inline">\(m = n - 2\)</span> ，因此我们只讨论 <span class="math inline">\(m = n - 2\)</span> 的情况。</p>
<p>容易想到把所有材料划分成两个集合，然后两个集合当做一个 <span class="math inline">\(m = n - 1\)</span> 的子问题。如果存在合法的划分，那么原问题有解。我们证明，如果原问题有解，也一定存在合法的划分。</p>
<p>把一道菜看做连接两个材料的边，那么对于 <span class="math inline">\(m = n - 2\)</span> 时的一组解，得到的图一定有至少两个联通块，并且可以发现有至少一个联通块是一颗树（反证，如果都不是树，把点数和边数累加可以得到 <span class="math inline">\(m \ge n\)</span> ，产生矛盾）。那么把任意一颗树看做集合 <span class="math inline">\(A\)</span> ，其他的所有联通块看做集合 <span class="math inline">\(B\)</span> ，这就是一个合法的划分。</p>
<p>这里一个划分是合法的当且仅当两个集合都满足 <span class="math inline">\(\sum a_i = (n&#39; - 1) \times k\)</span> 。</p>
<p>设 <span class="math inline">\(b_i = k - a_i\)</span> ，上述条件等价于 <span class="math inline">\(\sum b_i = k\)</span> ，问题转换为在 <span class="math inline">\(b\)</span> 中找到一个和恰好为 <span class="math inline">\(k\)</span> 的子集，经典的 01 背包问题，用 bitset 优化即可。</p>
<p>复杂度 <span class="math inline">\(O(T \frac{n m k}{w})\)</span> 。</p>
<h2 id="超现实树">超现实树</h2>
<h3 id="做法-1-正解">做法 1 （正解）</h3>
<p>对于两棵树 <span class="math inline">\(A, B\)</span> ，称 <span class="math inline">\(A &lt; B\)</span> 当且仅当 <span class="math inline">\(A\)</span> 可以生成 <span class="math inline">\(B\)</span> 。</p>
<p>不难发现树林不是完备的当且仅当存在一颗无限大的树不能被生成，设该树为 <span class="math inline">\(T\)</span> ，不妨假设在所有足条件的树中 <span class="math inline">\(T\)</span> 是极小的。注意到如果 <span class="math inline">\(T\)</span> 的某个点满足左右儿子的大小都超过 <span class="math inline">\(1\)</span> ，那么一定存在另一颗比 <span class="math inline">\(T\)</span> 小的树 <span class="math inline">\(T&#39;\)</span> 同样满足条件，这违背了 <span class="math inline">\(T\)</span> 的极小性。那么称一颗不存在任何点的左右儿子大小都超过 <span class="math inline">\(1\)</span> 的树为备选树，可以发现，树林非完备当且仅当存在一颗无限大的备选树不能被生成。</p>
<p>那么我们只需关注树林是否可以生成所有无限大的备选树，注意到非备选树始终无法生成备选树，因此我们即使在树林中我们也只需要考虑备选树。</p>
<p>我们递归地判定树林 <span class="math inline">\(e\)</span> 是否可以生成所有无限大的备选树，如果 <span class="math inline">\(e\)</span> 中存在大小为 <span class="math inline">\(1\)</span> 的树，<span class="math inline">\(e\)</span> 显然是完备的，如果 <span class="math inline">\(e\)</span> 中没有树，<span class="math inline">\(e\)</span> 显然不是完备的。否则，可以发现 <span class="math inline">\(e\)</span> 中的备选树可以分为四类：</p>
<ol type="1">
<li>没有左儿子</li>
<li>没有右儿子</li>
<li>左儿子大小为 1</li>
<li>右儿子大小为 1</li>
</ol>
<p>设这四种树去掉根保留另一个较大的儿子后分别构成树林 <span class="math inline">\(a, b, c, d\)</span> ，那么不难发现此时 <span class="math inline">\(e\)</span> 是完备的当且仅当 <span class="math inline">\(a, b, c, d\)</span> 都是完备的，递归判定即可。</p>
<h2 id="翻修道路">翻修道路</h2>
<h3 id="做法-1-4">做法 1</h3>
<p>考虑所有道路长度都为 <span class="math inline">\(1\)</span> 的情况。</p>
<p>弦图遇事不决完美消除序列。不妨假定 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 就是一个完美消除序列且 <span class="math inline">\(t = n\)</span> 。设翻修的路径是有向的，从 <span class="math inline">\(s\)</span> 指向 <span class="math inline">\(t\)</span> 。</p>
<p>首先翻修的路径中的任意一条边 <span class="math inline">\((x, y)\)</span> 都满足 <span class="math inline">\(x &lt; y\)</span> 。反证法，对于翻修路径上某一个点 <span class="math inline">\(x\)</span> ，其前驱后继分别为 <span class="math inline">\(y, z\)</span> 。如果 <span class="math inline">\(y &gt; x \land z &gt; x\)</span> ，那么 <span class="math inline">\(y, z\)</span> 之间一定有边，把翻修路径中的 <span class="math inline">\(y \rightarrow x \rightarrow z\)</span> 换成 <span class="math inline">\(y \rightarrow z\)</span> 一定不劣，并且一定仍然合法。</p>
<p>那么直接从小到大连有向边然后 bfs 求个最短路即可，复杂度 <span class="math inline">\(O(n + m)\)</span> 。</p>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>关于积性函数前缀和的一些胡扯</title>
    <url>/2020/08/29/%E5%85%B3%E4%BA%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E8%83%A1%E6%89%AF/</url>
    <content><![CDATA[<p>想出一道不一般的积性函数前缀和的题，题没出出来，倒是发现不少有意思的东西。</p>
<a id="more"></a>
<h2 id="一些定义">一些定义</h2>
<p>有些定义是我胡扯的。</p>
<p>对于积性函数 <span class="math inline">\(f\)</span> ，称其特征函数 <span class="math inline">\(F\)</span> 为 <span class="math inline">\(f\)</span> 关于质数 <span class="math inline">\(p\)</span> 的函数，准确来说 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(f\)</span> 的特征函数当且仅当对于任意质数 <span class="math inline">\(p\)</span> 有 <span class="math inline">\(F(p) = f(p)\)</span> ，可以发现 <span class="math inline">\(F\)</span> 并不是唯一的，但是我们只考虑最简单的那个，例如对于任意质数 <span class="math inline">\(p\)</span> 有 <span class="math inline">\(f(p) = p + 1\)</span> ，不妨令任意 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(F(x) = x + 1\)</span> ，可以发现 <span class="math inline">\(F\)</span> 并不一定是积性函数。</p>
<p>记积性函数 <span class="math inline">\(I_m(x) = x^m\)</span> 。</p>
<p>对于数论函数 <span class="math inline">\(f\)</span> ，其前缀和函数记为 <span class="math inline">\(S_f\)</span> ，满足 <span class="math inline">\(S_f(n) = \sum_{i=1}^n f(i)\)</span> 。</p>
<p>记 <span class="math inline">\(B(n) = \lfloor \sqrt{n} \rfloor\)</span> ，<span class="math inline">\(n / i = \lfloor \frac{n}{i} \rfloor\)</span> 。</p>
<h3 id="关于特征函数">关于特征函数</h3>
<p>两个积性函数相乘（狄利克雷卷积），它们的特征函数相加（线性相加）。</p>
<h2 id="powerful-number">Powerful Number</h2>
<p>众所周知 Powerful Number 可以快速求一类积性函数前缀和，这玩意的本质是什么呢？</p>
<p>对于积性函数 <span class="math inline">\(f\)</span> ，称其为 Powerful Function ，当且仅当其有特征函数 <span class="math inline">\(F\)</span> 恒为 0 。</p>
<ul>
<li>定理 1 ：Powerful Function 在 <span class="math inline">\(n\)</span> 以内的非零的值只有 <span class="math inline">\(O(\sqrt{n})\)</span> 个。</li>
</ul>
<p>那么 Powerful Number 求 <span class="math inline">\(S_f(n)\)</span> 的本质就是找一个与 <span class="math inline">\(f\)</span> 特征函数相同的数论函数 <span class="math inline">\(h\)</span> ，然后令 <span class="math inline">\(g = f \times h^{-1}\)</span> ，可以知道 <span class="math inline">\(g\)</span> 特征函数是两者相减，那么 <span class="math inline">\(g\)</span> 一定是 Powerful Function ，于是根据</p>
<p><span class="math display">\[S_f(n) = \sum_{i=1}^n g(i) S_h(\lfloor \frac{n}{i} \rfloor)\]</span></p>
<p>枚举 <span class="math inline">\(g\)</span> 的有效值，也就是 Powerful Number ，问题可以从求 <span class="math inline">\(S_f\)</span> 转换为求 <span class="math inline">\(S_h\)</span> 。</p>
<p>如果 <span class="math inline">\(S_h(n)\)</span> 可以 <span class="math inline">\(O(1)\)</span> 求，那么 <span class="math inline">\(S_f(n)\)</span> 就可以 <span class="math inline">\(O(\sqrt{n})\)</span> 求，但大多数时候并非如此。</p>
<h2 id="卷积构造">卷积构造</h2>
<p>卷积构造也是求积性函数前缀和的利器，杜教筛便是广为人知的一个例子。</p>
<p>构造狄利克雷卷积 <span class="math inline">\(f \times g = h\)</span> ，那么根据</p>
<p><span class="math display">\[S_f(n) = S_h(n) - S_g(n) + S_f(B(n)) S_g(B(n)) - \sum_{i=2}^{B(n)} (g(i) S_f(n / i) + f(i) S_g(n / i))\]</span></p>
<p>即可把求 <span class="math inline">\(S_f(n)\)</span> 的问题转换为求 <span class="math inline">\(S_g, S_h\)</span> 。</p>
<p>事实上，把上式换个方向，构造卷积 <span class="math inline">\(f = g \times h\)</span> ，根据</p>
<p><span class="math display">\[S_f(n) = \sum_{i=1}^{B(n)} (g(i) S_f(n / i) + f(i) S_g(n / i)) - S_f(B(n)) S_g(B(n))\]</span></p>
<p>也同样可以把求 <span class="math inline">\(S_f(n)\)</span> 的问题转换为求 <span class="math inline">\(S_g, S_h\)</span> 。</p>
<h2 id="回到-powerful-number">回到 Powerful Number</h2>
<p>有时候找不到特征函数相同的可以 <span class="math inline">\(O(1)\)</span> 求前缀和的数论函数，但是可以把特征函数拆成两部分的和，然后两部分分别可以找到对应可以 <span class="math inline">\(O(1)\)</span> 求的数论函数，这时候也是可以用 Powerful Number 去算的。</p>
<p>也就是构造卷积 <span class="math inline">\(h = a \times b\)</span> ，如果 <span class="math inline">\(S_a, S_b\)</span> 都可以 <span class="math inline">\(O(1)\)</span> 求值，那么根据上文的卷积构造的式子，就可以 <span class="math inline">\(O(\sqrt{n})\)</span> 求出 <span class="math inline">\(S_h(n)\)</span> ，这时候对于任意与 <span class="math inline">\(h\)</span> 特征函数相同的 <span class="math inline">\(f\)</span> ，都可以利用 Powerful Number 来 <span class="math inline">\(O(\sqrt{n}\log{n})\)</span> 求出 <span class="math inline">\(S_f(n)\)</span> 。</p>
<p>注意到对于任意常数 <span class="math inline">\(m\)</span> ，<span class="math inline">\(I_m\)</span> 都是可以 <span class="math inline">\(O(1)\)</span> 求值的，那么只要 <span class="math inline">\(f\)</span> 的特征函数可以表示为恰好两个形如 <span class="math inline">\(x^k\)</span> 的单项式的和，<span class="math inline">\(S_f\)</span> 就是可以 <span class="math inline">\(O(\sqrt{n}\log{n})\)</span> 求的。</p>
<p>例如 <span class="math inline">\(f(p) = 2, f(p) = p + 1, f(p) = p^5 + p^3\)</span> 等。</p>
<p>由于上文构造卷积两个方向都可行，那么如果 <span class="math inline">\(f\)</span> 的特征函数可以表示为恰好两个形如 <span class="math inline">\(x^k\)</span> 的单项式的差，是否可以以同样复杂度求前缀和呢？</p>
<p>很遗憾答案（似乎）是否定的，因为另一个方向（杜教筛的方向）需要递归用到自身的函数值。不过虽然没法做到 <span class="math inline">\(O(\sqrt{n}\log{n})\)</span> ，用杜教筛的 trick 可以把这类问题都做到 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 。</p>
<p>这里顺便可以思考思考，为什么约数个数函数，约数和函数有 <span class="math inline">\(O(\sqrt{n})\)</span> 算前缀和的公式？本质上就是因为约数个数函数是 <span class="math inline">\(I_0 \times I_0\)</span> ，约数和函数是 <span class="math inline">\(I_0 \times I_1\)</span> ，两者的特征函数分别是 <span class="math inline">\(1 + 1\)</span> 和 <span class="math inline">\(x + 1\)</span> 。</p>
<h2 id="更一般的情况">更一般的情况</h2>
<p>如果 <span class="math inline">\(f\)</span> 的特征函数可以是一个多项式，如何求 <span class="math inline">\(S_f(n)\)</span> ？</p>
<p>多项式可以拆成若干单项式的和，单项式可以拆成若干系数为 <span class="math inline">\(1\)</span> 的单项式的和，也就是说这样的 <span class="math inline">\(f\)</span> 总可以找到对应的 <span class="math inline">\(h\)</span> 表示为若干 <span class="math inline">\(I_m\)</span> 的狄利克雷卷积。</p>
<p>例如 <span class="math inline">\(f(p) = 3p^3 + p^2 - p + 1\)</span> ，那么设 <span class="math inline">\(h = I_3 \times I_3 \times I_3 \times I_2 \times I_1^{-1} \times I_0\)</span> ，不难发现逐个合并可以以 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 的复杂度算出所有 <span class="math inline">\(S_h(n/i)\)</span> ，然后用 Powerful Number 的做法可以 <span class="math inline">\(O(\sqrt{n})\)</span> 求 <span class="math inline">\(S_f(n)\)</span> ，也可以 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 求出所有 <span class="math inline">\(S_f(n/i)\)</span> 。</p>
<p>如果系数更大，比如 <span class="math inline">\(f(p) = K p\)</span> ，那么设 <span class="math inline">\(h = I_1^K\)</span> ，快速幂合并，可以以 <span class="math inline">\(O(n^{\frac{2}{3}}\log{K})\)</span> 的复杂度求出所有 <span class="math inline">\(S_f(n/i)\)</span> 。</p>
<p>更一般的结论就不难导出了，如果 <span class="math inline">\(f\)</span> 的特征函数可以是一个多项式，可以以 <span class="math inline">\(O(Ln^{\frac{2}{3}}\log)\)</span> 的复杂度求出所有 <span class="math inline">\(S_f(n/i)\)</span> ，其中 <span class="math inline">\(L\)</span> 是多项式的次数。</p>
<h2 id="min25-筛">min25 筛</h2>
<p>众所周知的是，如果 <span class="math inline">\(f\)</span> 的特征函数可以是一个多项式，min25 筛也可以求 <span class="math inline">\(S_f(n)\)</span> ，虽然复杂度是 <span class="math inline">\(O(n^{1-\epsilon}+Ln^{\frac{3}{4}}/\log)\)</span> 但是实际运用非常优秀。</p>
<p>所以上述做法在实际运用中并不理想，这也是我没能出出一道题目的原因，除非 <span class="math inline">\(n\)</span> 开到特别大放到天河一号上面跑，否则上述做法的实际运行效率就不会优于 min25 筛。</p>
<p>但是上述做法的复杂度确实更优秀，或许可以为这类问题的理论研究提供一定的思路。</p>
<p>有意思的是，这两种做法的思路和方向虽然截然不同，但它们都只关注积性函数的特征函数，这或许能带来一些启发。</p>
<h2 id="end">End</h2>
<p>本文尽是一些胡扯，主要是为自己突发的灵感记个笔记，如有错误的地方还请指正。</p>
<p>可惜的是这个做法在实际应用中没啥用，但是我目前没有进一步的优化思路，如有想法欢迎讨论。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>APIO2020</title>
    <url>/2020/08/15/APIO2020/</url>
    <content><![CDATA[<p><del>就呆机房考试了一上午，写个屁游记啊。</del></p>
<p><del>边打 APIO 边写游记，这感觉很妙啊。</del></p>
<a id="more"></a>
<h2 id="考试">考试</h2>
<h3 id="painting-walls">Painting Walls</h3>
<p>被题意卡了一小会，搞懂题目后发现就只要对于每个位置暴力枚举如果从该位置开始染色，第一个工人是谁，然后 DP 一下。一开始用了 map 去 DP ，被卡了。然后换滚动数组去 DP ，结果发现还是被卡了。查了好久才发现我用了一个 <code>set</code> 在每次更新 DP 值后都会执行 <code>insert</code> 操作。。。我因为它的大小是 <span class="math inline">\(O(n)\)</span> 就莫名其妙的地以为这个 <code>set</code> 带来的时间复杂度始终是 <span class="math inline">\(O(n\log n)\)</span> 。。。</p>
<h3 id="swapping-cities">Swapping Cities</h3>
<p>有理有据的分析可以发现一个子图中 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 是合法的当且仅当有度数为三的点或者有环。<del>然后这就是大家所熟知的 Kruskal 重构树了</del>。</p>
<h3 id="fun-tour">Fun Tour</h3>
<p>一开始打了一个基于重心的贪心，交上去只过了 <span class="math inline">\(n \le 7\)</span> 的分，<del>疯狂对拍</del> 冷静分析后发现贪心假了。</p>
<p>然后就打了暴力 dfs 的 26 分，继续想，想了个有理有据的动态换根 DP ，由于 subtask3 的树高是 <span class="math inline">\(O(\log)\)</span> 的，可以暴力修改 DP 值。于是写写写写写写写，越写发现细节越多，写着写着突然发现比赛结束了。。。</p>
]]></content>
  </entry>
  <entry>
    <title>近期考试总结</title>
    <url>/2020/08/13/%E8%BF%91%E6%9C%9F%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章。</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f3ab43964040a0b388ecb2fb639b9d384e5bd7d3cafe8c91f4fe812921cbae7c">178052232ef3e919ddef1b669edf4de3dbdba471066ffb4cc2d34752c4c56284aaa9e6ed228bf37b552b1e5018c4a98b3dbda1890b350260b910343e03ebe9781e866dbc93061189e0bcbcd91abe1fdbb6d0f8170ad003bc9a91708e05a6b86d1656454f48476a4bbf67c1819d17ffc582a1e2778d60370d6c59104eb6ec7a377febb40c04495a77f558bfe5af845900a8387d39eeedc7eb257b5957d8d83ef417bdc499f479d0e088fb8822cad70a59d44d6a6ec63fda4adeb24f482390f57490231d4eebca0e1d3edec767cee87d647a5173ef3f1efa15aaeeb2d226ea5c51da497e6eacef1cf5fb0e58c17635515348f02b91f9a90479105a1851b9c0418af091a64c2246b046b96446ecb155cdfdcc3832a2e384b3e794ff7109656efe8b0230320072182e3e6c157f883a3fc48f75a83b3e2f5ae5f22b81b0c5f79fdab13091c00b8450a9a6503957096c884e6b8d186f0944ee33f3c629802b89cf76d3a60aced853904f40857e35176c8cf99dbfb3c904e4a2f690caccca2e876e41e250931c6e325ce79ad899e14c8f741f7121e831d32eb41a7058061a3af493f4f750caed567ab312a101a9350b52c9a05f476ef2279f8eb586f08f19992bcf122258225a010f2a078741901699ce2e37f0aa42695fc30d57d50b396d6c844d1f250d15794e07257fa58ccb5e105347df8b795c6f7bf3715d23fb2aac437d222675795b0421b81138c74d8baecfe4e9a0dc9ade06efc3a9a7d9790c9f0c18ae9287a67fe17f9c69afcbba8fd821773cc1321e886f47fce1f1d9797ca5a3b67da6c2d225f05d2d7340bfd4c03b563dc9fb319aa352be84f049db882e102c2d6e319e0d40a15d5f026d99f95132ad2e4a8fe9e840c5034e3359266af8148938e02f2f3871f896b8c1e0143cf8388b3f96ec8fe0c4bbe9b34f910f19b518bfd5aa7bea16339bc33b1eb425eb1e3c5431985cbdfce27938c47aacd92190a8513724b5b4dbe026a29c6785fc3a0d8e3b242fbdcd676a4c2c4c388f61fabd95afb03c20c6fbfa4e5231293bc3eb9cba1eae870ab6c00a710bb1ec14b91b16c826e57b25d8f55926f18af583f008cbf72ffb8299d904f82581d42971eef686d8f634e73f6f77270666c1fdc140390656b53805d9e99d4383216cc35dea4ca0197ec68463f479a2bd5ccefd132f712b20fa8a5664c0acc59bd6bfa5c6f28cc4eecc9aaa4e1b4b860e69a13fee2ff6141b76dfb196d20f7aa72df8fadc2cb6322a0d5375ec16e7ca229b51a4fe90f5edfc56ea4b7564220406941e7c62bdc49c4f9be0af56e67a083fd7e8c86dd7e295b09279bdc24198ba2093e7ebb0871590456810d326a9107f877cff24cdf29fd17162fa74b295ad0c9f8f858f3f96d136655c06eda9cf46698ee167960e3658938f10dac21a8c25625f4896d4b0a1ea22287a1897f154565417a40227f75b3a629898d0021b964867e7365a54393e9219bf7df0fadcd53fe452d3af6b45e2072c81fc6c546048a72aa52b26136706236a54dbcaeabdee04486bfe4086be231e34f0d757aec3417d89a0db56d79ea7f0c5fb41e4c1012d64c540a8fcca35dc5c15c028cc6134c2c9533d0091273474ab9c1a4573a004ffbf75e4c07247f787a1f55c006200ad1d952c569e2b9f60899c3ad3f9188b321c016530d2e1a903899affd4fdffeae9a63452f2fd98990287e07f3181dd4c30fc5283d686375b3c7a0222cd1dfbd9be6f79dbdda9cd478cb9ba0b1f4d07c887014c1fd7e2abd344e65d1486b4c1ed031f35acfba09d7b705fb208fefc2164fa91ba2ed5553b66bd5f3dcc5caacf71da5f725d97d11bc8f66a12992c0c7a7f4d1c0449bb358c13daf9c847592604a8bb5ccac327c49e53ed2beed4b607957a0f5e4b89d128a4a09fbb563e749efa59dfae3a1b7f846a1e347ee2583bf8ca3959729ac2a9b4d60ac85c45d4aa2d47c9312042824344ba6f7323e9661d10a56118cc9e37d6df6c57160cb4dcf54348a46c3531b490cd09956025180eed7eafd7a91565b8f032dc7e7cc1b2e5e92261c5309efaf84e03419714a4abae7e47f66f4cb66998a650dc5cc263934884e64dfaa4e9ba146c7ba02a440aee370f128a2fbf1f2bd3aa27e007bdde4aa0c1596a64550227ae421dbb21f0a349994ed4c295be698407cebf66ba92ef81488629d13a0818b1c1f336c0fd5398efc03156b2e64e4b7d3248ee8d8052b543d0b77d743802c55d36d8fbe84a05392d7bc7bc67d8b98e8534c65477cd23306b723bbd5cd98397eb28aeb53ac951f6ae2b54dd47f9e0eeeaa98a60d17bd4ce7f30bc6ba08034afde1595c00fe208a25d953e9b3da99c4f6ade80e9f16762e0de54b143fa9b02000f94bf6efc1ac5d22a85714b73acc7436233f83bc5e7db443ad010de2b6c60e5e65b7c4c71fef48071ee372e98ef60690b3a71bcbe243558193b32fac90fd36109c54b25fe20983ed9836d6de1b8d0d3c49fd2d7dda2e5353270bb54ac7823162748df34cc38bb1bf206688f11c9697b49193fd75f9bb67299aad2d0ced629e80f3e0b1369fd94b7358005254b12deb200ac5446c348537c2e5b932245957c10b04ff460a8acf7af313f742c0632b3ddb9212aeab5904074288a6b8a843eebd96ab4fdab6458f4a21b373be1644e3e4200cb300c26687ba4e7da23cd422d88e1431ade5b2130ae6c94f9bd50762f5b80c7440b93a5bf0167b64355933a0ea5d9635a0d4231c338bac931060d440018a2484aa494aa005fb6a0beb4889f58cee79dac81f8664d5bfcd75a1245ac4c8329fe2e4e1c0ad7ab9c51b2b4849a4ac30e0c2d7eb94780283a94fb95e1271a6ee706d83802964e9685914d9d45cc30508925955ba5f4747d9c8124f02aaca8c191601b3268425b458ec98eea504bf8f5db0001900a7dde4b43e56ab618c1695514ec19fbaf0df199f6d36b0e1819b5c9d06f1eb7e12c413fe8cbb63e6896006e97ce9078f303920e9f7864d4b46a6294e2b97822c2121cb1809ae0301fba9e3d6a1135451bdfeb8c4a485bd27df1b6129614879c983a68c96a9b9a36426f395a3eac7a7c8aa070440b09d909ac176450909b6df4c953e835b5121dcdc1c6aa93c279b0833e7d64b156217daf00f2a1633ad8c1a5648e3a9faa4c914aecc18c3c33b3cac3b3843fb41573519d79664c7b4e2bff52ef417fd01faf3397e8261c88c0dbf254c058b97c2a860ef2b6466412dd3e8f9b01759704f5a344cb40ff09ff26bc5ff85372778d9766ace2649ef81deb91c12265757942fbb7b9cb4782feb8adec5ada76e9359048a811ce8e686f0b5e748f18c11171ae468b954486d313b1ba940c0ef7963a3ea8da2571440fe647996dd9468baf73e8f0858df05aa14759d88613a4c0ae412d0639bbab275a06121667d1d971b36b805c6dddc283c088a407a4e3aba7afce225e8206681c99bb5cc8f7e20f68f07ac52e6f4e82964d243c7d352b611187ce222e045e04a5d353733d86a21843e2e735bc3ea127ab1668444c7955de090b1c6889c9c90b9dda95fd1b7c9342f81ab576fe620368f3cf545772b35acdd48242143fdff4103ae22cc8a3df00ece4b1f3e671b66ecd4f41810fe435fa4ae17ca211787da8f7b5273777a6115c030149561ade9fd35b5f01e959bed051801def9c3da05065f9ca4847fd4dcc562088920d28e128d699ae953b2861671c76b1a1fa50b92c3d04ccbbef4603f5541033117a65f514c29dfe06e86f0d33933145ef8e5b6aa010ab3d42d29fb0232e2708cde8f1cf099528ac6a6fa2f95a6565bfe90fe48f7ce39fd9ec8dbf4f628f45966ff2f87b0464f457a98e659e245230b177e72890a885c260022d56ec2b8f3a360244e2688a6a327337528aa623c2972175dde26bf2094d06702aa91db8fa212ccaa5eb938acffaaff2f9fca43a94380d2fc3f86e5cc8e52c173bd4a58fc45d925b8729987e00fec0be5862835d41f8e784c3bebd4132ee1124d23ecdf2d430601aa58d65eac1beec5258f832d8952de82d0c69ff3255b60d28338355fc0c3e143bab216887bddb48756f748a1671ab70ce566291058dcd5a36b36c8ccae80eacbf694e50ae90d91461a7c95aa5170b0782bb13053f05f48d4e1946ac4cbb92a737cb71901c3c764fff1cf8c435c24e00b9ca20ea9aee8aaae76b6cf7bff030c2bb7c0605bfcb987beab2bc80fa4384d5362eceebedd879bfb687ff31f4d1919ead239d796d5ce1730afef54c5a55d4cf730bec1b3f4cfce46f8f33126f2f86d8ba258624b9378373b3ee78e3d44fa18f6ca6488730e0a667b8c0b4c3a773ae4a4f7fc0688e4a841e461be966759bcda09fac5226142358ce55518c6204bb524be24fc091f67591671a564df2a068c2780976bf5d09eda018f3c49977962e30d6b5554b3f626334c23e150b3511d47be42abd82d4a7a4f1c1d40a9cb6e4dd60abab3600015f69b7a33d46ad236f14724496d00ecaa75ae2c0dbe8e77aee46f06e5555f51f79695b50a36731dce819a37ec8f0da911dff4c9d6c2f923c8735de119379e9b4ec4d62a32f789a293a2a1f792f65619e607f5cce82281e690301e609a55ed9610e663b678971ecd4d3757b164cbadc0fb26f10213f11603c73e8156fb86d0ba3c21f298fd514257844f487fd0874367aa2c7666a60af0cc3c9f9dd2d207e2d0281e7fec9681c3f2d7732c1365f604a0e92315c08d6fac6567764792cf6c0d81ad357102703d6f09f1d7104164b97e4b8b1ec40f465006af13db431d75f609ca4832242c644d903ef26f8ed6f0d977a973f401be0cc09e234d76ebf84927559745258aeb9b9e107c49165cdfe5c7a5c470e4a31d9531eebaaf50ebd60d3a10d769b060cdfd78c5e100e345966bb9403a5fd6628c95cb1f7b349cee5f14363ffd80b92754f6ac5a6784251c51348ee9e2611d1c69ad434f2acf6acde29c539f200f4062ed6092835241a0809d40dc1c1de21786df71835bae6abb012a783446cac01a58a31be432dc42c82deb61684305776d668528bb2a3be3e31766fd1c1b11466f7a91fe3eac7822f92616fc09d2de10b214093e7b6ec18bf22216c9e2ffad516ccd4c67be40212d8f61dc1319d5407703008750bbbd816582797eb3d81ee1f9613bbda7621f221336c08d2d5f98458dd6ff59555bb86e4a55dedc5bd150fc82157d11ce7647e028f69a89fc32b32ddf5a59eaedb379a3df6dba9fcd9b6d8321166e2c116b49ceea142a3312239592e81cde19e8274cb99540c284bee0cff3fcb9ac69aaea7caa7b0b519c9721c73e1d496f69d2fdd145f7b083cd1d13d1899bad40e341756fadba2ad95608aa17921cebea58292479936a2d39e57101577f629cf2397b2351dcb241399fedd246ef026c80c3f9e80ee46d3328833a46368b88bb87b4d866b0cd2d01f8a97c45aa9bf7f28c48c3a756c0c7a7815ee4b08a867c2b5b88a421208a721eebff952a91557d02eb2eadd2c9073a8f398965c8b92b1ab7f93e89d01a477c5c39564d65e0434f55a5c1ca1d4403832dc60ee45bc8822bed79e09bf50a8589c573e7af2658bd76cd948f51e0d2806ac023336674f8dc4bb62844a5b0ea9206b07d4ebe1de2589677b96912a2bb43eeb5525529cb26cabdef78e5579fe022b12493f2330c5ddab1d22b76fba959d1548c9fd2558f9b48b87c28a21ef670f613f2e8261bcb0e1fbccee28c95202b47d6fcb36dee933bae3eb2dfa1836f625f00a49ec87771c0a7ceceef9f651254bb34ca6d76df84dd318f445f4a8531a0ef343e0219f11bcf96115005d40d8ec8bef65e14b9951e7f0c6d0f77ab62ef37e697506e2e532d2fce60d8c7fb79c830cb5e286632fd8d61c2122dbc4f01fc9d2196fa7a7f14d894f5db79304a245cb3f1c5723286d46e530b3e27502507845b3682d820a53a5fe24923a573889cad3f5d970fd91ceca85ea3722229f5ffa1ce3ada2e077530a1ca1f76f7ce4d7c777f294812245f2421a6b54d320edbfabed7c1272d2992d6ef9ccd9105055df4bd8c343f3195bd6d3b56c2331aa606e6b3f18ec4f9a95caf0188dc6c4646da95cde5f40dc2468f3bcb6a92cbd5205353c068b0bfa0a8f6d2464689bf6f6ea1ff93b3a94efff869aa8eb8edbb0ce1da1befddb2dc985ea351cf19b932055e9005a93f619832028eb7ac264d075db15bf95534817dcdd0827b9634f48197d81a97415ef3cabd6596ec6a42e08d89edff57714d63cb144d5bfe6e448302cec8a05e6d12d29d4bcd3a80ecfe91a930c156ab2b801606ad93e6b2ba89bad509f9ba77f610a21d4ff517a5b6ee671235398843a73b8803d4c06908d5622cd76a5bc5d5852dd6ee6bccbdf2808813d886e6ec4b48a156e6077faa678f8d106e2e16608f747310a0ea2ff130e09aa52af81d1cb6d2210867cfb0901d6c00c2e38fd171b51ce2a252c8f07ad403d7a2a02f83ea3aa70473ca308469b3f28d83e9570d0179be575c9f7e215a317c0253a2da91069be8feadef944d850b0acc02d41b9e382a6705c8fcd3f0104dc7249a6cc745c8dbc5057a6e7006de39fcc76c1a3ddb5d30300c8f3f88032a3b91d375ee8fb41156a9e65afe26b9724ef0b830a54e1c7d329bb1c1f71e9a82778ba3b6bf715b0cf265f37053a4496cc24e4406316a67674e2b1fdfd7f6e8bb884bcee85f99931ed3592d7099cf1657d0efc72bcd8b87e8f7e61aded8c5b78527717677966bb5227c063ca75f32fd8c9fe3d60bd0e49d0b8fd4a267bc8bed29a3d05f24b374408e6a4938294d9269b000d1aad7270837e0f4fa44ebf294fc12a4bb9a43815983458bcf1c19a51d4739795f117112e4b29f687366273b00d6625d0b5dbd065c459357545af5b074c68e9d2c3191aa597e3f10ad342f0921b16ffc31e18e8ceedbe7a682c7da843217cfdd99f619df7e806f2d7c6f4454c5f760be50c4a93bdcb6e8cdcd4f2605b41226cb9f7708e5b0aa6a1b34bbb2c2e22e495c888a81ec76cf2407bddc43db18b6852b9a8e5ed675b40131ea235cd73f90a453e59fcd446e00b5afa299c4041df681666960367fdf80d3830d6947ed20b182186211d4700e723f6b14598f1d65f4bbfa84c40c0ac3b67b58e0dcc056c61f152bae22d8655b60b788ec0822f6349b17accbdf075ad1efdfb26066c36f54acd15371a388c7387e4b0aac64b12820f6f44083720cf481b4ddfe91337da29cbbbbb97907305e67070d3aa55c57161cb0e89142a0424f233c72a86963ae872d62cbcee6b8eae618bfd8c62fe6f09e85549c877aa6d77ac138e2a00e4d7d8da0fc43bc8a2975bb35f3c31a922face81017f7052921f1f2ed29a54c9594c9afb4833e60b93a1a98a1bdc49c6d37756dc4d2d04aacb34afc6fb24d9a28c7805fd025128d690bcc490429228330722d199cd7a1e801f17679d2af12b26d3119f095476a90de8292545881b142d90a12cf6847c72203fdb6b8e4cea5f1e93c9248a00e5bb3cfc8c69d878e44253e176bceb4667fd3371e9ac2ab644912929ffc7a4ce9e2a9e705ff38f44cf9b1b7a006afd9112e2308b6b963ef4fbfb265025061de6f966f19b92532f5851091b8781310bb80be8652789eccb7f0967c39e925351afc3fc440405bc72812cb88f44c1cd2d3ac6f55cfde136e29c838eaa580f8353166b391dba6991e1ee011afcbb21c05f16680d3f4650500f0def34c7ae0c637362eff81137c73b740dfdde7ee46b9bf62d752c365b21b04c1bfc326c9dbd2ad052391084b27e18c97901bb371b7b64fcfb75a65a6a029d11a78b861447799966e23706c1be162ca063fac283b01bd7a88de16f9cb88682465203fc4329d085f4ab0fc9ec5d509508524c3bc9e9758de239a36e262df87eef4f59dc6564815f7773a1a83fb85070fa4fab2624e0a6cc919dea034e29e8aca14f982a1966d96d289fb3bc83678addb3dc24ccf4939c36f78533ef2a18f6df4ede4fe431085f5b3c5f74129edf8af751057a6475a4dd374542a0676cd611d95caf9c0b72a849e7b82eee8605aa82bd5518766e01c7759b1a5653ec18f1a81763c170dd8f386653ab7e60ae8d056fc2aa162560e531a5d5e2e01b836aeac4302175cf709fa59bbfcddeed5bbf8953508bdfdb58c9202ca80c351e0ab524997249b735d0198632a5d42349c49812cb0615cc9266f14b2dee431559f4e95307d9b7f82a268353e0f52e874f85ff8aad32d6af1c5ab70a2bea3540c50ebe4402883f7f7d779ffb799576f5198f702e046a57bd0e436a1532f65cdff44f85490a2f150315b5330245018652c5a4f8056507a6d37d948b7a1707e67e3480fc6b6696bed6124ba9790c9d0b2c40ed766751316573aac97c5ebe9410f0cfe9f964027c33ba240cb9523eebf81ef35ad092238d9d3ea8a5a16c89a0ae561efee1b3c9dc58dadc7c4820903cc8fa70ac320e8bdfe4a95cd287d06a34d48a4e0c4f178ffa07440c92733a1cac459cb728a4dfbe17457488d41be953185c06b51e3a323ad46442d441b15972e4f283224ed7a21f40220d1f834129e75d6443474cddb9a1cc64765ce41d986e8975905867e5ccc39cde9ad170a52a701a3c01f0640effde45208baddd2eaddce41bed31db46371232b0c73dd3380c34f6b442079c89c4cc4dc3e646651d7637d2b158ca8af4c32e4b9cdafdc6ce832ea7bc3a9d9037edb99bab57534b51c153e6235c2c8117b19be67a465f9d4659715936b613279f82f00fdb8fe551a0674401a27862486f4e813e0d61911c741cea1fafe1ad973bc91d0e49c74dff7193749f2cbcb1d33751040eebb822c2ab72523db9015ea8fda21c11428622d0e1f87759ce087319522f9bd68592a627f463a19e2fc340730c3860e865d9af50d5676bdd9f1e2eb6e34360fd163686fd68adc4f6216c85deb6ea23f636278478968b1bb6d05ca897187e2aee8a7ebb67047e73091eded0ebc299301802b0c28abb2cdaf21f135de7c82039abf9e773ef1437d81d0736fa4dd8ee342471a99f5737f3ad68a3c56ee46063b09ad11660231126401abcc7bb2ba2ae5f4a28e6046c5fb2c1eed1a9f2e0b97d6bc0f1eed00a555be9367be159bb0d051a22cd0751e93f732568899357d2c41d6c5d476e36e3aa7a87e63c404598cc01028da231037e797187ae28b826e652883d449db7b8ce014e61507b7092eb2371bbac994bc56ca3c4e73e146a3aacf08d0deff6466fc370e5b812febc98c37d708ac597bec5e78adfb787d7845f380e44ba8e3f1306dd353280eccc5c88b50094bec6edead79ba246f39672cd757a9821e8cbd09eda377dccc427518cefbed33f942b4160ea22c762085b8dada2f7340ff89c99ae60e514180952243d7616c5aeb6272465393b7614441711b3b06320221963e3988e3ccd71d6708521262e6776ed3974d2687be30eeb65240569b4e970ff42f461c649f974cf008f726cfcf91ea1f06ba60ecd4ac2b9b9e6e00c1040acbf348a7eb6034543c812d1e65904e81706d75aed2741734454409c3d73b6eff338b6e08cd026f6e7a3636d7dccf03c6d8526ec23910a019db442672e60c17497e21cfadc4459e64ed575d4716dd74ab461dd38c5b5202f4d74aae308fc148909b83c125ab2a158ccb777d8bc8e95e9265fd9eeb32ef68ea5b20f06dd7bc0047aefa2907c038f16189e262beadf549a4362007d3fc5b748b265182a327222cf9bee2225e0ea9b5f99e767b0faefae8107ce4aeb877ae6f7b3ad0d5b95874c330d14d69d506b06efc724d851366fe127a6c3f6f0f74311b5690e612419cfc7263a35f33b56cd1c9f408ccbf4879d94397960e4350ac3752c2604d1cd2b2013487ec1d926d07b1943115f8d3811103a46704b4612c62ecca4e3c009c3d1ec6142328f741fef67006561ea72fcc13c17288a0bcc35fe2f4afcadda9caedfa09e1b4635d78b3c730aa944248ca8456031dda44817974411e572fab14e2768da50bbd56bae7319554716864972e3db251f13761073f4ea4ba65f177bf1c8cb9f275d73f8004e16647ec8f79ac428ed9ac2d06d31c44fbd76f98cc2eb8b0d5817f9e938aa9333833eee41ab6bcb4f7356e0befe0247d7a2c3cfb2d20811d4ad3adee690265f97701f3d9755be3630357623f0ab7e4fb625733ab07b9f56a0724c0af9d4458618f288a0d63b443f5fe45a9b945af5dafa5eac24739662bb5448d5e73015416b4c37152591e0ca8f04e903725ac09ef0068d8d3de55a6286daeeef53d549fbbefaf5d297dd0241335cb726df54edfa7bddbc6c295e0a051ad3b658b4f27774343cc9e7c5a09e15d0cb335e0fc6ff374c47a945e5ddb44d9a4287bbf72f4d5b92f31dae8fd368f73e1fd1a67cca50318456c7c5aa6fedd5622c149f0d28d03a306b389ea88ef5b7b9c47eb8c5900b505b3f144910c19641481d3f2d8fa8a4880126b1e24d0e2a2a0d0739d1a8a969286a0e363b6a8ffa2baff199462c3d0e658e11f1cb281a05a140b12fe7c9494fc0e517ae8a6ed2033e867762c5a0e47c72b98e8fba5a75fb80bbaa96213fdce291bdcf669972c1d9e8e6b7596b3621d1f4c0718a8a28d2890353a1dcfdcb2f0a02f9fa9fa351b854b41218b40fe88b7e606d2c348b53980a845f95cb1654cc103e19d42a49d44a4ea552e89881fb939f53fcfc8bbab2de667c9f1d240dc3581349f1ab355ed4b82e0ca506541826e3a5aa241f18d54482002c2a7efbb2cbb6844a3996bf86b8f59c787da0b022c033e932321cf8a38e8111f6034ec60561f308ccfdcee6056448914b9fdd0ba4fa06776f6b8198326ee492db02d1f98da1e63e912714e36f1544e5115d3aee36540b01d0b58ac983bc14ce9975df7b4a5e8bcb0a355aacb5ebf1dfe4db316f82132e04464d767a8f1643524a3d21cf028d10a31ff1d1b37c1f81b7bacd517546dddf450feb16b45cddf0d6927c499025a93514539cb7e855fc6ab465de5fb78a4dc4d5d95955be07d455e9af266954fc68a3a1a2dcd7469d4bccf8de4bf7f3eda6e3ca7bd2943212ce23c5304875fcc9028fd77fc1ad3c483df19e32d069d79776364c8fb6b0bb17578e366d76e6177e60f115c16549373a0131af9dd525644bc438e640bf2d21f13456e715cbf84020d088e2a4212080aa862db5b04349c0e91f9e4343eb195116feac8c2d7c418ae6c835817cf4a36c5c2e2954ac14df15af32971cdc85d98e546a69fc8cdb7968cbfecdb2c594f3939d7604154feddd5215b198b06a071d83678e91468566e9595678716783fae06c4e045caa19d95a3c39d219cddd688659f95911ca45e8831ba97b716de8633fae8bbf9f7250a699db3dec360c9b29879b434598f25f5c7ac67378d9cb629f47774105f5929db2329a885641c4c07aea692a8bcb5f6d023af6d5e923db542a4b71a8fdc65f84eb8255b85e62436aba4024df2ab3796d97db8421f9559bb9d1348c949c90b8d2a68107c6a283e24f518ea7a27901e6d9fc9bb5d5eba368e2baf66ee1d8a417d965b8bc0d67e4d23be57183365781dd3082c46385a65c623a1c3d90f20261bbe152339c135fe502d2c1f3d9bca7ea902eaa5a4bcfc1763779210de2083449bd2100917dff8ab693382a4fa43247866f833fbb5cb187876701014972191b5e6eb3600a1ca80635bbb07863a7cce2abdb2e2fb4934c54cc61c93dbe4edf308ab1e8c20d87e8655003e8aaa7ffc7c7feb08d47481d2a2e0775c764fb6e1aaefeaef303d36b6cfca9c5fd4ee1f6057405639963bf296ed3e9839cf8525e0f99b85d52c05dfcb9f4cee259d7564c65644be2ce3d0e58920ea7c9514ac13739fbd764d6f5a078205ffbbe9f4c73f5447ec2e09f73cadb366566a78198bb4d2d28b30cc1e4ff40198747f7ad67045e55f38014a6aa540c12b17617d13f0d465b0e3659db86b6ee9d078bdeec4ca452f2cb00f5ae6601d7bf61d35b32aec763eaca8c7b8ae1caa0539fac491923c06b8a034343058bc9a1f4456fbbfd405e3261b662acdbcdb777f467af0e70515c57a53b2612ce53d6af24837f52ea61f0631a0c075b4e269889b43a312fa01b1cf04e031139456d6646255458ed3dfde7143f05acd00790eada2d9a8024cf9fca95f32621f9bdce3bc333b7b8575060575d9c961c983424f1aac42135f7ef993131cad1c1e25b693d911e5d40ee695c450cbdb343e4494df83ad1eec1e058778cd4fbcf3ff5f0351c09a0588e6752f568cb7b3cd0d9845a2d8131815a004e7e1ff45cf4afe64f0f58326e30027ea0776b7b9f54560cdf2a045c70c7cd7cd7568b900552637ccf0e0a1fcb7e6482bc36adba0eb031cee26f305cdaa8a9aac3c5cadd05ddba3ba4629e68fd4adf0aebcbadcf861be8faf9ac23e8913042ca2c9c078a7312027064c6caa744c45803ae0fac5e231a554520ea86425f954537b0b500e87380232115f685a0ff66d1db5fe8f8e40613f3d4ed8d5c81497fed6b16b16716a225e783ff140ae40c91b50ba8d08359059616f58c32c214b4db7cb15f27cacdf7c5ef929314422596b8e58847243104d19355c6dadc82a592310d6f81e65cb9c5b3f82a2813a8207c95eab8d1eb02f61c21022906a6257adb3ca841b7daf45231fd6f062c5a784bbe16dd9553c0f8b2747a855ad9b98fbc25aeb5e352a3814b77b8cf3a812eefe3a35a35b6a55d24e221850886ac9f0a11baf3a8f8228e8a494f3b8d76600d7723434dcf284c7b16e16b7d86dfa909f8a6f595b845f1935a84266b23729701e78ac028cf2f9c201d85997f2cc3a3eafecc38dba47dc86e11168ae5b16d7ac05c4d42a96fcceb8ed1784edb776f4b9731082a53637d8d1f5194cb3be7157ee7bb659df688b56792885eac92c58c5951069afc8f7a2eca25b0eab33a0537a04a67dfa328a220026b9a18177b1e7bc67f1bc6ff935e3349783b103d45533b1e19a3f719393694b89749e6e877784153d5d526299b2d8f4f77baf01557f04c86a01bfddf9b5b526d15ba956277eb814e9994703d9e5195c3ef6c64aef1101934002ff5d89f9b9757a3d08e982d33f4da6d28ef6eecf25fd0bb3719fbd74e2be311a531e707fd701abb7541baa3c651ce6e59f6d89bd192fbf6d7828d8f62de808220f3ef9e3106174fb4399c9a0e3366d605a593b447af90d516f2f7be9b25f3d8f31328e9ac0353d41dc4d3242d2f7a4566c2060588b32b615b238f68a4f0e3ba3ce12c8bd81cb8dbd5d8c9ef4e2e7aa3a324835eab4d435ab1c6da749e2c0e6074f5e126bd5a2dfff114daa34a32a8a393d020909e57a89e2ea6c04c540bf97809dc2b8d2348fd4d8c3fbdc5c8047180c2e8ae5c6ea35cef4b0719fd287a43d6fcc91db1ed7434d5ded42dc6b4ba359f2044c34d729031c8fe200e8cb926d0ada4d0a15be98b2bbe077dc2f8f44ecd65d3cf15c4bd16fa16a9726e0edd25c3f36a9c9f376c111c666d8900cab00bad61b1ca40644bcb1256e77c316673f92f70c06725fa168ee7a6feea35d734af5e56a6b30738f1ce0fde8101564353aa1f79bceb0c9ca007935451d416d0eec1bdf19fe11146d6060e412e7e48178461b46a365a9b8b0140dbd99167239abf0636dcc3f61934259caddc93b8adc63451525f3c66b4269ff3eeab179c14d563e17590d05d3d2a611de51deef4b300a7813572cf6c52a245eba2c4623c01b66db1ba2a434062278765ba2308caca632c9b7eb2bb4494a85919673e38014c2d3a9c03fb0e6053d0381292d1610d8b8429a3a36f4e9f7b923640517dc5f4aeea375ef1f00daf85d9d406786f2c645f847e9f9f7f8a4ffc5f9c398d9533eb51c0aaa467198d4e8d3e0767b96b903f4aec08cba531bf0d16217c4ee4a56477aa2e851e4706dea574678e573372df7d151ab08c9a72ac2f1857297be9dd2318f611765410487f8da65fc431c6bf22d752e9ae3d56f83bf3074ecd4d376a73b7149ff178d151f3ccd4c6ed3b46fc51f78580c7171b9069c2ae0f170f2905dd9819389b04e4d6c18b4b5f74d276db6e2a4e1a3a58990b41e9d1d9793a079fde0043f1629d32ec3c9c777e6379ceb099ed887ebd037e2c0abbe98356be3ded7faf49f9fbacce1479ca90eda3983248b1213a1b449cfbaa4fb0c88072b061d9deef73dd941a7e235071c4a5bf37230fdcd8708a58f9623c70c04e024e2ed2a2476d9da3561224e454473dfa6a46be49e9dcf75e08939efb1986789d73c5d16abe31f69de5a361ad4faa58ecd448f6c827adbfb38355d71a7e1b6d4f18536618cae286d696e08359e95d7178b9c18c08a30377df85403a1c2951da679d6dc6b3d9a45890bb11fcd58c89c4c52772cc3be9a4164c3878835573329bb46b91dd436ac3cdfd718b52fbe19ffade62d2e52d0031c67aca364c3d2e71aa494af00419fbe7ed3db2f784534f6990f92645a5158c863c771d71421fcc93663160ce6c67c1d3a4a400fcbb629fa09fc431f4e270750b8ce046c2aa409161c5185dbc9c2943ce27d71d91220a647dfc7613e159eba2e0ace6b5c9fa528bf15c9c44188a19b27f171f917dd8be5836264379fb643b20ecf1257d1b50cd207a96ddb8f63e35d5a8452819f49c6f83efa989f7ffe85a7ed6276a43950b790eb885d2107a3ad17b56013b3a1feb36cb959af7afe9845dc72b170648a1d6e07a241866ba0fa0443404af558da84ab98e6456a58ed23ebafca13e0e27c55f1c352e70ad7f87af59ef8632a1751d748282994161382017536f5ef81e617e8c817a100a0c07aea2b6abd7489f6db71999cb78af2299a1939287fa2ff7c26c41ad2847b00b0f20778416f16364b366efd994b5c10568bc4de8aaf42d71809d44d6c713346f0751743f89c50f8a3568e3c1f6d251ba9fbfe78ff54427217b5a2424dddb30978e2a010ed8be8daa6ddcdbdebb507d8657fe30f284ab4f2b65950623e043f34c875a605ccd502cb18fbcd6c451743a8a42ff24a94fa464dca3c9bdd95ce60b454fa28cafeb23e79c30cfc27053455180f3bc59446d2bf99bcae5d6c8c92bd74a9e3c709950202353402aa195374cc2b5ab2597ebc7035d79f2b649799a3cebb8b2cb92236ffad4dbd53fa5c50af571c10b6f43e0a5fb3592304d874fe5467da020e9883fc02f32c7e8cdf8e051cf8af51afb9f5193c3b034a99c1a27e45ffb4664638f960307911e41a6cb841004e996e8faa373c57a86e75cd031a5af94c3756f5e592f0c59a33f81434cc2d18a926a8c2ffa169edf4d66c36f730de95431da7ce8a6587a9566aacecb0f6d1aeb88577863c7960c990cb82c7ab83c8920b72102115d1f375d733cf6e58eeb5c43521965b166f37b7c723bc3f9a84bc932f481b27a46e6b1ae483c3bbe6f9b7bbc05e8f119dce89448eeae7f2b12023e29f92a4aa525a4180ab239fd58f8a121361b4f17a2a985078c7ba32a33b976549fa5a548f9d20915f46d010a7cedd5bb6e1247f39e9b56edb1a0656e3b8d7eb3e008f5d11a5a250aa3090ffa76852c6bd0bb213ae00fd015d6de141fafaddbd16c17935c064334a3de040976e1a565a883ad879e33b72cfe856498ebd8fded962547ed3dc8d0526a16f8d86616498426812f6ebc7d4ecb1303a6ef27a331646992d23e129845064affeb6b036f855f7c1f4b9075d4c0a5e7c41cf4debf307c157e08e12de83da52cb9e05b5c87d4acba7b73c844dc058d35bcd074204448d1f69c30a0381b2c85e28d85cd6d61d7dfc186f51c3a567c64486eace4d9bf07deee546edd149b1c3f86384c091a68b759a8d7993681210f2fb50f88400e46a0a65382342707fa90f4165500e5aa78a30025b17d6e422cffdef44283da74a87ad2d49bfd54689405796a4efca01a9faad13c861bdf14bd28b232fa98452b13cd068832e6e8ab7a423e3bc1cd884c6ade7239bb390b1fb40d1409d51ef73c4eb27d7cd4a0ca0b6583665cf534f1f755db21c30bb958ab24f8dbc267c7ac2154a8db9e02827cef984ba6e12eb2506c0e80d9e45766f432691c5c425663df6297efd8f09d74f1be42fe099c1809b9f1d52096ec722acc2a39475c85115a39e19713cc118e34264bba25832ff888ceea9e6a86194bdde582165ac1804e81d9867fe3e4a338dfc23a42b16ace98bb1b42a317381c72b045702ea7b2c66a9e089b461f8fbee05ac02fd8e41332c299ec2d80cf87e3be2083472bbe8e0982e321509aa7910a2874a01f4f3ef3465ea93344625e10129dc5af44aff751f64e4955fed475712dec028eb477d7cc32ccc243413815f66de7615f054e065e19f19dcc8559926a6659b85ef0b5182c240d3366939d759be50dd176c6c7de50e00bdef2204bdbabfff7dfee2bdaff85c13994eac87b0d220f2332d958cb02d2cd06516958433bc5ca357c45132ff2a11c14a6ff7950410c7a577c8067ea6c964507a3346b8dd7c8dd49ca1d577e916994c5f0f4602f3d082fda29dfba3e3cd59907ff49ad252ae84ebd5dedaf33cbc36a450cdb1b97e79eb03a492a0bbb5563c6cba0126188addf9f71cc5da28fa5cee6cd6bcfc34efe07555ecbd88995106e271d38c3fd43b5d59c622463793b256c21ae2d7cb33138b597d936c9bbca66d83386f87c63fc3ee94c76ead5e56054fa7244859f84d3b4015ee86809b7c084cf5763fa339999406bc5907abd6123fd5dc9d0f486305021e3effd309d94bb64626e491f1a7095a63438d74788ab320829018faa80a81c09d9af73437d9529a0cc1f7f324661f3b1373f76bea05f2a0ab9c8a50495bbde1793f734977242efb7bd6012229545a34fca14df9dedfaf7dcd8c30e2e06449eebbf8bf93efd2ee95d3a9bb311e405979fb3f5f2750660ef6013a261ee10bc496d1d8ee524f21235e17878e93b404ffdcb9c877f762f5fa9213d538cdfa92c9bdc8668e02d8b52123d39ee17c6d1f240469d384866210396d4796576a766599fb0f4f51ba510138ffc83cc742948052ac14100d80a1141a09308bbbffde5dbfc96f7177df35dd6c78597fcb9b5f585a95cedb93f6dc222e6aa7f71e7befcb24dfaba81b991620fffc09ae1dece23cb4ff0cb880ca773ade6c5611931223a8b70ba69e842e3126f63cbba1071e88ea164889f2a96c9bb5bdf015b5fb05e4a1a4877a84e4afb16c55128b279184ec754c7a9f6e8df3caf9c77a164bcedb0d4174802c7da502b59147f36e63c32d8a4c5604fe69f0e62e16e2227ec6a9005191b3e215615fa0676a9f808287c40cabab82dcc15c9be83f3aab9cae5e39a6bb8b70f87a212a5f4a73f1e22717fd7b7d809902a97fddd23b9a7b27c7d700903cc2ae888f3aedfba51d98ae1d702d481da178e0a1722aa09b63d54a990a0fd0f179c7c4d012608f20fa78a8ad076126a0d4423d64b7e01b0338cf8a552b4fc028616fb7338cdd23c9aa8fb1cff0a45be69bc94291e8ed408734f9ab9bfe40b32823a4101822fe7ba797da907cbd03109f36bfca099b9739cd7484c2461133d874db0f42a9bc0013df0a451879e6f503ea2aca9cab5bda3e9f1c20f14c15dabfb6ace0542b3c061cd9b775795645ee62f7f09367305b65cccba39880e383a22ad535669891ede95d2e9750991a8de1817e759215231dc5f97ab8bb03427170999861908fab7f0017438690c31c6db4d082015857ce5f3d2b85cb11c3495652bd07b80ea1956638b7c792021d2b11e23b1314097c716ea1d66743bb4957025054ba9d89ff2e05f184b78ff1d70035e67eb3722926b2028da1187e8408800cad886889eb373ea7ba95c5a3f7ada787f0703bb312e661c52da600669219c7a5114472406ec7f140cbc4a906da1cdac381c9dbb1a8758f0e14f5014147ec088207da549f774da2eb2cf62b0da6feb0e4e03062d4f9d10d12cf28f235494e86e4cbf3c31729f62d5183352fd33a4f0678fb6a8c9a93e61db0c8764b9d42718b9e20b5480e1a564421468c96ebdc210d6e5e937b57f49e55480b5bdda916a1014ae7b9bb0dd98f078f55b2136cb56174d36955d1798a1bd6d62fe5c9b55d1d6b02373abb69239dfbb2c22e0e4c7d350058015d2ae44236e8f0970d8df51040f3ee0bb18be77112517111a1c3eff0fc61d4c2d58e5cf0e26737a9e27d2282044841d0bfb77f7aeb2010888d00e979256c2492914912cf2ae22556cb1db8ee2ab95aad26314f053e0b600c5f761350d795a45fcce806a38f4a190bfb156199759f853b87091002354a804fb0bc8aacaec6b5726f70bdb63c5fb2a4f50d753877073d66e779023188c35de674c41998113fc70854ca10f9970b7f273ecb0d292e534d31d268b564180da8521a0c136cb71f1444df35d8261ed07766f66eac3536e20fe5cfa8066b735afce198c001fa6204ef299400640d4717303ea91e920f6e7afe02549b91fd0d61fae96cbfb7c143e74eed1bd31d3bbbfe133e9cac0808f5947b942589db2c3df57ec55838304ae90e830c54a000379a3b6d5bb49045ceac2e1571176a3ff77739d4a4ebb114ab74ef90b78e1abfbf5dbe38c486159930f1988f660585ea9e916910d6a81427e4c7468664b69f2695dbe0549916cb1c605b9f96faa1ec2ae320107f8f07c3833ec6dc3bd1d94f2056fb0a2760af56ef1fe433b4f41c0e497312cf889ff468e7b8008764384cc774e36c513d0152d7bd94c871292e3aab740044ecd1a3cbbd8ca5247e5aefb45c09c001af982b6fb55e29c23f16b746dcc8449d286fb0fa1f51d2165e4bc4dfd2567d92be085995cca66ed01cb28991603fa5e991b2a2a42463f817e31cc15e3589b1d594c88e75ab07e458a57db5cec6383ba81166e7d68dcb236d00479e156f5844e3e68ce210a9c173fad13f3893c3ae04b4c631c17091d8ca508d708b7016a6fe839aab2b469ef222e636cd8cfd866f77c41f1ca4d1b8bb6f442a1af09e91783ffeb25d003e43181d391c174059f70ab7376fb76228d236b4edbad86f3a3ae045b5863eaefade48ea5c2e412d35648ea414dd5142903cd2c41268d4aff1c8bca474d4eb40440a4badcdb02243320ad6504d35f76f29a1c2d5e7e2289b87547a7a0ca5c3fcef994782c05b25b77a25205d574d97d219fafe741fb2d8d33f574821c8bc28a22219a0a782a55122d96676ed50bb4ad60f14475ee276f49e1561ad24f40715cfd0bd460e617637258eae90482a8ef1e62f9220b05aca55753f0928c16029371c30eab988f093c422be97f61c9c1f796708f1b7e479d85d6506ade6bbc6b59ae6a5ec0617d219f578b5112fd62a09f90b4641537985b7c1cca55c7ac41d4183a21589a927cba703b66231b832ca9adbadbf31381d996a0c1228d83add7aa8aeceea03ee322eb42e9bcbd2dcd8fdd191c9194b9ad714f4bd1a36c9029fed3a80a378f77e10bd20a0a383d7b74b51ae78784121f74cf498d2acbc63f18d75c5225a47264b18b846badbf357ec19c446ce074346cbd43da6251e97cac8bbbb19e58fe378decb65b1cc780299627b00375288e48d11baf8abc64d9991771d7d655ca9e52e270dda9115fdefe79fb324f3bbd8a7588505402408af1f9604f6d40bb0680f713a9d66e67d02c209fa6137c5186b31dce5ffe1721cef72d08f75cb831a2b9182afd2c9caeaa7a9bc307233226c8d28ed5d59927a3f16957f5fd4c67ca7479b79e523e522ad9832627b8be9b67b40906ef1eaccd56b4306a139c7d23af7023f0e270b552c0c1eb711a8ea835d76ee6e0c13876f6e832cd68790fe0cae29d01849a344bb9c116dfed7ac3dac7313dd67f2373f2bb6797332fc4c2493bf1eb2d60d241e059c3249dbd9cd3fe52f967775f6c57eeab1e00ea3d4eeded763786b41a08c66b38786675a84990ff1cc22dcf146a86814b711fa80c94f8a76918228ec9713e1f715514a57ec67840db31d37c718a93fc8b68cd3fdfc787619e9e75ef601713deea4d4818cd3992e7cb67fe6fb104f947f81de28bd011f5d5678a2460c80774b7392abe78026e73dd10bd31874fc3323bdcc65646ca1c97fe8960f3b48e86c4af9fc1c0f043d5612fe2d07444c8ef9f7968d1c19300538dfa55d3832e0dde805c9b4b9dea4cfdf266abe889b5510970f8dccd1eded20db0558dacbd7fc46d20ad68ae6af509edc5c8e5738ffff4a84320cb90e7939ee1c4d397414d48c435e62bad146421e843ecc0cbac13c6a6aac80dd74b1d412626975aa214288e90d53baf7f85446250d56616975aa7f6ec1e4cd31c4619d4956ddcef4f71d84d66dc46a2d8e5c54fbc0c64fb00f316f6b58aed04488dedd0b74eaaf791d6c1a4dfff407f0a74a326b300dffb1a6c289dbb5528791a2c513ed8d67f610a54ea84a55433f504139f024ef8031817a6ef1f05bb25889d32f4e4eb2c6659e838a91655641e0920bebda8975d460893a9a3848615ebe1fb08a588885e3fd02ed0a6023ac7054250bedfc127cb7f26923d3e247e9c7b08fc219be346ee7c80ba5497f2bea144a4e9cb6f5263e54a556e3671f7ace67b558d2aea535ce9ab2579095232f17f9b3b15a85bbe9af3da2cfc1cf0b02675fe8755f29af595206f6ff97defc2c1ca80d4e1e5239fe4b4939dd9fa4111886de24544351f2000c43e353cadb25634b69dfb3788f711ee397d1cd7a5a276f1256bb65de066b17a7e7b0d80f70abbbaeb596475016ab8e6e0b41ba99c1835b809dbe35404784764c91bfe60031647760893bcc7d763f3a304d2fd8a7f20928f7b7dc7b09a8ace1c0970695e0f7663139d0e70b8b81f1111d9ebccc8fce775df1c509031142d0195cbc2d26ca85be95c10788b57838f0bf39a5de308df6fffd340653ed4195eb73ca7854efea955ec2702915ede46bf2bae15e52ffd465d192668d859238ecf538497ffd5d84f0066c7a9180c456f90045aa764e7eb60112618fc9047e8b6c7d4d409431fa9fb28a448d57f1296730775799c8e86b82f97a67d552cdf14f88a85ef8d9623ecaf43165db89c390b036e541c477356c8c4d8e6a32f6bcc81f3c9b0bbe1d6afcc87cd67853783e97042289106309be20e1939ae8f45429000cac0ab23b6bb3d3651ee3be5bc7a0669a44e9e4d674f5c539f9f4bc1cb309343be625d7518de2fc6088a7e4008323e8b030cda6918614c3d1e7df09fe8dadec56cd582e13db4a8ffd94111f1f33f463319a5d4182e92beadc2a885efdf819af04181e1a7ca0a5ef0c7d56c9f8aad1efa800342a6ef6c70046ecec9cd318db17b1e2a9d7b29524d331ca8c106fa782063bd81dbdf581b7a76c2399f1b93353ef34f6f3065a6329ad1e5fde83764888917cfbafa99db0dfd5318e9ff976b1bfea4338530927c1bc5741786134de084e0bf39f799fa741fdb2733b0ec6f6aaff54c7ea040feb66af5c703ceff08aa84ebcd936b169f201cae6db2cf8627c441be1f282c784a3fe9ede33d30e39e21dcac421938a5e6bc94ba2a128394aee723d78b57269a67d667af79a8e296d4fc5ce63a3c06c076b71342e60aab9809274c4d67ab61ea6d840bda7773d613067f2025433b1027f7917f394d4aff902271b504dde470c5b2b52bcdd6da0ead1d61dc31c584c9e2fb624764061076d82944082e802f6fbd52cc9c7d028319743078c4cbe1da890dae78b873baf473fb1a4cc20ceee2db5679eb095b93eae26eaa3357e4f42db9fc633a713ddc0ecaa10ed98a90192571695c588ad11c9d3cd203ddd06980468e43b29ead0058fd0202b0d5f2d42a6112324cf6cdf0f17a35738d5ba3dad42c9494b641b22ce88ae6a7b2faa3437e4a8e0c8d37373d2c97c3ac62740c2bc27153717e33d3236ceb842d5ae2b37ae6f82a0b67d01a6fc76080c87e4136e3bcea9b3ceefead6c6c1cc8778c13053f11b6c2c97940c29bb26cb4d3544d742aff4fdf8c6b5d0c956107274830a13dc51cc855423bd5abf4dd9ae0ed06489b35efbcf34fb7d6e96c2b2b843fba4b721debb6a4bc0520e17740ed133aa8b00ba9641e00600aff702746094a58f98ba2f3d4be52b23c801839574d3838e34d87b20425aedb9987c42fe484c497d0033abd606d57185b29eaa640064c0b033dd160ff409cee455fbc2e82c6a85e64f840f6013aa81525e1d1e64e715c18a8eeb25e4730a180f1c6866b3b8e0ff89603c1e11aaa7ce0aa8270e8d7132bc82041f32e084a9519a1f1a64c7da7f04f6d66569b0f332575ca8b373a35712f8a2cb24035f9f3a039e177db23356cc3b367e4ecbb376fe2358a98c56da5ff2664f126c0ba69b8b0af641a825dbb247dddf1765448c4b08acaf2b34ccb8aeaab043c4e53cd23e2397c85ad237eb0e2f46f48cc2be98eef08f80055987d8a559d566310d2b16aca5183d7457fb9024fcc0ad379ac12e4d75ca51f8ff351001d0165ea400a1adb821ea00402a73dd12c824af0dde03c27ee3d717e054dbb64a51580ebee967b0f9e73d2f24a69fd14c6114a262be7f6ffcfe8ea4fd003860012f55cff7a9038880ae1567e391a4f165a4129dc08d30099625ecd175732b3ffd5b5ca6b25862044635376b2efe50856ca8eae4209e3cfcd6d8511462d6132bec7f35961bd5b1202d30398f7e13f8037b9616677e05b7c9f37a6d37018856fb513b862d226ae512cb2838754f8646fd58852563a619829fe8dc04f57750952c207f79763004ec37d2d92a868fa68716ff8772053241147de25c6e335871237924b0b4acef97ef2dd5599f748ad507e90025ef478983829bfaab008dce18ffe98108c367f94c90eb50f494bb2c5edcb4df77afb7c03e96ab35b07289497b8ab2554ae043fb31e6e1f153af23ae8a16c540c5df7790db97b6ed537fd89d2c6b9cbd5e933e945f2565740d8095bac921d2fdcbf0cd5f9cfacfaa632c0ce8c5a734ca10f4890ef99f3c56b49d42a1ea019ea90284440857654ab062d7ea3a5cf7f16a4ed01a9a0274d08b4e389e25b824f2a25cf247263953df3db6788d432f87c9635d0e1f8b3d6cedc4a985e26332e50e1a9b5c1d528c785f628252a5e3f2105f96ffd880ca9aa0827f28361cb037604255adaac818395fcd99b8ba3a37776211b891a83f3ad1e02ec1ab31a356a48632c10c4cd875083ab8ffe88817ec3b4a0ba8766b5177e8b492e67508ca20f80204b45cc561b30386ada800452514b2bdb2a052e9a53af8c593eef12a391bfee3f155112687ac383538a9772201817e5077c5fc851d17816cd3e0097a0b7e9c2de8ceee7dd48ec118774881d16e191a2c3c4b26c8b045b4130d261c3b55f522f209cc448ca87a147113b4ccaaf2b146e61e8ec173f7b6c9ee8c27ffd8f46a445ad654a77da876da65407e645990b92da38fafbc00e8357faf07078bf5ca7e3b59bd0ff1bd1f63771cb8af04729bf3f9422ad654cbbbb93397469c305694b02ff16d77abf8035ba1c89e047263f425ec6311242c5325b890a81de40de8f0593cbca2d25fa66f711c3eddf3874e600759329ad489e85dd774608d87f77cfe4348025c9a4045dcd8603fa5c2160ef849b0962bd9162484801eb3b452c95e3f777e75335e43f947b2ffef442bf571d31d44001a049ee60cdebdff60bdd56b139884f28b8204383cd5c74c26901d54ef968a12bcd684662f915f2163986b4a294ced1dd7ca3bae682877db9a29dce714b9a4e942b64c7f6472b997a779a255f3bbf4221105796e902c918508373c3d48c9cdd8a96324d9225b26276a0e0fb54567cba8a0d8666e88f9145e0fe857aed370b6191da7b43a8a3ff185087c56d7787ede2e6520982ab3f30661ec8db8e19e721f6500ecaa4d5660c5e13d43738606e0cb632c0b1f4cd3823e9e6f0c07703f1b5d969ab19618ce290c5a200ca6a2532b8c55130908f03ec18a8b08262ef77cd50dc96d222cdd00c8038fd644bb53a246be59f7ad45b932c6e5f0d2859d66a0dce5b2170e2799b2bf2cc5fb5621400cd566a8088a3efa7f705dd6a5a318147dbdf8a17ed402d468d679fcdecd5c1de988b58b47706ea87334e4e49610bf294cc270ab4eea8b87702908eaf7c7b2d9a5ead4b984fc3409882ae6cb15dfe8edae9ec51ca6a94fcb985851d3e61e2bdca3e9efffbf3436027b74e2d95e54ac6e482ac7a3ba9f2cd2ebbea7ec831284120fcae0b158f32692205aa7613d340e1116d48705b7b6a469c599516050b933f3d1f9269da32246b3a5acde1480d12ed2d1ba6b6522983ae747869629c8c721d94a2d7ddd4ded5d32cafe6bff0e6040076483d7ac38747d4b86e0cfbc0091e006744ca25bbb4a7107b1f762f443d0cd6ab697b0aaa7f41627d6f439fcbe997d5d5ccefcacc428e19119a88ad0d02834b2c1553f81fc6af8e8c3fa65e2f39b79819616e94708fabe8ab5574c158fa882833e20c6deb0d00b1dab5dab4bc80f576b2162533064bf7f7dc47b890edbdc01fdeb0812e46085de75c16e44889642b8a488c949558d764a67b3687c9bf403ab6b160f4a9a8db3c9ebb665cfc12452c56346f3ce1cf73f8dcf779e0bf98faae9370b07c9611b7e12859bcc022944d4ef87aea3f666fbf9f0a771a7a06907b81a74083c3a9deddb11adc80accaae964669332ba06ac53deecc96749ade3c3daf3c3bf95d0cfdd217f426af843545df2cc460f007b06d92f32901bf7aac1534e63c051d365c923f3e85416c73dcdc03034e97d1cde9134f2c8d299071d675de57bfeca74a5938ec63d739b5b491fcf92a14dcc7444030e548cb0e6490f690df5cb86f065d1bfd8c7c0d94aa07b9e94d00276191d2f61998f4163cdf273cd1146e328ad6fa96407ae9600fcbfeef90a6d9904c3a8d557ae79c3e374983eb27c51bb8785b848953e065749073ea06ea9510052f79e5d24b78b542f2bba445051f3d378db741644fc47a209e3a2e1ef7080015d66a20e1b1869483868b8dab92ebbb4af275bea5a82b56a49d0106d4abf3b174d26389db916c1ac13e54b187589e2ea4e65e0cadd97d87011f5b3d6dfaeae5c907cbe027c1b8f9f445f3f5c99adb1a5c3a18a46c2e215af09f459d1c0b39a5ca35bf8d9c908b89a675c90760690cb3d502f525ff77e428005429bf14880a7b7f9230f9150f8f2536b2e345aba3570f1c9dc94566b438e6328c2f39ffb350e3a43a545ce1386882d2786f2cfa222a11969e913aba0b5d131c4fbd2a1764430b1764b764a785145a3c4c2e7526778ce3f993f48c4d202660235c9ce37606dd89c8be675fa93d0720c3b3f20c64a8012ac58cdc0aae5c577cd60f22e00979906fd8efebf6c2e26f96f639bc942919fa9f135b8b1049b3b95c14d074f0a612a7f629602f8f49c8df1fb660396f7e090f3526f8d7a8fe4445162843761126630af9528e06a558de27a8077455db60db3e0308c252b81e5d45089ccf8505cdad4df15efc286b5b5a4b39a414eb6d2a7e13ad6e484471f3fc0070609d38b4cdf8f6d0abffe4a05e58ef4fa5daa40eedc947cad744a8315c096fe809d3979402ca66f68e0657487522468f08edd9a2d9be664e000721ca85cc30957614ea930c69748599e6b1c174cad4772b1d2e1e4d9b8c07458b19b38008461e0b82fa939bfc438f8c7e59015e1eacb52a467067f07f7c86408c630e42dbafe8695e2b82a1a59738ecea577643f6c45945cba29539be7203ab04d207c97131fe7af236f03098d0219a1533a4c5a7e6a6565add328dd88f8c2bc7c727698001ecd3cb2f8b81eea14a8a2cb6f5d1b2323972eda51d44684de6480215d0d7efed1283332431c906ebfbab8e5459a5b5229eddaff4961be3dc6df759201c890139dfe382f042c11643a71ead480ca72d2591a6d12446109538f647adddde0f4936edf84ad20dd6cc323ca21ed3db76a76478a0aac9f81bfdc1f34c6ef228d155c591c24d4a91aab16a97c281e71091b869c2c1d4276c50c2c70ddbd16ba7bb99b9a01142d8d5d12027d52f460f0dff29650cbb320b64ee3a7e4b7e28f5ece0f7d8d51f2a0969a07209f993a9b9cf1f9bda7dff351370e2ad0aa216bacc7977f9c619d4a29ab72a9d3c408fc8a3176b7797238e89f978aa9df604d5cac577d01e57d9f58473788bee3bf0c1772b72679c2d3ac3c98af0fca7616b4bcac08c398609ef649194d93fa64dc01ead845e7512f90fd88c60215b6bfd02e4c3f5a5e56a22e5fbd5a14ff64cd1ba71d0b6e6250fd8e94fe8235e45d6021d7c1fb8d944b1062dfc74451a1f9b6c4e82b2a177b8cd06cbb29fdfb7556489af2b2ca4b29851a38ce7f8bf818dc21844727ac3f1d04a3c3f3ad0eee2c9358a5b083a4f7249fc5943d5f494ac6f0d2706da21d13ac1448dc488f00efcb9e0c0c79dad52b470632be8af1b57a63ebe3f0a705e3a9ee198d18f6776be80be92d95240e37a960bab11ad3dd09b2621291384eef7d10923d1097e4932fc5c1bf488736c7e46c67bfdc6c08a60bf3daed1647190509f837874a3b4f9ef610b25fb355bc26a3757b81dad75bd82e5c72ba6f4f40568bd115480df35ca376ef1c0c9e18760db5457cd777d31875cf5031de66b670b4184dbdc263aac1901d935c4fe6ce7c28e87c4166695fcaca7a3d2e7c665e453aea600af1a69fcf979216707e2abe89761314f6fcb222793bb7fd4047fdf13b5503d098ee2e3e7e0f49bab1269d9f4d392b8d406bea4bd555012999ad123dc77fede6fada2e99862212644958af0f395eb3309b1eeb4234898394699aa52bba18005dec149014b92e3bc5bc836037103750ca54f1a76373055b326db85d4a3775a241e86be85449ee1a49164ce1cfbf2187175aa75cfcff874e8a81d2714016cdd5006edb3b9a16f2973a961edf43189f78099dbd790e1ed23b00b4fc0703dad2a73c254f889593b0c0f6db9402d13faaf5b5d4a527468b79aaba8069128dcd1b64dac79b925fe098d5f44d3865d4ddb136c22cb2a436741a8360912168280e5167880a04b591debc5ae32ae765c80395513986f5ddd7233b17f4562d6af66b18ba6f6c6311248bb0f550c658b5743988f616fca4d2bd333e7f0f0f3b19a1b93aa0006592751586a20cfd391a12d39e5f5d9be02af47f53db385fc39fbbd2cd4135c554968800acbd7f9574e24ba498c2ca9a629b2c31c954546cda434f8d0ed97bfd897adbcbb4c8dd1c0511b77ba138a6afaf9264095bb380deceb51f1dadf7dacb8077663fd614d0cef890f593678a8139f20bf17ec023b7c1c19dd702a7fb7a4381752883c1ccec5c2fc5cdb58606b7b15efbd9886ef1c16ad986b909f8079b64d804262216730a63ea5c68c841c688d2981649e2b6fe4d14f884f37b0e2e402a43433b1210279817a15c77c2d1fb06237010e4af8e3cf8a9c2ce4edfd818fbc2f9f65e8fd319208d4340aff6e750f6a24759acc301f65203444fd4b768d9d4516a36e31dc9a2e7cb47f15efc36ad33ad7ed7e81185d86c18d0961ba2cc7eaa7fa6b26aabef9bb1260a2975b3be81dc93179386e4a1e73877af0f0ec7a60b35092aeaba5f429d0222d4d4eebd4be00fd0a8898867083d6319bcf2855125b3ac473d384460d844bbd0e131ecd963f9bac08fe0d57b2531426748db0fc366a97c6b8a5e82a7ebd07cac606cd7ee38d79384383a0f1a31560210920f74ad4328b6d85693870c5d3702368cc1d74bcf5d2526fc5a0f34afd25de75c54565f63cfde2ba59b929515172ac39a66773a8d4c7eff4308fa6d0421804a9c6f7902537fdc86d82309112ca676ccfad84a93d04bee11b06fb59ad5f40625ac00a452d4d7b60e71caf7b2d84e4207662e42dc9c17621d08c0f0c2e2e221ec6f8d17ca94766be6fe8c9f6505d51c893b7ac8a6bd10e79f252db57593ea73ba1f2978ef96c76aec9bda1237ce10a53f49d1817aadda2e4e562c11ad91ea0579ba8148003f1c3c60f7aa8b274038476ec071201a0b4f220b29cc887c09150ed30930ab8c1f4ec1351aad3a4c8389234dd3783ace3e95244cd0b863f3ba0fe75a9859eda33fe85570e04c9f766504e7b5068edeffe6cb5fc0824a974159bb05e3d5d65bfff8be1a67091829f6617f97bdd5cb3f577d95aa05c12cb2346032f94b8b6af94840f52a15048418458c0532d994be1f6e52462cf99f486a5e31b36aa1d0fc22f54fac2751576f777e8fb176168251dd751dcd09212affb640f57b808ca97dc8e3ee7b4cde969ee57106f88e1225a48091a90e23b26c019bf1c679abe73c0b08bd64d2deab70f9ec3a53560e0889ba161e75e331664933670f81d7dbf530b9d0502b130ec6bba4e15fd7c018a6f617bb1099e96f71eed884607fb133626ccc7153df4bafc6fabce430049f02250e8cc002a8671c6e3a6014028d4e3569ed0b066bf463ebf390e0292f678dab4e0568d38c0ff208899a2f9806c41cd0a46ce7cd1fa9197fb9093fe80f03b1a5381ed662cbb6cf29bc1d42c3f17b4f01768921b569ede11f3056518a1224a65829541407475f82eea00c2fceab6c27c54284e3fc434226e9250a45fccaec2a27e3d65fdbe22315e563316a5413def303400011fad1bed97e428974aed8d8f8fe588d56d80ac499da89e34994010ad724e0ab9b418d61db565951f6adc1e6d46a3a32801979461464003080284007fcb5c356c81a2deb181de68e7121259dab45fc013914f59727dc48bfb6a553b01024fa726f795008234f69132de7ab417b8974bb22c6292088189a5d74db7b7db548ab4124cdefec1ff218bab72e5e6bc04f88d775658312b86bba06474d4bd82552421a5a436eea2d9424db5469598843df7db7482e776389af675e830377662de87b48b4de37ff8e1361ed491c394424b15f9ec66ce59843fd89a61116069e71681c88e0d24c1f3cdd08813d907e86e3b8c272c99582aa86448bc74069e53fda3cc9531cdbb01761e7988f040be4d24d06f057a0ad89d88ca9075870dfa21398831639778ae9ba77d51617b3f739af414d72694ec978517505a38e0b31999c24433906caa983ea754c141ef69ef98aaa20cff646c7d12eb4982dfe57cde67e1b2fa46e755f6112d6e1a2833d7b176e4ab38055140ee5937fa7cd1a404b17a0c057dd09e5384d1bab1163e5f03277989f311ca4091083a3c78aba97cbe6efad60fbc9ade7b3c1fff16a4cdb4dc25d8c3dfe7a276506ed4660faeb491f85541c23be1e750b61da7d3520dc1528ae34cb4e7394461df05767430d8606aa427191b7af731e985d165b2c75827f4dca89280e7e16301a66454a924af5cd26a855fb34e23a0d267bebf4db2f948572b3f98c5e958da06ef107867d53810eec619064c6ca4919e319a4c08753cf7551dec5d8d9a395d43c230867c65e7b720b1f765008d5322098bdf35e01b76f74358135cd6aff3b93fda0494c1f89fe679e479be9b857f8a81d70800ba96ad11af025d85937543b5ee9f50f6acf529fc52dfb0a940605fc4aa3521da405f9a751877d690add7aec45098193a585666e9ecfc2773bd4e15c05a569db9e4f8cda2d2d5eb5e2ec89b2c87d000a111cfe69b13f41b1242f04e447364564fd854ac31e7ae220f0783b5b10acd3e37c1f2b285c7e3f467256ee6fdef5e5798b2386bc481dad37af3d05d5d5f1b9754649d6a4ce323dca1fe8b01350eeb7c5dbcf1ff456adba08ffe39df094f5e43c1089ff4063126b71aaa57300323526f310d8cc75ffb377ee8f1463402e4673788be5d163efa1a42179f549403698c93b8b110da5d3bce033de7fd0a05853ae9feae6321e4da1b9f8a43fa27bc01b5c7e24420a6fb46b1735bf0356d43d228a18b8f6767cb078edae486836e57c777d5fadc116dcecf7b0def032de42f56d0913157f2fb5462411e5a5c3ae6cf5d884e322b33b198e7004e8698f7327b16aad417ea9b55bef13405cf821292a73a1072d2ba9a583547bdfcd980388d450704557a1a580065002f588f9d00b72016b3655cf2a1bd5d6ca26be460459f4f726b99141665340b2cc125cabfa6322127aae6f6fc8656f71ec14e88ea6549347f16fa8c8b9326ee9f1f5f9f49a981350dd8a71a07e3798636e527cd7702fb522e9b2c10811c2237fd51faab305d914430d6332ed96302a030223373e11c15008286a9208989f25465f455d9822be5f27565b0a3d74dd1d86702757250a77119d72fd55d33037ea28b2351ed0855fd3f0bf85efe5707ecc3c76e2b4fe3b4be6754bc5fcdad91c60b444e16238b4bd0530749683cb36a8ba4232e41dd7a9c5cb7809a9ac33bf32fe0663fc97688343ef2cd6426c110fa48c917accb24fb3c8a03be5454488f31f7468add8cdb7cf4130882909f97b1f69df1dc6a8fe6ad316a3926aa947cb1b8370e54a3b2dd96c8cd34e77ab7d045dff9a456ecfdfb1f64d91c8c6928575dfe08036e3b58bca639aa85268b94a28aaa0912913b68fd343054e2adc1a18604f524c4f6879f68a8a20f3e7a39683123d231b0d902a4700e8bbc32f6217d3c1fd762de99ad5ea0a687b5d7d0c8df3bc01fab1e6db0baacd7a788754427944591a17a29ef606ed4527f7e12b4b3e1f334d0578fb48ae6bb5ba467fce2381c481e7c3b6ba0d372df66ef109cbf8e8960bef51ffc83c9ceb33b4ee00efb119f506c77dc3eecefe2153fd9d747f99025a69099f100a2592315946f8fb3c9b2256c408f03ad293f7f510c6b46a6460958f5deb12c4838555d0374807f7945806dbb6f1fc69d4fd7f940690b7a17d7b4dedd9c9a5fd727d56e83c2ec28543ef51205ef8be391bd2751684c2e1151cb022d8afe6bff3fa790768ebd594854168889f94a4216251da7b6453c8953c16ad73a979eee00032583b534c2742d8af244d4661169cb1df71a8e400e9d098d626abb869dcf8f1b8d6a0b352c1fef4151644acf84eb717ce205f7b3ec91e0e267cacddb66daf32c9ea4b39e519c97c9f78cfba75ea4dd33156e7da5928b10223c83d6f8af47e8dc73161b5fe46f1499894eec6d624c08e2d327315eb70a7de35760e5dd36e30e37a4f493fdd99a3992dfcb8d0dd1d97567fb331b0b9032c1f863cfb7f433a34a38eb8fc382f0e7527259de61c87bbe6daf1a64310c238b0b1c95a481d9035d6604ecb8089a21043db073a87771669e226dd0c6cacf0f9f580152cca5be5070d75fb208c5cb7d441487e396c13c0adc5099b69c81cbc38a99c6ea7ba5d475fe51079bc52a8827bc06b54341cd79fb112577a098d75a15dee354ec6fa839c036e30add3cf867320728b95734c8d959fa0b35f037fdb4dc98531fa94c4c76f979887e6fef9268d72998d046f8deccfe90d1daea1210a606818127bce5e99f1e16faf2a7780eb26103718515127bfa4cb760b73b93e5fb68ec623b58975521485a99df25590f4d12eee46e42e09f8007bd32728354a578ed7a96addd53b33e8fe35e9b58f748ce34eb9b70f65c129df347ed52166b39b92fdccf704cc493de936ef21753cf5bb91d372d19912e567361ce58957730cabfd4f6b0a357ff59ebceaff174d4bd0e2cab586d8773cec9a38d82ba731285492d7debd7fdba32f9192e8870bcea81b4a775a2e6ad555f1d9cab0c114603998473758da1982a1afe92694b1ae8dc0a63777459811770cd6066f22e283923697a18845292546673a6793ccad81cfb7f71b05027137e20fdb5b7f05d21275ea7889bd39acf28f0d233f04de3bc68ef4197b25ac7f26192e3472dd247829ed6133074479067bc6ced69c70b046772afff69bacd2b22b86dcd14752457503ab7a33d0eac60c309d386b911ed42499536c7dfdbeefb9db593ee289c53e1c4360f6db5beb35286d45b62d5466fc817e9a6ebb9861b68d89e2e33c8ebba054eccd346d9bdbf801f11c82516a72c3c418f543569f7fb8f362d41b9e2ed809c46cfe1d31ee6359089c51a4be44284b58e03b9f963c3f83edfb528422bf56a76b6cc7adbb1907fd9ec6a9c6ba905be194c37fc3198d0e95be4a2f49b2d100cfcf2a72181b15e208223f58eec15986b412e215d75df4fbc39954bef1da7f0b1973b2fb642d440f9ce7ebd429fbd7f669e9b902388054dfbe7f7c691e5636832b62b9eda1999cb5ae3b4c8100735749ade10ad2925a71856bdcc5f6954c709ffe61829a17c41c401f2672c602e60db34f5b222ad642753dfba9cbf75e2b7ba2914e099e784437aac1f18f07e0e3887712d3d8d6578e2e63fc7d6d8b46fd1101819cecd7cdc0c40be037fac9bb7203680492633e1be9a0c705b1170eb9bc56b1037b6f62673e5090a62fa017d56ce7289f75efde04369d81f3e493f02d196bc7bbe9c71a76f483f6e0a663438d0e9951dd2c0e7aa2748172dfedf43f7c8bb78c9af9f0d2c65d9edde094e2bef6a215773cd6d6f7ed8fa7780b3029f51883cf7edc36bdfbbace49fde4414e1ce356650f0d44dec85b2c6a0203f9a288443c285755236458aa5917e659e1ada9f27a93f4b189a84d823d4b777fed9f4779d2bd313b7c9a664921627eb3fa089e260d93b9c5c3cfce9677fe2c18e2334b026d2b286997ebd49be553fe6a9e8289c9f3de6672feaac598f80f820ee61c7fc9b9a73c11b7e53a575c4888387a70a80f88e37ff2d927f3c6c115ef6c9a9c329d5cf1ccea2543f7df79a8ce2845d95c359992f67d7d145e0361341da622f21654018f900bc1eabeebfbf4360228d03c72e936d457a78fe99a2a3cdb47a8188246211427dfbcb708cd0d3a42cccfb547785795a8de806ef3810e09ca53ce60b9b6f133e1d00a8bb1a639d04a9e0cec15734c3d9d9d26e4301635c0db47801c8eaad4fea555ebe6b2d7d7e14f2c658741ad887ae79dbf35230d8ba9ce7df851593df09e216b6b65d6355e8a5e29ef0254b00a3cbb17f80ec4e7b60d6085448473db04ead3258dd208a489d50e30b9669a3e71037d0dd8d38646686d7fa73c74281417d54912833176ef6d636ce8bea18ccc1856daac2d0d35588c0b15da3512d8516854292f613f183312b0ebfded9bc404267e7ec57ebe6bcaeb8f60f06ff88944fc45cc311ac25682621cbc719693ff4dd3c05e6e428e5bdb64c55c01c286e22d28081d5c69562324f9ab977692f64c495a59d3c9412978342444dbe9c2254136408b8afda046c3c2d76079cbc2c85dd8bb8d9f72ed4abd898295da1f71898f4d3f3109324f4628d45885bcbe7a2598350f9d213d4cd75704764829d16cafb6881d26e48f13ce599df562b55bfa75e5394f96c8dc420d9d539a2f02af604b618dbe499169a4c0a0469e14305fb7eae30e97b408a45caf37c7a2f16e4bff3a82c3a5a897643f31df9bd4491ac2e450e00adcc539558f998ecbae0252065e4250f990dc536593bb5afba602f4dad6f779a5632c79c608f6836b7c98f2f02aa529ce513800792e8e2af99b919d9a3bc22bc4eaeaf5666ad32267c9e4c1e886549ed3edec47a8b88b86b9b3a76a2c6727de07641329727ab6f27ba11cd7783ffccdbae6562763d3cfac66fd7df8f762ad2aa84f5d26b9c7a125368195e211d49332e14e29b4c4710366f87899582b1c4ed43d1c501a6238213ab4fe04af64dd0297b4ac9142ba6a702af485390f0585ef9befcd7f85981750b2ddcd80a8b667400bf4a898a0de64348a9ce82e6d4aeebb3e8d67e85fd0035fc48c599d97e07ad8271820844195e821180fd492bcd5603e65b8506ca1800ed9c3123d416ef57d0c19b31eb37bff6dad195c9d0e4664ec3b970b62e4047f39e7d32781499dad6a8c347b3928edcf851c971f148c8acb4abaa8706daf425d62d8faff4852deb5e33cca3a3983401d505f91acb6c7f279914ed2fb2b196adf6fe3c9e26e8d828e2943efa1e81749a6044405a449c512ab048d5e5d02158443b5ba094318220facfa2e2253a2dc925b8d8849cc58055dffb919262a302ac416f4a3231fd1fc53996c56827bbaefa5edd5ad03c43b54a4a2d8d8e43fcda623158df55974af3b6f233434bac431a2cea390145e2c8c2875e1d1d69866b65217d16fb2c2b3bd77f693daa0b5ff7535808301dd9702610870a47aa269bbd5fadcbf5d22719a53959845562868c26ca0dd4026baf00edd5b89051ebd28d3a3dd0bb8072ff6e36b24a4b28000c522ca769436d6910a3644f823b4f02cb9f95ec9cb9d964f6859677c84c872e46da92f83a3a8c6cfd50ac5def2d134dc8a6a51ce183d1811072686941d4164e08996b97df163f1b0b08064f861319887de021ed28929a341d89da93cc2c876465f25f7aaf9c7d5c0660274c5088b179db277b87a85d6190b2819189821131e1854a0a2818baa1e9999639636a79a06a11d8df36d1f130a3995f53c4c6b5195047a5c28c9b8a4e656b7e988b71125503863b68f4e15d0e715771616b09796f47f91c569f763daf4b8c07c67c3d1b0edd07f292ddac541b39a5cd6cd029ea359b138c0a9e675249a5c7bccd8b55640549ccb61482efbbf12b28203d468bb466c5764879625ee91bbf0ec4d9c9176d33473b5b64e38b21c796818a1e48b753c499b08196e14c69131c399577b78de336e828bfdb36b5a37eeaeee2478316c57f690c0fb732e059731a5c602aa69e2c63af5c15c00804e94787dfd8bd7c6c0d35b7945f658e727cabe6435ecd3e27be2d0c3dd3e7ea8d04e34272f3b6ede6e549bfe4922cf9b29f04514a738fa1310d35f7ea45a473487ac1637527e62eef3cae089916fb32a381746ecc4719b40b4058912da44ace3036db7fd5cf75ec7b675808fec5d66037068ae8a7404b55a9561bc33aceb7f42c65c8213d119783e5c1bd0b6fa53f130c4abfb065e40f4975ea72007f5821dc96fd37e84bf118a657cdb346095f4395de7c7dc1b2a7013a4e3855cbb9d29eb954c37266757ac309b9f9bae766655128262092089df180811fdaf9ada4d8991b3ff93e0ea4f62929f30269b8d7d6dda2dac4b840abb96ef349477cdfcfe7d3bd445dc061d981119e66818901eda4ed4b37d936bce304df92edd2a8c35a7db133d16842a0e68651a88a763857410df6345709f50a0303f861f055d8ff2bb84ab53c207e64dcf89a6103dd287eb94f79bdc12a137fbc6a41997f60ef6c897de04ffdbca503049732e04796a7b071cdd4fcf76fb6335ce5e125151905ed2b73ab487c2e95e379aa2bd66780e2663a06d46ea888b5dc72bc3641d6405f3db7d86a0339137ff0f2ca41d5dfed0166704e9ab58afd8f92935c46d683e7abe32809ef1ef077979d791b7f6d180636ce7a636ad56c7efed2b6cfcfc253078e06e6c125ea8ae5da0f83c8f07b6abae0824bcbcb2e2ceda7545a3c0763dc89c8864e66bc9af0b63bb757678cdd73725705ffc565c11fa58d5e451440a36bf8cb657f1bf7d359ae116b173e03948fbf8c1f4baefc173329f69f029651102830d7ab1e4e5b3155e2168b472680f3651297918ce610c63c1e0d20a2bc4ea2608e2129c02232400a17715b37eb2523f7fe480bc4afcc1c234f853c9c5a439ece494f3a2048fea881c48a43420b28762be80181737f600c1d955d7ead3dda969dd66288b64752a0ea1b56a727db1197855689b5e321219660d21727d4b5d14ad4e32cd06f6822f804838bf9a92dffa4969e1f74891c74294bf4d7625425b1dcb768994e5c330957fd6946678d70f7c44304152f4c382b7e3c1284404ab04f32b9887abf80d94f813cde407c50e0979909ab23372bdcd49bee261a15e0b818dcd3ce90cab8bf5d238e0d57c94191d4c42f5d002b2e27480e818a15d9d9ae3a97898620fe66874447eaa8ccdf4978ecaab4b5cdb481c487d24029179b578ee8ee9f6d277748338c757fab242678b82a3b9fed6fff198413412a0637f2b7c638772b053aa46295129142fcf039bde287399a78247f119659963fd7c9886390e1ec660af198d4e45fd05146586a1253ca79457a37f9d834dca1c3a6784448aff303eef70e541a044b9c6377dd004a772d4f098dcbbda843ed75d2dab3fba82bfa59487ce06b1e095af0f3c3ca3ddf9c2da9d272ca1bad02b4f430e604bf91a5ba45070526065a6d629cece545bf38364475b4f51fb66c92c6fb96b7b3c58596b30013441356f83aef2aa4512854cecdeb76726d1ef537ff78abc532f7726d2005d171a8146beb92659094afe53009d405ef4674252bed020fba22bdf3ffc0f85759751a4de2b1e1e55e7419627d55c945cb0876d1c78a908bac5324b82ec1e3f92c978577c57c3ad530c1658f325fdc1dc007322b7255146828621bcfc708800d3f906a6f10ea77e420d639926470578ff14164bb2d5a996fbd790664a92df70bc6fbcf1416e7916c4cdcfb3f3b3357a0d8d484db52cc3bb227ebc3862f7101979d4db298e28206fce5cd859e3aeffcaed6245e0d9a8fd312a45a356874b9c8f93fe01baee82888a6103b4b4f8184cbd5c56958cf2b01486f1cb0569e495cf74ee763e86fe449b572af902610d403ff7398bf92ae22abf9d1ef596db7fa1503309da46c89c5a49183a5a1515ac2dc916cd56f515441d3ba446a9aa41c0ce31b23a0030e8efd14cebbd2fc1b05fd11cca43f60c047ee89c22ae7e5e326c2bfed163d863ad709604451a84a7ccbb43ac19c35745501fba068af56648df2175d559f6df44ff1305d71c54687db20d4c760fae202e1bc1a867f7e75da6324d1aa71f3c39c599221323f784f7064f62c45fb4d1ef254b358df5246bd4353d4c5a8a56f0777991a27e2984266a03d5310b05a95ba9f00392207f9ac025e3544b14f9137b66c6b68420d1aa7af5eb7696feca35c0584715106a0def7133a2f17aea366a7cb2e595fbbc255622a760188fb877f83239345c2ae852aa014d7255be090d85bfcb7eca5f969d08a2e5c2004161962fbdbd71ffb5426ab759698d4d636cf541d8b06132e791c7a6e21b0e619be41f1cea7f056fe7c2727552e98988bbd1370ed762e32352b481ed9afeceecbcf19e0f65ceebd2c1122acff966bd06b50105db5496b1523691a86b2029bf644d5e7e2dced52da097acf08fc7d578e92cd6e739585c4b5df09895a9daf6702728ebe425782b0a6ae7b88110bc11281caf623d9c6b82ec7ba868b8ce5c82b129c03b81ee8a04c562b19c9a40b56e63763b2f64798c0ff3455925cd8a42491e9c53f8bef81d0a81f6015ff642f76b3dbf8a2a88b56acecfd6b4d91da42e9916b428ae1aacdd98950f01def7167606ca4112e151cb5b8b2746411e86b7aa8cb0aa274b4c495e446993cdcb505f40b0b955fd4a7e35da85a254a455e46332a775e76da80b9f5cae9f817413fb1ec477eed5ea2a8a0765af2788184920c995fe0058abb5846f6277a5e5fab46fd7e99625276be726e7fe70583798ef3f08d9a2cbca63c837f3e93853467ae1d85f386c5d611fe1d5d75036eb672ed062423c517a5a88107d846546154b982fd20d63183d8a2c694d749700cc31d3932328d9dcfe19b8d727ea5b1fcc63bbb50d0cfc374a94d53e9af154603abb23951520abd476c385b97352bc538196707b23d4fd7c1c9a70b912aa7b1436b38b93ecf1c035f873a7437a14fbf1336ae341b50bbd6804d9246ff36ede5c90eb42b4c7f519a1224f3fee4f9a93c644a9eb4379867eb8ebafca9d129c1b75793cb21a3b8150c16c17a0c34fff2887c43dd9e7ea4f6652811bd2eaa915b6276c0fb2b427f9749ad02b7dcf2a28c455e5d2a3cca047f1d22a426e146cad414a37a536a3b962e7a5d107a05191b3e4c5be49d211ca7f8522893eaeebab8e7a3c0f604434096e99d5038e54a024599d0082779bccb54e4d42f027fdbf25eef3a14177544c8ee8e7ba8bb6f32b434aace7fd9fcf7eb260ece5170d31b9889ba274c19784e1724105ad6cd587a487f37487ff5086aa93f7ef96445d973dc4fbf2a81f31e9fba4d43bccc5475a45426f5c6754bae5974a56df64c728928381821a0a56908450e647fbc7cd998f21f06f361ac4573eebc14005ca716534a37037c6ccb15a2b5adccf54431649a35797d7c8e940d0ee25e29cd3b388b006cea4895e3ea7ee59fee63ce399f2f7320999cf30843f237b82eaa5508ab8dee1f47237a5faa34d0de394ef415076e53fb8bd2b48c18d774ade9c1bd58a89fc7de214805fbbc452da3ee37ceaf60ae112ff2dedd44595b6e78dcd9f2e3cd796a80b8eebcc7c13f8f2869c319492151b3667ffeed359cd468d95b971aa45af026f44e8ae28fbe81bb59cb4ca43df062456dc30891fe2e8e04d0d0d6e2d5cca485b67d538d7751292eb1cc39cd4548223cc66ed1d369c728f99e955ce842afd1f388c0cf306ad43e8eb1a35e2b5dfc31a8df5dff826e12ca2576a7dc2693efbda7d9625b36e2aa3bf297c537bd1916c34b4bde265863deeb1d6db9ece96028a7b28fec405bced733233c269705115e43ecc0228f8975b223721ccfac41d122290025eaa13240cc764723fe91c3328ac5e62e4e9b800977ad072e9c498ada7189f8626e0df877652eb11f52ec16d0be5f374b34679be87aeeb681b703fb0a1cf5c86cc8fe493263e5d885ffdeb5dd9bfcbc51b8296e4052162c90202b4ddee3b70b5ade031eb2c1554732e68ebbb1c1bac6deeda75e8018b9e0e87be08ad9e2e82163204362a59bc4acacadf0724139be9ebb9cc70b77311d210026842a7cf6d9055c908c454ceac713c37bec8749eefcd38aea630fde70e57d14e9347f984e7d4a72bce94903cbf771d4da990881f7046984ad3359cbeeac8cba794229471112e569e654ed1a669ef7fdd6f762e1d50fcfb36e0847d42ba6eede10b40794c6e901fe734d0065eefb576fbc627f81efa6775c8af26e925509e81ce6d8491e7e79c607a694b714cc02fcc334b9d4e9b1e360a2cc4ff2330a052f54fabd5005472018b28aeaa8f90ced5d1e18f184f0afa4f2776bfc1a0c6ec0cf9fb784479c45f3d51d99adc22578c00e2a949858232488d244dc20d195e8f8b2f2c5b550f4136b0c81830e1122f7af19ea4a10778fe789c5483655c991462c375c9de5020fb6a7640d5ab2f4ea569dba09137124ef02a9a1d16a564bb0eae12298dc1065a9a41e598d604e538fa4568c383d741905a968f2fa8c26a2c49e3d928c9f8efe0c79434602eb67ca8b40e75bba6af016f788ff09d9422fba5baebeb7cd57c2bb073f8661c72e0762d284ed582ebab677721039b8b149eb20a71183327afda5f8945264c68ce87c5ccc287715669499de9825608b96a6e656c2c7d82da265c37a05ed5a9ab7ea772a1de4e516a638d35ebf225bdfef127006c139f910dc8175c88f469639a6f445f4af7f894423c5cabaf74d439e96ce063279e772cba99e39aa1deb872b2c4115de583aa144f7a5577779896fd480c24b0878765ea19888a4704ff2f06d4ac567c8fb0fbf4be3ad9adae0afdf1ea03141442aaf1330c4fddcf0dd601298f0af6c831a040bde975fc0c80f08366eb5dfd1637e6490a3b591408a0174817831ea7148155b5a34bb03bae2cedb5646190657e5c1f598aa0db3c7d1e2dee374593f8436efab75cd8eedc10ec2feaad31fb735e4f16af4952c8904e58cab9284cc0ff279f90f617260c9d93db657fda7c6f871bc271ed9b033486d01b5ea792f60a5da921255142536884a0fcdbb42979576c888e0e07a5e29af34fbad68f4e61b777849fc23e6adc1bd2cd007848bd718d4a99e0764d8db82fb7d3e25b0aae13818a55ff41210e5b509bc00da68ede11d245e05dd6c7a0f5ffe9f8dace44125266cccf9479e6ab309f03238debc8b89a98de83dff2847538ba2f27970c73ba6f6bcbd93f9f3245e933ada42ac4675129eca6cd4065e75595bf08b196fed1b065838bad7c2de557ab33b19425be47c3eb89bc2c9565a0704b161df784528e4251a03e40c388471ad5364e4ecc2ca9a578f5f7962339ba4e04ca06e96088e3eeb6ed5cd9f8f496215115c0c592c7a73ecab35ab2c05cb66989ffb8b46e1301a78da856d26b1ccdb40f7a8ee2f7691e9256edf51a3d108b2e38a236b839e001c7e0d8abc1f630068a1432938599916443e468459926dff5aa3daa22729661dd6131dbe1d28876fb55da1a632c161de23623994bac8298b483ada36d088fe9191d512964adf48ccab4d7264627ee315249bbe6380bcb2dcac0373aa69e802c994dc878de3c3b85ecc839584dfea4904340c0fbd93c22fd861fa070c3b5b0246987c9918b9a0abead0a5f4d9f403fd00c65fa96ba880e82e2018abbdce298cf7151c79355111e2194debec0cd0f97ec62f07d39d3a5d653ebd9b4a2bc2f1358e66d1676e10c6cd6b05c64d8ee9cc2a006dac63fc9acab8dc9e4eb34dd09050466c6cef1bc0c503f82aa07f17c9276a1d55150e3c99e3e6bd39de3342f823aba02000a83d9e08afcec8862f8502425b68afa59ab3982e80fd45c344bb3aa02861b92c3acb33373f7d941b98737d59e27414e3f32f6bf016821477e941aecb1bfc962c5782e97528bd5a55ff3f7c4b69f4d992b47b1824d2db95b60f67c50f7ef7b8d9d00af0911cba21d0abe24762fef9536a3b00b1269055607181710518b27c44ff1326abd340f1f69f62c6492bbfd8e81564d4efbe1d57c3608fc8727bb57c3106f57c54ba690e17211ad00a2f3b10cc81f111ed6bdb48e1a7c7d00a2144a5f5e1bd65c16b746385357da8d0ad123e2b9e82b3ef8da37126ef794b84d978cc6afa7f5c3068da87e562052b828c34d53dff1887a0595119bff518e11de168193a53000eac1c08359033e98be78de2af0e7b962c0f988b6977e92f84f125e38a1852fb0c5e424443f8381421ddf30805653ebdf083c5ae5db6135e2ddf2f065fe5ba8fcc0eefa680a71170702fd380efe4e165546cdc90ed1210948ee3b3328b0ccd739c443e20f180beb4b9df7b216c4270a2219ba09d4b8a398f5ec73fdb4babd9c8c5144e65451eb6acf5cb0eb9b20310125b8623e8503c91396f2fbed065601d93f039a0a581d6a00cd38c0b10ec9f980338de587f5fdc039a53b494b84c1157558a0b201b6c6e17c9dde7e94b1c8a4f9478a84a93154a7f9466308ae1f58ad8815af4259a08314ae9b04cef0a2ed39583cbe1351ff65f8d1de621d579a8bd629aaafcd588448b9ca68c3a533d41b652e01d10237bec5a72000f941340c31bc52f6e6d31a6c2b2ca613f96c3354f1031cb18b4021c41e0ef636d47fe520f71b757eeb7190ec65db5130291fbb88d2e6239d5075da9d643a57ff6471c14a3de4667ff07ba01a922a2f90afc64c20e699a708f4e63affaedd356573b769d26ebabbf34429e37c5d01266ec91d360e9ab1124b277f5aec9a07bbbbb869fdd1a9dc274e2f0e5592546c9e9523956f6ab2b95f64d325a78d933300d6927ffe39729eb2192a9af2f6dce8fd72156767d712f9ea893e01c0b8a79719152792a7ba9627eb60fe15e8d656abf6d4c6bb873442640d4a9c982569a87eca6e1054f25b28a8ceeb3621125393b995d638a7130964a9da3d16070c2129b8a50539d2b6f2c4619c7e4337d24963442c3accae4d3e7dab6ee963740d897d62a47a95dc47c31631c6506559c71691d191e1e975868af91b274126de0531635ed90935f09db58e69b9bcaf6bac3bc387a5f9eab62dc78982de1aba75e58db425197ce0bbc4a7a600baee61c3009b4593c8d7e0c2aaaa9d4be228c54e86bb1801b15954607fbd0e99d0293c06dd9f791eb6f36e54016493be3d51d33315548b90fe7c40cdbcab0460d0103162335bd6b681577c10aaed67de62d60d60dfca7e54c317e0e1438bfb682b24b9ed74e7fecde8a3908e934c6ea9fdd005b140e7bef9f3836e36122015d5cc06795129334b7b454c2c674a50b004db7647b2efd09cc538448fcff357f41182375ba19b03eaa03b340e7d59ec9034f93dfc31323583e16a06f098090f6e623101a16efdc3836ba391f32109ce1ef3636bd6dcee9df7f513b75beb94e92c480f632b43d6518bd3a5eaa182741ca957abf24f89262bc620b277a59bd4a754f3288cec1882181fe82241c8e2328e634305771763861f1da7b983669753a1bff8695e353384ab8a9e9a7bc157e44325b8701f6628c07938fffe6c483edbcddc6c720a77d64db83a8e1e8183f072c07e056ca8bc8b309fb103874cffca95e68d0075835fe77d99224734120941ecac4c75038761505749bbefb4ca9be0313fd085a0a28cbff38e9f73728bdf501ebf7f6666321b3ad66a914bfa343c4e1a1f6ddefe343a0b53f372542475fef27bcf0218f5dae17a188934bf38a1a0b62c13bbd5aac5fc3a362c4cec0dad484902bf96f1b0366054e5b0a22eb99b11f20fa01f8f4efc9985b2022ac3bb0a3cfcd3064b2cb0e9ad7d0385d7756a378a3c1b7588bd96949942dc4b77e05b32ff1173dfb89e29d8304a38b89e2629ff30c49ddbfb66e6397082da0e638e2405164e4e1c8d4d662f1a58b5309c694067dd683c96b9cf811e328d0aa3b4e74eba9be094b20f92b8ad03e6eb3c85eb867bcf62dd9942d67c4de3b7ae8dff145b9e3905f0e230fed23c4da2fa42175512574989befde83f8812793ad2b8369ddccd6cf7af315ab723fe8866d08774e1bb1891aea9695da6c57a798e08848cf1ef0a601d3a6a440e73042f0ddd59117e16e0b5971e442f045ab97ca8a4f4988c95767224a18a853038ad63602ea7083715f231da8b42de08c523d010981f2a8c12fabfc710c85df4c52ff0f79f4b29209f0d9e7ae7177a58923104f72b646e87d8a9f0634a8770f6c81bae9eb30189c730a0ed5c75edca59f1bae687b6d34b422b2fefd3664286e68075d018176e6a60913863263b94410a3c3ced85be6572d6ff6a057547f1f386eec0082fc7e572a31485f7ddb5c4658c2fb735180ea44fe136241d73040b6b6cef9b23b7f33e1ae9192a6ac7b8e7793087b7e33d1e461f41620d5e26768246579574f57647d8f0c77b0ab5966871fb09208c6550d72352c256fce49aab53d676f4fb2bd32481e890becbea34f66cbf9fadd938f7b9df954c89b1a37f08a854f01abf0103dd1784aa5598eddf8dcdc2f0a9f7ed46224c86c73903811f75b00680a8b4d80f253f7c3eef5add8d43f45b0befaac0988e6eebfc6bdbbab7d98dce51d279fa061eaac953506f5c37099e02fc6d97e6a6dde8f25157c9ac3e00522fa7ba561fd57d06e0f4fd6a56279a62fcef7b71a639c5c52593f98bdc05c083f2e0303e7248b561fb46cf80a84aac5da223342d71bba4810343cabc54f8e76e37e536c58ad5aaeaa71cda403850d56cc3f69932d4991038f96464a761670c10c62dbfafc36761303e31b67fefc56126bfe53b6400c10d238c903c0e59dc6c16d1785641069205cc5e01ad502a090cd24bfdbfeee43362aa667ddcafdf1c641faf5811a6336e7a6f65fcab2d8e00fc6600d2ec03d1d74e9b875803df6f491bfb84a333c69939b08498f255b3750def5401ca89119cc037e32ed1901984106c2ee47ea73aafb5509019a980347d5cf877e804951a7571dba903d1d9862c71d676b1ce183f3a38138e27f19e797d07e29598c0b25222e5b9ab971aac6aa7cf7fbe8c1ca036276014e6fa2c2b70c8d56295e7da9906c2604a4592a9e19831b042fc880ddce250f1f0e29c62c552fc6909ea479cb8947f3198ee9fd199fbe3ed8a1c2adc74d86dea57068147f894a9636622a6d50f95b2ccaf558ad6f0b130973fe8ebcfb030c86ea2b2d302895f9ab9209cf6596541158623f8bb3c564598c9e632dadbd3589698db3484e5008a169d9820da9cfb0042aa1c8512136f872d51ab38734e9cf864d1c19f960cc822186f4600f9a65fcb2e5d9f6b9b1120c272fe3db6b48e80e3e7699f3f799280f61682c9dea535a6e424ca61bf7a9b80643b8523450be94e77ebdb52ef170fe131f028a7bd9c7198812219e3c80e18c8e46442b50c047a2a83ff9753ba63f502cae973e5675af33acb17f007d9459084926c222391801b7ace5b781e9d8f47e026058f271e6f1c053a2ed5f4398ede305906102aff9dee538c7e9c13cd8a41c0543125fc8ab8ec1220ccc1eea70e926e22512302371091fe9558a0c45d3f86f91c761de350548c0334d946be6a339134490c9a61c393b64e1d543da86da5cd597e7e43e755e6c23559e2dde0e967b6930bd6bd4a01b596c5ff9cc16b9fea410cb05d625a42d51237e06bed7185232a6953fca5b2f0e9d400ec1f81c7f028688ac2e98d784fe38c83ab8d7d506b945034c09ee6baba678646d387c9803116a70ba167e1479d8a14cfefffea308670f16a48cb7e107b1d526449d86cd6a2dd7d75195ed2e34d016ccfc6e5c2bad26aded4c644c80956766453cf382d870ed28bd225e6f90056df9ce714a385d95164445148096027c45410f8fc330d79c925b7a35b9dde9875eb23348cebeaf5e5123106e2e296e7acb2beb9d23e5a62adb5876ceb4b8c1a71ad141c9a0df44341e4b2b2e1331776956a13f9aca0b9eb8989b5ba9eea60b1aa4dddc6058b77a4c11a3e7a7ebef0d15cab5a2366346c192678a024cfe16e1081f0945615dae75d8e6eb2f6f8cd00c31bb2f5f2986bed53355048e66531414d357238d97b27ab467846aceee0f26362c35f97a1a1cf5e0bec2f000581f4045a81b957ccbc76b7da34a6856002ee05194853402be3238b8878ae291bf04132292700ce8d004303e392510a64851f6e2d0841efe10e0159a30db0b6efee2a345be8cdd8ecca344d1480e15b8f8e878c8c963c679fe06ca65a51de3d08b123991b925f74a32ab5509932766aa879c87ef89c882b16b231be2f5bc81dcfeaf81b6b363cb12f98602ddf15797a4274590d85b4c416f96b1b7e8ea43b13e82c1e6c5401b38297d13e693a7a297cd45e8c81a5704653b117e183307923e057ecd6c73f196fea8f8c160ffb64324e0b5036861e025ffe56a1d65528adc647c951b7e080124483be7cddb852cd8f29b6fc4b61c9a92368663e85358f7d8816727c6ff442d550add99bd6930b6fe22d6d5011c3fb6a6f0a96625de14649dc00e05fca6c463ff23e56ab7a28ba76e354121de96a0a0ceb62e51279ad42184129a6567846f9d2fd48fa3660923aa0f482d7d866a594c1bb0d62a762b5e122c75c39e87aa30c2472d7e7460f9345b3eabd1d587308e2371bdbf306d943c8b71d0e499be30d3c233c370f5ec0c0dbf0236241a588b25e47e060022d7bbe87631cff6f60e4d479ffdc5622084ca05d2c3f4faac9737a83da5b5c52ae9e16e5dc5c13aea0228ed0da7c467095650053f1ae89a1bff41e72e4ac5371162e1a76797011dcdbb023336f7bc63f756f5661821cb3e5edf3f723cdcc30a7a7be8ed8c1552606d1cc938134901dc594ef99ec83b4dc802886d5e056e584bf9b64662b8e019b83ba04ba6822742a82684200eda22937adf8b5e615891cd63299cc800f92a6a4c856ea14d86cebc85679bcccada82e3554264dd70a9f0618321351fe4d33ca63df55936312e573023e34f55d14ae11f599e1ee4ad3e0c0bd41629fe8e8bb45d8f3eddefe0bed60b8be7d05f0ba230d7e0b69b52bf56aeb95d510c83cfc230f19677b9ccdca20eed59795e22ddd332971d2705525627e7e76fb29ea95c07cd7deb2f5c9004938fc918b12f46c8a0e6d7f3df838176f187c4b9a27d13f27833f462957deac7a0d43501f968edd7b0e489571384380b472341e76717f263ed8091f5edf551fce2c369268f5f35fd7ec8d485d490556c5f04b393dc6fd72637818ce38848fb95242a7cda4b73b5bce63fdbcfb74307c4c4edf5db2e8990ac747a92e8f0a9f68ca8e0f6c412e5423c8d190bbb1130c7043149feddc922c3652bb3c7c53c82d421430a46d3684602adb448d341de03a4a8edccede2de70cf0a8a05e07422315d55bebe6e211f5caaad786e3443c4c6374be251bfec9537ed23704f36678b79b83b9bbe5234738115e7f0f469969cf8618ea67d154d7c9d7829c329b6a73dbf57f66620a8c9fb3b99ce2ccf5dacf9de779fe5c789a2f7b3282d63c1f637b7a2e7edf5857bf87ca105ff24cb5fc608863dd00d069da82da6d8b37683c14d3779ff96cb9efc11154f83806264d8f6b5315c5c3be9f810dd965b8c354b6d7058c1005d886dae956796b8a74b7e87d4d35cfd9616369e2c20f1037a7d22b44f78cf362c21cbceebd2e8aa9c29b7a3eeb5131754c3078e8bd5ce9ecb99b830541507d4471cf8261d0cf790dc4933cb8bf840e33babacbda2f16e5f723abc2192b52226f8ebcd7329c3dd3ea6aaca97b41e27ab454324460fae7e82ec0cd363df75b3f174462ee5d5d14e47eee1964357a2758894ee92d0f48b1f7387230bffcf1a5829b0cf58073bdb08a3e8311f97b87a18e1d90053383d4e62e48ab619ac27eec65ee1b375e663e7abcf8135bde559790598b5b272bcdd686aebb1cd2698bd12160f7838bf3b58c2b603e6ddeb96706e883041c4c81ee00a058dd027d57e44bf9b5e0b2ba018e884f5b595d5905131dce013c90b06628bf61b8a229ff2f15f8c035101d28b5295e56a7de86332bd470750a4860b2491098f516c510105c5c233c8194239ab470eac74278706158ee7ed6629db851dfd390612d7c130315a3cec936cef84f21d10344ed77047b9e6b9b7dc017cab97dac30eaa33d813ca9a023284f610c27b04f7186ab1902536fe11450eecf782ebae7b28fc8140ae09ff2537b0d0ec353bd14b8137332b93a2e31e7f85a7c8544a8ed7110e1d97a3c0fac5f63dea3b49ea98d5d8fe8a688a6930db936df3262951af3da942482320e0413e66f8c769ca8be5faa090eab9a6839617f60af7175e9bf7cc8f96c8c975a2b992e384972eacbf9afdc52f7ef88b1b50c4200da96b349cc05be229f2a1e71767eea4a0f42b17e39029ab3eb1128f479f4e6fd41a6a5a02c6b7ed09d15033e6473c355261d1a476cd91c08ac03972d2f4f2c47d9cf91f76e20a2540437243f396c512f369a0bb6225e66bbf7164bfb97c1f8268e047f0111d63a7afbe6d7c147b080ecf6776574f8f09d0d57f593eb15be47a58a4183dd09e6a0778df2c6b9ac9ac82a2e5738d82a9090b8024f1f5dee5dae0effdd7cb3ea90f2fe58e1925a013c517054936cb61db5dcd8cfea232d0d889b592e9670e4f3506b2e59c3b2e5b26f4e47a8332b8af5e586113b4b2ed4e41d266fb1a4f576fd7f79abc339804d93c3f985cdc16b2b06c27d12bdbd301af484f5d1e0eed2ec944bc0d63cfa964f9bedb60a5ab692d0ed6092a61ba8df1d8562b189b9a156b9ae1d1b06b3c2a178cd62d1d6f45ad5550511cf12ebe45358a2e76a12c4f67fba02e9f329da0557d1b7a692a4e12469ace3837a334e361f92b1379bdeba98960d0803b71e209b0b3e4d499b10fa4d0757dbf0213dc72253487769bbdeac3d40389614d24fb573a75afe36266e3fb6fa1f5dd938969417d62eebb7e92592c32f15aef85513aa9b15b147e00c887b95b5acded65470ad034c52e15520a1ec3641aaf89cd7ffd7df213b075e7bd9791891a8b1904f7ed593b9c231a04da6afac2ecc50e3554fda088a6a62c754f87b354e5a23fc64434c1413dadd2ea6edeb0c187cfe904d6e0f423fc15c53a25415313271928399ddef44b8bdafb1d902062daa3e14f387f48a17c54976b89ba00825933bc3192d61dab48fe598935a8867d588e393e3c1bf8c2bcd3ee662ad2d86648de9a0614b04002b068e8900cdda59ae0612d8b6633162825d51706d0434217167b4a80152b60ff63a69342e71b4e2cb098f48423a19253b3bb52b3ec46d46dd0198d3df7a473fa86a9d4f547eb80b3cc3b6146971bbecbaa1be02216df5e833c39a8bf0941155c1d7eea86ccde92d3d720b683fc1e1fa3dbf0fe0a5ba8d85e3161c51c0736ee700204afd51db6dabe3b6e36388131872647107825f3f864a4bc1548a90c7f2db8e9fdd0b9c9ec6d139c27ee6b9f2b9bc2e2117b5a6abf771fd06e2a477eb3b73b66a88e60ae02a06f0220fc9247ef699184967a7fbd69c5adf2c28207d1451c8d38f7fc1e65c24a34848853f5469ad5dc86368641f379c41daa217329b45ff9b3d24e087f51b7b3bd50334a1d716c07d3b8a1bb321fae1d2ad9bb22a8f17dbca58a71ac</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>刷板题系列</title>
    <url>/2020/08/11/%E5%88%B7%E6%9D%BF%E9%A2%98%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p>我已经菜到只能刷板题了 QwQ 。</p>
<p>愈发意识到，会和熟练是两码事，熟练与不熟练的差距真的很大。</p>
<a id="more"></a>
<details class="note "><summary><p>半平面交</p>
</summary>
<ul>
<li>可用交点 + 叉积判断是否弹栈。</li>
<li>先弹队尾，后弹队首。</li>
<li>加完所有直线后还要用队首来弹队尾。</li>
<li>注意处理平行线。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">z</span> <span class="params">(ld x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= <span class="number">0</span> <span class="keyword">and</span> x &gt;= <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/* struct T &#123; ld x, y; &#125;; */</span></span><br><span class="line"><span class="comment">/* typedef T vector, point; */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span> ld x, y; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> ld x, y; &#125;;</span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span> - (point a, point b) &#123; <span class="keyword">return</span> &#123;a.x - b.x, a.y - b.y&#125;; &#125;</span><br><span class="line">point <span class="keyword">operator</span> + (point a, <span class="built_in">vector</span> b) &#123; <span class="keyword">return</span> &#123;a.x + b.x, a.y + b.y&#125;; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">from</span> <span class="params">(<span class="built_in">vector</span> a)</span> </span>&#123; <span class="keyword">return</span> a.x &gt; <span class="number">0</span> <span class="keyword">or</span> (z(a.x) <span class="keyword">and</span> a.y &gt; <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function">ld <span class="title">cross</span> <span class="params">(<span class="built_in">vector</span> a, <span class="built_in">vector</span> b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x; &#125;</span><br><span class="line"><span class="built_in">vector</span> <span class="keyword">operator</span> * (<span class="built_in">vector</span> a, ld b) &#123; <span class="keyword">return</span> &#123;a.x * b, a.y * b&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">point</span> <span class="params">()</span> </span>&#123; point a; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;a.x, &amp;a.y), a; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span> point p; <span class="built_in">vector</span> v; &#125;;</span><br><span class="line"><span class="function">ld <span class="title">cross</span> <span class="params">(line l, point p)</span> </span>&#123; <span class="keyword">return</span> cross(l.v, p - l.p); &#125;</span><br><span class="line"><span class="function">point <span class="title">inter</span> <span class="params">(line a, line b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a.p + a.v * (cross(b, a.p) / cross(a.v, b.v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line">line li[maxn], q[maxn];</span><br><span class="line">point p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = read, lp = <span class="number">0</span>, l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = read;</span><br><span class="line">        point a = read, b = a;</span><br><span class="line">        <span class="keyword">while</span> (-- k) &#123;</span><br><span class="line">          point c = read;</span><br><span class="line">           li[++ lp] = &#123;c, b - c&#125;;</span><br><span class="line">         b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        li[++ lp] = &#123;a, b - a&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::sort(li + <span class="number">1</span>, li + lp + <span class="number">1</span>, [] (line a, line b) &#123;</span><br><span class="line">               <span class="keyword">if</span> (from(a.v) != from(b.v)) <span class="keyword">return</span> from(a.v) &gt; from(b.v);</span><br><span class="line">                ld tmp = cross(a.v, b.v);</span><br><span class="line">             <span class="keyword">if</span> (z(tmp)) <span class="keyword">return</span> cross(a, b.p) &gt;= <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">return</span> tmp &lt;= <span class="number">0</span>;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> <span class="keyword">and</span> z(cross(li[i].v, li[i - <span class="number">1</span>].v))) <span class="keyword">continue</span>;</span><br><span class="line">     <span class="keyword">while</span> (r &gt; l <span class="keyword">and</span> cross(li[i], p[r]) &gt;= <span class="number">0</span>) -- r;</span><br><span class="line">       <span class="keyword">while</span> (r &gt; l <span class="keyword">and</span> cross(li[i], p[l + <span class="number">1</span>]) &gt;= <span class="number">0</span>) ++ l;</span><br><span class="line">       q[++ r] = li[i];</span><br><span class="line">      <span class="keyword">if</span> (r &gt; l) p[r] = inter(q[r - <span class="number">1</span>], q[r]);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; l <span class="keyword">and</span> cross(q[l], p[r]) &gt;= <span class="number">0</span>) -- r;</span><br><span class="line">    p[l] = inter(q[r], q[l]);</span><br><span class="line"></span><br><span class="line">   ld ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">2</span>; i &lt;= r; i ++)</span><br><span class="line">        ans += cross(p[i] - p[l], p[i - <span class="number">1</span>] - p[l]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, ans / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>扩展卢卡斯</p>
</summary>
<ul>
<li>算阶乘之前预处理 <code>mod</code> 以内的前缀积。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; ll x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span> <span class="params">(ll x, ll k, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">   ll res = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) (res *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">      k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span> <span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line"> ll g = exgcd(b, a % b, y, x);</span><br><span class="line"> y -= a / b * x;</span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span> <span class="params">(ll a, ll mod)</span> </span>&#123;</span><br><span class="line">   ll x, y;</span><br><span class="line">  exgcd(a, mod, x, y);</span><br><span class="line">  x %= mod;</span><br><span class="line"> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shit</span> &#123;</span> ll x, y; &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line">ll pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">shit <span class="title">fact</span> <span class="params">(ll n, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="keyword">int</span>(power(p, k, maxn));</span><br><span class="line">   shit res = fact(n / p, p, k);</span><br><span class="line"> res.y += n / p;</span><br><span class="line">   (res.x *= power(pre[mod], n / mod, mod)) %= mod;</span><br><span class="line">  (res.x *= pre[n % mod]) %= mod;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span> <span class="params">(ll n, ll m, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> mod = <span class="keyword">int</span>(power(p, k, maxn));</span><br><span class="line">   pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mod; i ++)</span><br><span class="line">      pre[i] = i % p ? pre[i - <span class="number">1</span>] * i % mod : pre[i - <span class="number">1</span>];</span><br><span class="line">   shit a = fact(n, p, k), b = fact(m, p, k), c = fact(n - m, p, k);</span><br><span class="line"> (a.x *= inv(b.x * c.x % mod, mod)) %= mod;</span><br><span class="line">    a.y -= b.y + c.y;</span><br><span class="line"> <span class="keyword">return</span> a.x * power(p, a.y, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">100</span>], M[<span class="number">100</span>], p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n = read, m = read;</span><br><span class="line">    <span class="keyword">int</span> mod = read;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x = mod; i &lt;= x; i ++)</span><br><span class="line">       <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">           M[++ p] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, ++ k, M[p] *= i;</span><br><span class="line">          A[p] = <span class="keyword">int</span>(C(n, m, i, k));</span><br><span class="line">       &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i ++) &#123;</span><br><span class="line">     ll t = mod / M[i];</span><br><span class="line">        (ans += t * inv(t, M[i]) % mod * A[i]) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>后缀排序</p>
</summary>
<ul>
<li>重新计算 <code>rank</code> 之前要把 <code>rank</code> 拷贝到 <code>tmp</code> 数组用于比较。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn], rank[maxn];</span><br><span class="line"><span class="keyword">int</span> tmp[maxn], t[maxn], sa2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ++ t[<span class="keyword">int</span>(s[i])];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">256</span>; i ++) t[i] += t[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i --) sa[t[<span class="keyword">int</span>(s[i])] --] = i;</span><br><span class="line">  <span class="keyword">int</span> max = rank[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        rank[sa[i]] = s[sa[i]] == s[sa[i - <span class="number">1</span>]] ? max : ++ max;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; max &lt; n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) sa2[++ p] = n - i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span> (sa[i] &gt; m) sa2[++ p] = sa[i] - m;</span><br><span class="line">      <span class="built_in">std</span>::fill(t, t + max + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ++ t[rank[i]];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i ++) t[i] += t[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i --) sa[t[rank[sa2[i]]] --] = sa2[i];</span><br><span class="line">       <span class="built_in">std</span>::copy(rank, rank + n + <span class="number">1</span>, tmp);</span><br><span class="line">     max = rank[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">            rank[sa[i]] = (tmp[sa[i]] == tmp[sa[i - <span class="number">1</span>]] <span class="keyword">and</span></span><br><span class="line">                  tmp[sa[i] + m] == tmp[sa[i - <span class="number">1</span>] + m]) ? max : ++ max;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">   build(n);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, sa[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>带花树</p>
</summary>
<ul>
<li>缩花的时候必须跳 <code>pre</code> 更新而不能跳并查集。</li>
<li><del>缩花前先判断两个点是否已经在一个花里了</del>（不判也不影响正确性）。</li>
<li>bfs 的点必须是非匹配点。</li>
<li>缩花的时候要把黑点染成白点并加入队列（事实上任何把点染白的操作都要入队）。</li>
<li>白点搜到黑点啥事没有。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> match[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn], bas[maxn], col[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> bas[x] == x ? x : bas[x] = find(bas[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbase</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> mark[maxn], mp;</span><br><span class="line">  ++ mp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!x) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">       x = find(x);</span><br><span class="line">      <span class="keyword">if</span> (mark[x] == mp) <span class="keyword">return</span> x;</span><br><span class="line">        mark[x] = mp;</span><br><span class="line">     x = pre[x], <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blossom</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (find(x) != rt) &#123;</span><br><span class="line">     <span class="keyword">int</span> y = match[x];</span><br><span class="line">        <span class="keyword">if</span> (col[y] == <span class="number">1</span>) col[y] = <span class="number">0</span>, q.push(y);</span><br><span class="line">      pre[y] = z, z = y;</span><br><span class="line">        bas[x] = bas[y] = rt;</span><br><span class="line">     x = pre[x];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::fill(col, col + n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(pre, pre + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) bas[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">  col[s] = <span class="number">0</span>;</span><br><span class="line">   q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u])</span><br><span class="line">          <span class="keyword">if</span> (col[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (!match[v]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> x = u, y = v; x; x = pre[x])</span><br><span class="line">                       match[y] = x, <span class="built_in">std</span>::swap(match[x], y);</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                col[v] = <span class="number">1</span>;</span><br><span class="line">               col[match[v]] = <span class="number">0</span>;</span><br><span class="line">                pre[match[v]] = u;</span><br><span class="line">                q.push(match[v]);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[v] == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> b = getbase(u, v);</span><br><span class="line">               blossom(u, v, b);</span><br><span class="line">             blossom(v, u, b);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read, m = read;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> u = read, v = read;</span><br><span class="line">      G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span> (!match[i])</span><br><span class="line">           ans += bfs(i, n);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, match[i]);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>KM</p>
</summary>
<ul>
<li>要等队列全部弹空了再更新顶标。</li>
<li>由于是 bfs ，也要记 <code>pre</code> 以便在找到増广路后交错更新，但这里的 <code>pre</code> 只需要记从右边到左边的点，表示的是更新其 <code>slack</code> 的点。</li>
<li>只能找 <code>slack</code> 为零的点尝试増广。</li>
<li>l, r 很容易混淆，需要注意。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>, inf = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> val[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> lvi[maxn], rvi[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> slk[maxn];</span><br><span class="line"><span class="keyword">int</span> lma[maxn], rma[maxn], lh[maxn], rh[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"> rvi[v] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (rma[v]) <span class="keyword">return</span> lvi[rma[v]] = <span class="number">1</span>, q.push(rma[v]), <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (v) <span class="built_in">std</span>::swap(lma[rma[v] = pre[v]], v);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check for (int v = 1; v &lt;= n; v ++) <span class="meta-keyword">if</span> (!rvi[v] and slk[v] == 0 and add(v)) return</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::fill(lvi, lvi + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">std</span>::fill(rvi, rvi + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">std</span>::fill(pre, pre + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">std</span>::fill(slk,slk + n + <span class="number">1</span>, inf);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">  q.push(s);</span><br><span class="line">    lvi[s] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v ++)</span><br><span class="line">                <span class="keyword">if</span> (!rvi[v]) &#123;</span><br><span class="line">                  <span class="keyword">int</span> dt = lh[u] + rh[v] - val[u][v];</span><br><span class="line">                  <span class="keyword">if</span> (dt &lt;= slk[v]) slk[v] = dt, pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            check;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dt = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v ++) <span class="keyword">if</span> (!rvi[v]) dt = <span class="built_in">std</span>::min(dt, slk[v]);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) <span class="keyword">if</span> (lvi[u]) lh[u] -= dt;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v ++) rvi[v] ? rh[v] += dt : slk[v] -= dt;</span><br><span class="line">       check;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read, m = read;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v ++)</span><br><span class="line">            val[u][v] = -inf;</span><br><span class="line"> <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = read, v = read, w = read;</span><br><span class="line">        val[u][v] = <span class="built_in">std</span>::max(val[u][v], w);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) &#123;</span><br><span class="line">     lh[u] = -inf;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v ++)</span><br><span class="line">            lh[u] = <span class="built_in">std</span>::max(lh[u], val[u][v]);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) bfs(u, n);</span><br><span class="line"> ll ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans += lh[i] + rh[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, rma[v]);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>半在线卷积</p>
</summary>
<ul>
<li>可以预处理转移数组 <span class="math inline">\(b\)</span> 的点值表示，从而把两个 log 的瓶颈之一卡成一个 log 。</li>
<li>用 <code>long long</code> 存的话加法就不需要取模，但是不在瓶颈。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T &amp;x)</span> </span>&#123; x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> R[maxl &lt;&lt; <span class="number">1</span>], G[maxl + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span> <span class="params">(ll x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k += mod - <span class="number">1</span>;</span><br><span class="line">  ll res = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) (res *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">      k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= maxl; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">int</span> *r = R + n;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">         r[i] = r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) * (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    ll g = power(<span class="number">3</span>, (mod - <span class="number">1</span>) / maxl);</span><br><span class="line">    G[maxl / <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = maxl / <span class="number">2</span> + <span class="number">1</span>; i &lt;= maxl; i ++) G[i] = g * G[i - <span class="number">1</span>] % mod;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = maxl / <span class="number">2</span> - <span class="number">1</span>; i; i --) G[i] = G[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span> <span class="params">(<span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ull a[maxl];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] = ull(b[R[n + i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">              ull x = a[k], y = a[k + m] * ull(G[m + k - i]) % mod;</span><br><span class="line">             a[k] = x + y, a[k + m] = x + mod - y;</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) b[i] = a[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::reverse(a + <span class="number">1</span>, a + n), dft(a, n);</span><br><span class="line">  ll inv = mod - (mod - <span class="number">1</span>) / n;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] = inv * a[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> force = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> d[maxl];</span><br><span class="line"> <span class="keyword">if</span> (n &lt;= force) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">                a[i] = (a[i] + <span class="number">1l</span>l * a[i - j] * b[j]) % mod;</span><br><span class="line">          a[i] = <span class="number">1l</span>l * a[i] * c[i] % mod;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    solve(a, b, c, m);</span><br><span class="line">    <span class="built_in">std</span>::copy(a, a + m, d), <span class="built_in">std</span>::fill(d + m, d + n, <span class="number">0</span>);</span><br><span class="line">   dft(d, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) d[i] = <span class="number">1l</span>l * d[i] * b[n + i] % mod;</span><br><span class="line"> idft(d, n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i ++) (a[i] += d[i]) &gt;= mod ? a[i] -= mod : a[i];</span><br><span class="line">  solve(a + m, b, c + m, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b[maxl &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">std</span>::copy(a, a + force, b);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> m = force &lt;&lt; <span class="number">1</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">std</span>::copy(a, a + m, b + m), dft(b + m, m);</span><br><span class="line">  <span class="built_in">std</span>::fill(a, a + n, <span class="number">0</span>), a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   solve(a, b, c, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxl], c[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">   <span class="keyword">int</span> n = read, l = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (l &lt; n) l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) read(a[i]);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) c[i] = <span class="number">1</span>;</span><br><span class="line">   Solve(a, c, l);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>扩展 BSGS</p>
</summary>
<ul>
<li><span class="math inline">\(b \bot \gcd(a, p)\)</span> 时要及时返回无解。</li>
<li>可能不到 <span class="math inline">\(\sqrt{p}\)</span> 轮幂次就重复了，要及时退出以防 <code>map</code> 内用大的指标覆盖了小的指标（只是求可行解的话就无所谓）。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">power</span> <span class="params">(ll x, <span class="keyword">int</span> k, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k += mod - <span class="number">1</span>;</span><br><span class="line">  ll res = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) (res *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">      k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line"> <span class="keyword">int</span> g = exgcd(b, a % b, y, x);</span><br><span class="line">   y -= a / b * x;</span><br><span class="line">   <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x, y;</span><br><span class="line">    exgcd(a, p, x, y);</span><br><span class="line">    x %= p;</span><br><span class="line">   <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + p : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> g = <span class="built_in">std</span>::__gcd(a, p);</span><br><span class="line">  <span class="keyword">if</span> (g == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">     <span class="keyword">int</span> s = <span class="keyword">int</span>(<span class="built_in">sqrt</span>(p)) + <span class="number">1</span>, ia = inv(a, p), x = b;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s <span class="keyword">and</span> !<span class="built_in">map</span>.count(x); i ++)</span><br><span class="line">            <span class="built_in">map</span>[x] = i, x = <span class="number">1l</span>l * x * ia % p;</span><br><span class="line">       <span class="keyword">int</span> A = <span class="keyword">int</span>(power(a, s, p));</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i ++)</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">map</span>.count(x))</span><br><span class="line">              <span class="keyword">return</span> i * s + <span class="built_in">map</span>[x];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             x = <span class="number">1l</span>l * x * A % p;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span> (b % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   b /= g, p /= g;</span><br><span class="line">   <span class="keyword">int</span> x = exbsgs(a, <span class="number">1l</span>l * b * inv(a / g, p) % p, p);</span><br><span class="line">   <span class="keyword">return</span> x == <span class="number">-1</span> ? <span class="number">-1</span> : x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">int</span> a = read, p = read, b = read;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">int</span> x = exbsgs(a, b, p);</span><br><span class="line">     <span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>min25 筛</p>
</summary>
<ul>
<li>不需要单独维护质数的函数前缀和，由于需要的质数都不超过根号，直接在 <span class="math inline">\(g\)</span> 上面就能查到，并且有 <code>id(p) == p</code> 。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; ll x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">200005</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line">ll w[maxm], n;</span><br><span class="line"><span class="keyword">int</span> sq, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">id</span> <span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? x : m - n / x + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">s</span> <span class="params">(ll x)</span> </span>&#123; x %= mod; <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nop[maxm], pr[maxm], pp;</span><br><span class="line">ll g1[maxm], g2[maxm], g[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span> <span class="params">(ll x, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[j] &gt;= x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res = g[id(x)] + mod - g[pr[j]];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = j + <span class="number">1</span>; i &lt;= pp <span class="keyword">and</span> pr[i] &lt;= x / pr[i]; i ++) &#123;</span><br><span class="line">     ll v = pr[i];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; v &lt;= x; k ++) &#123;</span><br><span class="line">         (res += (pr[i] ^ k) * (S(x / v, i) + (k &gt; <span class="number">1</span>))) %= mod;</span><br><span class="line">         v *= pr[i];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  sq = <span class="keyword">int</span>(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(n = read));</span><br><span class="line">   <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">       w[++ m] = r = n / (n / l);</span><br><span class="line">        g1[m] = r - <span class="number">1</span>, g2[m] = s(r) - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sq; i ++)</span><br><span class="line">       <span class="keyword">if</span> (!nop[i]) &#123;</span><br><span class="line">          pr[++ pp] = i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= sq / i)</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= sq; j += i)</span><br><span class="line">                 nop[j] = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = m; i &lt;= w[j] / i; j --) &#123;</span><br><span class="line">              <span class="keyword">int</span> k1 = <span class="keyword">int</span>(id(w[j] / i)), k2 = pr[pp - <span class="number">1</span>];</span><br><span class="line">                (g1[j] += (mod - <span class="number">1</span>) * (g1[k1] + mod - g1[k2])) %= mod;</span><br><span class="line">                (g2[j] += (mod - i) * (g2[k1] + mod - g2[k2])) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) g[j] = g2[j] + mod - g1[j] + (w[j] &gt;= <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (S(n, <span class="number">0</span>) + <span class="number">1</span>) % mod);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>pollard-rho / miller-rabin</p>
</summary>
<ul>
<li>miller-rabin 选 9 个质数 (2 到 23) 就可以判断 <span class="math inline">\(10^{18}\)</span> 内所有数。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; ll x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span> <span class="params">(ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line"> ll t = a * b - ll(ld(a) / c * b + <span class="number">0.5L</span>) * c;</span><br><span class="line">  <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + c : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span> <span class="params">(ll x, ll k, ll m)</span> </span>&#123;</span><br><span class="line">  ll r = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) r = mul(r, x, m);</span><br><span class="line">     x = mul(x, x, m);</span><br><span class="line">     k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span> <span class="params">(ll n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"> ll k = n - <span class="number">1</span>, t = power(p, k, n);</span><br><span class="line"> <span class="keyword">if</span> (t != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!(k &amp; <span class="number">1</span>) <span class="keyword">and</span> t == <span class="number">1</span>) &#123;</span><br><span class="line">      t = power(p, k &gt;&gt;= <span class="number">1</span>, n);</span><br><span class="line">       <span class="keyword">if</span> (t != <span class="number">1</span> <span class="keyword">and</span> t != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">isp</span> <span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> p : pr) <span class="keyword">if</span> (n == p) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p : pr) <span class="keyword">if</span> (n % p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p : pr) <span class="keyword">if</span> (!check(n, p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">nxt</span> <span class="params">(ll a, ll c, ll n)</span> </span>&#123;</span><br><span class="line">   ll t = mul(a, a, n) + c;</span><br><span class="line">  <span class="keyword">return</span> t &gt;= n ? t - n : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::mt19937_64 <span class="title">e</span><span class="params">(<span class="number">2333</span>)</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">getd</span> <span class="params">(ll n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;ll&gt; <span class="title">r</span><span class="params">(<span class="number">0</span>, n - <span class="number">1</span>)</span></span>;</span><br><span class="line">   ll c = r(e), a = nxt(r(e), c, n), b = nxt(a, c, n);</span><br><span class="line">   <span class="keyword">int</span> lim = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        ll v = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lim <span class="keyword">and</span> a != b; k ++) &#123;</span><br><span class="line">            v = mul(v, <span class="built_in">std</span>::<span class="built_in">abs</span>(a - b), n);</span><br><span class="line">           a = nxt(a, c, n);</span><br><span class="line">         b = nxt(b, c, n);</span><br><span class="line">         b = nxt(b, c, n);</span><br><span class="line">     &#125;</span><br><span class="line">        ll g = <span class="built_in">std</span>::__gcd(v, n);</span><br><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span><br><span class="line">     <span class="keyword">if</span> (lim &lt; <span class="number">128</span>) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> getd(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll max;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">factor</span> <span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> <span class="keyword">or</span> isp(n)) <span class="keyword">return</span> max = <span class="built_in">std</span>::max(max, n), <span class="keyword">void</span>();</span><br><span class="line">    ll d = getd(n);</span><br><span class="line">   <span class="keyword">while</span> (n % d == <span class="number">0</span>) n /= d;</span><br><span class="line">   factor(n), factor(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      ll n = read;</span><br><span class="line">      max = <span class="number">0</span>, factor(n);</span><br><span class="line">       <span class="keyword">if</span> (max == n) <span class="built_in">puts</span>(<span class="string">&quot;Prime&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>万能欧几里得</p>
</summary>
<ul>
<li><span class="math inline">\(n\)</span> 在辗转相除后会到 <span class="math inline">\(lim^2\)</span> 级别。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  ll x, y, s;</span><br><span class="line">   ll a1, a2, a3;</span><br><span class="line">&#125; Z = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">node <span class="keyword">operator</span> + (node a, node b) &#123;</span><br><span class="line">  node c;</span><br><span class="line">   c.a1 = (a.a1 + b.a1 + a.y * b.x) % mod;</span><br><span class="line">   c.a2 = (a.a2 + b.a2 + a.y * a.y % mod * b.x + <span class="number">2</span> * a.y * b.a1) % mod;</span><br><span class="line">  c.a3 = (a.a3 + b.a3 + a.x * b.a1 + a.y * b.s + a.x * a.y % mod * b.x) % mod;</span><br><span class="line">  c.x = (a.x + b.x) % mod;</span><br><span class="line">  c.y = (a.y + b.y) % mod;</span><br><span class="line">  c.s = (a.s + b.s + a.x * b.x) % mod;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node <span class="keyword">operator</span> * (node a, ll k) &#123;</span><br><span class="line">  node r = Z;</span><br><span class="line">   <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) r = r + a;</span><br><span class="line">        a = a + a;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">F</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, ll n, node X, node Y)</span> </span>&#123; <span class="comment">// 从 0 开始标号！</span></span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> Y * (b / c) + X;</span><br><span class="line"> <span class="keyword">if</span> (b &gt;= c) <span class="keyword">return</span> Y * (b / c) + F(a, b % c, c, n, X, Y);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= c) <span class="keyword">return</span> X + F(a % c, b + a % c, c, n - <span class="number">1</span>, Y * (a / c) + X, Y);</span><br><span class="line">    ll t = (a * n + b) / c;</span><br><span class="line">   <span class="keyword">if</span> (t == <span class="number">0</span>) <span class="keyword">return</span> X * (n + <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> F(c, a + c - b - <span class="number">1</span>, a, t - <span class="number">1</span>, Y, X) + X * (n - (t * c - b - <span class="number">1</span>) / a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T = read;</span><br><span class="line">    node X = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    node Y = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read, a = read, b = read, c = read;</span><br><span class="line">      node d = F(a, b, c, n, X, Y);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld\n&quot;</span>, d.a1, d.a2, d.a3);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>
<p>来一个从 1 开始标号的简洁版本<del>（适合全文背诵）</del>：</p>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="function">node <span class="title">F</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, ll n, node X, node Y)</span> </span>&#123; <span class="comment">// 从 1 标号 (b &lt; c) (a &lt; c)</span></span><br><span class="line">    ll t = (a * n + b) / c;</span><br><span class="line">   <span class="keyword">return</span> !t ? X * n :</span><br><span class="line">      X * ((c - b - <span class="number">1</span>) / a) + Y +</span><br><span class="line">       F(c % a, (c - b - <span class="number">1</span>) % a, a, t - <span class="number">1</span>, X * (c / a) + Y, X) +</span><br><span class="line">     X * (n - (c * t - b - <span class="number">1</span>) / a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">f</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, ll n, node X, node Y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> Y * (b / c) + F(a % c, b % c, c, n, Y * (a / c) + X, Y);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>多项式求逆</p>
</summary>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T &amp;x)</span> </span>&#123; x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> R[maxl &lt;&lt; <span class="number">1</span>], G[maxl];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">power</span> <span class="params">(ll x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) k += mod - <span class="number">1</span>;</span><br><span class="line">  ll res = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) (res *= x) %= mod;</span><br><span class="line">        (x *= x) %= mod;</span><br><span class="line">      k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= maxl; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">int</span> *r = R + n;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">         r[i] = r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) * (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    ll g = power(<span class="number">3</span>, (mod - <span class="number">1</span>) / maxl);</span><br><span class="line">    G[maxl / <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = maxl / <span class="number">2</span> + <span class="number">1</span>; i &lt; maxl; i ++) G[i] = G[i - <span class="number">1</span>] * g % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxl / <span class="number">2</span> - <span class="number">1</span>; i; i --) G[i] = G[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span> <span class="params">(<span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ull a[maxl];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] = ull(b[R[n + i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">              ull x = a[k], y = a[k + m] * ull(G[m + k - i]) % mod;</span><br><span class="line">             a[k] = x + y;</span><br><span class="line">             a[k + m] = x + mod - y;</span><br><span class="line">           &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) b[i] = a[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::reverse(a + <span class="number">1</span>, a + n), dft(a, n);</span><br><span class="line">  ll in = mod - (mod - <span class="number">1</span>) / n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] = in * a[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">polyinv</span> <span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> t[maxl], b[maxl];</span><br><span class="line">    b[<span class="number">0</span>] = <span class="keyword">int</span>(power(a[<span class="number">0</span>], <span class="number">-1</span>));</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::copy(a, a + m, t);</span><br><span class="line">     <span class="built_in">std</span>::fill(t + m, t + (m &lt;&lt; <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        dft(t, m &lt;&lt; <span class="number">1</span>), dft(b, m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (m &lt;&lt; <span class="number">1</span>); i ++)</span><br><span class="line">            b[i] = ll(<span class="number">2</span> + ll(mod - t[i]) * b[i]) % mod * b[i] % mod;</span><br><span class="line">      idft(b, m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">std</span>::fill(b + m, b + (m &lt;&lt; <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::copy(b, b + n, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  init();</span><br><span class="line">   <span class="keyword">int</span> n = read, l = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (l &lt; n) l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) read(a[i]);</span><br><span class="line"> polyinv(a, l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>FFT</p>
</summary>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span> </span>&#123; <span class="keyword">double</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> R[maxl &lt;&lt; <span class="number">1</span>];</span><br><span class="line">com W[maxl];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= maxl; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">int</span> *r = R + n;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">         r[i] = r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | (i &amp; <span class="number">1</span>) * (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxl / <span class="number">2</span>; i ++) W[maxl / <span class="number">2</span> + i] =</span><br><span class="line">        com(<span class="built_in">std</span>::<span class="built_in">cos</span>(<span class="number">2</span> * M_PI / maxl * i), <span class="built_in">std</span>::<span class="built_in">sin</span>(<span class="number">2</span> * M_PI / maxl * i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxl / <span class="number">2</span> - <span class="number">1</span>; i; i --) W[i] = W[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span> <span class="params">(com *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (i &lt; R[n + i]) <span class="built_in">std</span>::swap(a[i], a[R[n + i]]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">              com x = a[k], y = a[k + m] * W[m + k - i];</span><br><span class="line">                a[k] = x + y, a[k + m] = x - y;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span> <span class="params">(com *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">std</span>::reverse(a + <span class="number">1</span>, a + n), dft(a, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) a[i] /= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">com a[maxl], b[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   init();</span><br><span class="line">   <span class="keyword">int</span> n = read, m = read, l = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (l &lt; n + m + <span class="number">1</span>) l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) a[i] = read;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) b[i] = read;</span><br><span class="line">   dft(a, l), dft(b, l);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i ++) a[i] *= b[i];</span><br><span class="line">   idft(a, l);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="keyword">int</span>(a[i].real() + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>回文树</p>
</summary>
<ul>
<li>与 SAM 不同的是，回文树的比较总是要拿 <code>len</code> 和原串 <code>s</code> 作为依据，而不是仅仅判断 <code>ch[u][x]</code> 是否有值。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>, maxc = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn], ch[maxn][maxc], len[maxn], dep[maxn], cp = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i - len[pre] - <span class="number">1</span>] != s[i]) pre = fail[pre];</span><br><span class="line"> <span class="keyword">int</span> &amp;now = ch[pre][x];</span><br><span class="line">   <span class="keyword">if</span> (!now) &#123;</span><br><span class="line">     now = ++ cp;</span><br><span class="line">      len[now] = len[pre] + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> ((pre = fail[pre]))</span><br><span class="line">           <span class="keyword">while</span> (s[i - len[pre] - <span class="number">1</span>] != s[i]) pre = fail[pre];</span><br><span class="line">     fail[now] = ch[pre][x] ? ch[pre][x] : <span class="number">2</span>;</span><br><span class="line">      dep[now] = dep[fail[now]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">   len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  fail[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ans = <span class="number">0</span>, las = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">       s[i] = (s[i] - <span class="string">&#x27;a&#x27;</span> + ans) % maxc + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">       las = insert(las, i);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans = dep[las], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>Manacher</p>
</summary>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">22000005</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> M = <span class="number">1</span>, R = <span class="number">1</span>;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">     h[i] = <span class="built_in">std</span>::min(h[M + M - i], R - i + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">while</span> (s[i - h[i]] == s[i + h[i]]) ++ h[i];</span><br><span class="line">      <span class="keyword">if</span> (i + h[i] - <span class="number">1</span> &gt; R)</span><br><span class="line">         M = i, R = i + h[i] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i --)</span><br><span class="line">        s[i &lt;&lt; <span class="number">1</span>] = s[i], s[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>, s[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">   manacher(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>); i ++) ans = <span class="built_in">std</span>::max(ans, h[i] - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
<details class="note "><summary><p>二次剩余 Cipolla</p>
</summary>
<ul>
<li>注意先用欧拉准贼判断无解，以及特判 0 的解。</li>
</ul>
<figure class="highlight cpp">
<table>
<tr>
<td class="gutter">
<pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre>
</td>
<td class="code">
<pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T &amp;x)</span> </span>&#123; x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> I2, P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">com</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> x, y;</span><br><span class="line">    com (<span class="keyword">int</span> x, <span class="keyword">int</span> y = <span class="number">0</span>): x(x), y(y) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> com <span class="keyword">operator</span> * (com a, com b) &#123;</span><br><span class="line">    <span class="keyword">return</span> com((<span class="number">1l</span>l * a.x * b.x + <span class="number">1l</span>l * a.y * b.y % P * I2) % P,</span><br><span class="line">         (<span class="number">1l</span>l * a.x * b.y + <span class="number">1l</span>l * a.y * b.x) % P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">com <span class="title">power</span> <span class="params">(com x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    com r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">     <span class="keyword">if</span> (k &amp; <span class="number">1</span>) r = r * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">e</span><span class="params">(<span class="number">233</span>)</span></span>;</span><br><span class="line">   <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read;</span><br><span class="line">        read(P);</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (power(n, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x == P - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Hola!&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(<span class="number">0</span>, P - <span class="number">1</span>)</span></span>;</span><br><span class="line">     <span class="keyword">int</span> a = r(e);</span><br><span class="line">        <span class="keyword">while</span> (power((<span class="number">1l</span>l * a * a - n + P) % P, (P - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x == <span class="number">1</span>) a = r(e);</span><br><span class="line">        I2 = (<span class="number">1l</span>l * a * a - n + P) % P;</span><br><span class="line">       <span class="keyword">int</span> x = power(com(a, <span class="number">1</span>), (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).x, y = P - x;</span><br><span class="line">       <span class="keyword">if</span> (x &gt; y) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
</td>
</tr>
</table>
</figure>

</details>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>wqs二分</title>
    <url>/2020/08/09/wqs%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h2 id="直奔主题">直奔主题</h2>
<p>直接举例子吧，考虑这样一个问题：给定一个长为 <span class="math inline">\(n\)</span> 的数列，要选<strong>恰好</strong> <span class="math inline">\(k\)</span> 个不交的子段使得选择的子段总和最大。</p>
<h3 id="朴素-dp">朴素 DP</h3>
<p>朴素 DP 是设 <span class="math inline">\(f_{i,j,0/1}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个选择 <span class="math inline">\(j\)</span> 段最后一个有没有选的最大收益，时间复杂度 <span class="math inline">\(O(n^2)\)</span> ，必须有一维 <span class="math inline">\(j\)</span> 处理“恰好”这个限制。</p>
<p>有没有更优秀的复杂度呢？</p>
<a id="more"></a>
<h3 id="带权二分">带权二分</h3>
<p>设 <span class="math inline">\(F(x) = \max \{ f_{n,x,0}, f_{n,x,1} \}\)</span> ，也就是选择恰好 <span class="math inline">\(x\)</span> 个不交子段的最大收益。注意到虽然不能直接求出 <span class="math inline">\(F(k)\)</span> ，但是求出 <span class="math inline">\(\max\{F(x)|1 \le x \le n\}\)</span> ，也就是函数的最值（以及函数取最值的位置）是不难的（可以直接去掉上述 DP 的第二维）。如果取最值的位置恰为 <span class="math inline">\(k\)</span> 就能得到答案。</p>
<p>可惜最值并不一定取在 <span class="math inline">\(x = k\)</span> ，但是可以考虑做一个调整，如果魔改问题，钦定每选一个子段就可以得到 <span class="math inline">\(p\)</span> 的额外收益，那么此时恰好选 <span class="math inline">\(x\)</span> 个子段的最大收益就是 <span class="math inline">\(F(x) + px\)</span> ，如果 <span class="math inline">\(p\)</span> 选取合适，就能让 <span class="math inline">\(G(x) = F(x) + px\)</span> 的最值恰好取在 <span class="math inline">\(x = k\)</span> ，此时 <span class="math inline">\(F(k) = G(k) - pk\)</span> 就是答案。</p>
<p>如何选择这样一个 <span class="math inline">\(p\)</span> 呢？把这个问题抽象到二维平面，可以发现 <span class="math inline">\((x, F(x))\)</span> 构成了一个凸包，而 <span class="math inline">\(F(x) + px\)</span> 的意义就是斜率为 <span class="math inline">\(-p\)</span> 的直线在该点上的截距。这样以来不难发现这个 <span class="math inline">\(p\)</span> 是可二分的，这个二分过程就是 wqs 二分。</p>
<p><del>懒得画图，不配图了。</del></p>
<h2 id="扩展">扩展</h2>
<p>wqs 二分也可以嵌套，比如 CF739E 一题中，有两个不同的数列，要分别选取 <span class="math inline">\(a, b\)</span> 个元素并最大化收益，其中如果有一个位置在两个数列中同时被选会有一定的代价。</p>
<p>朴素 DP 是设 <span class="math inline">\(f_{i,j,k}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个位置在两个部分分别选 <span class="math inline">\(j, k\)</span> 个元素的最大收益，复杂度 <span class="math inline">\(O(n^3)\)</span> 。</p>
<p>设 <span class="math inline">\(F(j,k) = f_{n,j,k}\)</span> ，抽象到三维空间上就是点 <span class="math inline">\((j, k, F(j, k))\)</span> 构成的三维凸包！于是可以拿一个平面去截这个三维凸包。也就是确定两个附加代价 <span class="math inline">\(p, q\)</span> ，使得 <span class="math inline">\(G(j,k) = F(j,k) - jp - kq\)</span> ，那就可以求出也就是平面 <span class="math inline">\(z = px + qy + K\)</span> 截出来的截距 <span class="math inline">\(K\)</span> 。二分套二分即可求解，复杂度 <span class="math inline">\(O(n log^2 n)\)</span> 。</p>
<p>三维空间可能有点抽象，也不一定要从这个角度理解，从二分套二分（也就是先来个 wqs 二分，然后对于新的问题继续 wqs 二分）的角度可能更容易理解，也更接近实现。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2020</title>
    <url>/2020/08/04/WC2020/</url>
    <content><![CDATA[<p>别人在放暑假的时候，我却在参加 冬 令 营 。</p>
<p>不愧是冬眠营，前面四天的授课和营员交流都没听懂啥，真就冬眠去了。。。</p>
<p>第一天上来就是松松松手把手教你写一个路由器？</p>
<p>营员交流 20 分钟 100 页 ppt ？</p>
<p>授课讲的东西太多是 OI 无关的，营员交流信息量又太大<del>（把课件蒯走就完事了）</del>，还好是线上冬令营，掉线了反正也重连不上，干脆颓废折腾去了。</p>
<p>总而言之，前四天全都在划水，一点也不夸张。所以重点就全在 Day5 的考试上了。</p>
<a id="more"></a>
<h2 id="day5.0">Day5.0</h2>
<p>花 30min 把题目都读了一遍，感觉大概是 T1 数据结构，T2 数学/图论，T3 贪心/DP （嗯？怎么和省选 D1 有点像）。不过今年 WC 怎么三道传统题啊，昨天还在担心会不会有什么奇奇怪怪的题目。</p>
<p>于是 T2 -&gt; T3 -&gt; T1 的顺序开题。</p>
<h3 id="有根树">有根树</h3>
<p>问题很诡异，先写了个裸暴力，写完后发现可以优化，优化完后还是暴力，但是这个优化的过程让我发现了这个问题的一个看上去可做的转换。</p>
<p>但还是遇到了瓶颈，有一个部分很难维护，最后仍然 10 分暴力。</p>
<p>update: 不过由于我暴力写了很多优化，虽然上界很高但是一般数据跑不满，所以好像多水了一些分数？</p>
<h3 id="猜数游戏">猜数游戏</h3>
<p>开场肝数学题总没错，按照题目描述的关系建图，这个图就很有性质，可以对每个团单独算贡献。想了想感觉图论的模型没错并且不难，那么问题的瓶颈就在于数学的部分，也就是怎么确定连边。容易想到 BSGS ，但是复杂度太大。如果是质数的话可以用原根来解，但是是 <span class="math inline">\(O(p)\)</span> 的。仔细想了想发现固定底数是对多个数做 BSGS 的复杂度并不是单次 <span class="math inline">\(O(\sqrt{p})\)</span> 的，预处理的部分可以共用。然后就写了质数的 50 分。</p>
<p>想了想合数 <span class="math inline">\(q^k\)</span> 虽然不存在原根，但是如果一个数如果是 <span class="math inline">\(q\)</span> 的倍数那么可以 <span class="math inline">\(O(k)\)</span> 暴力枚举幂次，否则对于 <span class="math inline">\(q\)</span> 的原根 <span class="math inline">\(g\)</span> ，<span class="math inline">\(g\)</span> 的幂次覆盖了所有与 <span class="math inline">\(q\)</span> 互质的数。</p>
<p>意识到这个结论后感觉很 amazing ，但是不会证，不过对拍没有出错，应该是对的。</p>
<p><del>两个特殊性质给的提示还是挺明显的。</del></p>
<p>update: 事实上这个结论是错的，但绝大多数情况下成立，根据某篇论文，<span class="math inline">\(q \le 10^12\)</span> 内的反例仅有 <span class="math inline">\(q=2, q=40487, q=6692367337\)</span> 。而非常辛运的是，原题的数据范围使得这样的反例不可能出现。</p>
<h3 id="选课">选课</h3>
<p>感觉题目很复杂，数据范围也很复杂，费好大劲才弄明白这是个什么东西。</p>
<p>一开始以为是费用流或者模拟费用流，否掉了，然后就没思路了，便去打 <span class="math inline">\(p=0\)</span> 的部分分，这部分每段贪心然后背包合并就可以了，但是由于时间原因放弃了 <span class="math inline">\(\sum_s = T\)</span> 的部分，写了 30 分。</p>
<h2 id="day5.1">Day5.1</h2>
<p>卧槽听了 T2 才知道原来原根的定义就是幂次覆盖 <span class="math inline">\(\phi(p)\)</span> 个数的数，之前一直以为只有 <span class="math inline">\(p\)</span> 为质数的时候覆盖 <span class="math inline">\(p-1\)</span> 个数的数才叫原根。。。</p>
<p>而且 <span class="math inline">\(p\)</span> 有原根当且仅当 <span class="math inline">\(p=2 \lor p=4 \lor p = q^a \lor p = 2q^a\)</span> ，其中 <span class="math inline">\(q\)</span> 是奇质数。</p>
<p>而且这玩意还只是弱化版。。。</p>
<p>神仙群友，甚至不需要 BSGS ，可以利用原根证明两个点有边当且仅当它们的阶有整除关系，一个点集是团当且仅当这些数的阶相等，用试除法把每个数的阶求出来就行了，据此可以得到一个 <span class="math inline">\(O(n\log^2p)\)</span> 的做法，可以通过第一个加强版。不过对于第二个加强版当 <span class="math inline">\(p\)</span> 任意的时候这个做法似乎就不行了。</p>
<p>流下了没有数理基础的泪水。。。</p>
<p>T3 完全不会。</p>
<p>T1 连链的答案都没有注意到，自闭了。</p>
<h2 id="day6">Day6</h2>
<p>上午的讲座听了一会，听的时候看到了一道 NOI 的提答题《旷野大计算》，卧槽真好玩，然后就咕掉了讲座去玩提答了。</p>
<p>下午闭幕式进不去，又咕了，在机房划水，还是通过看了闭幕式的 compu 才知道自己水到了金牌。暴力拿金，妙啊妙啊，我还以为 T1 完全把我区分掉了。</p>
<p>一开始听说我是 135 分，金牌线 130 ，心想自己是压线金牌了，不过完全不能理解自己为什么挂了分（我特意留了 40 分钟进行全面的检查，调试，对拍等工作以确保得分稳定）。后来又听说自己是 165 ，再后来有了数据自测又是 155 分。到现在都没搞清我的分数，不过排在了 rk11 ，湖南 rk2 ？</p>
<p><img src="/images/wc2020.png" /></p>
<p><del>终于有个还算能看的排名了！</del></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>WC</tag>
      </tags>
  </entry>
  <entry>
    <title>弦图相关</title>
    <url>/2020/08/04/%E5%BC%A6%E5%9B%BE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>简单记录弦图相关概念和算法。</p>
<details class="note info"><summary><p>一些定义</p>
</summary>
<p>弦：连接环上不相邻两点的边。</p>
<p>弦图：每个简单环都有至少一条弦的无向图。</p>
<blockquote>
<p>事实上，可以预见的是，弦图的每个简单环都可以表示为若干三元环的对称差。</p>
</blockquote>
<p>团：任意两点都有边的无向图。</p>
<p>单纯点：与其相邻的点集的导出子图是团。</p>
<p>完美消除序列：点集的一个排列 <span class="math inline">\(\{p\}\)</span> ，满足每个点 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(p_j (j &gt; i)\)</span> 的导出子图中都是单纯点。</p>

</details>
<a id="more"></a>
<h3 id="弦图判定">弦图判定</h3>
<p><strong>定理：一个无向图是弦图当且仅当它有一个完美消除序列。</strong></p>
<p>对于一个弦图，可以从后往前确定完美消除序列，定义一个点的势为与当前已经确定的点有边的点的数量。每次选择势最大的未加入的点加入完美消除序列即可。</p>
<p>但是如果不是弦图，求出来的序列就不会是完美消除序列，因此弦图判定等价于判定该序列是否为完美消除序列。 从后往前枚举每个点按定义判定即可，需要注意如果当前判定到了点 <span class="math inline">\(x\)</span> ，说明在其后的点 <span class="math inline">\(y\)</span> 都是满足完美消除序列的性质的，据此可以在判定的时候优化，复杂度 <span class="math inline">\(O(n+m)\)</span> 。</p>
<h3 id="最小色数">最小色数</h3>
<p>等于最小团数，等于所有点在加入前的势的最大值加一。</p>
<p>事实上最优方案就是从完美消除序列从后往前染色。</p>
<h3 id="最大独立集">最大独立集</h3>
<p>等于最小团覆盖数。</p>
<p>事实上最优方案就是从完美消除序列从前往后加点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>弦图</tag>
      </tags>
  </entry>
  <entry>
    <title>好题题解整理（三）</title>
    <url>/2020/08/03/%E5%A5%BD%E9%A2%98%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>没有摘要。</p>
<a id="more"></a>
<hr />
<h2 id="cf1368f-lamps-on-a-circle">cf1368f Lamps on a Circle</h2>
<p>有一个长为 <span class="math inline">\(n\)</span> 的环，环上每个点是一个开关，Alice Bob 玩游戏，每轮执行以下流程：</p>
<ol type="1">
<li>Alice 选择是否结束游戏。如果是则游戏结束。</li>
<li>Alice 选择一个参数 <span class="math inline">\(k\)</span> ，并将任意 <span class="math inline">\(k\)</span> 个开关打开。</li>
<li>Bob 将任意<strong>连续</strong>的 <span class="math inline">\(k\)</span> 个开关关闭。</li>
</ol>
<p>Alice Bob 分别想要最大最小化最后打开的开关数量。设 <span class="math inline">\(R(n)\)</span> 是双方执行最优策略时最后打开的开关数量。</p>
<p>交互题，实现 Alice 的策略，使得最后打开的开关数量不少于 <span class="math inline">\(R(n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>不妨让 Alice 去复制 Bob 的操作，那么只要 Bob 选择连续 <span class="math inline">\(k\)</span> 个开关不是全开的，通过一次复制后回到 Bob 操作，局面不变，但是 <span class="math inline">\(k\)</span> 会变小，因为 Alice 只需要选择那些实际上被 Bob 关闭的开关。</p>
<p>那么可以发现 Bob 实际上只能关掉不超过 <span class="math inline">\(k\)</span> 的一个全部打开的连续段。游戏的一轮可以转换为以下流程：</p>
<ol type="1">
<li>Alice 选择是否结束游戏。如果是则游戏结束。</li>
<li>Alice 选择一个参数 <span class="math inline">\(k\)</span> ，并将任意 <span class="math inline">\(k\)</span> 个开关打开。</li>
<li>Bob 选择长度不超过 <span class="math inline">\(k\)</span> 的 <strong>连续</strong> 的一段 <strong>打开的</strong> 开关关闭。</li>
</ol>
<p>进一步可以发现这个游戏只需要进行一轮，进行多轮是没有意义的。这样一来，游戏的最终局面仅仅由 Alice 第一次打开的开关集合有关，设 Alice 打开了 <span class="math inline">\(p\)</span> 个连续段，第 <span class="math inline">\(i\)</span> 个连续段长度为 <span class="math inline">\(a_i\)</span> 。那么问题就是在满足 <span class="math inline">\(\sum_{i=1}^p (a_i+1) \le n\)</span> 的前提下最大化</p>
<p><span class="math display">\[\sum_{i=1}^p a_i - max\{a_i\}\]</span></p>
<p>显然前者的和最大不超过 <span class="math inline">\(n-p\)</span> ，只需要最小化后者，尽量使得 <span class="math inline">\(a\)</span> 平均时最优，可以得到</p>
<p><span class="math display">\[R(n) = max\{n - p - \lceil \frac{n-p}{p} \rceil\}\]</span></p>
<p>用上述策略实现 Alice 即可。</p>

</details>
<hr />
<h2 id="cf1368e-ski-accidents">cf1368e Ski Accidents</h2>
<p>有一张 <span class="math inline">\(n\)</span> 个点的 DAG ，每个点的出度不超过 2 ，求一个大小不超过 <span class="math inline">\(\frac{4n}{7}\)</span> 的点集使得该点集的补集的导出子图没有一个点同时有出度和入度。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>一个很自然的贪心是按照拓扑序一个个加点，只要当前点加入后仍然不存在同时有出度和入度的点就加入该点。最后把没有加入的点作为答案。</p>
<p><del>猜结论选手直接一交发现它 A 了。</del></p>
<p>这样做确实是对的，观察这个诡异的分数 <span class="math inline">\(\frac{4}{7}\)</span> ，注意到 <span class="math inline">\(1 + 2 + 4 = 7\)</span> ，这或许能带来一些启发。</p>
<p>称上述贪心过程中加入的点集为 <span class="math inline">\(S\)</span> ，其补集为 <span class="math inline">\(C\)</span> ，<span class="math inline">\(S\)</span> 的导出子图中没有入度的点集 <span class="math inline">\(A\)</span> ，其他的点集为 <span class="math inline">\(B\)</span> 。由于每个点的出度不超过 2 ，显而易见的是 <span class="math inline">\(|C| \le 2|B| \le 4|A|\)</span> ，那么 <span class="math inline">\(|C|\)</span> 就不会超过 <span class="math inline">\(\frac{4n}{7}\)</span> 。</p>

</details>
<hr />
<h2 id="lg5433-月宫的符卡序列">lg5433 月宫的符卡序列</h2>
<p>给定长为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span> ，定义一个回文串的权值是该回文串在 <span class="math inline">\(s\)</span> 中所有出现位置的中点（下取整）的异或和，求最大权值回文串。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>PAM 在处理中点相关的问时会比较无力，如果是端点算贡献倒是很好用 PAM 处理。但也未尝不能做。虽然 PAM 只能简单地维护 right 集合，但只要来个 PAM 套 01-trie ，用类似于《联合省选 2020 树》的技巧，就能推广到维护中点集合，不过会带来时间和空间上更大的开销，不在讨论范围内。</p>
<p>manacher 处理中点相关的问题往往更简单，把 <span class="math inline">\(s\)</span> 特殊处理后得到 <span class="math inline">\(t\)</span> ，考虑每个位置作为中点的贡献，贡献到的会是一堆串，这些串在 PAM 上形成了一条链。因此对 <span class="math inline">\(t\)</span> 建 PAM ，配合 manacher 做树上差分即可。这个 PAM 比较特殊，事实上此时这个 PAM 是真正的回文自动机，不需要建两个根节点。</p>

</details>
<hr />
<h2 id="lg5227-ahoi2013-连通图">lg5227 [AHOI2013] 连通图</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 点 <span class="math inline">\(m\)</span> 边的图，<span class="math inline">\(q\)</span> 次询问，每次给定大小 <span class="math inline">\(O(1)\)</span> 的边集求原图删掉该边集后是否连通。</p>
<p>时间复杂度：<span class="math inline">\(O(n + m + q)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p><del>大力 lct 维护动态图连通性。</del></p>
<h3 id="引理-1">引理 1</h3>
<p>对于任意一颗生成树，给每条边一个 01 向量，满足每条树边的向量恰好是其被覆盖的非树边的异或和，且每条非树边的向量线性无关。那么有：<strong>删掉边集 E 后图不连通当且仅当 E 中向量线性相关。</strong></p>
<p>证明繁琐，可以参见 yhx-12243 的博客。</p>
<h3 id="正题">正题</h3>
<p>显然给每条非树边一个线性无关的向量是不现实的，这至少需要 <span class="math inline">\(m-n+1\)</span> 维。不妨给每条非树边一个均匀随机的 <span class="math inline">\(k\)</span> 维向量，本质上是一个哈希，<span class="math inline">\(k\)</span> 足够大的时候冲突概率就会很低，冲突概率约为 <span class="math inline">\(2^{d-k}\)</span> ，其中 <span class="math inline">\(d\)</span> 是边集大小。</p>
<p>于是只需要判断一组向量是否线性相关即可，边集很小，暴力判断或使用线性基。复杂度 <span class="math inline">\(O(\frac{k}{w})\)</span> 或 <span class="math inline">\(O(\frac{k^2}{w})\)</span> ，不妨取 <span class="math inline">\(k=w\)</span> ，可以做到 <span class="math inline">\(O(1)\)</span> 回答询问。</p>
<p>边集大小任意的话复杂度分析下来应该是 <span class="math inline">\(O(n + md + q\frac{d^3}{w})\)</span> ，因为需要分配的维度大小得是 <span class="math inline">\(d + O(1)\)</span> 的。</p>

</details>
<hr />
<h2 id="loj536-libreoj-round-6花札">loj536 「LibreOJ Round #6」花札</h2>
<p>Alice Bob 分别有 <span class="math inline">\(n\)</span> 张牌，每张牌有一个颜色和一个点数，每个人轮流打出一张牌，要求必须和上一张的颜色或者点数一致，不能操作者输。</p>
<p>Alice 先手，求每张牌作为第一张牌被打出后游戏的必胜必败态。</p>
<p>时间复杂度：<span class="math inline">\(O(n^{\frac{5}{3}})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<h3 id="图论模型">图论模型</h3>
<p>把双方的牌看做节点，然后根据是否有颜色/点数相同连边，得到一张二分图 <span class="math inline">\(G\)</span>，那么这个游戏就可以描述为：从一个节点开始，每次选一条边走过去，不能走重复的点，不能操作者输。</p>
<p>这是个经典问题，同《[JSOI2009] 游戏》，结论是一个点是先手必胜的当且仅当它存在于所有最大匹配的交集中，应用反证法很容易证明。然而游戏那题数据范围小得多，显然不能直接套用过来。</p>
<h3 id="优化连边">优化连边</h3>
<p>注意到 <span class="math inline">\(G\)</span> 的边数是 <span class="math inline">\(O(n^2)\)</span> 的，必然需要优化连边。</p>
<p>直接在二分图上优化连边不太方便。不妨用网络流描述这个二分图匹配，然后优化网络流的连边使得前后的网络流等价。由于两点连边当且仅当颜色或点数相同，容易想到对每个颜色和点数建辅助点，然后在网络流上，<span class="math inline">\(u\)</span> 向所有颜色和点数连边，所有颜色和点数向对应的 <span class="math inline">\(v\)</span> 连边，就能间接连边 <span class="math inline">\(u \rightarrow v\)</span> 。这样一来点数和边数都是 <span class="math inline">\(O(n)\)</span> 的。</p>
<h3 id="残量网络">残量网络</h3>
<p>然后需要判断一个点 <span class="math inline">\(u\)</span> 是否存在于所有的最大匹配中，也就是在所有最大流中 <span class="math inline">\(S \rightarrow u\)</span> 这条边都有流量。常规的做法是求出一组最大流，然后删掉 <span class="math inline">\(u\)</span> 再求一遍最大流，若最大流减小了就说明 <span class="math inline">\(u\)</span> 所有最大流都要经过 <span class="math inline">\(u\)</span> 。虽然删掉 <span class="math inline">\(u\)</span> 重新跑最大流是不现实的，但是这可以带来一些启发，在一组最大流的残量网络上考虑这个过程，可以发现删掉 <span class="math inline">\(u\)</span> 不改变最大流说明可以通过一些手段把 <span class="math inline">\(S \rightarrow u\)</span> 的流量退掉并且不影响最大流，也就是说<strong>残量网络上存在一条从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(u\)</span> 的路径</strong>。</p>
<p>那么求出任意一组最大流，然后在残量网络上 dfs 出所有 <span class="math inline">\(S\)</span> 能到达的点 <span class="math inline">\(u\)</span> 即可。</p>
<p>dinic 的复杂度是 <span class="math inline">\(O(n^2m)\)</span> 的，查了一下在单位容量的图上似乎是 <span class="math inline">\(O(\max\{n^{2/3}, m^{1/2}\} m)\)</span> 的（不确定），在此题中就是 <span class="math inline">\(O(n^{5/3})\)</span> 。</p>

</details>
<hr />
<h2 id="lg6730-wc2020-猜数游戏">lg6730 [WC2020] 猜数游戏</h2>
<p>给定模数 <span class="math inline">\(p\)</span> ，定义一个数 <span class="math inline">\(x\)</span> 的导出集合为 <span class="math inline">\(F(x) = \{y|x^k \equiv y \pmod{p}\}\)</span> 。对于一个非空集合 <span class="math inline">\(S\)</span> ，称它的非空子集 <span class="math inline">\(T\)</span> 是优秀的，当且仅当 <span class="math inline">\(T\)</span> 中元素的导出集合的并集是 <span class="math inline">\(S\)</span> 的父集。<span class="math inline">\(S\)</span> 的权值定义为其最小的优秀子集的大小。</p>
<p>给定大小为 <span class="math inline">\(n\)</span> 的一个数集 <span class="math inline">\(S\)</span> ，求所有子集的权值和。另外，保证 <span class="math inline">\(p=q^k\)</span> ，其中 <span class="math inline">\(q\)</span> 是奇质数。</p>
<p>时间复杂度：<span class="math inline">\(O(nk\log p + d(\varphi(p))k)\)</span> ，其中 <span class="math inline">\(d\)</span> 表示约数个数函数，<span class="math inline">\(k\)</span> 表示 <span class="math inline">\(\varphi(p)\)</span> 的质因子个数。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<h3 id="集合关系">集合关系</h3>
<p>先考虑一个关键的问题，如何判断 <span class="math inline">\(y \in F(x)\)</span> 是否成立。一个朴素的做法是 BSGS ，单次复杂度 <span class="math inline">\(O(\sqrt{p})\)</span> ，显然代价太大不能接受。</p>
<p>但是注意到 <span class="math inline">\(p\)</span> 是一定有原根 <span class="math inline">\(g\)</span> 的，那么如果 <span class="math inline">\(q|x \lor q|y\)</span> 可以直接枚举 <span class="math inline">\(k\)</span> 暴力判断，否则一定可以表示为 <span class="math inline">\(x = g^a, y = g^b\)</span> 。于是 <span class="math inline">\(y \in F(x)\)</span> 等价于关于 <span class="math inline">\(k\)</span> 的方程 <span class="math inline">\(g^{ak} \equiv g^b\)</span> 有解。该方程等价于 <span class="math inline">\(ak \equiv b \pmod{\varphi(p)}\)</span> ，显然有解的充要条件是</p>
<p><span class="math display">\[\gcd(a, \varphi(p)) | \gcd(b, \varphi(p))\]</span></p>
<p>注意到事实上 <span class="math inline">\(\mathrm{ord} x = \frac{\mathrm{lcm}(\varphi(p), a)}{a} = \frac{\varphi(p)}{\gcd(a, \varphi(p))}\)</span> ，因此上式还等价于</p>
<p><span class="math display">\[\mathrm{ord} y | \mathrm{ord} x\]</span></p>
<p>也就是说只需要求出 <span class="math inline">\(S\)</span> 每个数模 <span class="math inline">\(p\)</span> 意义下的阶，就可以简单判断这个集合关系了。求阶可以用试除法 + 快速幂，试除只需要枚举 <span class="math inline">\(\varphi(p)\)</span> 的每个质因子，复杂度 <span class="math inline">\(O(\log^2p)\)</span> 。</p>
<h3 id="统计答案">统计答案</h3>
<p>如果将 <span class="math inline">\(y \in F(x)\)</span> 这个关系连边 <span class="math inline">\(x \rightarrow y\)</span> ，那么一个点集的权值就是最小点覆盖。观察这个图，由于连边的唯一判断依据是阶，可以发现阶相同的数连成了一个团，把这个团看做一个整体的点的话，整张图就是一张 DAG 。那么算一个给定图的权值是容易的，就是没有入度的团的数量（注意这张图的连边有传递性，也就是分层后层数不超过 2）。</p>
<p>现在要统计所有子集的权值和，对于每个团单独算贡献，那么一个子集 <span class="math inline">\(T\)</span> 中该团产生贡献（作为没有入度的团）当且仅当</p>
<ol type="1">
<li>该团中至少一个点在 <span class="math inline">\(T\)</span> 中</li>
<li>连向该团的其他团的任何点都不在 <span class="math inline">\(T\)</span> 中。</li>
</ol>
<p>设一个团大小为 <span class="math inline">\(x\)</span> ，有 <span class="math inline">\(y\)</span> 个不在该团的点连向该团，那么综上一个团的贡献就是 <span class="math inline">\((2^x-1)2^{n-y-x}\)</span> 。</p>
<h3 id="建图">建图</h3>
<p>可以发现尽管我们知道了连边方式，但是 <span class="math inline">\(n\)</span> 很大的时候显式地连边显然不行，不过我们并不关注具体连边，只需要关注每个点的入度。</p>
<p>统计一个阶为 <span class="math inline">\(x\)</span> 的团的入度的数量也就是统计有多少个数的阶是 <span class="math inline">\(x\)</span> 的倍数。目前我没有想到很好的解决方案，可以用高维前缀和做这个经典问题，复杂度 <span class="math inline">\(O(d(\varphi(p))\log)\)</span> 。</p>

</details>
<hr />
<h2 id="lg3665-usaco17openswitch-grass-p">lg3665 [USACO17OPEN]Switch Grass P</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 个有色点 <span class="math inline">\(m\)</span> 条带权边的图，<span class="math inline">\(q\)</span> 次询问，每次修改一个点的颜色，求权值最小的边，满足两个端点颜色不同。</p>
<p>时间复杂度：<span class="math inline">\(O(m\log + n + q\log)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>确定一颗最小生成树，那么所有非树边不可能作为答案。</strong></p>
<p>应用反证法，注意到非树边的权值一定不小于其覆盖的所有树边，并且如果非树边两个端点颜色不同，那么其覆盖的树边也一定存在至少一个端点异色。</p>
<h3 id="正题">正题</h3>
<p>根据引理 1 ，图可以转换为树。</p>
<p>考虑如何维护一个修改，由于修改一个点只会影响其连接的边，一个经典的做法是度数分块，但是不能接受。正确的做法比较繁琐，就是对于每个点维护其儿子的颜色集合，这是很好维护的。其次维护每个点往儿子连边的最优答案，维护儿子集合的同时也能更新。再然后就是维护每个点的最有答案，对于询问取最小值。</p>
<p>个人认为本题精彩的部分就在于引理 1 。</p>

</details>
<hr />
<h2 id="hdu6311-cover">hdu6311 Cover</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 点 <span class="math inline">\(m\)</span> 边的无向图，要求使用最少的路径覆盖所有边。</p>
<p>时间复杂度：<span class="math inline">\(O(n + m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>不妨假设图连通。假设用 <span class="math inline">\(k (k &gt; 1)\)</span> 条路径覆盖所有边，那么将路径的端点用 <span class="math inline">\(k\)</span> 条虚边连成一个回路，那么该回路就是新图（原图加虚边）的欧拉回路。</p>
<p>同样的，如果先给图加上 <span class="math inline">\(k\)</span> 条虚边然后求新图的欧拉回路，把欧拉回路上的虚边割掉就可以得到原图的一组 <span class="math inline">\(k\)</span> 个路径的覆盖方案。</p>
<p>那么问题等价于加上最少的虚边使得图有欧拉回路，一个无向图有欧拉回路当且仅当所有所有点的度数为偶数，因此最少的加边方案就是把奇度点（一定有偶数个）任意弄个匹配。</p>

</details>
<hr />
<h2 id="cf1299e-so-mean">cf1299e So Mean</h2>
<p>有一个 <span class="math inline">\(n\)</span> 元排列 <span class="math inline">\(\{p\}\)</span> ，需要通过若干次询问确定该排列，每次询问可以给定一个子集，得到该子集的平均数是否为整数。</p>
<p>特别的，对于该排列的逆 <span class="math inline">\(\{q\}\)</span> ，总有 <span class="math inline">\(q_1 &lt; q_n\)</span> 。</p>
<p>询问次数不超过 <span class="math inline">\(18n\)</span> ，<span class="math inline">\(n\)</span> 是不超过 <span class="math inline">\(800\)</span> 的偶数。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<h3 id="trick-1">trick 1</h3>
<p>询问大小为 2 的子集 <span class="math inline">\(\{p_i, p_j\}\)</span> ，可以知道它们的奇偶性是否相同。</p>
<h3 id="trick-2">trick 2</h3>
<p>询问大小为 <span class="math inline">\(n-1\)</span> 的子集 <span class="math inline">\(U \setminus \{p_i\}\)</span> ，由于 <span class="math inline">\(\sum_{x \in U} x \equiv \frac{n(n+1)}{2} \equiv 1 \pmod{n-1}\)</span> ，询问的结果为真当且仅当 <span class="math inline">\(p_i \equiv 1 \pmod{n-1}\)</span> ，容易发现只有 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 满足条件，因此这样就能确定 <span class="math inline">\(q_1\)</span> 和 <span class="math inline">\(q_n\)</span> 。</p>
<p>结合 trick 1 ，可以知道所有数的奇偶性。</p>
<h3 id="trick-3">trick 3</h3>
<p>考虑推广 trick 2 ，在已知 <span class="math inline">\(q_1 ... q_k, q_{n-k+1} ... q_n\)</span> 的情况下询问一个大小为 <span class="math inline">\(n-2k-1\)</span> 的子集 <span class="math inline">\(S \setminus \{p_i\}\)</span> ，其中 <span class="math inline">\(S\)</span> 是剩余的未知数，注意到 <span class="math inline">\(\sum_{x \in S} x \equiv \frac{(n+1)(n-2k)}{2} \equiv k+1 \pmod{n-2k-1}\)</span> ，因此询问的结果为真当且仅当 <span class="math inline">\(p_i \equiv k + 1 \pmod{n-2k-1}\)</span> ，满足条件的数只有 <span class="math inline">\(k+1\)</span> 和 <span class="math inline">\(n-k\)</span> ，并且它们奇偶性不同，由此可以确定 <span class="math inline">\(q_{k+1}\)</span> 和 <span class="math inline">\(q_{n-k}\)</span> 。</p>
<p>可以发现反复使用这个 trick 总能在 <span class="math inline">\(O(n^2)\)</span> 次询问后得到整个排列。</p>
<h3 id="trick-4">trick 4</h3>
<p>通过 trick 1 + trick 2 实际上得到了所有数在模 2 意义下的值。对于 <span class="math inline">\(p_i \bmod 2 = 1\)</span> ，其在模 4 意义下只能是 1 或 3 ，如果用三个和为 1 （模 4 意义下）的已知的数（<strong>称之为 3 元组</strong>）和 <span class="math inline">\(p_i\)</span> 一起询问，就可以判断出 <span class="math inline">\(p_i\)</span> 在模 4 意义下的值，对于 <span class="math inline">\(p_i \bmod 2 = 0\)</span> 同理。</p>
<p>同样的道理，知道每个数模 4 的值后还可以通过若干 7 元组得到每个数模 8 的值。</p>
<h3 id="trick-5">trick 5</h3>
<p>如果能找到 <span class="math inline">\(k-1\)</span> 个模 <span class="math inline">\(k\)</span> 意义下的和两两不同的 <span class="math inline">\(k-1\)</span> 元组，把任意 <span class="math inline">\(p_i\)</span> 和它们逐个询问就能得到 <span class="math inline">\(p_i \bmod k\)</span> 。</p>
<h3 id="中国剩余定理">中国剩余定理</h3>
<p>如果知道了 <span class="math inline">\(p_i\)</span> 在模 <span class="math inline">\(3,5,7,8\)</span> 意义下的值，根据中国剩余定理，可以知道其在模 <span class="math inline">\(3 \times 5 \times 7 \times 8 = 840\)</span> 意义下的值，也就是真实值。</p>
<p>而 trick 4 和 trick 5 给出了每个模数求值的方法，但是需要一些已知数。trick 3 恰好给出了产生一些已知数的方法（事实上只需要 8 个）。综上，就可以使用较少的询问得到答案。</p>
<p><em>如果不用 trick 4 的话，直接用 trick 5 处理 8 这个模数，就要使用 trick 3 产生更多的已知数，容易导致询问数过大。</em></p>

</details>
<hr />
<h2 id="hdu6842-battle-for-wosneth2">hdu6842 Battle for Wosneth2</h2>
<p>Alice Bob 打架，两者生命值分别为 <span class="math inline">\(n, m\)</span> ，命中率分别为 <span class="math inline">\(p, q\)</span> ，从 Alice 开始轮流攻击对方，生命值先到 0 的一方败。求 Alice 胜率。</p>
<p>时间复杂度：<span class="math inline">\(O(n + m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>一个朴素的 DP 是设 <span class="math inline">\(f_{n,m}\)</span> 表示当前局面下的胜率，转移枚举下两次攻击的情况，可以得到 <span class="math inline">\(f_{n,m} = a f_{n,m-1} + b f_{n-1,m} + c f_{n-1,m-1}\)</span> ，其中 <span class="math inline">\(a,b,c\)</span> 是只与 <span class="math inline">\(p,q\)</span> 有关的常数。</p>
<p>把这个 DP 放在二维平面上，就是从 <span class="math inline">\((n, m)\)</span> 走到任意一个满足 <span class="math inline">\(x&gt;0\)</span> 的 <span class="math inline">\((x, 1)\)</span> 。可以枚举 <span class="math inline">\(c\)</span> 的步数 <span class="math inline">\(k\)</span>，注意到 <span class="math inline">\(a\)</span> 的步数和 <span class="math inline">\(c\)</span> 的步数总和始终为 <span class="math inline">\(m-1\)</span> ，那么就需要对所有 <span class="math inline">\(b\)</span> 的步数算贡献。此时可以知道 <span class="math inline">\(b\)</span> 的步数的上界是 <span class="math inline">\(n-1-k\)</span> ，而每一个 <span class="math inline">\(b\)</span> 的具体步数 <span class="math inline">\(i\)</span> 的贡献是与 <span class="math inline">\(k\)</span> 无关的，那么预处理个前缀和即可。</p>
<p>具体的，问题等价于求</p>
<p><span class="math display">\[(a+c) \sum_{k} \sum_{i=0}^{n-1-k} \binom{m-1}{k} \binom{m-1+i}{i} a^{m-1-k} b^i c^k\]</span></p>
<p>即</p>
<p><span class="math display">\[(a+c) \sum_{k} \binom{m-1}{k} a^{m-1-k} c^k \sum_{i=0}^{n-1-k} \binom{m-1+i}{i} b^i\]</span></p>
<p>后面的 <span class="math inline">\(\sum\)</span> 里头的值与 <span class="math inline">\(k\)</span> 无关，可以预处理。</p>

</details>
<hr />
<h2 id="uoj549-unr-4序列妙妙值">uoj549 【UNR #4】序列妙妙值</h2>
<p>给定长为 <span class="math inline">\(n\)</span> 的值域 <span class="math inline">\([0, 2^v)\)</span> 的整数序列，划分为恰好 <span class="math inline">\(k\)</span> 段使得每段异或和的总和最小，求该最小值。</p>
<p>时间复杂度：<span class="math inline">\(O(n k 2^{v/2})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p><del>一个朴素的 DP 是设 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个分 <span class="math inline">\(j\)</span> 段，然后暴力转移。另一个朴素的 DP 是设 <span class="math inline">\(f_{i,j,x}\)</span> 表示前 <span class="math inline">\(i\)</span> 个分 <span class="math inline">\(j\)</span> 段最后一段为 <span class="math inline">\(x\)</span> 然后 <span class="math inline">\(O(1)\)</span> 转移。巧的是这两个 DP 都跟正解没啥关系。</del></p>
<p>将序列做个异或前缀和得到 <span class="math inline">\(\{a\}\)</span> ，沿用第一个朴素 DP ，不过转移枚举分段点的位置是很难优化的，不妨考虑转移枚举分段点的 <span class="math inline">\(a\)</span> 的值。于是转移的复杂度就从 <span class="math inline">\(O(n)\)</span> 变成了 <span class="math inline">\(O(2^v)\)</span> 。</p>
<p>考虑这个过程实际上是维护了一个 <span class="math inline">\(g_x\)</span> 表示分段点的 <span class="math inline">\(a\)</span> 值在 <span class="math inline">\(x\)</span> 时候的转移最大值，转移事实上是求：</p>
<p><span class="math display">\[\max \{g_x + (x \oplus a_i)\}\]</span></p>
<p>而注意到更新 <span class="math inline">\(g\)</span> 是 <span class="math inline">\(O(1)\)</span> 的，直接把 <span class="math inline">\(g_{a_i}\)</span> 和当前 DP 值取 max 即可。这个 DP 关键就在于这个 <span class="math inline">\(g\)</span> ，它可以看做一个 <span class="math inline">\(O(2^v)\)</span> 查询和 <span class="math inline">\(O(1)\)</span> 修改的数据结构。然而修改次数和查询次数是几乎相等的，显然我们希望让两者的复杂度尽量平摊。</p>
<p>那么到这里思路就很显然了，每次查询只枚举前 <span class="math inline">\(v/2\)</span> 位，对于后面 <span class="math inline">\(v/2\)</span> 位查表，而每次修改只需暴力更新后 <span class="math inline">\(v/2\)</span> 位对应的表即可。</p>

</details>
<hr />
<h2 id="uoj551-unr-4校园闲逛">uoj551 【UNR #4】校园闲逛</h2>
<p>有 <span class="math inline">\(n\)</span> 点 <span class="math inline">\(m\)</span> 边的有向图，边权为 <span class="math inline">\(V\)</span> 以内的正整数。<span class="math inline">\(q\)</span> 次询问，每次询问从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的边权和恰为 <span class="math inline">\(z\)</span> 的路径有多少（可以不是简单路径）。</p>
<p>时间复杂度：<span class="math inline">\(O(n^3 V + n^2 V \log V + m \log V + q)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>容易想到弄 <span class="math inline">\(n^2\)</span> 条边，每条边是一个多项式，其 <span class="math inline">\(k\)</span> 次项系数是原图该条边边权为 <span class="math inline">\(k\)</span> 的数量。那么只要对于每个 <span class="math inline">\(x, y\)</span> 求出从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的所有路径的多项式乘积的和 <span class="math inline">\(f_{x,y}\)</span> ，询问的答案就是 <span class="math inline">\([x^z] f_{x,y}\)</span> 。</p>
<p><strong>倍增求这个多项式</strong> ，也就是说每次在已知 <span class="math inline">\(f \bmod x^{k}\)</span> 的基础上求出所有的 <span class="math inline">\(f \bmod x^{2k}\)</span> 。</p>
<p>注意到倍增后增加的路径都是权值在 <span class="math inline">\([k, 2k)\)</span> 内的路径，目标是统计这些新增的路径。</p>
<p>对于一条新增路径，称使得路径权值大于等于 <span class="math inline">\(k\)</span> 的第一条边为关键边（比如对于 <span class="math inline">\(k=4\)</span> ，路径 <span class="math inline">\(1+2+2+1\)</span> ，第三条边为关键边），考虑 <strong>通过枚举关键边来统计对应的新增路径</strong> 。</p>
<p>那么一条新增路径可以按照三部分，一是关键边前面的部分，而是关键边本身，三是关键边后面的部分。注意到一三部分的权值都不会超过 <span class="math inline">\(k\)</span> ，因此都可以在上一轮的 <span class="math inline">\(f\)</span> （称为 <span class="math inline">\(g\)</span> ）中表示出来。而对于边权在 <span class="math inline">\([k, 2k)\)</span> 内的边，它们在路径中至多出现一次，且一定作为关键边。</p>
<p>那么一个简单的做法就呼之欲出了。先枚举一部分 <span class="math inline">\((x, y)\)</span> 和二部分 <span class="math inline">\((y, z)\)</span> 。设 <span class="math inline">\(h_{x,y}\)</span> 表示 <span class="math inline">\((x, y)\)</span> 上的关键边构成的多项式，<span class="math inline">\(t_{x,z} = \sum_y g_{x,y} \times h_{y,z}\)</span> ，那么 <span class="math inline">\(t_{x,z}\)</span> 的 <span class="math inline">\(d (d \in [k, 2k)\)</span> 次项系数就是从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(z\)</span> 前两部分到 <span class="math inline">\(z\)</span> 的权值为 <span class="math inline">\(d\)</span> 的路径数。</p>
<p>然后把第三部分考虑进来，注意到对于 <span class="math inline">\(t\)</span> 我们只关注它的 <span class="math inline">\(k\)</span> 次项系数到 <span class="math inline">\(2k-1\)</span> 次项系数，不妨设 <span class="math inline">\(h\)</span> 表示 <span class="math inline">\(t\)</span> 的后 <span class="math inline">\(k\)</span> 项系数构成的多项式，那么直接枚举第三部分 <span class="math inline">\((x, y)\)</span> ，设 <span class="math inline">\(s_{x,z} = \sum_y h_{x,y} \times g_{y,z}\)</span> ，<span class="math inline">\(s\)</span> 的前 <span class="math inline">\(k\)</span> 项系数就是我们需要的。于是有</p>
<p><span class="math display">\[f_{x,y} \bmod x^{2k} = g_{x,y} + x^k (s_{x,y} \bmod x^k)\]</span></p>
<p>每次只需要对 <span class="math inline">\(O(n^2)\)</span> 个多项式做 DFT/IDFT ，那个类似于 floyd 的 <span class="math inline">\(O(n^3)\)</span> 转移都是可以线性点乘的。</p>

</details>
<hr />
<h2 id="agc001f-wide-swap">agc001f Wide Swap</h2>
<p>给定 <span class="math inline">\(1 ~ n\)</span> 的排列 <span class="math inline">\(P\)</span> 和参数 <span class="math inline">\(K\)</span> ，每次可以进行如下操作：</p>
<ul>
<li>选择两个下标 <span class="math inline">\(i, j\)</span> 满足 <span class="math inline">\(1 \le i &lt; j \le n \land j - i \ge K \land |P_i - P_j| = 1\)</span> ，交换 <span class="math inline">\(P_i\)</span> 和 <span class="math inline">\(P_j\)</span> 。</li>
</ul>
<p>求进行若干次操作后可以得到的字典序最小的排列。</p>
<p>时间复杂度：<span class="math inline">\(O(n \log)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>不妨设 <span class="math inline">\(Q\)</span> 为 <span class="math inline">\(P\)</span> 的逆，在 <span class="math inline">\(Q\)</span> 上考虑这个问题，那么每次操作等价于：</p>
<ul>
<li>选择下标 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(1 \le i &lt; n \land |Q_i - Q_{i+1}| \ge K\)</span> ，交换 <span class="math inline">\(Q_i\)</span> 和 <span class="math inline">\(Q_{i+1}\)</span> 。</li>
</ul>
<p>也就是交换相邻的差不小于 <span class="math inline">\(K\)</span> 的两个位置，那么可以发现对于 <span class="math inline">\(i &lt; j \land |Q_i - Q_j| &lt; K\)</span> ，<span class="math inline">\(Q_i\)</span> 始终会在 <span class="math inline">\(Q_j\)</span> 左边。也就是说如果把这样的关系连边 <span class="math inline">\(i -&gt; j\)</span> ，那么最终可以得到的排列 <span class="math inline">\(Q\)</span> 一定是图的一个拓扑序。也可以知道图的拓扑序一定对应一个可以得到的排列 <span class="math inline">\(Q\)</span> 。</p>
<p>目标是要最小化 <span class="math inline">\(P\)</span> 的字典序，这是否等价于最小化 <span class="math inline">\(Q\)</span> 的字典序呢？</p>
<h3 id="字典拓扑原理">字典拓扑原理</h3>
<p><strong>对于任意 DAG 的拓扑序 <span class="math inline">\(P\)</span> 以及其逆 <span class="math inline">\(Q\)</span> ，<span class="math inline">\(P\)</span> 是字典序最大的当且仅当 <span class="math inline">\(Q\)</span> 是字典序最大的。</strong></p>
<p>记 <span class="math inline">\(\mathrm{rev}P\)</span> 表示排列 <span class="math inline">\(P\)</span> 的翻转。同样条件下，不难得到以下推论；</p>
<ul>
<li><span class="math inline">\(P\)</span> 是字典序最小的当且仅当 <span class="math inline">\(\mathrm{rev}Q\)</span> 是字典序最大的。</li>
<li><span class="math inline">\(\mathrm{rev}P\)</span> 是字典序最大的当且仅当 <span class="math inline">\(Q\)</span> 是字典序最小的。</li>
<li><span class="math inline">\(\mathrm{rev}P\)</span> 是字典序最小的当且仅当 <span class="math inline">\(\mathrm{rev}Q\)</span> 是字典序最小的。</li>
</ul>
<h3 id="end">End</h3>
<p>于是乎只需要最大化 <span class="math inline">\(\mathrm{rev}Q\)</span> 的字典序，拓扑序的 <span class="math inline">\(\mathrm{rev}\)</span> 就是图把边翻转后的拓扑序。</p>
<p>可是注意到直接连边的话，边数是 <span class="math inline">\(O(n^2)\)</span> 的，但是由于对于这张图我们只关注其可能的拓扑序，许多边都是没有必要的。据此可以用线段树找到每个点必要的出边，细节略去。</p>

</details>
<hr />
<h2 id="keoj199-爱乐之城">keoj199 爱乐之城</h2>
<p>对于正整数 <span class="math inline">\(x\)</span> 定义</p>
<p><span class="math display">\[f(x) = \sum_{i=1}^x \sum_{j=1}^x [i \bot j] ij\]</span></p>
<p><span class="math display">\[g(x) = \sum_{i=1}^x \sum_{j=1}^x \mu (ij)\]</span></p>
<p>对于数集（严格定义，不允许重复元素） <span class="math inline">\(S\)</span> 定义</p>
<p><span class="math display">\[h(S) = \sum_{T \subset S} g(\gcd T) \prod_{x \in T} f(x)\]</span></p>
<p>要求维护数集 <span class="math inline">\(S\)</span> ，支持在线加入元素和查询 <span class="math inline">\(h(S)\)</span> ，数的大小不超过 <span class="math inline">\(n\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>考虑 <span class="math inline">\(f, g\)</span> 的逆向差分，有：</p>
<p><span class="math display">\[\Delta f(x) = f(x) - f(x - 1) = 2 (\sum_{i=1}^x [i \bot x] ix) - [x = 1]\]</span></p>
<p><span class="math display">\[\Delta g(x) = g(x) - g(x - 1) = 2 (\sum_{i=1}^x \mu (ix)) - [x = 1]\]</span></p>
<p>设 <span class="math inline">\(f_0(x) = \sum_{i=1}^x [i \bot x] ix\)</span> 以及 <span class="math inline">\(g_0(x) = \sum_{i=1}^x \mu (ix)\)</span> ，这两个函数都是可以莫比乌斯反演预处理的，因为 <span class="math inline">\(\sum\)</span> 内有值的条件都是 <span class="math inline">\([i \bot x]\)</span> ，具体过程略去。通过预处理这两个函数就可以进一步得到 <span class="math inline">\(f, g\)</span> 的所有取值。</p>
<p>然后考虑维护答案，简单的想法是对于每个 gcd 维护一个函数，然而这样问题仍然会很困难，这里需要一步转换，设 <span class="math inline">\(\delta\)</span> 是 <span class="math inline">\(g\)</span> 的狄利克雷卷积逆，那么有</p>
<p><span class="math display">\[h(S) = \sum_{T \subset S} (\sum_{d | \gcd T} \delta(d)) \prod_{x \in T} f(x)\]</span></p>
<p>整理得到</p>
<p><span class="math display">\[h(S) = \sum_{d=1}^n \delta(d) \sum_{T \subset S} (\prod_{x \in T} f(x) [d | x]) = \sum_{d=1}^n \delta(d) \sigma(d) \]</span></p>
<p>而对于每个 <span class="math inline">\(d\)</span> 维护 <span class="math inline">\(\sigma(d)\)</span> 是很简单的。</p>

</details>
<hr />
<h2 id="lg6292-区间本质不同子串个数">lg6292 区间本质不同子串个数</h2>
<p>如题，串长为 <span class="math inline">\(n\)</span> ，询问数为 <span class="math inline">\(q\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>建 SAM ，离线，扫描线，树链剖分，前缀覆盖，栈，略。</p>

</details>
<hr />
<h2 id="th1682-c">th1682-c ????</h2>
<p>咕咕咕。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>咕咕咕。</p>

</details>
<hr />
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title>Green Hackenbush</title>
    <url>/2020/08/01/Green-Hackenbush/</url>
    <content><![CDATA[<p>最近看到一个有意思的博弈问题。</p>
<p>对于一张无向连通图（不一定是简单图），规定一个点为根，两个玩家轮流操作，每次可以删掉根可以到达的一条边，不能操作者输。</p>
<p>这类博弈即 Green Hackenbush 。</p>
<a id="more"></a>
<h2 id="树">树</h2>
<p>从简单情况入手，对一棵有根树做 Green Hackenbush ，如何得到一棵树的 SG 值？</p>
<p>首先，如果树的点数恰为 1 ，SG 值显然为 0 。</p>
<p>如果根的度数恰为 1 ，设与根相连的点为 <span class="math inline">\(u\)</span> ，设 <span class="math inline">\(u\)</span> 的子树对应的 SG 值为 <span class="math inline">\(k\)</span> ，不难发现原树的 SG 值即 <span class="math inline">\(k+1\)</span> 。</p>
<p>如果根的度数大于 1 ，那么可以把根“分裂”，把原树拆成一个森林，每个森林的根的度数都恰好为 1 。容易发现这个森林与原树等价，那么应用 SG 定理，原树的 SG 值就是每个子树的 SG 值加一的异或和。</p>
<h2 id="图">图</h2>
<p>对于一般图的情况如何处理？</p>
<p>有一个定理，把图缩成边双树，然后对于一个有 <span class="math inline">\(k\)</span> 条边的边双，在对应节点上挂 <span class="math inline">\(k\)</span> 个点（其实也可以挂 <span class="math inline">\(k \bmod 2\)</span> 个点），这样得到的一棵树的 SG 值与原图相同。</p>
<h2 id="证明">证明</h2>
<p>这篇博客写得好水啊，补个证明算了。</p>
<h3 id="融合">融合</h3>
<p>等价于把所有形如 <span class="math inline">\((y, z)\)</span> 的边替换为 <span class="math inline">\((x, z)\)</span> 然后删去点 <span class="math inline">\(y\)</span> ，然后如果 <span class="math inline">\(y\)</span> 是根，把根换成 <span class="math inline">\(x\)</span> 。</p>
<p>这样的操作称为在图中融合两个点 <span class="math inline">\(x, y\)</span> 。</p>
<h3 id="引理-1">引理 1</h3>
<p>对于一张只有恰好一个点数至少为 2 的环且该环包含根的图，融合该环上任意两点，游戏的值不变。</p>
<details class="note primary"><summary><p>证明</p>
</summary>
<p>咕咕咕。</p>

</details>
<h3 id="定理-1">定理 1</h3>
<p>对于仙人掌图，融合同一环上的任意两点，游戏的值不变。</p>
<details class="note primary"><summary><p>证明</p>
</summary>
<p>考虑边双树，从叶子开始逐个考虑，对于一个点数至少为 2 的环，考虑其子树，根据引理 1 该环上任意两点是可以融合的。把该环上所有点融合继续归纳，可以证明所有环都是可以把任意两点融合的。</p>

</details>
<h3 id="定理-2">定理 2</h3>
<p>对于任意图，融合同一边双联通分量上的任意两点，游戏的值不变。</p>
<details class="note primary"><summary><p>证明</p>
</summary>
<p>证明一个等价的命题，任意图一定满足两个条件之一：</p>
<ol type="1">
<li>没有边双联通分量</li>
<li>存在一对在同一个边双联通分量的点，融合后游戏的值不变。</li>
</ol>
<p>（只要证明存在性是因为，如果一个点对是不满足定理的，那么融合其他点后该点对始终不会满足定理，因此只要把满足定理的点对不断融合即可）</p>
<p>对图的边数应用数学归纳。边数为 <span class="math inline">\(0\)</span> 的时候显然满足条件 1 。假设边数不超过 <span class="math inline">\(n\)</span> 时都成立，考虑一个边数为 <span class="math inline">\(n+1\)</span> 的图。分类讨论。</p>
<h4 id="情况-1">情况 1</h4>
<p>没有边双联通分量，满足条件 1 。</p>
<h4 id="情况-2">情况 2</h4>
<p>存在两个点 <span class="math inline">\(x, y\)</span> ，它们之间有至少三条边不重复的路径。</p>
<p>这时候融合 <span class="math inline">\(x, y\)</span> ，游戏的值是一定不变的。设原图为 <span class="math inline">\(G\)</span> ，融合后的图为 <span class="math inline">\(H\)</span> ，考虑游戏 <span class="math inline">\(G + H\)</span> 。先手进行一次操作后，后手在另一张图上进行同样的操作，注意到一次操作至少删掉一条边，因此双方操作后两张图的边数都不超过 <span class="math inline">\(n\)</span> 。这个时候可以把两个图不断进行融合，可以发现融合后两张图完全一致，因此 <span class="math inline">\(G + H\)</span> 是一个值为 <span class="math inline">\(0\)</span> 的游戏，这意味着 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(H\)</span> 相等，融合不影响游戏的值，满足条件 2 。</p>
<p>需要注意的是，由于 <span class="math inline">\(x, y\)</span> 之间有至少三条边不重复的路径，在双方操作后 <span class="math inline">\(x, y\)</span> 之间有至少两条边不重复的路径，因此总是可以融合的。</p>
<h4 id="情况-3">情况 3</h4>
<p>如果图既不满足情况 1 也不情况 2 ，这样的图一定是仙人掌图。应用定理 1 即可，满足条件 2 。</p>

</details>
<h2 id="参考文献">参考文献</h2>
<p>论文有点看吐了，咕咕咕的地方到时候再补吧。</p>
<p><a href="https://yhx-12243.github.io/OI-transit/records/hdu3094%3Bpoj3710%3Bsoj366%3Bac2667%3Bagc017D.html">yhx-12243 的博客</a></p>
<p><a href="http://www.math.uchicago.edu/~may/VIGRE/VIGRE2006/PAPERS/Bartlett.pdf">A Short Guide to Hackenbush</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>好题题解整理（二）</title>
    <url>/2020/07/28/%E5%A5%BD%E9%A2%98%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>没有摘要。</p>
<a id="more"></a>
<hr />
<h2 id="loj576-libreoj-noi-round-2签到游戏">loj576 「LibreOJ NOI Round #2」签到游戏</h2>
<p>有一个长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{B\}\)</span> ，每次可以选一个区间 <span class="math inline">\([l, r]\)</span> ，代价是 <span class="math inline">\(B\)</span> 在该区间的 <span class="math inline">\(\gcd\)</span> ，得到一个方程 <span class="math inline">\(\sum_{i=l}^k x_i = K\)</span> ，要求花费最小的代价得到 <span class="math inline">\(n\)</span> 个线性无关的方程。</p>
<p><span class="math inline">\(q\)</span> 次询问和修改，每次修改会修改 <span class="math inline">\(B\)</span> 的一个位置的值。</p>
<p>时间复杂度：<span class="math inline">\(O(n\log+q\log^2)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>存在最优解选择的每个区间满足 <span class="math inline">\(l=1 \lor r=n\)</span> 且存在 <span class="math inline">\([1, n]\)</span> 。</strong></p>
<p>设 <span class="math inline">\(y_i = \sum_{j=1}^i x_j\)</span> ，那么选择区间 <span class="math inline">\([l, r]\)</span> 实质上是选择方程 <span class="math inline">\(y_r - y_{l-1} = K\)</span> ，注意有 <span class="math inline">\(y_0 = 0\)</span> 。</p>
<p>转换为图论问题，每个 <span class="math inline">\(y_i\)</span> 是一个节点，一个方程是一条边，方程线性无关等价于图无环<del>，那么这个问题本质上是求最小生成树</del>。</p>
<p>在这个图论问题的基础上该引理是很自然的。定 <span class="math inline">\(0\)</span> 为树根，把边定向，从父亲指向儿子，那么对于一条边 <span class="math inline">\(u \rightarrow v\)</span> ，若 <span class="math inline">\(u &lt; v\)</span> 则把 <span class="math inline">\((u, v)\)</span> 换成 <span class="math inline">\((0, v)\)</span> ，否则换成 <span class="math inline">\((u, 0)\)</span> 。容易发现每条边的代价不增，并且新图仍然是一颗树。此时每条边必然连向 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(n\)</span> ，并且必然有边 <span class="math inline">\((0, n)\)</span> 。</p>
<h3 id="引理-2">引理 2</h3>
<p><strong>存在最优解满足：存在参数 <span class="math inline">\(p\)</span> 使得选择的区间由 <span class="math inline">\([1, n]\)</span> ，<span class="math inline">\([1, i] (p \le i &lt; n)\)</span> 和 <span class="math inline">\([j, n] (1 &lt; j \le p)\)</span> 组成。</strong></p>
<p>根据引理 1 ，由于选了 <span class="math inline">\([1, n]\)</span> ，选前缀 <span class="math inline">\([1, i]\)</span> 和选后缀 <span class="math inline">\([i + 1, n]\)</span> 是等价的。那么最优解显然就是在每个 <span class="math inline">\([1, i]\)</span> 和 <span class="math inline">\([i+1, n]\)</span> 中选代价较小的一个，前者随 <span class="math inline">\(i\)</span> 单调不增，后者随 <span class="math inline">\(i\)</span> 单调不减。那么选前者的必然是一段后缀 <span class="math inline">\(i\)</span> ，选后者的必然是一段前缀 <span class="math inline">\(i\)</span> 。</p>
<h3 id="正题">正题</h3>
<p>由引理 2 ，可以二分参数 <span class="math inline">\(p\)</span> ，比较 <span class="math inline">\([1, p]\)</span> 和 <span class="math inline">\([p, n]\)</span> 的 gcd 大小进行判定。然后根据不同前后缀 gcd 的数量是 <span class="math inline">\(O(\log)\)</span> 的，求答案枚举不同的 gcd 算贡献数量即可。</p>
<p>用线段树维护序列 <span class="math inline">\(B\)</span> ，需要支持 <span class="math inline">\(O(\log)\)</span> 的区间 gcd 查询或者把二分放在线段树上。具体细节不在讨论范围内。</p>

</details>
<hr />
<h2 id="zr1390-五一省选集训day1a">zr1390 【五一省选集训day1】a</h2>
<p>给定 <span class="math inline">\(k\)</span> 次多项式 <span class="math inline">\(f(x) = \sum_{i=0}^k a_i x^i\)</span> ，求多项式快速幂 <span class="math inline">\(f(x)^n \bmod x^m\)</span> 的各项系数。</p>
<p>时间复杂度：<span class="math inline">\(O(mk)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>这应该算一个经典套路？</p>
<p>设 <span class="math inline">\(P(x) = f(x)^n = \sum_{i\ge{0}} b_i x^i\)</span> ，对等式 <span class="math inline">\(P(x) f(x) = f(x)^{n+1}\)</span> 两边求导，整理得到</p>
<p><span class="math display">\[P&#39;(x) f(x) = n P(x) f&#39;(x)\]</span></p>
<p>比较等式第 <span class="math inline">\(r\)</span> 项系数，有</p>
<p><span class="math display">\[\sum_{i=0}^k a_i b_{r-i+1} (r-i+1) = n \sum_{i=1}^k a_i i b_{r-i+1}\]</span></p>
<p>上式就是 <span class="math inline">\(b\)</span> 的递推式，<span class="math inline">\(O(mk)\)</span> 递推出所有项即可。</p>

</details>
<hr />
<h2 id="th1691-a-最短路">th1691-a 最短路</h2>
<p><span class="math inline">\(n\)</span> 个点的简单有向图，点有正权，找一个权值和最小的导出子图满足 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 相互可达，求最小权值和。</p>
<p>时间复杂度：<span class="math inline">\(O(n^3)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>对于一个合法的导出子图，把任意一条从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的简单路径称为主路径。由于要满足 <span class="math inline">\(n\)</span> 可以到达 <span class="math inline">\(1\)</span> ，主路径上会挂一些往回走的路径，称为回溯路径，如下图所示：</p>
<p><img src="/images/2.png" /></p>
<p>底下的直线是主路径，上面的弧线是回溯路径，称一个回溯路径的起点和终点分别为 A 类点和 B 类点，可以发现存在最优解主路径上只考虑 <span class="math inline">\(n\)</span> 以外的这两类点的话，它们交替出现。</p>
<p>据此可以设计 DP ，状态内只需要考虑主路径最后两个特殊点，转移就是最短路的松弛。两种状态 <span class="math inline">\(f_{i,j}, g_{i,j}\)</span> 的意义如下两图：</p>
<p><img src="/images/3.png" /></p>
<p><img src="/images/4.png" /></p>

</details>
<hr />
<h2 id="bz2560-串珠子">bz2560 串珠子</h2>
<p>有 <span class="math inline">\(n\)</span> 个点的无向图，第 <span class="math inline">\(i\)</span> 个点和第 <span class="math inline">\(j\)</span> 个点之间有 <span class="math inline">\(c_{i,j}\)</span> 条无向边，求简单连通子图数目。</p>
<p>时间复杂度：<span class="math inline">\(O(2^n n^2)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>设集合幂级数 <span class="math inline">\(f_S\)</span> 表示只点集 <span class="math inline">\(S\)</span> 的导出子图的连通子图数目。连通的限制很强，考虑忽略限制得到类似的集合幂级数 <span class="math inline">\(g\)</span> ，然后反演。对于 <span class="math inline">\(g_S (S \neq \varnothing)\)</span>，枚举任意一个点所在连通块，有</p>
<p><span class="math display">\[\forall x \in S, g_S = \sum_{x\in{T} \land T \subset S} f_T g_{S \setminus T}\]</span></p>
<p>从这个式子直接做就是 <span class="math inline">\(O(3^n)\)</span> 的，但是注意到这很能和子集卷积扯上关系，如果把每个上式枚举每个 <span class="math inline">\(x\)</span> 累加，可以得到</p>
<p><span class="math display">\[|S| g_S = \sum_{T \subset S} |T| f_T g_{S \setminus T}\]</span></p>
<p>另设两个集合幂级数 <span class="math inline">\(F_S = |S| f_S\)</span> 和 <span class="math inline">\(G_S = |S| g_S\)</span> ，上式即 <span class="math inline">\(G = F \times g\)</span> ，于是</p>
<p><span class="math display">\[F = \frac{G}{g}\]</span></p>
<p>利用集合幂级数的占位多项式科技即可。</p>
<p>事实上 <span class="math inline">\(F\)</span> 就是 <span class="math inline">\(f\)</span> 这个集合幂级数求导的结果，上式两边积分，还可以得到 <span class="math inline">\(f = 1 + \ln g\)</span> ，加 <span class="math inline">\(1\)</span> 是因为求导再积分损失了常数项。</p>
<p>从另一个角度考虑，反演那一步改成枚举实际连通块数量，就有 <span class="math inline">\(g = \sum_{i\ge{0}} \frac{(f-1)^i}{i!} = e^{f-1}\)</span> ，减一是因为实际连通块不能算空的。</p>

</details>
<hr />
<h2 id="th1691-c-集合操作">th1691-c 集合操作</h2>
<p>给定一个长为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(n\)</span> 个下标集合，第 <span class="math inline">\(i\)</span> 个集合 <span class="math inline">\(S_i\)</span> 初始只有一个元素 <span class="math inline">\(i\)</span> 。</p>
<p>定义 <span class="math inline">\(F(S, i) = \sum_{j\in{S}} [a_i = a_j]\)</span> ，以及 <span class="math inline">\(G(S, k) = \sum_{i\in{S}} \sum_{j\in{S}} [F(S, i) + F(S, j) \le k]\)</span> ，要求维护两种操作（一共 <span class="math inline">\(n\)</span> 次）：</p>
<ol type="1">
<li>给定 <span class="math inline">\(i, j\)</span> 令 <span class="math inline">\(S_i \leftarrow S_i \cup S_j, S_j \leftarrow \varnothing\)</span> 。</li>
<li>给定 <span class="math inline">\(i, l, r, k\)</span> 求 <span class="math inline">\(G(S_i \cap [l, r], k)\)</span> 。</li>
</ol>
<p>时间复杂度：<span class="math inline">\(O(n^{\frac{5}{3}})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<h3 id="问题-1">问题 1</h3>
<p><strong>只有一个不变的下标集合 <span class="math inline">\(S\)</span> ，每次询问给定 <span class="math inline">\(l, r, k\)</span> 求 <span class="math inline">\(G(S \cap [l, r], k)\)</span> 。</strong></p>
<p>对于一个询问，设 <span class="math inline">\(T = S \cap [l, r]\)</span> ，构造序列 <span class="math inline">\(b\)</span> 满足 <span class="math inline">\(b_i = \sum_{j\in{T}} [a_j=i]\)</span> ，那么不难发现答案实际上是 <span class="math inline">\(\sum_{i} \sum_{j} b_i b_j [b_i + b_j \le k]\)</span> 。</p>
<p>注意到 <span class="math inline">\(\sum_i b_i = O(n)\)</span> ，因此 <span class="math inline">\(b\)</span> 不同的取值只有 <span class="math inline">\(O(\sqrt{n})\)</span> 种，把相同的取值放一起考虑，双指针一下就可以 <span class="math inline">\(O(\sqrt{n})\)</span> 处理。那么问题转换为怎么维护这个 <span class="math inline">\(b\)</span> ，<span class="math inline">\(T\)</span> 中每个元素对 <span class="math inline">\(b\)</span> 的影响是 <span class="math inline">\(O(1)\)</span> 的，因此使用莫队处理询问即可。</p>
<h3 id="问题-2">问题 2</h3>
<p><strong>只有一个下标集合 <span class="math inline">\(S\)</span> ，每次询问给定 <span class="math inline">\(l, r, k\)</span> 求 <span class="math inline">\(G(S \cap [l, r], k)\)</span> ，每次修改在 <span class="math inline">\(S\)</span> 中添加一个新的下标 <span class="math inline">\(i\)</span> 。</strong></p>
<p>在问题 1 的基础上要支持插入一个元素。不难想到带修莫队，每次插入就是时间轴的一个移动，容易发现时间轴的一次移动对 <span class="math inline">\(b\)</span> 的影响也是 <span class="math inline">\(O(1)\)</span> 的。</p>
<h3 id="问题-3">问题 3</h3>
<p><strong>有若干不变的下标集合 <span class="math inline">\(S_i\)</span> ，每次询问给定 <span class="math inline">\(i, l, r, k\)</span> 求 <span class="math inline">\(G(S_i \cap [l, r], k)\)</span> 。</strong></p>
<p>沿用问题 1 的解决思路，对每个集合单独开一个莫队显然不行，注意到 <span class="math inline">\(\sum_i |S_i| = O(n)\)</span> ，不妨考虑阈值分块，称 <span class="math inline">\(|S_i| \le n^{\frac{2}{3}}\)</span> 的为小集合，反之为大集合。对于小集合的每个询问，线性地求出答案，对于大集合沿用莫队，由于大集合只有 <span class="math inline">\(O(\sqrt[3]{n})\)</span> 个，询问总数是 <span class="math inline">\(O(n)\)</span> ，可以证明莫队总复杂度是 <span class="math inline">\(O(n^{\frac{5}{3}})\)</span> 而不是看上去的 <span class="math inline">\(O(n^{\frac{11}{6}})\)</span> 。复杂度分析时应该注意普通莫队的复杂度事实上是 <span class="math inline">\(O(n\sqrt{q})\)</span> ，而且 <span class="math inline">\(\sqrt{q}\)</span> 是个凹函数。</p>
<h3 id="问题-4">问题 4</h3>
<p><strong>有若干下标集合 <span class="math inline">\(S_i\)</span> ，每次询问给定 <span class="math inline">\(i, l, r, k\)</span> 求 <span class="math inline">\(G(S_i \cap [l, r], k)\)</span> ，每次修改在 <span class="math inline">\(S_i\)</span> 中添加一个新的下标 <span class="math inline">\(j\)</span> 。</strong></p>
<p>在问题 3 的基础上会多一些情况。小集合可能变成大集合，可能前一段时间暴力算后一段时间莫队，不影响复杂度。大集合添加元素时，沿用问题 2 的思路，应该使用带修莫队。注意到询问总数是 <span class="math inline">\(O(n)\)</span> 的，因此所有大集合的时间轴长度和是 <span class="math inline">\(O(n)\)</span> 的。这里的带修莫队可能会比较复杂，但不会增加复杂度。一个可行的做法是每次时间轴的长度达到 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 时就把莫队的答案跑出来，然后把时间轴清理掉。这个复杂度和问题 3 的复杂度分析一致。</p>
<h3 id="正题">正题</h3>
<p>好了，通过层层递进已经得到了弱化问题的解法。那么对于完整的问题，无非就是把插入元素换成了合并集合，容易想到启发式合并，那么本质上仍然是插入。但是插入的次数并不是 <span class="math inline">\(O(n)\)</span> 的，它带个 <span class="math inline">\(\log\)</span> 。乍一看这个复杂度分析爆了，但实际上是不会变的，因为集合的大小和始终是 <span class="math inline">\(O(n)\)</span> 的，时间轴的清理次数仍然是 <span class="math inline">\(O(\sqrt[3]{n})\)</span> 而并非看上去的 <span class="math inline">\(O(\sqrt[3]{n}\log)\)</span> 。</p>
<p><del>不愧是 lxl 出的数据结构题。</del></p>

</details>
<hr />
<h2 id="uoj21-ur-1缩进优化">uoj21 【UR #1】缩进优化</h2>
<p>一份 <span class="math inline">\(n\)</span> 行的代码，第 <span class="math inline">\(i\)</span> 行有 <span class="math inline">\(a_i\)</span> (<span class="math inline">\(a_i \le M\)</span>) 个空格作为缩进，要求确定一个 Tab 宽度 <span class="math inline">\(x\)</span> 使得每一行尽量把空格替换成 Tab 后字符总数最小。</p>
<p>时间复杂度；<span class="math inline">\(O(n+M\log{M})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>降智好题？</p>
<p>不难发现问题等价于最大化 <span class="math inline">\(\sum_{i=1}^n \lfloor \frac{a_i}{x} \rfloor (x - 1)\)</span> 。碰到这个整除第一反应可能是整除分块，于是可以得到一个 <span class="math inline">\(O(M+n\sqrt{M})\)</span> 的做法。</p>
<p>然而不妨枚举答案 <span class="math inline">\(x\)</span> ，可以发现整除的值的上界是 <span class="math inline">\(\lfloor \frac{M}{x} \rfloor\)</span> ，此时可以枚举每个可能的值算贡献，复杂度是调和级数。</p>
<p>这告诉我们，当对多个数分别进行整除分块算贡献的时候，可以结合到一起转换为调和级数的复杂度。</p>

</details>
<hr />
<h2 id="loj6400-yww-与连通块计数">loj6400 yww 与连通块计数</h2>
<p>给定一颗 <span class="math inline">\(n\)</span> 个节点的树，每个点有点权，称一个连通块是合法的当且仅当其点权的 gcd 和 lcm 分别为 <span class="math inline">\(P, Q\)</span> ，求合法连通块数目。所有点权没有平方因子，且质因子不超过 50 。</p>
<p>时间复杂度；<span class="math inline">\(O(2^w n)\)</span> ，其中 <span class="math inline">\(w\)</span> 是点权的质因子数目。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>由于点权没有平方因子，事实上可以把点权看成一个集合，那么一个连通块合法的条件可以转换为点权交为空集，点权并为全集。把集合看成 <span class="math inline">\(w\)</span> 位二进制数，这个条件也等价于每个二进制位在连通块中同时存在点权为 0 的点和点权为 1 的点。</p>
<p>到这里做法其实很多。一个容易理解的做法是子集容斥，注意到一个二进制位同时存在 0 和 1 是较难计算的，但是其否定形式，一个二进制位的数全部相同，这个条件是很好处理的。设 <span class="math inline">\(f_S\)</span> 表示钦定 <span class="math inline">\(S\)</span> 二进制位为 1 的位置必须满足所有点权全部相同的连通块数目。那么答案就是</p>
<p><span class="math display">\[\sum_{S} f_S (-1)^{|S|}\]</span></p>
<p>而每次计算一个 <span class="math inline">\(f_S\)</span> 显然可以只需要考虑每个点权在 <span class="math inline">\(S\)</span> 上的取值，那么在这种意义下一个连通块是合法的当且仅当所有点权相同。那么只把相同点权的两个相邻点连边，问题转换为求一个森林的连通块数目，这就很朴素了，线性 DP 即可。</p>

</details>
<hr />
<h2 id="loj6399-yww-与魔法阵">loj6399 yww 与魔法阵</h2>
<p>给定长 <span class="math inline">\(n\)</span> 的一个 01 构成的三角形，求一个子三角形满足边界位置都是 0 且面积最大。这里三角形就长这样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">00</span><br><span class="line">000</span><br><span class="line">0000</span><br></pre></td></tr></table></figure>
<p>时间复杂度；<span class="math inline">\(O(n^2)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>子三角形的数目是 <span class="math inline">\(O(n^3)\)</span> 的，显然无法显式地一一枚举<del>（甚至不能隐式地一一枚举）</del>。事实上由于只是需要最大化面积没有必要考虑到每个子三角形。考虑增量法，对于当前的最优面积 <span class="math inline">\(S\)</span> ，只需要考虑面积超过 <span class="math inline">\(S\)</span> 的子三角形。</p>
<p>从下到上枚举，枚举每一个点作为子三角形的最上方顶点考虑更新答案。只需要判断是否存在子三角形比当前面积大。经过一些预处理后可以 <span class="math inline">\(O(1)\)</span> 检查。预处理的东西有点多，这里略去。</p>
<p>显然答案的增长次数是 <span class="math inline">\(O(n)\)</span> 的。</p>

</details>
<hr />
<h2 id="cf1349d-slime-and-biscuits">cf1349d Slime and Biscuits</h2>
<p>有 <span class="math inline">\(n\)</span> 个人，第 <span class="math inline">\(i\)</span> 个人一开始有 <span class="math inline">\(a_i\)</span> 个石头（<span class="math inline">\(\sum_{i=1}^n a_i = m\)</span>）。每一轮依次执行如下两个操作直到有一个人拥有 <span class="math inline">\(m\)</span> 个石头：</p>
<blockquote>
<p>在 <span class="math inline">\(m\)</span> 个石头中随机选择一个，设该石头的所有者为 <span class="math inline">\(i\)</span> ，在 <span class="math inline">\(i\)</span> 除外的 <span class="math inline">\(n-1\)</span> 个人中随机选择一个 <span class="math inline">\(j\)</span> ，把该石头从 <span class="math inline">\(i\)</span> 移动到 <span class="math inline">\(j\)</span> 。</p>
</blockquote>
<p>求期望轮数。</p>
<p>时间复杂度：<span class="math inline">\(O(n+m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>若第 <span class="math inline">\(i\)</span> 个人拥有 <span class="math inline">\(m\)</span> 个石头，则称游戏停留于 <span class="math inline">\(i\)</span> 。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个位置对答案的贡献，也就是答案的期望中停留在第 <span class="math inline">\(i\)</span> 个位置的组成部分。严格来讲是一个条件期望，是在停留于 <span class="math inline">\(i\)</span> 的条件下的期望轮数乘上停留于 <span class="math inline">\(i\)</span> 的概率。那么根据 <span class="math inline">\(f\)</span> 的定义容易知道答案即 <span class="math inline">\(\sum_{i=1}^n f_i\)</span> 。</p>
<p>但是直接计算 <span class="math inline">\(f_i\)</span> 是困难的，因为要停留于 <span class="math inline">\(i\)</span> ，最难以处理的限制是停留于 <span class="math inline">\(i\)</span> 之前不能在任何位置停留。不妨忽略该限制，让游戏无休止的进行，设 <span class="math inline">\(g_i\)</span> 表示第一次停留于 <span class="math inline">\(i\)</span> 时的轮数的期望。考虑两者关系，枚举第一次停留的位置 <span class="math inline">\(j\)</span> ，有</p>
<p><span class="math display">\[g_i = \sum_{j=1}^n (f_j + A_{j,i} p_j)\]</span></p>
<p>其中 <span class="math inline">\(p_j\)</span> 表示第一次停留的位置恰好是 <span class="math inline">\(j\)</span> 的概率，<span class="math inline">\(A_{j,i}\)</span> 表示把停留于 <span class="math inline">\(j\)</span> 作为初始状态，到第一次停留于 <span class="math inline">\(i\)</span> 经过的轮数的期望。</p>
<p>考虑计算 <span class="math inline">\(g_i\)</span> ，此时只需要关注第 <span class="math inline">\(i\)</span> 个人拥有的石头，不难发现其他的石头不管在谁手里都是没有区别的，那么 <span class="math inline">\(g_i\)</span> 的值只和 <span class="math inline">\(a_i\)</span> 有关，不妨构造 <span class="math inline">\(h\)</span> 满足 <span class="math inline">\(h_{a_i} = g_i\)</span> ，而计算 <span class="math inline">\(h\)</span> 是很简单的，可以线性消元解出，或者差分后直接递推。</p>
<p>然后考虑计算 <span class="math inline">\(A\)</span> ，不难发现 <span class="math inline">\(i \neq j\)</span> 时有 <span class="math inline">\(A_{j,i} = h_0\)</span> ，反之有 <span class="math inline">\(A_{i,i} = 0\)</span> 。</p>
<p>那么只需要计算出 <span class="math inline">\(p\)</span> 就可以得到 <span class="math inline">\(f\)</span> 了，可惜 <span class="math inline">\(p\)</span> 是很难计算的，但是注意到我们并不需要关注 <span class="math inline">\(f\)</span> 具体的值，只需要知道 <span class="math inline">\(\sum f_i\)</span> ，另外尽管无法求出 <span class="math inline">\(p\)</span> ，但是可以知道有 <span class="math inline">\(\sum p_i = 1\)</span> 。到这里不难想到把上式求和，得到</p>
<p><span class="math display">\[\sum g_i = n \sum f_i + (n - 1) h_0\]</span></p>

</details>
<hr />
<h2 id="bz2688-green-hackenbush">bz2688 Green Hackenbush</h2>
<p>两个人轮流在一棵树上删边，每次删边后不与根联通的子树直接被删去，不能删边的游戏者输。</p>
<p>现有 <span class="math inline">\(n\)</span> 棵树，第 <span class="math inline">\(i\)</span> 棵树是含有 <span class="math inline">\(a_i\)</span> 个节点的二叉树（从 <span class="math inline">\(C_{a_i}\)</span> 个里面随机选一个）。求先手必胜概率。</p>
<p>时间复杂度：<span class="math inline">\(O(n^4)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>如何得到一棵树的 SG 值？</p>
<p>如果根的度数恰为 0 ，SG 值显然为 0 。</p>
<p>如果根的度数恰为 1 ，设与根相连的点为 <span class="math inline">\(u\)</span> ，设 <span class="math inline">\(u\)</span> 的子树对应的 SG 值为 <span class="math inline">\(k\)</span> ，不难发现原树的 SG 值即 <span class="math inline">\(k+1\)</span> 。</p>
<p>如果根的度数大于 1 ，那么可以把根“分裂”，把原树拆成一个森林，每个森林的根的度数都恰好为 1 。容易发现这个森林与原树等价，那么应用 SG 定理，原树的 SG 值就是每个子树的 SG 值加一的异或和。</p>
<p>然后就可以 DP 求解了，设 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(i\)</span> 个节点的二叉树中 SG 值为 <span class="math inline">\(j\)</span> 的概率。然后合并答案就利用 SG 定理和背包合并即可。</p>

</details>
<hr />
<h2 id="cf1067e-random-forest-rank">cf1067e Random Forest Rank</h2>
<p>给定一颗 <span class="math inline">\(n\)</span> 个节点的树，随机生成一个子图，每条边都有 <span class="math inline">\(\frac{1}{2}\)</span> 的概率出现，求该子图的邻接矩阵的秩的期望。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<h3 id="引理-1">引理 1</h3>
<p><strong>一颗树的邻接矩阵的秩就是其最大匹配数的两倍。</strong></p>
<p>咕咕咕。</p>
<h3 id="引理-2">引理 2</h3>
<p><strong>一个森林的邻接矩阵的秩就是其最大匹配数的两倍。</strong></p>
<p>显然如果图有多个连通块，其邻接矩阵的秩就是每个连通块的邻接矩阵的秩的和。那么根据引理 1 不难推广到引理 2 。</p>
<h3 id="正题">正题</h3>
<p>有了引理 2 就能直接 DP 了。首先树的最大匹配基于一个贪心：选一个根，然后每个子树分别匹配，如果有一个儿子是非匹配点，就把当前节点与该节点匹配。森林的话是类似的。朴素的一个 DP 是设 <span class="math inline">\(f_{u,0/1}, g_{u,0/1}\)</span> 什么的，边匹配边计数，但这里有个更简洁巧妙的 DP 设计。</p>
<p>设 <span class="math inline">\(f_u\)</span> 表示在上述贪心过程中 <span class="math inline">\(u\)</span> 与一个儿子匹配的概率，把每个匹配的贡献算在父亲上，不难发现答案就是 <span class="math inline">\(\sum 2f_u\)</span> 。转移计算 <span class="math inline">\(u\)</span> 无法与儿子匹配的概率，此时 <span class="math inline">\(u\)</span> 的每个儿子 <span class="math inline">\(v\)</span> 对“无法匹配”这个事件而言是独立的，有</p>
<p><span class="math display">\[f_u = 1 - \sum_v (\frac{1}{2} + \frac{1}{2} f_v)\]</span></p>

</details>
<hr />
<h2 id="th1693-b-组合数问题">th1693-b 组合数问题</h2>
<p>给定 <span class="math inline">\(n, m\)</span> 求 <span class="math inline">\(\sum_{i=0}^{n}(-1)^{i} \sum_{j=0}^{n} j^{m} \binom{j}{i} (m+i)^{j}\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(n\log m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>式子那么长唬你的，交换求和顺序，原式即</p>
<p><span class="math display">\[\sum_{j=0}^{n} j^{m} \sum_{i=0}^{j} (-1)^{i} \binom{j}{i} (m+i)^{j}\]</span></p>
<p>二项式定理展开后面的幂次，原式即</p>
<p><span class="math display">\[\sum_{j=0}^{n} j^{m} \sum_{k=0}^{j} \binom{j}{k} m^{j-k} \sum_{i=0}^{j} (-1)^{i} \binom{j}{i} i^{k}\]</span></p>
<p>看上去式子变复杂了，问题不大，因为最后一个求和符号里头的式子很友好，看上去很像第二类斯特林数的通项公式：</p>
<p><span class="math display">\[\genfrac\{\}{0pt}{}{k}{j} = \frac{1}{j!} \sum_{i=0}^j (-1)^{j-i} \binom{j}{i} i^k\]</span></p>
<p>代入，原式等于</p>
<p><span class="math display">\[\sum_{j=0}^{n} j^{m} \sum_{k=0}^{j} \binom{j}{k} m^{j-k} \genfrac\{\}{0pt}{}{k}{j} j! (-1)^j\]</span></p>
<p>然后会发现 <span class="math inline">\(k\)</span> 枚举了个寂寞，<span class="math inline">\(k &lt; j\)</span> 时这个斯特林数都没有值，直接令 <span class="math inline">\(k=j\)</span> ，于是原式等于</p>
<p><span class="math display">\[\sum_{j=0}^{n} j^{m} j! (-1)^j\]</span></p>
<p>虽然不难，但还是很妙，原式后面 <span class="math inline">\((m+i)^j\)</span> 这个幂次替换成任意 <span class="math inline">\((K+i)^j\)</span> 都不会影响答案，<span class="math inline">\(m\)</span> 的贡献仅仅在于 <span class="math inline">\(j^m\)</span> 。一旦发现这个巧妙的性质问题就很明了了。</p>

</details>
<hr />
<h2 id="th1693-c-三角形">th1693-c 三角形</h2>
<p>给定一个点数 <span class="math inline">\(N \times M\)</span> 的网格图，求有多少定点都在格点上的三角形，满足三角形区域内（包括边上）只有恰好 3 个格点。</p>
<p>时间复杂度：<span class="math inline">\(O(N^{\frac{2}{3}} + M^{\frac{2}{3}})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>要统计的三角形可以分为以下两类：</p>
<p><img src="/images/5.png" /></p>
<h3 id="pick-定理">Pick 定理</h3>
<p><strong>一个顶点都在个点上的多边形的面积恰好为 <span class="math inline">\(a + \frac{b}{2} - 1\)</span> ，其中 <span class="math inline">\(a, b\)</span> 分别是多边形内部的格点数和边上的格点数。</strong></p>
<h3 id="引理-1">引理 1</h3>
<p><strong>一个顶点在格点上的三角形只在区域内有恰好三个个点当且仅当其面积为 <span class="math inline">\(\frac{1}{2}\)</span> 。</strong></p>
<p>必要性：直接套用 pick 定理，有 <span class="math inline">\(a=0,b=3\)</span> ，面积就是 <span class="math inline">\(\frac{1}{2}\)</span> 。</p>
<p>充分性：还是套用 pick 定理，有 <span class="math inline">\(a + \frac{b}{2} - 1 = \frac{1}{2} \land a \ge 0 \land b \ge 3\)</span> ，容易解出恰有 <span class="math inline">\(a=0,b=3\)</span> 。</p>
<h3 id="引理-2">引理 2</h3>
<p><strong>第二类三角形面积始终不为二分之一。</strong></p>
<p>不妨设上图的左下右上坐标分别为 <span class="math inline">\((0, 0), (n, m)\)</span> ，另外两个顶点坐标分别为 <span class="math inline">\((a, m), (n, b)\)</span> ，那么三角形面积即 <span class="math inline">\(\frac{nm-ab}{2}\)</span> 。应用反证法，若面积恰为二分之一则 <span class="math inline">\(ab=nm-1\)</span> 。由于 <span class="math inline">\(ab &lt; am &lt; nm\)</span> ，那么 <span class="math inline">\(ab \le nm - 2\)</span> ，矛盾。</p>
<h3 id="引理-3">引理 3</h3>
<p><strong>在确定对角线的前提下，使得第一类三角形面积恰为二分之一的合法的第三个顶点不超过一个，并且当且仅当对角线上没有其他格点时存在一个合法第三顶点。</strong></p>
<p>不妨设上图的左下右上坐标分别为 <span class="math inline">\((0, 0), (n, m)\)</span> ，第三个顶点坐标 <span class="math inline">\((a, b)\)</span> ，那么有 <span class="math inline">\(am - bn = 1\)</span> ，根据不定方程那一套理论，方程有解当且仅当 <span class="math inline">\(n \bot m\)</span> ，并且对于任意一组解 <span class="math inline">\((a_0, b_0)\)</span> ，所有解都可以表示为 <span class="math inline">\((a_0 + kn, b_0 + km)\)</span> 。</p>
<p><del>接下来证明 <span class="math inline">\(n \bot m\)</span> 时恰有一组合法解。</del>这部分咕了。</p>
<h3 id="正题">正题</h3>
<p>需要注意第一类三角形有一些对称的情况，只考虑上图中的一种然后乘 4 即可。那么根据三个引理，答案就是</p>
<p><span class="math display">\[4 \sum_{i=1}^N \sum_{j=1}^M (N - i) (M - j) [i \bot j]\]</span></p>
<p>到这里终于转换为数论问题，看到互质无脑莫反，得到原式等于</p>
<p><span class="math display">\[4 \sum_{k\ge{1}} \mu(k) \sum_{i=1}^{N/k} \sum_{j=1}^{M/k} (N - ik) (M - jk)\]</span></p>
<p>注意到 <span class="math inline">\((\lfloor \frac{N}{k} \rfloor, \lfloor \frac{M}{k} \rfloor)\)</span> 的值只有 <span class="math inline">\(O(\sqrt{N} + \sqrt{M})\)</span> 种，枚举每一种算答案，不难发现只要杜教筛筛出 <span class="math inline">\(\mu(k), \mu(k)k, \mu(k)k^2\)</span> 三个函数的前缀和即可。</p>
<p>这玩意应该叫。。。双关键字整除分块？</p>

</details>
<hr />
<h2 id="lg5284-十二省联考2019-字符串问题">lg5284 [十二省联考2019] 字符串问题</h2>
<p>给定字符串 <span class="math inline">\(S\)</span> 。有 <span class="math inline">\(n\)</span> 个 A 类子串<del>（可以加五分）</del>和 <span class="math inline">\(m\)</span> 个 B 类子串，每个 A 类子串有个支配集合，由 B 类子串构成。支配集合的大小总和不超过 <span class="math inline">\(k\)</span> 。</p>
<p>求一个长度最大的串 <span class="math inline">\(T\)</span> ，使得存在一个分割 <span class="math inline">\(T = t_1 + t_2 + t_3 + ... + t_p\)</span> ，满足：</p>
<ul>
<li><span class="math inline">\(\forall 1 \le i \le p\)</span> ，<span class="math inline">\(t_i\)</span> 是 A 类子串。</li>
<li><span class="math inline">\(\forall 1 \le i &lt; p\)</span> ，存在 B 类子串 <span class="math inline">\(r\)</span> 属于 <span class="math inline">\(t_i\)</span> 的支配集合，使得 <span class="math inline">\(r\)</span> 是 <span class="math inline">\(t_{i+1}\)</span> 的前缀。</li>
</ul>
<p>时间复杂度：<span class="math inline">\(O(|S|+(n+m)\log+k)\)</span> （这里认为字符集大小为 <span class="math inline">\(O(1)\)</span>）。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>容易想到转换为图论问题，把所有 A 类子串和 B 类子串看做一个节点，A 类子串的出边集合就是其支配集合，B 类子串的出边集合就是它作为前缀出现的 A 类子串集合。</p>
<p>定义 A 类子串的权值为其长度，B 类子串的权值为 0 ，那么问题就是在这张有向图上求最长路（不一定是简单路）。由于权值都是非负且不存在零环，只要有环 <span class="math inline">\(T\)</span> 的长度就可以是无穷大。而没有环的时候它是张 DAG ，直接 DP 求最长路即可。</p>
<p>看起来做完了，然而有一个问题，可以发现 B 类子串的出边集合大小是 <span class="math inline">\(O(n)\)</span> 的，这张图的边数是 <span class="math inline">\(O(nm)\)</span> 的。</p>
<h3 id="后缀树优化建图">后缀树优化建图</h3>
<p>搞个标题看起来逼格一些，咱不会后缀树，还是用 SAM 吧。</p>
<p>注意到 B 类子串 <span class="math inline">\(q\)</span> 向 A 类子串 <span class="math inline">\(r\)</span> 有边当且仅当 <span class="math inline">\(q\)</span> 是 <span class="math inline">\(r\)</span> 前缀，也就是前者的反串是后者的后缀。而所有节点都是 <span class="math inline">\(S\)</span> 的子串，不妨对 <span class="math inline">\(S\)</span> 的反串建 SAM ，那么此时有边的条件就是在 parent 树上 <span class="math inline">\(r\)</span> 在 <span class="math inline">\(q\)</span> 的子树内。那就好办了，利用 parent 树优化建图，但是要考虑到只有 B 类串向 A 类串连边，直接建图会产生 A 类串到 A 类串或者 B 到 B 的不合法边。另外 SAM 的一个节点代表了多个子串，为了避免连出自环的情况可能需要额外拆点（舍弃了 SAM 最简的性质）。</p>

</details>
<hr />
<h2 id="cf102465jgym-mona-lisa">cf102465j(gym) Mona Lisa</h2>
<p>有四个随机数生成器 <span class="math inline">\(A, B, C, D\)</span> ，每次可以从一个随机数生成器中等概率获得一个 <span class="math inline">\([0, 2^n)\)</span> 的整数。要求分别从四个生成器获得整数 <span class="math inline">\(a, b, c, d\)</span> 满足 <span class="math inline">\(a \oplus b \oplus c \oplus d = 0\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(2^{\frac{n}{3}})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<h3 id="生日悖论">生日悖论</h3>
<p>表述一：对于两个长度为 <span class="math inline">\(O(\sqrt{n})\)</span> 而值域 <span class="math inline">\(O(n)\)</span> 的随机数列，它们的交集的大小的期望是 <span class="math inline">\(O(1)\)</span> 的。</p>
<p>表述二：对于两个长度为 <span class="math inline">\(O(n)\)</span> 而值域 <span class="math inline">\(O(n)\)</span> 的随机数列，它们的交集的大小的期望是 <span class="math inline">\(O(n)\)</span> 的。</p>
<h3 id="正题">正题</h3>
<p>这种类似于碰撞的东西往往就要考虑生日悖论，生日悖论总能带来很好的效果。</p>
<p>对于每个随机数生成器，分别取 <span class="math inline">\(O(2^{n/3})\)</span> 个元素得到集合 <span class="math inline">\(S_a, S_b, S_c, S_d\)</span> 。然后称前 <span class="math inline">\(\frac{n}{3}\)</span> 个二进制位为关键位，找到 <span class="math inline">\(S_a, S_b\)</span> 中关键位异或为 0 的值，并把它们的异或和加入集合 <span class="math inline">\(P\)</span> ，那么 <span class="math inline">\(P\)</span> 的每个元素在关键位上的取值都是 0 。对 <span class="math inline">\(S_c, S_d\)</span> 做同样的处理得到 <span class="math inline">\(Q\)</span> 。</p>
<p>根据生日悖论的表述二，<span class="math inline">\(P, Q\)</span> 的大小的期望都是 <span class="math inline">\(O(2^{n/3})\)</span> 。</p>
<p>接下来在 <span class="math inline">\(P, Q\)</span> 中分别找到两个元素 <span class="math inline">\(x, y\)</span> 满足 <span class="math inline">\(x \oplus y = 0\)</span> ，这样的 <span class="math inline">\(x, y\)</span> 就对应一组解。事实上就是求 <span class="math inline">\(P \cap Q\)</span> ，注意到由于 <span class="math inline">\(P, Q\)</span> 的元素只在 <span class="math inline">\(\frac{2n}{3}\)</span> 个非关键位上有值，可以认为它们是值域范围 <span class="math inline">\(2^{2n/3}\)</span> 的随机数，那么根据生日悖论的表述一，它们交集的大小期望是 <span class="math inline">\(O(1)\)</span> 的。</p>

</details>
<hr />
<h2 id="nowcoder6766-a-等级之题-n18.3">nowcoder6766-a 等级之题 N1（8.3）</h2>
<p>初始时有 <span class="math inline">\(n\)</span> 个黑球和 <span class="math inline">\(m\)</span> 个蓝球。进行 <span class="math inline">\(k\)</span> 轮操作，每一轮操作如下：</p>
<ol type="1">
<li>有 <span class="math inline">\(p\)</span> 的概率添加一个黑球，有 <span class="math inline">\(1-p\)</span> 的概率添加一个蓝球。</li>
<li>从所有球中随机扔掉一个球。</li>
</ol>
<p>求最后黑球的数量的期望。</p>
<p>时间复杂度：<span class="math inline">\(O(\log k)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>容易发现操作不会改变球数，设 <span class="math inline">\(N = n + m + 1\)</span> 。容易想到设 <span class="math inline">\(f_{i,x}\)</span> 表示 <span class="math inline">\(i\)</span> 轮操作后黑球数量为 <span class="math inline">\(x\)</span> 的概率然后 DP 。那么 <span class="math inline">\(f_{i,x}\)</span> 有 <span class="math inline">\(P_{x,-} = \frac{x}{N}(1-p)\)</span> 的概率转移到 <span class="math inline">\(f_{i+1,x-1}\)</span> ，有 <span class="math inline">\(P_{x,+} = \frac{N-x-1}{N}p\)</span> 的概率转移到 <span class="math inline">\(f_{i+1,x-1}\)</span> 。</p>
<p>设 <span class="math inline">\(i\)</span> 轮操作后的黑球期望 <span class="math inline">\(E_i = \sum_{x=0}^N f_{i,x} x\)</span> 。然后考虑 <span class="math inline">\(f_{i,x}\)</span> 在一轮转移中对期望值的贡献，有 <span class="math inline">\(P_{x,-}\)</span> 的概率减一，<span class="math inline">\(P_{x,+}\)</span> 的概率加一，这部分期望的改变量就是 <span class="math inline">\(P_{x,+} - P_{x,-} = \frac{N-1}{N}p - \frac{x}{N}\)</span> 。</p>
<p>为了方便，设 <span class="math inline">\(a = \frac{N-1}{N}\)</span> ，有</p>
<p><span class="math display">\[E_{i+1} = E_i + \sum_{x=0}^N f_{i,x} (ap - \frac{x}{N}) = E_i + ap - \sum_{x=0}^N f_{i,x} \frac{x}{N} = a(p+E_i)\]</span></p>
<p>妙啊，迭代一下这个递推式就可以快速幂了，最后整理可以得到</p>
<p><span class="math display">\[E_k = a^k E_0 + p (N-1) (1 - a^k)\]</span></p>

</details>
<hr />
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title>好题题解整理（一）</title>
    <url>/2020/07/27/%E5%A5%BD%E9%A2%98%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<!-- 一场真实的模拟考后意识到自己思维能力严重不足，遂暂停了正在进行的真题训练计划，提前执行思维训练。-->
<p>没有摘要。</p>
<a id="more"></a>
<hr />
<h2 id="th1690-a">th1690-a</h2>
<p>给定一个 <span class="math inline">\(n\)</span> 个点的竞赛图，求一个 <span class="math inline">\(m\)</span> 边染色方案。（<span class="math inline">\(n=3000, m=14\)</span> ）</p>
<blockquote>
<p>竞赛图是任意一对点都有恰好一条有向边的有向图。</p>
</blockquote>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>这样转换问题：允许边染上多种颜色，给每个点 <span class="math inline">\(u\)</span> 一个颜色集合 <span class="math inline">\(S_u\)</span> ，对于一条边 <span class="math inline">\((u, v)\)</span> ，它染上颜色 <span class="math inline">\(c\)</span> 当且仅当 <span class="math inline">\(c \in S_u \wedge c \notin S_v\)</span> 。</p>
<p>这样一来很容易给出一个构造方案：把大小恰为 <span class="math inline">\(\frac{m}{2}\)</span> 的颜色集合任意分配给每个点即可。这样任意一对点 <span class="math inline">\(u, v\)</span> 都存在一个 <span class="math inline">\(u\)</span> 拥有而 <span class="math inline">\(v\)</span> 没有的颜色。并且有 <span class="math inline">\(\dbinom{m}{\frac{m}{2}} \ge n\)</span> 。</p>

</details>
<hr />
<h2 id="th1690-b">th1690-b</h2>
<p>有一张 <span class="math inline">\(n\)</span> 个点的无向图满足任意一个导出子图都存在一个度数不超过 <span class="math inline">\(k\)</span> 的点。每次可以询问一个点集是否有边，如果有会给出任意一条，要求用 <span class="math inline">\(n(2k+1)\)</span> 次询问求出边集。其中 <span class="math inline">\(n\)</span> 是已知量，<span class="math inline">\(k\)</span> 是未知量。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>这个 <span class="math inline">\(k\)</span> 的限制很奇怪，很难得到直接有效的性质，需要敏锐的观察力。</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>每次在图中找到度数最小的点删除，删除的点按顺序构成一个序列，在该序列中从前向后连边得到新图，新图中每个点的出度不超过 <span class="math inline">\(k\)</span> 。</strong></p>
<p>应用反证法，如果新图存在一个度数大于 <span class="math inline">\(k\)</span> 的点，设该点的闭合子图的点集为 <span class="math inline">\(S\)</span> ，可以发现 <span class="math inline">\(S\)</span> 在原图中是一个每个度数都超过 <span class="math inline">\(k\)</span> 的导出子图，矛盾。</p>
<h3 id="引理-2">引理 2</h3>
<p><strong>这张图可以 <span class="math inline">\(k+1\)</span> 染色。</strong></p>
<p>根据引理 1 提到的序列，把该序列从后往前染色，由于每个点出度不超过 <span class="math inline">\(k\)</span> ，染色数不会超过 <span class="math inline">\(k+1\)</span> 。</p>
<h3 id="引理-3">引理 3</h3>
<p><strong>图的边数不超过 <span class="math inline">\(nk\)</span> 。</strong></p>
<p>根据引理 1 提到的序列可以简单得出，注意引理 1 提到的新图和原图边数相等。</p>
<h3 id="正题">正题</h3>
<p>有了三个强大的引理就可以做题了。</p>
<p>维护染色集合，逐个加入每个点 <span class="math inline">\(u\)</span> 并求出 <span class="math inline">\(u\)</span> 与已加入的点之间的边。加入点 <span class="math inline">\(u\)</span> 时和每个染色集合放一起询问。如果询问得到了一条边，该边一定包含 <span class="math inline">\(u\)</span> ，因为一个染色集合是一个独立集，这时候把该边另外一个点在询问集合里去掉继续询问，直到询问出来没有边。</p>
<p>然后就得到了当前已经加入的点的导出子图，每次求出引理 1 提到的序列并用引理 2 的方法重新染色，复杂度 <span class="math inline">\(O(n^2k)\)</span> 。</p>
<p>询问的次数不超过 <span class="math inline">\(n|C| + |E|\)</span> ，其中 <span class="math inline">\(|C|, |E|\)</span> 分别是染色数和边数。根据引理 2 和引理 3 ，询问次数不超过 <span class="math inline">\(n(2k+1)\)</span> 。</p>

</details>
<hr />
<h2 id="th1689-b">th1689-b</h2>
<p>给定 <span class="math inline">\(k\)</span> 次多项式的 <span class="math inline">\(k+1\)</span> 个点值 <span class="math inline">\(f(0)\)</span> 到 <span class="math inline">\(f(k)\)</span> ，对于正整数 <span class="math inline">\(q, n\)</span> 求 <span class="math inline">\(\sum_{i=1}^n f(i)q^i\)</span> <span class="math inline">\((q\neq{1})\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(k+\log{n})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>设 <span class="math inline">\(S(m) = \sum_{i=0}^{m-1} f(i) q^i\)</span> 。</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>存在 <span class="math inline">\(k\)</span> 次多项式 <span class="math inline">\(G\)</span> 满足 <span class="math inline">\(S(m) = q^m G(m) - G(0)\)</span> 。</strong></p>
<p>对 <span class="math inline">\(k\)</span> 应用数学归纳法。对于 <span class="math inline">\(k=0\)</span> 不难证明。对于 <span class="math inline">\(k \ge 1\)</span> ，对 <span class="math inline">\(S(m)\)</span> 和 <span class="math inline">\(q S(m)\)</span> 作差，设 <span class="math inline">\(g(i) = f(i) - f(i-1)\)</span> ，显然 <span class="math inline">\(g\)</span> 是 <span class="math inline">\(k-1\)</span> 次多项式。那么根据归纳假设，存在 <span class="math inline">\(k-1\)</span> 次多项式 <span class="math inline">\(P\)</span> 满足 <span class="math inline">\(\sum_{i=0}^{m-1} g(i) q^i = q^m P(m) - P(0)\)</span> ，于是可以得到：</p>
<p><span class="math display">\[(1-q)S(m) = q^m P(m) - P(0) + f(-1) - q^{m+1} f(m)\]</span></p>
<p>从中不难得到这样一个 <span class="math inline">\(k\)</span> 次多项式 <span class="math inline">\(G\)</span> 。</p>
<h3 id="正题">正题</h3>
<p>根据引理 1 ，我们可以通过求 <span class="math inline">\(G(n+1)\)</span> 和 <span class="math inline">\(G(0)\)</span> 间接求出 <span class="math inline">\(S(n+1)\)</span> 。</p>
<p>然而对于 <span class="math inline">\(G\)</span> 我们知道的只有它的次数和它与 <span class="math inline">\(S, f\)</span> 的关系，所以求 <span class="math inline">\(G\)</span> 仍然要从 <span class="math inline">\(S, f\)</span> 下手。</p>
<p>比如对 <span class="math inline">\(S\)</span> 作差可以间接对 <span class="math inline">\(G\)</span> 作差，得到 <span class="math inline">\(qG(m+1) - G(m) = f(m)\)</span> ，这是个递推关系。</p>
<p>那么通过已知的 <span class="math inline">\(f\)</span> 的点值和这个递推关系可以得到 <span class="math inline">\(k+1\)</span> 个方程和 <span class="math inline">\(k+2\)</span> 个变量，还差一个就可以解方程。</p>
<p>我们还没有用到 <span class="math inline">\(G\)</span> 的多项式次数为 <span class="math inline">\(k\)</span> 这个性质，把 <span class="math inline">\(G\)</span> 做 <span class="math inline">\(k+1\)</span> 次差分便可再得到一个方程：</p>
<p><span class="math display">\[\sum_{i=0}^{k+1} G(i) \binom{k+1}{i} (-1)^i = 0\]</span></p>
<p>线性消元即可解出 <span class="math inline">\(G(0)\)</span> 到 <span class="math inline">\(G(k+1)\)</span> ，然后线性拉格朗日插值即可得到 <span class="math inline">\(G(n+1)\)</span> 。</p>

</details>
<hr />
<h2 id="lg4548">lg4548</h2>
<p>按如下方式随机生成一个序列：每次等概率在序列末尾添加一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的正整数，当长为 <span class="math inline">\(m\)</span> 的给定序列 <span class="math inline">\(\{a\}\)</span> 成为随机序列的子串时停止。求该随机序列的期望长度。</p>
<p>时间复杂度：<span class="math inline">\(O(m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>似乎是道论文题，比较偏数学，代码没几行。</p>
<p>设 <span class="math inline">\(X\)</span> 表示随机序列的期望长度，其 PGF 为 <span class="math inline">\(F(x)\)</span> 。</p>
<blockquote>
<p>常识：<span class="math inline">\(E(X) = F&#39;(1)\)</span> 。</p>
</blockquote>
<p>设 <span class="math inline">\(g_k\)</span> 表示序列长度为 <span class="math inline">\(k\)</span> 时仍然没有停止的概率，即 <span class="math inline">\(P(X&gt;k)\)</span> ，其 OGF 为 <span class="math inline">\(G(x)\)</span> 。</p>
<blockquote>
<p>常识：<span class="math inline">\(F&#39;(1) = G(1)\)</span> 。</p>
</blockquote>
<!-- 由于 $1 - [x^k]G(x) = \sum_{j=0}^k [x^j]F(x)$ ，即 $\frac{1}{1-x} - G(x) = \frac{F(x)}{1-x}$ ，整理后得到 $(1-x)G(x) = 1-F(x)$ ，两边求导并代入 $x=1$ 得到 $F'(1) = G(1)$ 。当然直接从定义上更好证。 -->
<p>如果序列长 <span class="math inline">\(k\)</span> 时仍未停止，考虑如果直接在后面添加序列 <span class="math inline">\(\{a\}\)</span> ，一定会结束，但最后的长度未必恰好是 <span class="math inline">\(k+m\)</span> ，可能是任意的 <span class="math inline">\(k+i\)</span> ，其中 <span class="math inline">\(i\)</span> 是序列 <span class="math inline">\(\{a\}\)</span> 的一个 border 长度。</p>
<p>于是可以得到 <span class="math inline">\(G(x) (\frac{x}{n})^m = \sum_{i\in{S}} F(x) (\frac{x}{n})^{m-i}\)</span> ，其中 <span class="math inline">\(S\)</span> 是 border 长度集合。</p>
<p>代入 <span class="math inline">\(x=1\)</span> ，有 <span class="math inline">\(G(1) = \sum_{i\in{S}}F(1) n^i\)</span> ，<span class="math inline">\(F(1)=1\)</span> 也是常识，于是 KMP 求出 <span class="math inline">\(S\)</span> 后就可以算出 <span class="math inline">\(G(1)\)</span> 。</p>

</details>
<hr />
<h2 id="cf643f">cf643f</h2>
<p>有 <span class="math inline">\(n\)</span> 个人和若干个桶，每一天每个人会选一个桶的集合并品尝。有恰好一个桶有毒，品到毒的人立即晕倒，人们以身试毒，确定哪个桶有毒，同时希望晕倒人数不超过 <span class="math inline">\(p\)</span> 。</p>
<p>设 <span class="math inline">\(R_i\)</span> 表示试毒进行 <span class="math inline">\(i\)</span> 天，最坏情况下人们最多能在多少桶中找到毒，求出 <span class="math inline">\(R_1\)</span> 到 <span class="math inline">\(R_m\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(pm)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>给每个人选一个桶的集合不好处理，不妨给每个桶选一个被品尝的集合 <span class="math inline">\(S\)</span> ，首先必须满足 <span class="math inline">\(|S| \le p\)</span> ，否则该桶有毒会直接导致失败。</p>
<p>那么 <span class="math inline">\(R_1\)</span> 的值就呼之欲出了，由于只进行一天，必须给每个桶分配一个不同的集合，否则无法区分集合相同的桶，那么答案就是集合的数量： <span class="math inline">\(\sum_{i=0}^p \binom{n}{i}\)</span> 。</p>
<p>推广到更一般的情况，试毒假设进行 <span class="math inline">\(t\)</span> 天，对于一个集合为 <span class="math inline">\(S\)</span> 的桶，如果该桶是毒，那么第一天过后人们就只需要在集合恰为 <span class="math inline">\(S\)</span> 的所有桶中尝试，并且会增加 <span class="math inline">\(|S|\)</span> 名晕倒人数。</p>
<p>于是可以设计 DP ，设 <span class="math inline">\(f_{i,t}\)</span> 表示已经晕倒 <span class="math inline">\(i\)</span> 人，试毒还剩 <span class="math inline">\(t\)</span> 天的情况下人么最多能从多少桶中找到毒，可以得到转移：</p>
<p><span class="math display">\[f_{i,t} = \sum_{j=0}^{p-i} \binom{n-i}{j} f_{i+j,t-1}\]</span></p>
<p>初值是 <span class="math inline">\(f_{i,0}=1\)</span> 。这个 DP 的复杂度是 <span class="math inline">\(O(p^2m)\)</span> 的，不难发现是卷积形式，可以优化到 <span class="math inline">\(O(mp\log{p})\)</span> ，但还是不够。</p>
<p>从组合意义的角度考虑这个 DP ，需要关心的只是 <span class="math inline">\(f_{0,t}\)</span> ，其转移代表选 <span class="math inline">\(t\)</span> 个数组成序列 <span class="math inline">\(\{a\}\)</span> ，有 <span class="math inline">\(f_{0,t} = \sum \binom{n}{a_1} \binom{n-a_1}{a_2} \binom{n-a_1-a_2}{a_3} ...\)</span> ，这其实就是在 <span class="math inline">\(n\)</span> 个数里面依次选数，选数总数不超过 <span class="math inline">\(p\)</span> 的方案数。不妨先选出所有要选的数，然后再把这些数分为 <span class="math inline">\(t\)</span> 个可区分的集合。注意到 <span class="math inline">\(t\)</span> 个集合之间是两两独立的，那么每个数可以自由放进 <span class="math inline">\(t\)</span> 个集合中的任意一个集合，集合的划分方案数就是 <span class="math inline">\(t\)</span> 的总数次方。最终可以得到：</p>
<p><span class="math display">\[R_t = f_{0,t} = \sum_{i=0}^p \binom{n}{i} t^i\]</span></p>

</details>
<hr />
<h2 id="cf700e">cf700e</h2>
<p>给定串 <span class="math inline">\(S\)</span> ，找到长度为 <span class="math inline">\(k\)</span> 的串的序列 <span class="math inline">\(\{s_i\}\)</span> 满足 <span class="math inline">\(\forall i \in [2, k]\)</span> ，<span class="math inline">\(s_i\)</span> 在 <span class="math inline">\(s_{i-1}\)</span> 中出现至少两次，且 <span class="math inline">\(s_0\)</span> 是 <span class="math inline">\(S\)</span> 的子串。求最大的 <span class="math inline">\(k\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(|S|\log)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>存在一个最优解，满足 <span class="math inline">\(s_i\)</span> 是 <span class="math inline">\(s_{i-1}\)</span> 的后缀。</strong></p>
<p>对满足条件的序列前缀长度 <span class="math inline">\(k\)</span> 应用数学归纳，<span class="math inline">\(k=1\)</span> 显然成立。对于 <span class="math inline">\(k\le{2}\)</span> 如果 <span class="math inline">\(s_k\)</span> 不是 <span class="math inline">\(s_{k-1}\)</span> 的后缀，不妨把 <span class="math inline">\(s_{k-1}\)</span> 后面的若干字符删除，直到 <span class="math inline">\(s_k\)</span> 成为 <span class="math inline">\(s_{k-1}\)</span> 后缀。注意到任意 <span class="math inline">\(s_i\)</span> 删除末尾的若干字符后仍然会在 <span class="math inline">\(s_{i-1}\)</span> 出现至少 2 次。因此可以从 <span class="math inline">\(k\)</span> 到 <span class="math inline">\(2\)</span> 不断删除后面末尾若干字符直到满足条件，而 <span class="math inline">\(s_k\)</span> 不会发生改变，不会影响后面的部分。</p>
<h3 id="引理-2">引理 2</h3>
<p><strong>对于 SAM 上的任一节点 u ，其后缀链接为 v ，v 的任一串在 u 的任一串的出现位置集合都相同。</strong></p>
<p>可以反证。如果有不相同，可以发现对于任意 u 的最长串 <span class="math inline">\([l, r]\)</span> ，字符 <span class="math inline">\(l-1\)</span> 是可以唯一确定的，换言之存在更长的串与 u 节点的最长串 right 集合相同，这与 SAM 的性质矛盾。</p>
<h3 id="正题">正题</h3>
<p>有了这两个引理，就可以在 SAM 上 DP ，并且只需要考虑从每个节点的后缀链接的转移，如果其后缀链接节点的任一子串在该节点的任一子串中出现至少两次，转移的时候就加一，否则不变。</p>
<p>问题转换为判断一个节点的后缀链接是否在该节点出现至少两次。没有想到什么巧妙的做法，可以线段树维护 right 集合，然后随便从 right 集合拿一个点查询指定区间是否有后缀链接的 right 集合元素。</p>

</details>
<hr />
<h2 id="cf1285f">cf1285f</h2>
<p>给定一个值不超过 <span class="math inline">\(m\)</span> 的正整数集合 <span class="math inline">\(S\)</span> ，对于所有 <span class="math inline">\(x, y \in S\)</span> 求 <span class="math inline">\(\max(\mathrm{lcm}(x, y))\)</span> 。</p>
<p>时间复杂度：<span class="math inline">\(O(m^{1.5})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>设集合 <span class="math inline">\(T\)</span> 满足 <span class="math inline">\(T = \{d | \exists x \in S, d | x\}\)</span> ，那么答案等于对于所有 <span class="math inline">\(x, y \in T, x \bot y\)</span> 求 <span class="math inline">\(\max(\mathrm{lcm}(x, y))\)</span> 。</p>
<p>从大到小考虑 <span class="math inline">\(T\)</span> 的每个数，对于当前数 <span class="math inline">\(x\)</span> ，设 <span class="math inline">\(y\)</span> 是与 <span class="math inline">\(x\)</span> 互质的最大的“可能有用”的值。可以发现一个性质，由于 <span class="math inline">\(x\)</span> 此时是未考虑的数的最大值，那么 <span class="math inline">\(\forall x &lt; k &lt; y\)</span> ，<span class="math inline">\(k\)</span> 在考虑完 <span class="math inline">\(x\)</span> 之后都不会对答案产生贡献，可以把这样的 <span class="math inline">\(k\)</span> 从“可能有用”的范畴删去。</p>
<p>那么可以用一个栈 <span class="math inline">\(R\)</span> 维护所有“可能有用”的值，在普通的栈的基础上还要支持查询是否存在一个与 <span class="math inline">\(x\)</span> 互质的数从而确定是否需要弹栈，弹完栈后的栈顶就是对应的 <span class="math inline">\(y\)</span> 。</p>
<p>众所周知互质的条件很好用莫比乌斯函数表示，于是接下来要做的就是套路了：</p>
<p><span class="math display">\[\sum_{y\in{R}} [x\bot{y}] = \sum_{d|x} \sum_{d|y,y\in{R}} \mu(d)\]</span></p>
<p>维护 <span class="math inline">\(f(d) = \sum_{d|y,y\in{R}} \mu(d)\)</span> 即可。</p>

</details>
<hr />
<h2 id="at_agc035_f">at_agc035_f</h2>
<p>有一个 <span class="math inline">\(n \times m\)</span> 的网格，依次执行两个操作：</p>
<ol type="1">
<li>对每一行选择非负数 <span class="math inline">\(a_i\)</span> ，把该行左边 <span class="math inline">\(a_i\)</span> 个格子加一。</li>
<li>对每一列选择非负数 <span class="math inline">\(b_i\)</span> ，把该列上边 <span class="math inline">\(b_i\)</span> 个格子加一。</li>
</ol>
<p>形式化的，合法网格的格子 <span class="math inline">\((i, j)\)</span> 的权值为 <span class="math inline">\([j \le a_i] + [i \le b_j]\)</span> ，求有多少不同的合法网格。</p>
<p>时间复杂度：<span class="math inline">\(O(n+m)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>每个 <span class="math inline">\(a_i, b_i\)</span> 随便选的方案数很好算，但是一种合法网格对应多个选取方案。</p>
<p>例如 <span class="math inline">\(a_i = j, b_j = i - 1\)</span> 和 <span class="math inline">\(a_i = j - 1, b_j = i\)</span> 对网格的影响是相同的。</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>称一个满足 <span class="math inline">\(\forall b_j &gt; 0, a_{b_j} \neq j-1\)</span> 的选取方案选取方案是优秀的，所有优秀的选取方案和所有不同的合法网格一一对应。</strong></p>
<h4 id="part1">Part1</h4>
<p>每个优秀方案对应的网格不同。</p>
<p>反证法。设两个不同的优秀的选取方案分别为 <span class="math inline">\(\{a\}, \{b\}\)</span> 和 <span class="math inline">\(\{c\}, \{d\}\)</span> ，它们对应的网格相同。设 <span class="math inline">\(j\)</span> 是最小的满足 <span class="math inline">\(b_j \neq d_j\)</span> 的数，如果不存在这样的 <span class="math inline">\(j\)</span> ，那么 <span class="math inline">\(b, d\)</span> 相同，<span class="math inline">\(a, c\)</span> 不同，对应的网格显然不会相同，矛盾。不妨假设 <span class="math inline">\(b_j &lt; d_j = i\)</span> ，考虑格子 <span class="math inline">\((i, j)\)</span> 的权值，必须是 1 ，那么有 <span class="math inline">\(c_i &lt; j\)</span> 且 <span class="math inline">\(a_i \ge j\)</span> 。</p>
<p>由 <span class="math inline">\(c_{d_j} \neq j-1\)</span> 可以得到 <span class="math inline">\(c_i &lt; j-1\)</span> ，如果 <span class="math inline">\(j=1\)</span> 显然不存在合法 <span class="math inline">\(c_i\)</span> 。如果 <span class="math inline">\(j\ge{2}\)</span> ，由于 <span class="math inline">\(j\)</span> 是最小的满足 <span class="math inline">\(b_j \neq d_j\)</span> 的数，有 <span class="math inline">\(b_{j-1}=d_{j-1}\)</span> ，考虑格子 <span class="math inline">\((i,j-1)\)</span> 的权值，可以发现并不相等，矛盾。</p>
<h4 id="part2">Part2</h4>
<p>每个合法网格存在优秀的选取方案对应。</p>
<p>合法网格对应若干任意选取方案，对于一个不优秀的选取方案，把所有 <span class="math inline">\(a_i=j-1, b_j=i\)</span> 替换为 <span class="math inline">\(a_i=j, b_j=i-1\)</span> 即可得到优秀方案。</p>
<h3 id="正题">正题</h3>
<p>通过引理 1 ，问题转换为求优秀的选取方案数，直接做比较困难，考虑容斥/反演。对于一个选区方案，称一个 <span class="math inline">\(j\)</span> 是不优秀位置，当且仅当 <span class="math inline">\(a_{b_j}=j-1\)</span> 。设 <span class="math inline">\(f_r\)</span> 表示恰好有 <span class="math inline">\(r\)</span> 个不优秀位置的方案数，答案就是 <span class="math inline">\(f_0\)</span> 。</p>
<p>设 <span class="math inline">\(g_r\)</span> 表示钦定了 <span class="math inline">\(r\)</span> 个不优秀位置的计算方案数，于是有：</p>
<p><span class="math display">\[\frac{n^{\underline{r}}m^{\underline{r}}}{r!} (m+1)^{n-r} (n+1)^{n-r} = g_r = \sum_{i\ge{r}} f_i \binom{i}{r}\]</span></p>
<p>二项式反演即可得到 <span class="math inline">\(f_0\)</span> 的表达式。</p>

</details>
<hr />
<h2 id="lg6596">lg6596</h2>
<p>求 <span class="math inline">\(n\)</span> 个点的割边不超过 <span class="math inline">\(m\)</span> 的简单连通图数目，点是可区分的。</p>
<p>时间复杂度：<span class="math inline">\(O(n^3)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>设 <span class="math inline">\(f_i\)</span> 表示恰有 <span class="math inline">\(i\)</span> 条割边的方案数，可以发现如果钦定 <span class="math inline">\(i\)</span> 个割边，还要保证剩下的 <span class="math inline">\(i+1\)</span> 个连通块是边双。设 <span class="math inline">\(g_i\)</span> 表示钦定 <span class="math inline">\(i\)</span> 条割边的计数方案数，根据 <span class="math inline">\(g\)</span> 的定义，钦定 <span class="math inline">\(i\)</span> 条割边后只需要保证剩下 <span class="math inline">\(i+1\)</span> 个连通块是连通的。而 <span class="math inline">\(f, g\)</span> 的关系显然是二项式反演。</p>
<p>钦定割边的过程可以转换为先把点划分为 <span class="math inline">\(i+1\)</span> 个集合，然后它们各自独立，都形成连通块，再在这些点集里连割边。设这些点集的大小组成大小序列 <span class="math inline">\(\{a\}\)</span> ，那么有：</p>
<p><span class="math display">\[g_i = \sum_{\{a\}} (\prod_k h_{a_k}) (\prod_k a_k) n^{|a|-2}\]</span></p>
<p>其中 <span class="math inline">\(h_x\)</span> 表示 <span class="math inline">\(x\)</span> 个点的连通图数目，<span class="math inline">\((\prod_k a_k) n^{|a|-2}\)</span> 是连割边的方案数，这个划分集合的过程显然可以用 <span class="math inline">\(O(n^3)\)</span> 的 DP 描述。</p>
<ul>
<li>求 <span class="math inline">\(h\)</span> ：</li>
</ul>
<blockquote>
<p>设 <span class="math inline">\(H_x\)</span> 表示 <span class="math inline">\(x\)</span> 个点的无向图数目，每条边独立，有 <span class="math inline">\(H_x = 2^{\binom{x}{2}}\)</span> ，枚举一号点的连通块大小，有 <span class="math inline">\(H_x = \sum_{i=1}^x \binom{x-1}{i-1} h_i H_{x-i}\)</span> 。于是可以 <span class="math inline">\(O(n^2)\)</span> 求出 <span class="math inline">\(h\)</span> 。不难发现可以利用多项式科技做到 <span class="math inline">\(O(n\log)\)</span> ，不在讨论范围内。</p>
</blockquote>
<ul>
<li>连割边的方案数：</li>
</ul>
<blockquote>
<p>把每个连通块抽象成一个点，<span class="math inline">\((i, j)\)</span> 之间连 <span class="math inline">\(a_i a_j\)</span> 条边，该图的生成树个数就是连割边的方案数，应用矩阵树定理，归纳一下行列式即可得到答案就是 <span class="math inline">\(n^{|a|-2} \prod_k a_k\)</span> ，过程繁琐，略去。</p>
</blockquote>

</details>
<hr />
<h2 id="at_agc023_d">at_agc023_d</h2>
<p>有 <span class="math inline">\(n\)</span> 个人，第 <span class="math inline">\(i\)</span> 的人住在数轴的 <span class="math inline">\(a_i\)</span> 处。所有人在一辆处于 <span class="math inline">\(S\)</span> 处的车上，人们会投票决定车的移动方向，第 <span class="math inline">\(i\)</span> 个人可以投出 <span class="math inline">\(p_i\)</span> 票，司机会为负方向投出半票，每次人数改变后重新投票。每个人会用最优的投票策略最小化到自己的坐车距离，求车的总行驶距离。</p>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>不妨假设 <span class="math inline">\(p_1 \le S \le p_n\)</span> ，<span class="math inline">\(\{a\}\)</span> 严格单调递增。</p>
<h3 id="引理-1">引理 1</h3>
<p><strong>若 <span class="math inline">\(p_1 \ge p_n \land S \ge a_{n-1}\)</span> ，车会一直向负方向开直到到达 <span class="math inline">\(a_1\)</span> 。</strong></p>
<p><del>对 <span class="math inline">\(n\)</span> 应用数学归纳法。</del>显然成立，好像负方向的人没有任何理由投正方向的票，而且一定能投赢。</p>
<h3 id="引理-2">引理 2</h3>
<p><strong>若 <span class="math inline">\(p_1 \ge p_n\)</span> ，车在到达 <span class="math inline">\(a_n\)</span> 前先到达 <span class="math inline">\(a_1\)</span> 。</strong></p>
<p>当车在行驶过程中若一直没有到达 <span class="math inline">\(a_1\)</span> 且正方向只剩下 <span class="math inline">\(a_n\)</span> 没有到达的时候，根据引理 1 ，此时车会一直往负方向开，先到达 <span class="math inline">\(a_1\)</span> 。</p>
<h3 id="正题">正题</h3>
<p>那么如果 <span class="math inline">\(p_1\ge{p_n}\)</span> ，第 <span class="math inline">\(n\)</span> 个人的坐车距离总是第 <span class="math inline">\(1\)</span> 个人的坐车距离加上一个定值，那么他可以把选票都给第 <span class="math inline">\(1\)</span> 个人。<del>打不过就抱大腿</del>。反之同理第 <span class="math inline">\(1\)</span> 个人会把选票给第 <span class="math inline">\(n\)</span> 个人。于是就可以住转换到 <span class="math inline">\(n-1\)</span> 的子问题，递归求解直到 <span class="math inline">\(n=2 \lor S &lt; p_1 \lor S &gt; p_n\)</span> 即可。</p>

</details>
<hr />
<h2 id="at_agc023_f">at_agc023_f</h2>
<p>给定一颗 <span class="math inline">\(n\)</span> 个点的有根树，每个点有取值在 <span class="math inline">\(\{0,1\}\)</span> 的点权，求树上拓扑序对应点权序列的最小逆序对数。</p>
<p>时间复杂度：<span class="math inline">\(O(n\log{n})\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>树上拓扑序的问题除了子树合并外，还有另一种考虑方式。</p>
<p>每个点有一个拓扑序列，初始时是其本身。每次选一个非根点，把该点合并到其父亲节点并把其拓扑序列接在父亲节点的拓扑序列后，直到只剩根节点。容易发现此时根节点的拓扑序列和树上拓扑序列一一对应。</p>
<p>这样做的好处是避免了两个子树合并时拓扑序列的相互插入的处理。</p>
<p>定义一个点的重量是其拓扑序列中 0 的数量与 1 的数量的比值。事实上按照重量选点合并就是最优答案。不会证明，证明不会。</p>

</details>
<hr />
<h2 id="cf685c">cf685c</h2>
<p>给定三维空间 <span class="math inline">\(n\)</span> 个整点 <span class="math inline">\(P_i\)</span> ，找一个整点 <span class="math inline">\(Q\)</span> 使得 <span class="math inline">\(P_iQ\)</span> 的曼哈顿距离的最大值最小，求这个曼哈顿距离。</p>
<p>时间复杂度：<span class="math inline">\(O(n\log)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>二分答案 <span class="math inline">\(K\)</span> ，判断是否存在点 <span class="math inline">\(Q\)</span> 到所有点的曼哈顿距离不超过 <span class="math inline">\(K\)</span> 。</p>
<p>如果空间是二维，曼哈顿距离转切比雪夫距离后每个维度就独立了。</p>
<p>三维的话 <span class="math inline">\(Q\)</span> 的覆盖范围是一个正八面体，而切比雪夫距离的覆盖范围在三维是正方体。</p>
<p>加一个维度，把点 <span class="math inline">\((x, y, z)\)</span> 转换为四维点 <span class="math inline">\((a, b, c, d) = (x+y+z, x+y-z, x-y+z, -x+y+z)\)</span> ，容易发现两个三维点的曼哈顿距离等于对应四维点的切比雪夫距离。</p>
<p>然后就可以解出 <span class="math inline">\(Q\)</span> 对应的四维点在每个维度的取值范围，进而判断是否存在三维整点 <span class="math inline">\(Q\)</span> 。</p>

</details>
<hr />
<h2 id="lg4258">lg4258</h2>
<p>有 <span class="math inline">\(n\)</span> 个球和 <span class="math inline">\(m\)</span> 个盒子，每个盒子至多装三个球，每个球必须装进一个盒子里，且每个球有一个集合 <span class="math inline">\(S_i\)</span> ，第 <span class="math inline">\(i\)</span> 个球只能放进 <span class="math inline">\(S_i\)</span> 中的盒子里。</p>
<p>称一个放了不超过一个球的盒子是半空的，求一组方案使得半空的盒子最多。</p>
<p>时间复杂度：<span class="math inline">\(O((n+m)(m+\sum_{i=1}^n|S_i|)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>容易想到把球和盒子连边转换为图论问题。考虑转换为匹配，每个球必须是匹配点，其匹配的边代表其选的盒子。</p>
<p>盒子就很诡异了，首先一个盒子至多放三个球，那么一个盒子事实上要拆成三个点，其次“半空”的盒子要对答案产生贡献，不妨考虑能否使得半空的盒子增加一条匹配。当然是可以的，一个盒子“半空”意味着三个点中有至少两个非匹配点，那么把这三个点任意连一条边即可。</p>
<p>那么该图的最大匹配数减去 <span class="math inline">\(n\)</span> 就是答案。特别的是，要保证每个球是匹配点，那么从球开始找增广路即可，如果某个球不存在增广路，说明问题无解。</p>
<p>该图点数 <span class="math inline">\(n+3m\)</span> ，边数 <span class="math inline">\(m+\sum_{i=1}^n|S_i|\)</span> 。</p>

</details>
<hr />
<h2 id="th1688-c">th1688-c</h2>
<p>有 <span class="math inline">\(n\)</span> 个球和 <span class="math inline">\(m\)</span> 个盒子，每个盒子有一个集合 <span class="math inline">\(S_i\)</span> ，第 <span class="math inline">\(i\)</span> 个盒子只能放 <span class="math inline">\(S_i\)</span> 中的球。</p>
<p>定义一个盒子的权值为 <span class="math inline">\(\lfloor\frac{x}{2}\rfloor\)</span> ，其中 <span class="math inline">\(x\)</span> 是该盒子内放的球数，求一组方案使得盒子的权值和最大。</p>
<p>时间复杂度：<span class="math inline">\(O((n+m+\sum_{i=1}^m|S_i|)(m+\sum_{i=1}^m|S_i|))\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p><span class="math inline">\(\lfloor\frac{x}{2}\rfloor\)</span> 实际上就是将该盒子内的点两个分为一组能组成的组数。那么不难想到把一个盒子的 <span class="math inline">\(S_i\)</span> 中的球两两连边建图，图的最大匹配数就是答案。</p>
<p>但是这样边数会到平方级别，不能接受。需要优化建图。</p>
<p><img src="/images/1.png" /></p>
<p>如上图，对应一个 <span class="math inline">\(|S_i|=6\)</span> 的盒子的连边。紫色点表示球，红色点表示辅助节点，容易发现任意两个紫色点都可以通过辅助点间接匹配，其效果等价于两两连边。</p>
<p>注意要保证红色点数量为偶数，<span class="math inline">\(|S_i|\)</span> 为奇数的盒子就额外加一个红色点即可。</p>
<p>该图点数不超过 <span class="math inline">\(n+m+\sum_{i=1}^m|S_i|\)</span> ，边数不超过 <span class="math inline">\(m+\sum_{i=1}^m|S_i|\)</span> 。</p>

</details>
<hr />
<h2 id="cf1326f2">cf1326f2</h2>
<p>给定一个长 <span class="math inline">\(n\)</span> 宽 <span class="math inline">\(n\)</span> 的 01 矩阵 <span class="math inline">\(M\)</span> 。</p>
<p>对于一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(\{p_i\}\)</span> 和一个长为 <span class="math inline">\(n-1\)</span> 的 01 序列 <span class="math inline">\(\{a_i\}\)</span> ，称 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(a\)</span> 上合法，当且仅当 <span class="math inline">\(\forall i \in [1, n - 1], M_{p_i, p_{i+1}} = a_i\)</span> 。</p>
<p>对于所有可能的 <span class="math inline">\(a\)</span> 求出有多少 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(a\)</span> 上合法。</p>
<p>时间复杂度：<span class="math inline">\(O(p(n) 2^n n + 2^n n^2)\)</span> ，其中 <span class="math inline">\(p(n)\)</span> 是 <span class="math inline">\(n\)</span> 的划分数。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>既有 1 的限制又有 0 的限制难以直接处理。</p>
<p><strong>这类题有一个套路：忽略一类限制。</strong>这里我们忽略 0 的限制。</p>
<p>记 <span class="math inline">\(A(S)\)</span> 表示 <span class="math inline">\(a\)</span> 压缩为 <span class="math inline">\(S\)</span> 时的答案。考虑计算 <span class="math inline">\(A\)</span> 的父集和 <span class="math inline">\(B\)</span> ，即 <span class="math inline">\(B(T) = \sum_{T \subseteq S} A(S)\)</span> ，然后通过反演还原 <span class="math inline">\(A\)</span> 。那么这样就只有 1 的限制，<span class="math inline">\(B(S)\)</span> 的意义就是钦定排列一些相邻位置 <span class="math inline">\(p_i, p_{i+1}\)</span> 满足 <span class="math inline">\(M_{p_i,p_{i+1}} = 1\)</span> ，而未被钦定的位置没有任何限制。</p>
<p>可以发现，如果将 <span class="math inline">\(M_{i,j} = 1\)</span> 看作连边 <span class="math inline">\((i, j)\)</span> ，<span class="math inline">\(B(S)\)</span> 相当于将排列划分为若干连续段，要求每个段内必须连成一条链。那么对于 <span class="math inline">\(B(S), B(T)\)</span> ，如果 <span class="math inline">\(S, T\)</span> 代表的划分本质相同，就一定有 <span class="math inline">\(B(S) = B(T)\)</span> 。也就是说只需要对于所有 <span class="math inline">\(n\)</span> 的划分计算 <span class="math inline">\(B(S)\)</span> 即可。</p>
<p>预处理出 <span class="math inline">\(f(S)\)</span> 表示用集合 <span class="math inline">\(S\)</span> 内的点能组成多少条链。那么对于一个划分的答案，就是所有对应长度的点集划分的 <span class="math inline">\(f\)</span> 的乘积和。枚举点集划分是不可取的，事实上，将对应的 <span class="math inline">\(f\)</span> 做一个并卷积，最终序列的全集位置的值就是答案。因为确定了长度划分，如果若干集合存在一对有交，它们的并的长度就会小于 <span class="math inline">\(n\)</span> ，不可能是全集。</p>
<p>具体的，设 <span class="math inline">\(F_k(S) = [|S| = k] f(S)\)</span> ，那么一个划分的答案就是对应的 <span class="math inline">\(F_k\)</span> 的并卷积的末项。</p>

</details>
<hr />
<h2 id="loj575">loj575</h2>
<p>给定一个字符串 <span class="math inline">\(s_1, s_2, \dots, s_n\)</span> ，仅包含 <code>&lt;</code> 和 <code>&gt;</code> 两种字符。求「使得 <span class="math inline">\(p_i &lt; p_{i+1}\)</span> <strong>当且仅当</strong> <span class="math inline">\(s_i\)</span> 为 <code>&lt;</code> 的排列 <span class="math inline">\(p_1, p_2, \ldots, p_{n+1}\)</span>」的数量。</p>
<p>时间复杂度：<span class="math inline">\(O(n\log^2)\)</span> 。</p>
<details class="note primary"><summary><p>题解</p>
</summary>
<p>（未实现）</p>
<p>既有小于号的限制又有大于号的限制难以直接处理。</p>
<p><strong>这类题有一个套路：忽略一类限制。</strong>这里我们忽略 <code>&gt;</code> 的限制。</p>
<p>把 <code>&gt;</code> 看做隔板，忽略 <code>&gt;</code> 的限制后唯一的限制是隔板之间的一段数必须单调递增，也就是把 <span class="math inline">\(n\)</span> 个数填入每一段，设有 <span class="math inline">\(m\)</span> 段，长度组成序列 <span class="math inline">\(\{a\}\)</span> ，那么方案数就是</p>
<p><span class="math display">\[\frac{n!}{\prod_{i=1}^m a_i}\]</span></p>
<p>考虑怎么反演回去，直接一波子集反演的复杂度太大，无法接受。不同于 <code>cf1326f2</code> 的是，这里只需要对于给定的 <span class="math inline">\(s\)</span> 计算答案。可以应用另一个不知道叫啥的容斥，设 <span class="math inline">\(f_i\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 段，每个隔板的左边严格大于右边的所有方案的分母贡献，转移钦定一段后缀合并，有</p>
<p><span class="math inline">\(f_i = \sum_{j=0}^{i-1} f_j (-1)^{i-j} \frac{1}{(i-j)!}\)</span> 。</p>
<p>卷积形式，分治 NTT ，答案就是 <span class="math inline">\(f_m n!\)</span> 。</p>

</details>
<hr />
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI真题训练</title>
    <url>/2020/07/26/NOI%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>真题训练，不依靠外力做题，多写几个部分分，研究高效得分方法。</p>
<p>以下评测分数以 loj 提交为准（冒泡排序除外）。分数统计仅代表极限水平，并不代表真实水平，不供参考。</p>
<a id="more"></a>
<h2 id="noi2017">NOI2017</h2>
<p>0 + 76 + 100 + 70 + 100 + 88 + 20 = 454</p>
<p>集训队线 438 。</p>
<h3 id="整数">整数</h3>
<p>看完题就有了一个压位的平方暴力的思路，码了码 WA 在了减法的情况，改对后得到了 56 分，本来对照数据表以为只有 30 分左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read;</span><br><span class="line">    read.operator int(), read.operator int(), read.operator int();</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">32</span>;</span><br><span class="line">    ull FULL = (<span class="number">1l</span>lu &lt;&lt; B) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> o = read;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ix = read, k = read;</span><br><span class="line">            <span class="keyword">if</span> (ix &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ull x = ull(ix);</span><br><span class="line">                x &lt;&lt;= k % B;</span><br><span class="line">                k /= B;</span><br><span class="line">                <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                    data[k] += x;</span><br><span class="line">                    x = data[k] &gt;&gt; B;</span><br><span class="line">                    data[k] &amp;= FULL;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ull x = ull(-ix);</span><br><span class="line">                x &lt;&lt;= k % B;</span><br><span class="line">                k /= B;</span><br><span class="line">                <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                    data[k] -= x;</span><br><span class="line">                    x = data[k] &gt;&gt; B;</span><br><span class="line">                    <span class="keyword">if</span> (x)</span><br><span class="line">                        x = (<span class="number">1l</span>lu &lt;&lt; B) - x;</span><br><span class="line">                    data[k] &amp;= FULL;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = read;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, data[k / B] &gt;&gt; (k % B) &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冷静下来后发现可以类似于 odt 维护二进制位相同的连续段，把修改每一位拆开考虑就可以两个 <span class="math inline">\(\log\)</span> 维护，得到了 68 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = -- <span class="built_in">set</span>.upper_bound(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k2 = *it &gt;&gt; <span class="number">1</span>, x = *it &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == k2) <span class="keyword">return</span> it;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">set</span>.insert(k &lt;&lt; <span class="number">1</span> | x).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modi</span> <span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> p = find(k), q = p;</span><br><span class="line"> <span class="keyword">while</span> ((*q &amp; <span class="number">1</span>) == t) ++ q;</span><br><span class="line">  <span class="keyword">auto</span> r = find((*q &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> tmp = *p, tmq = *q;</span><br><span class="line">  <span class="built_in">set</span>.erase(p, r);</span><br><span class="line">    <span class="built_in">set</span>.insert(tmp ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">set</span>.insert(tmq ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read;</span><br><span class="line">    read.operator int(), read.operator int(), read.operator int();</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">0</span> &lt;&lt; <span class="number">1</span> | <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> o = read;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> x = read, off = read;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">                  <span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        modi(off + k, <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              x = -x;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">                  <span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        modi(off + k, <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">auto</span> p = find(read);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p &amp; <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后没什么思路了，感觉应该还是要压位，但是维护连续段后似乎难以直接压位？想到 <code>std::insert</code> 可以提供 <code>hint</code> 做到 <span class="math inline">\(O(1)\)</span> ，于是写了个带 <code>hint</code> 的版本，得了 76 分。（代码略）</p>
<p>然后发现两个 <span class="math inline">\(\log\)</span> 的瓶颈现在就只在 <code>find</code> 上，由于每次修改拆开后位置相隔很近，事实上 <code>find</code> 也可以给它来个 <code>hint</code> ，每次修改就只需要一次二分，剩下的在之前的基础上暴力跳就好了，复杂度理论上说应该是一个 <span class="math inline">\(\log\)</span> ，但是只有 84 分，本地测了一下最大的点要跑 2.7s 。</p>
<p><del>水讨论发现别人用这个方法直接过了，而且时间还不到 1s ，我 tm 又一次吃了常数的亏。</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>, maxk = <span class="number">30</span>;</span><br><span class="line">ull data[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">bool</span> hint;</span><br><span class="line"><span class="keyword">auto</span> set_hint = <span class="built_in">set</span>.end();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = hint ? set_hint : -- <span class="built_in">set</span>.upper_bound(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (hint) &#123;</span><br><span class="line">     <span class="keyword">while</span> (it != <span class="built_in">set</span>.end() <span class="keyword">and</span> (*it &gt;&gt; <span class="number">1</span>) &lt;= k) ++ it;</span><br><span class="line">       -- it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k2 = *it &gt;&gt; <span class="number">1</span>, x = *it &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == k2) <span class="keyword">return</span> it;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">set</span>.insert(it, k &lt;&lt; <span class="number">1</span> | x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modi</span> <span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = find(k), q = p;</span><br><span class="line"> <span class="keyword">while</span> ((*q &amp; <span class="number">1</span>) == t) ++ q;</span><br><span class="line">  <span class="keyword">auto</span> r = find((*q &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> tmp = *p, tmq = *q;</span><br><span class="line">  <span class="built_in">set</span>.erase(p --, r);</span><br><span class="line"> set_hint = <span class="built_in">set</span>.insert(p, tmp ^ <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">set</span>.insert(set_hint, tmq ^ <span class="number">1</span>);</span><br><span class="line">  hint = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = read;</span><br><span class="line">    read.operator int(), read.operator int(), read.operator int();</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">-1</span>);</span><br><span class="line"> <span class="built_in">set</span>.insert(<span class="number">0</span> &lt;&lt; <span class="number">1</span> | <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> o = read;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> x = read, off = read;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                hint = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">                  <span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        modi(off + k, <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              hint = <span class="number">0</span>;</span><br><span class="line">             x = -x;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxk; k ++)</span><br><span class="line">                  <span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        modi(off + k, <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="comment">/* hint = 0; */</span></span><br><span class="line">          <span class="keyword">int</span> k = read;</span><br><span class="line">            <span class="keyword">auto</span> p = -- <span class="built_in">set</span>.upper_bound(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p &amp; <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蚯蚓排队">蚯蚓排队</h3>
<p>刚开始有个启发式合并 + SAM 的想法，但是发现由于 SAM 只能在末尾加字符而不能加在开头，启发式合并是不可行的。</p>
<p>然后发现读错题了，原来询问是在所有串中询问，我还以为是对一个指定的蚯蚓队列进行询问。然后就想到了一个复杂度巨大的暴力，大概是 <span class="math inline">\(O(mk^2\log + cn + n\log + s\log)\)</span> ，预计 40 分，实际 56 分（全 1 的点复杂度瓶颈处少一个 <span class="math inline">\(\log\)</span> ）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> coe)</span> </span>&#123;</span><br><span class="line">   ull shit = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> x = i, k = <span class="number">1</span>; x <span class="keyword">and</span> k &lt; Maxk; k ++, x = pre[x]) &#123;</span><br><span class="line">     shit += ull(a[x]) * po[k - <span class="number">1</span>];</span><br><span class="line">        ull now = shit;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> y = j, k2 = k + <span class="number">1</span>; y <span class="keyword">and</span> k2 &lt;= Maxk; k2 ++, y = nxt[y])</span><br><span class="line">            <span class="built_in">map</span>[now = now * base + ull(a[y])] += coe;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    po[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxk; i ++) po[i] = po[i - <span class="number">1</span>] * base;</span><br><span class="line">   <span class="keyword">int</span> n = read, q = read;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        ++ <span class="built_in">map</span>[ull(a[i] = read)];</span><br><span class="line">   <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">      <span class="keyword">int</span> o = read;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> i = read, j = read;</span><br><span class="line">          nxt[i] = j;</span><br><span class="line">           pre[j] = i;</span><br><span class="line">           force(i, j, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> i = read, j = nxt[i];</span><br><span class="line">            force(i, j, <span class="number">-1</span>);</span><br><span class="line">          nxt[i] = pre[j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">int</span> len = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>)), K = read;</span><br><span class="line">           ull now = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">                now = now * base + ull(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">         ll ans = <span class="built_in">map</span>[now];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = K + <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">               now = now * base + ull(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">             now -= ull(s[i - K] - <span class="string">&#x27;0&#x27;</span>) * po[K];</span><br><span class="line">             (ans *= <span class="built_in">map</span>[now]) %= mod;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只会暴力，上面的算法主要问题是 map 太慢，用数组分摊给它优化一波：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ull B = <span class="number">24</span>, Bl = (<span class="number">1l</span>lu &lt;&lt; B) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;ull, <span class="keyword">int</span>&gt; Map[<span class="number">1</span> &lt;&lt; B];</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">map</span> <span class="params">(ull x)</span> </span>&#123; <span class="keyword">return</span> Map[x &amp; Bl][x &gt;&gt; B]; &#125;</span><br></pre></td></tr></table></figure>
<p>本地测最慢跑了将近 3s ，交上去，它过了。。。过了。。。。了。。。</p>
<p>看了看题解，发现这个正解就是把 map 换成哈希表？不会吧不会吧。（不过为什么我完全没有想到用哈希表啊？）</p>
<p>说起来也是，这题 2G 的空间原来是这个意图。。。</p>
<h3 id="泳池">泳池</h3>
<p>显然问题要转换为求最大面积不超过 <span class="math inline">\(K\)</span> 的概率，设随机变量 <span class="math inline">\(H_i\)</span> 表示第 <span class="math inline">\(i\)</span> 列的安全高度，不难得到 <span class="math inline">\(H_i\)</span> 的分布。</p>
<p>一开始想的是 <span class="math inline">\(O(n!)\)</span> 枚举所有 <span class="math inline">\(H\)</span> 的相对大小顺序然后计算，很快发现可以 DP ，设 <span class="math inline">\(f_{n,m}\)</span> 表示考虑 <span class="math inline">\(n\)</span> 列，这 <span class="math inline">\(n\)</span> 列最小值不小于 <span class="math inline">\(m\)</span> 的满足条件的概率，转移枚举最左边的最小值的位置和值即可，这个 DP 不需要任何优化就可以得到 70 分。一开始以为它的复杂度是 <span class="math inline">\(O(n^3)\)</span> 甚至 <span class="math inline">\(O(n^4)\)</span> 级别，冷静分析发现有调和级数，实际上不超过 <span class="math inline">\(O(n^2\log^2)\)</span> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, ll q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (K &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> h[<span class="number">0</span>] = mod + <span class="number">1</span> - q;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= K; x ++)</span><br><span class="line">        h[x] = h[x - <span class="number">1</span>] * q % mod;</span><br><span class="line">    <span class="built_in">std</span>::fill(f[<span class="number">0</span>], f[<span class="number">0</span>] + K + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; n ++) &#123;</span><br><span class="line">     <span class="built_in">std</span>::fill(f[n], f[n] + K + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; n * m &lt;= K; m ++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = m; n * x &lt;= K; x ++)</span><br><span class="line">                    (f[n][m] += h[x] * f[i - <span class="number">1</span>][x + <span class="number">1</span>] % mod * f[n - i][x]) %= mod;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[N][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉正解应该是 <span class="math inline">\(O(K^2 \log N)\)</span> 的复杂度，比如常系数齐次线性递推之类的。</p>
<p>或者这个转移看上去很能扯上卷积，正解可能可以用生成函数推导？</p>
<h3 id="游戏">游戏</h3>
<p>这道题学 2-sat 的时候做过了，题目的限制摆明了就是 2-sat ，只有形如 x 的地图不好处理，初看只能 <span class="math inline">\(O(3^d)\)</span> 枚举，但实际上只要随便枚举两种状态就能涵盖所有情况，因此带上个 <span class="math inline">\(O(2^d)\)</span> 就好了。</p>
<h3 id="蔬菜">蔬菜</h3>
<p><span class="math inline">\(x_i = 0\)</span> 的话显然把每个蔬菜的第一个拆出来然后全部排一遍序就行了，数据表上这个做法只有 20 分，但实际上直接这样做就有 44 分。。。i 了 i 了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = read, m = read, q = read;</span><br><span class="line">    <span class="keyword">int</span> pp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> a = read, s = read, c = read, x = read;</span><br><span class="line">      p[++ pp] = par(a, c - <span class="number">1</span>);</span><br><span class="line">     p[++ pp] = par(a + s, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + pp + <span class="number">1</span>);</span><br><span class="line">   p[<span class="number">0</span>] = par(<span class="number">0</span>, <span class="number">1000000000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i ++) &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">         <span class="keyword">while</span> (!p[pp].second) -- pp;</span><br><span class="line">         -- p[pp].second;</span><br><span class="line">          ans[i] += p[pp].first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">      <span class="keyword">int</span> d = read;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[d]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步地，可以把每种蔬菜拆成 <span class="math inline">\(c\)</span> 个单位蔬菜，每个单位蔬菜可以用二元组 <span class="math inline">\((a, T)\)</span> 表示，其中 <span class="math inline">\(a\)</span> 是收益，<span class="math inline">\(T\)</span> 是该蔬菜消失的时间。那么把所有单位蔬菜排序然后暴力贪心，单位蔬菜的数量理论上来说是没有保证的，但神奇的事随便减减枝直接搞就能得到 <span class="math inline">\(p \le 10^3\)</span> 的所有 80 分部分分，结合之前 <span class="math inline">\(x_i = 0\)</span> 的做法可以得到 88 分。</p>
<p>有理有据的做法也是有的，理论上把所有单位蔬菜拿出来不现实，但考虑到需要做的是把单位蔬菜排序，不妨把来源相同的单位蔬菜绑定在一起，用堆维护起来。注意到来源相同的单位蔬菜 <span class="math inline">\(a\)</span> 相同，用 <span class="math inline">\(T\)</span> 最大的单位蔬菜代表这些来源相同的蔬菜。一个非常重要的性质是，如果单位蔬菜 <span class="math inline">\((a, T)\)</span> 无法加入当前答案，那么它永远无法被加入之后的任何一个答案。推广到一些来源相同的蔬菜，如果 <span class="math inline">\(T\)</span> 最大的单位蔬菜无法被加入到当前答案，那么这些来源相同的所有蔬菜都可以扔掉。</p>
<p>这样一来就可以做到 <span class="math inline">\(O((n + pm)\log + (pm)^2)\)</span> 的复杂度，瓶颈部分 <span class="math inline">\(O((np)^2)\)</span> 在于每次暴力添加一个蔬菜到当前答案集合，事实上这个完全可以用数据结构优化，但是感觉也拿不到 <span class="math inline">\(10^5\)</span> 的部分分，所以就写了暴力。</p>
<p>下面的代码是 80 分代码（没有处理 <span class="math inline">\(x_i = 0\)</span> 的部分分）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line">ll ans[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cai</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> a, c, x, t;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">las</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (t) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">return</span> x ? (c + x - <span class="number">1</span>) / x : <span class="number">1000000000</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (cai a, cai b) &#123;</span><br><span class="line"> <span class="keyword">return</span> a.a == b.a ? a.las() &lt; b.las() : a.a &lt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, tim[maxn], tp, minT;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> t)</span> </span>&#123; <span class="keyword">return</span> t &gt;= minT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    tim[++ tp] = t;</span><br><span class="line">   <span class="built_in">std</span>::sort(tim + <span class="number">1</span>, tim + tp + <span class="number">1</span>); <span class="comment">// 懒</span></span><br><span class="line"> minT = tp / M * M;</span><br><span class="line">    <span class="keyword">while</span> (minT &gt;= <span class="number">0</span> <span class="keyword">and</span> tim[minT] != minT / M) minT -= M;</span><br><span class="line">   minT = minT &gt;= <span class="number">0</span> ? tim[minT] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> K = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> n = read, m = read, q = read;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;cai&gt; qu;</span><br><span class="line">    M = m;</span><br><span class="line">    qu.push(&#123;<span class="number">0</span>, <span class="number">1000000000</span>, <span class="number">0</span>, <span class="number">1000000000</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> a = read, s = read, c = read, x = read;</span><br><span class="line">      cai tmp = &#123;a, c - <span class="number">1</span>, x, <span class="number">0</span>&#125;;</span><br><span class="line">     qu.push(tmp);</span><br><span class="line">     ++ tmp.c;</span><br><span class="line">     qu.push(&#123;s + a, <span class="number">1</span>, <span class="number">0</span>, tmp.las()&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K * m; i ++) &#123;</span><br><span class="line">     cai tmp = qu.top();</span><br><span class="line">       qu.pop();</span><br><span class="line">     <span class="keyword">while</span> (tmp.c &lt;= <span class="number">0</span> <span class="keyword">or</span> !check(tmp.las()))</span><br><span class="line">          tmp = qu.top(), qu.pop();</span><br><span class="line">     ans[i] = ans[i - <span class="number">1</span>] + tmp.a;</span><br><span class="line">      add(tmp.las());</span><br><span class="line">       <span class="keyword">if</span> (tmp.c &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         -- tmp.c;</span><br><span class="line">         qu.push(tmp);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q --) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="keyword">int</span>(read) * m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分身术">分身术</h3>
<p>计算几何啥也不会，暴力求凸包，只能拿 20 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = read, q = read;</span><br><span class="line">  ll ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(P[i].x, P[i].y);</span><br><span class="line">  <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">      <span class="keyword">int</span> m = read;</span><br><span class="line">        <span class="built_in">std</span>::fill(mark, mark + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) mark[<span class="number">1</span> + (ans + <span class="keyword">int</span>(read)) % n] = <span class="number">1</span>;</span><br><span class="line">      m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span> (!mark[i]) p[++ m] = P[i];</span><br><span class="line">     <span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, [] (point a, point b) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">             &#125;);</span><br><span class="line">      <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         <span class="keyword">while</span> (p1 &gt;= <span class="number">2</span> <span class="keyword">and</span> cross(st1[p1] - st1[p1 - <span class="number">1</span>], p[i] - st1[p1]) &gt;= <span class="number">0</span>) -- p1;</span><br><span class="line">          st1[++ p1] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + m + <span class="number">1</span>, [] (point a, point b) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &lt; b.x;</span><br><span class="line">             &#125;);</span><br><span class="line">      <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         <span class="keyword">while</span> (p2 &gt;= <span class="number">2</span> <span class="keyword">and</span> cross(st2[p2] - st2[p2 - <span class="number">1</span>], p[i] - st2[p2]) &lt;= <span class="number">0</span>) -- p2;</span><br><span class="line">          st2[++ p2] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2) st1[++ p1] = st2[p2 --];</span><br><span class="line">      st1[p1 + <span class="number">1</span>] = st1[<span class="number">1</span>];</span><br><span class="line">     ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= p1; i ++)</span><br><span class="line">           ans -= cross(st1[i] - st1[<span class="number">1</span>], st1[i + <span class="number">1</span>] - st1[i]);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(k = 1\)</span> 似乎很有性质，预先求出凸包，如果删除的点不在凸包上可以忽略，否则能被新加入的点一定在一个三角形的区域内，而每个不在凸包的点至多属于两个不同的三角形区域，那么可以在每个三角形区域内再求一次凸包。</p>
<p>说是这么说，要实现感觉有点麻烦，咕咕咕。</p>
<p><del>听说这题的 idea 是 picks 出的。</del></p>
<h2 id="noi2018">NOI2018</h2>
<p>0 + 100 + 84 + 100 + 100 + 45 + 15 = 444</p>
<p>集训队线 452 。</p>
<h3 id="归程">归程</h3>
<p>如果允许离线，不难想到可以把边按 <span class="math inline">\(a\)</span> 排序，把询问按 <span class="math inline">\(p\)</span> 排序，预处理个最短路然后不断加边，用并查集维护每个点的答案，可以得到 65 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">  freopen(<span class="string">&quot;return.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   freopen(<span class="string">&quot;return.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read, m = read;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) G[u].clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         <span class="keyword">int</span> u = read, v = read, w = read, h = read;</span><br><span class="line">          G[u].push_back(&#123;v, w&#125;);</span><br><span class="line">         G[v].push_back(&#123;u, w&#125;);</span><br><span class="line">         e2[i] = &#123;u, v, h&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">        dijkstra(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> q = read, K = read, H = read;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">         <span class="keyword">int</span> s = read, h = read;</span><br><span class="line">          qu[i] = &#123;s, h, i&#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">std</span>::sort(e2 + <span class="number">1</span>, e2 + m + <span class="number">1</span>, [] (Edge2 a, Edge2 b) &#123;</span><br><span class="line">                  <span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">             &#125;);</span><br><span class="line">      <span class="built_in">std</span>::sort(qu + <span class="number">1</span>, qu + q + <span class="number">1</span>, [] (Query a, Query b) &#123;</span><br><span class="line">                  <span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) fa[u] = u;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">          <span class="keyword">while</span> (j &lt;= m <span class="keyword">and</span> e2[j].h &gt; qu[i].h) &#123;</span><br><span class="line">               <span class="keyword">int</span> u = find(e2[j].u), v = find(e2[j].v);</span><br><span class="line">                ++ j;</span><br><span class="line">             <span class="keyword">if</span> (dis[u] &lt; dis[v]) fa[v] = u;</span><br><span class="line">               <span class="keyword">else</span> fa[u] = v;</span><br><span class="line">          &#125;</span><br><span class="line">            ans[qu[i].id] = dis[find(qu[i].s)];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强制在线似乎可以直接把加边的过程可持久化，来一手可持久化并查集？</p>
<p>太麻烦了没写，还可以用 kruskarl 重构树，对于询问倍增到重构树上的点，然后求个子树 min 即可，写的时候重构树的点数只开到了 n ，WA 了几次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200005</span>, maxm = <span class="number">400005</span>, maxk = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxk = <span class="number">19</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> v, w; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn + maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge2</span> &#123;</span> <span class="keyword">int</span> u, v, h; &#125; e2[maxm];</span><br><span class="line"><span class="keyword">int</span> fa[maxk][maxn + maxm], top[maxn + maxm], minh[maxn + maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> top[x] == x ? x : top[x] = find(top[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;par&gt; q;</span><br><span class="line"> <span class="built_in">std</span>::fill(dis, dis + n + <span class="number">1</span>, <span class="number">2000000000</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">   q.push(par(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top().second, d = -q.top().first;</span><br><span class="line">      q.pop();</span><br><span class="line">      <span class="keyword">if</span> (d &gt; dis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G[u])</span><br><span class="line">          <span class="keyword">if</span> (dis[u] + e.w &lt; dis[e.v]) &#123;</span><br><span class="line">               dis[e.v] = dis[u] + e.w;</span><br><span class="line">              q.push(par(-dis[e.v], e.v));</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line"> freopen(<span class="string">&quot;return.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   freopen(<span class="string">&quot;return.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read, m = read;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) G[u].clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         <span class="keyword">int</span> u = read, v = read, w = read, h = read;</span><br><span class="line">          G[u].push_back(&#123;v, w&#125;);</span><br><span class="line">         G[v].push_back(&#123;u, w&#125;);</span><br><span class="line">         e2[i] = &#123;u, v, h&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">        dijkstra(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">std</span>::sort(e2 + <span class="number">1</span>, e2 + m + <span class="number">1</span>, [] (Edge2 a, Edge2 b) &#123;</span><br><span class="line">                  <span class="keyword">return</span> a.h &gt; b.h;</span><br><span class="line">             &#125;);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) top[u] = u, minh[u] = <span class="number">2000000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> np = n;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         <span class="keyword">int</span> u = find(e2[i].u), v = find(e2[i].v);</span><br><span class="line">            <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">           ++ np;</span><br><span class="line">            fa[<span class="number">0</span>][u] = fa[<span class="number">0</span>][v] = np;</span><br><span class="line">         fa[<span class="number">0</span>][np] = <span class="number">0</span>;</span><br><span class="line">            top[u] = top[v] = top[np] = np;</span><br><span class="line">           minh[np] = e2[i].h;</span><br><span class="line">           dis[np] = <span class="built_in">std</span>::min(dis[u], dis[v]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = np; x; x --)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; Maxk; k ++)</span><br><span class="line">              fa[k][x] = fa[k - <span class="number">1</span>][fa[k - <span class="number">1</span>][x]];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> q = read, K = read, S = read, ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = read, h = read;</span><br><span class="line">          <span class="keyword">if</span> (K) x = <span class="number">1</span> + (x + ans - <span class="number">1</span>) % n, h = (h + ans) % (S + <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k = Maxk - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">             <span class="keyword">if</span> (fa[k][x] <span class="keyword">and</span> minh[fa[k][x]] &gt; h)</span><br><span class="line">                 x = fa[k][x];</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans = dis[x]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序">冒泡排序</h3>
<p>稍加分析，不难发现一个排列 <span class="math inline">\(p\)</span> 是“好”的，当且仅当：</p>
<ul>
<li><span class="math inline">\(\forall j &lt; i \le p_i, p_j &lt; p_i\)</span></li>
<li><span class="math inline">\(\forall j &gt; i \ge p_i, p_j &gt; p_i\)</span></li>
</ul>
<p>直接拿这个写个状压 DP ，可以得到 44 分，代码略。</p>
<p>对于 <span class="math inline">\(q_i = i\)</span> 的情况，打个表不难发现就是卡特兰数，理论上结合上面做法可以得到 56 分，但实际上并没有这样的数据？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">  freopen(<span class="string">&quot;inverse.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">&quot;inverse.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; maxn) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) read.<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line">          ll ans = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">             (ans *= <span class="number">4</span> * i - <span class="number">2</span>) %= mod;</span><br><span class="line">                (ans *= power(i + <span class="number">1</span>, <span class="number">-1</span>)) %= mod;</span><br><span class="line">         &#125;</span><br><span class="line">            -- ans;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) p[i] = read - <span class="number">1</span>;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); S ++) &#123;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">-1</span>, max = <span class="number">0</span>, X = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x ++)</span><br><span class="line">             <span class="keyword">if</span> (S &gt;&gt; x &amp; <span class="number">1</span>)</span><br><span class="line">                    ++ i, max = x;</span><br><span class="line">            <span class="keyword">while</span> (S &gt;&gt; X &amp; <span class="number">1</span>) ++ X;</span><br><span class="line">           f[S] = g[S] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x ++)</span><br><span class="line">             <span class="keyword">if</span> (S &gt;&gt; x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">if</span> (x &lt;= i) ok &amp;= x &lt; X;</span><br><span class="line">                   <span class="keyword">if</span> (x &gt;= i) ok &amp;= x == max;</span><br><span class="line">                   <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                       f[S] += f[S ^ (<span class="number">1</span> &lt;&lt; x)];</span><br><span class="line">                        <span class="keyword">if</span> (x == p[i]) g[S] += g[S ^ (<span class="number">1</span> &lt;&lt; x)];</span><br><span class="line">                        <span class="keyword">if</span> (x &gt; p[i]) f[S] += g[S ^ (<span class="number">1</span> &lt;&lt; x)];</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            f[S] %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冷静下来，拿上面的性质进一步分析，发现一个排列是“好”的当且仅当它可以划分成两个上升子序列，也等价于最长下降子序列的长度不超过 2 。</p>
<p>这个性质就好用很多，比如可以直接证明不考虑字典序的答案确实是卡特兰数：</p>
<p>设计 DP <span class="math inline">\(f_{i, j}\)</span> 表示 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(i\)</span> 的排列，包含右端点的最大上升子段长度为 <span class="math inline">\(j\)</span> 的“好”排列数，转移新插入一个最大值，不难得到 <span class="math inline">\(f_{i, j} = \sum_{k \ge j-1} f_{i-1, k} = f_{i-1, j-1} + f_{i, j+1}\)</span> ，特别的是 <span class="math inline">\(f_{0,1}=1, f_{i,0}=0\)</span> 。这个时候稍有经验就会知道这个 DP 转移可以放在二维平面上，而 <span class="math inline">\(f_{i,0}=0\)</span> 的限制就是平面上的一条直线，不经过一条直线的路径数恰恰就是卡特兰数。</p>
<p>但是如果从小到大加数的话字典序的比较就难以压缩在状态里，不妨直接枚举 <span class="math inline">\(p, q\)</span> 的 lcp 以及 lcp 后面的一位，然后相当于确定了上述 DP 的一个初始状态，放在二维平面上利用折线法计算即可，可以得到 80 分，结合 <span class="math inline">\(p_i = i\)</span> 的情况理论上有 84 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll _path (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"> <span class="keyword">if</span> (x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[x + y] * ifac[x] % mod * ifac[y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">path</span> <span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span> </span>&#123;</span><br><span class="line">   ll tmp = _path(x1 - x0, y1 - y0) - _path(x1 - x0 - <span class="number">1</span>, y1 - y0 + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> tmp &lt; <span class="number">0</span> ? tmp + mod : tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">  freopen(<span class="string">&quot;inverse.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">&quot;inverse.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"> ifac[N] = power(fac[N], <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i --) ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) p[i] = read;</span><br><span class="line">       ll ans = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">std</span>::fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">set</span>.insert(i);</span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::max(p[i], x) + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">              <span class="keyword">if</span> (!vis[j]) &#123;</span><br><span class="line">                  <span class="keyword">int</span> _m = <span class="built_in">std</span>::max(m, j);</span><br><span class="line">                   <span class="built_in">set</span>.erase(j);</span><br><span class="line">                   <span class="keyword">int</span> k = *<span class="built_in">set</span>.begin();</span><br><span class="line">                  <span class="built_in">set</span>.insert(j);</span><br><span class="line">                  <span class="keyword">if</span> (k &lt; x <span class="keyword">or</span> (k &lt; j <span class="keyword">and</span> j &lt; m)) <span class="keyword">continue</span>;</span><br><span class="line">                    ans += path(_m, i, n, n);</span><br><span class="line">             &#125;</span><br><span class="line">            vis[p[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &lt; x) <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">if</span> (p[i] &lt; m) x = p[i];</span><br><span class="line">           <span class="keyword">else</span> m = p[i];</span><br><span class="line">           <span class="built_in">set</span>.erase(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans % mod);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法的瓶颈在于 <span class="math inline">\(O(n^2)\)</span> 枚举字典序的比较情况，再往下优化必然要用更巧妙的方式处理字典序比较，或者干脆抛弃从小到大加数的思路？</p>
<h3 id="你的名字">你的名字</h3>
<p><span class="math inline">\(l = 1, r = |S|\)</span> 的话，把 <span class="math inline">\(s\)</span> 建 SAM ，再把每个 <span class="math inline">\(t\)</span> 也建 SAM ，同时把 <span class="math inline">\(t\)</span> 放进 <span class="math inline">\(s\)</span> 的 SAM 里跑，得到 <span class="math inline">\(t\)</span> 的每个前缀在两个 SAM 里面分别对应的节点，然后在 <span class="math inline">\(t\)</span> 的 SAM 上跳 fail 算贡献即可，可以得到 68 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line"> freopen(<span class="string">&quot;name.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"> freopen(<span class="string">&quot;name.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, las = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">       las = insert(<span class="number">1</span>, las, s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">   tpos[<span class="number">0</span>] = ++ cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = read;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> l = read, r = read, m = <span class="keyword">int</span>(<span class="built_in">strlen</span>(t + <span class="number">1</span>));</span><br><span class="line">       <span class="keyword">if</span> (l != <span class="number">1</span> <span class="keyword">and</span> r != n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       cp = tpos[<span class="number">0</span>];</span><br><span class="line">     <span class="built_in">memset</span>(ch[cp], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[cp]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            tpos[i] = insert(tpos[<span class="number">0</span>], tpos[i - <span class="number">1</span>], t[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="built_in">std</span>::fill(vis + tpos[<span class="number">0</span>], vis + cp + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = <span class="number">1</span>, le = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (u <span class="keyword">and</span> !ch[u][x]) u = fa[u], le = len[u];</span><br><span class="line">         <span class="keyword">if</span> (u) u = ch[u][x], ++ le;</span><br><span class="line">          <span class="keyword">else</span> u = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> v = tpos[i], vlen = len[v], flen = vlen;</span><br><span class="line">         <span class="keyword">while</span> (!vis[v]) vis[v] = <span class="number">1</span>, v = fa[v], flen = len[v];</span><br><span class="line">            ans += vlen - <span class="built_in">std</span>::max(flen, le);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个做法推广到任意区间也不难，把 <span class="math inline">\(s\)</span> 的 SAM 节点的 right 集合处理出来，然后每次算贡献的时候查 right 集合在区间内最靠右的点然后得到实际匹配长度即可。但是 right 集合不能显式地建出来，一般有两种方式，一个是离线下来挂在对应位置然后 set 启发式合并，还有一种是线段树合并。后者唯一的缺点是空间开销较大，但是其他地方都很优秀，并且还能支持更多操作。</p>
<p>复杂度 <span class="math inline">\(O(n\log)\)</span> 级别，实现的细节比我想象中的要多，调了一段时间才过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>, maxd = <span class="number">2000005</span>, maxc = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxd];</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"><span class="keyword">int</span> ch[maxd][maxc], fa[maxd], len[maxd], cp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxd];</span><br><span class="line"><span class="keyword">int</span> spos[maxn], tpos[maxn];</span><br><span class="line"><span class="keyword">int</span> seg[maxd];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> lti, rti;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">&#125; pool[maxn * <span class="number">60</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> self pool[now]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++ pp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">int</span> an, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!an) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!now) <span class="keyword">return</span> now = an, <span class="keyword">void</span>();</span><br><span class="line"> pool[newnode()] = self;</span><br><span class="line">   now = pp;</span><br><span class="line"> self.max = <span class="built_in">std</span>::max(self.max, pool[an].max);</span><br><span class="line">    <span class="keyword">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  merge(self.lti, pool[an].lti, L, M);</span><br><span class="line">  merge(self.rti, pool[an].rti, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lain</span> <span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!now) now = newnode();</span><br><span class="line">   self.max = <span class="built_in">std</span>::max(self.max, p);</span><br><span class="line">   <span class="keyword">if</span> (L == R) <span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (p &lt;= M) lain(self.lti, L, M, p);</span><br><span class="line">  <span class="keyword">else</span> lain(self.rti, M + <span class="number">1</span>, R, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (r &lt; L <span class="keyword">or</span> l &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L <span class="keyword">and</span> R &lt;= r) <span class="keyword">return</span> self.max;</span><br><span class="line">  <span class="keyword">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::max(query(self.lti, L, M, l, r), query(self.rti, M + <span class="number">1</span>, R, l, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> now = ++ cp;</span><br><span class="line"> len[now] = len[pre] + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(ch[now], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[now]);</span><br><span class="line">    <span class="keyword">while</span> (pre <span class="keyword">and</span> !ch[pre][x]) ch[pre][x] = now, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span> (pre) &#123;</span><br><span class="line">      <span class="keyword">int</span> preto = ch[pre][x];</span><br><span class="line">      <span class="keyword">if</span> (len[preto] == len[pre] + <span class="number">1</span>) fa[now] = preto;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> sp = ++ cp;</span><br><span class="line">          len[sp] = len[pre] + <span class="number">1</span>;</span><br><span class="line">           fa[sp] = fa[preto];</span><br><span class="line">           <span class="built_in">memcpy</span>(ch[sp], ch[preto], <span class="keyword">sizeof</span> ch[sp]);</span><br><span class="line">          <span class="keyword">while</span> (pre <span class="keyword">and</span> ch[pre][x] == preto) ch[pre][x] = sp, pre = fa[pre];</span><br><span class="line">         fa[now] = fa[preto] = sp;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> fa[now] = rt;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">       dfs(v, n);</span><br><span class="line">        merge(seg[u], seg[v], <span class="number">1</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line"> freopen(<span class="string">&quot;name.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"> freopen(<span class="string">&quot;name.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">int</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, las = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        las = insert(<span class="number">1</span>, las, s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">       lain(seg[las], <span class="number">1</span>, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cp; i ++)</span><br><span class="line">       G[fa[i]].push_back(i);</span><br><span class="line">    dfs(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  tpos[<span class="number">0</span>] = ++ cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = read;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> l = read, r = read, m = <span class="keyword">int</span>(<span class="built_in">strlen</span>(t + <span class="number">1</span>));</span><br><span class="line">       cp = tpos[<span class="number">0</span>];</span><br><span class="line">     <span class="built_in">memset</span>(ch[cp], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[cp]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            tpos[i] = insert(tpos[<span class="number">0</span>], tpos[i - <span class="number">1</span>], t[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">     <span class="built_in">std</span>::fill(vis + tpos[<span class="number">0</span>], vis + cp + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = <span class="number">1</span>, le = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (u <span class="keyword">and</span> !ch[u][x]) u = fa[u], le = len[u];</span><br><span class="line">         <span class="keyword">if</span> (u) u = ch[u][x], ++ le;</span><br><span class="line">          <span class="keyword">else</span> u = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> R = query(seg[u], <span class="number">1</span>, n, l, r);</span><br><span class="line">           <span class="keyword">while</span> (!R <span class="keyword">or</span> R - l + <span class="number">1</span> &lt;= len[fa[u]])</span><br><span class="line">                u = fa[u], le = len[u], R = query(seg[u], <span class="number">1</span>, n, l, r);</span><br><span class="line">            le = R ? <span class="built_in">std</span>::min(le, R - l + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> v = tpos[i], vlen = len[v], flen = vlen;</span><br><span class="line">         <span class="keyword">while</span> (!vis[v]) vis[v] = <span class="number">1</span>, v = fa[v], flen = len[v];</span><br><span class="line">            ans += vlen - <span class="built_in">std</span>::max(flen, le);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="屠龙勇士">屠龙勇士</h3>
<p>注意到每条龙使用的剑是完全确定的，所有限制都是同余方程，直接 exCRT/exgcd ，但是会爆 long long ，需要非常注意，在特定地方使用快速乘。</p>
<p>还要注意剑的攻击力可能相同，用 <code>std::multiset</code> 存储而不是 <code>std::set</code> 。</p>
<p>出题人的意图可能是要考察选手对代码细节的掌控？反正我是调了好久。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">  freopen(<span class="string">&quot;dragon.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   freopen(<span class="string">&quot;dragon.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read, s = read;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(p[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(aw[i]);</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;ll&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">while</span> (s --) <span class="built_in">set</span>.insert(read);</span><br><span class="line"></span><br><span class="line">       ll min = <span class="number">0</span>, B = <span class="number">0</span>, M = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">         <span class="keyword">auto</span> it = <span class="built_in">set</span>.upper_bound(a[i]);</span><br><span class="line">           <span class="keyword">if</span> (it != <span class="built_in">set</span>.begin()) -- it;</span><br><span class="line">          <span class="keyword">int</span> t = <span class="keyword">int</span>(*it);</span><br><span class="line">           <span class="built_in">set</span>.erase(it);</span><br><span class="line">          <span class="built_in">set</span>.insert(aw[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!p[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ll x, y, g = exgcd(t, p[i], x, y);</span><br><span class="line">            <span class="keyword">if</span> (a[i] % g) <span class="keyword">goto</span> fail;</span><br><span class="line">            ll m = p[i] / g, b = mul(x, a[i] % p[i] / g, m);</span><br><span class="line">          <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b += m;</span><br><span class="line"></span><br><span class="line">          g = exgcd(m, M, x, y);</span><br><span class="line">            ll d = B - b;</span><br><span class="line">         <span class="keyword">if</span> (d % g) <span class="keyword">goto</span> fail;</span><br><span class="line">           d /= g;</span><br><span class="line">           M *= m / g;</span><br><span class="line">           B = (b + mul(mul(x, m, M), d, M)) % M;</span><br><span class="line">            <span class="keyword">if</span> (B &lt; <span class="number">0</span>) B += M;</span><br><span class="line"></span><br><span class="line">          min = <span class="built_in">std</span>::max(min, (a[i] + t - <span class="number">1</span>) / t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (B &lt; min) &#123;</span><br><span class="line">           ll d = (min - B + M - <span class="number">1</span>) / M;</span><br><span class="line">         B += d * M;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, B);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">fail:</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="情报中心">情报中心</h3>
<p>观察了下数据表，意识到这题要拿部分分必须从特殊性质下手。</p>
<p>暴力直接 <span class="math inline">\(O(n^3)\)</span> 该咋枚举咋枚举，15 分。</p>
<p>链的话可以正反来两次扫描线，由于每条边都是非负权值，算入一个的少了边的方案不会影响答案，15 分。</p>
<p><span class="math inline">\(c_i=0\)</span> 就只要考虑路径的代价，枚举每一条边，用 set 启发式合并求出经过每条边最小的两条路径，15 分。</p>
<p>剩下两个 <span class="math inline">\(S_1, S_2\)</span> 实在是写不动了。</p>
<p>大样例确实很给力，但是这部分分必须一个一个写，每个部分分的分值不高，太难受了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FORCE &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">305</span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;maxn&gt; bs[maxn], bm[maxn];</span><br><span class="line">   <span class="function">ll <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; u ++) &#123;</span><br><span class="line">         bs[u] = bs[fa[u]];</span><br><span class="line">            bs[u].<span class="built_in">set</span>(si(u));</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            bm[i] = bs[ma[i]] ^ bs[mb[i]];</span><br><span class="line">        ll ans = -inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++) &#123;</span><br><span class="line">              <span class="keyword">if</span> ((bm[i] &amp; bm[j]).any()) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;maxn&gt; b = bm[i] | bm[j];</span><br><span class="line">                    ll now = - mc[i] - mc[j];</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">                        <span class="keyword">if</span> (b.test(si(k)))</span><br><span class="line">                           now += fw[k];</span><br><span class="line">                 ans = <span class="built_in">std</span>::max(ans, now);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CHAIN &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve[maxn];</span><br><span class="line"> ll s[maxn];</span><br><span class="line">   ll bit[maxn];</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> n, ll x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> k = p; k &lt;= n; k += k &amp; -k)</span><br><span class="line">         bit[k] = <span class="built_in">std</span>::max(bit[k], x);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">     ll res = -inf-inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = p; k; k -= k &amp; -k)</span><br><span class="line">         res = <span class="built_in">std</span>::max(res, bit[k]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">ll <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + fw[i];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ve[i].clear();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (ma[i] &gt; mb[i]) <span class="built_in">std</span>::swap(ma[i], mb[i]);</span><br><span class="line">         <span class="comment">/* mc[i] += s[mb[i]] - s[ma[i]]; */</span></span><br><span class="line">          ve[mb[i]].push_back(i);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> R = <span class="number">1</span>; R &lt;= n; R ++)</span><br><span class="line">            <span class="built_in">std</span>::sort(ve[R].begin(), ve[R].end(), [] (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ma[i] &gt; ma[j];</span><br><span class="line">                 &#125;);</span><br><span class="line">      <span class="built_in">std</span>::fill(bit, bit + n + <span class="number">1</span>, -inf-inf);</span><br><span class="line">      ll ans = -inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> R = <span class="number">1</span>; R &lt;= n; R ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ve[R]) &#123;</span><br><span class="line">              ans = <span class="built_in">std</span>::max(ans, -mc[i] + s[mb[i]] - s[ma[i]] + query(n - ma[i]));</span><br><span class="line">               modify(n - ma[i], n, -mc[i]);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">std</span>::fill(bit, bit + n + <span class="number">1</span>, -inf-inf);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> R = n; R; R --)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : ve[R]) &#123;</span><br><span class="line">              ans = <span class="built_in">std</span>::max(ans, -mc[i] - s[ma[i]] + query(mb[i] - <span class="number">1</span>));</span><br><span class="line">              modify(ma[i], n, -mc[i] + s[mb[i]]);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> C0 &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">20</span>, Maxk = <span class="number">18</span>;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;ll&gt; a[maxn], b[maxn];</span><br><span class="line"> <span class="keyword">int</span> fa[maxk][maxn], deep[maxn];</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">lca</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (deep[x] &lt; deep[y]) <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = Maxk - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">         <span class="keyword">if</span> (deep[fa[k][x]] &gt;= deep[y])</span><br><span class="line">                x = fa[k][x];</span><br><span class="line">     <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> k = Maxk - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">         <span class="keyword">if</span> (fa[k][x] != fa[k][y])</span><br><span class="line">                x = fa[k][x], y = fa[k][y];</span><br><span class="line">       <span class="keyword">return</span> ::fa[x];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">ll <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) &#123;</span><br><span class="line">         deep[u] = deep[::fa[u]] + <span class="number">1</span>;</span><br><span class="line">          fa[<span class="number">0</span>][u] = ::fa[u];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; Maxk; k ++) fa[k][u] = fa[k - <span class="number">1</span>][fa[k - <span class="number">1</span>][u]];</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = n; u; u --) a[u].clear(), b[u].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         a[ma[i]].insert(mc[i]);</span><br><span class="line">           a[mb[i]].insert(mc[i]);</span><br><span class="line">           <span class="keyword">int</span> c = lca(ma[i], mb[i]);</span><br><span class="line">           b[c].insert(mc[i]);</span><br><span class="line">           b[c].insert(mc[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        ll ans = inf;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> u = n; u; u --) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (a[v].size() &gt; a[u].size()) <span class="built_in">std</span>::swap(a[u], a[v]);</span><br><span class="line">               <span class="keyword">for</span> (ll x : a[v]) a[u].insert(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (ll x : b[u]) a[u].erase(a[u].find(x));</span><br><span class="line">          <span class="keyword">if</span> (a[u].size() &gt;= <span class="number">2</span>)</span><br><span class="line">             ans = <span class="built_in">std</span>::min(ans, *a[u].begin() + *(++a[u].begin()));</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> -ans;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      ++ Case;</span><br><span class="line">      <span class="keyword">int</span> n = read;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u ++) G[u].clear();</span><br><span class="line">      <span class="keyword">bool</span> _chain = <span class="number">1</span>, _c0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">          <span class="keyword">int</span> a = read, b = read;</span><br><span class="line">          G[fa[b] = a].push_back(b);</span><br><span class="line">            read(fw[b]);</span><br><span class="line">          _chain &amp;= a == b - <span class="number">1</span>;</span><br><span class="line">         _c0 &amp;= fw[b] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = read;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">         read(ma[i], mb[i], mc[i]);</span><br><span class="line">            <span class="keyword">if</span> (ma[i] == mb[i]) -- i, -- m;</span><br><span class="line">      &#125;</span><br><span class="line">        ll ans;</span><br><span class="line">       <span class="keyword">if</span> (_chain) ans = CHAIN::main(n, m);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (_c0) ans = C0::main(n, m);</span><br><span class="line">     <span class="keyword">else</span> ans = FORCE::main(n, m);</span><br><span class="line">        <span class="keyword">if</span> (ans == -inf) <span class="built_in">puts</span>(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了看知乎这题现场最高 45 分？</p>
<h3 id="多边形">多边形</h3>
<p>啊这，完全没有思路？想了几个小时都没想出 <span class="math inline">\(K=1\)</span> 的正确做法。认输了，写个爆搜，只有 15 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (G[u].empty()) <span class="keyword">return</span> le[++ lp] = u, <span class="keyword">void</span>();</span><br><span class="line">    <span class="built_in">std</span>::sort(G[u].begin(), G[u].end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) dfs(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u])</span><br><span class="line">          <span class="keyword">if</span> (v == <span class="number">1</span>)</span><br><span class="line">              ++ ans;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u])</span><br><span class="line">      <span class="keyword">if</span> (!vis[v])</span><br><span class="line">         force(v, n - <span class="number">1</span>);</span><br><span class="line">  vis[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;polygon.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  freopen(<span class="string">&quot;polygon.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = read, m = read;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; u ++) G[fa[u] = read].push_back(u);</span><br><span class="line">  dfs(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= n; u ++) G[u].push_back(fa[u]);</span><br><span class="line"> <span class="keyword">if</span> (lp &lt;= m * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lp; j ++)</span><br><span class="line">               <span class="keyword">if</span> (j != i)</span><br><span class="line">                  G[le[i]].push_back(le[j]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++) le[lp + i] = le[i];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; i ++)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= i + m; j ++) &#123;</span><br><span class="line">             G[le[i]].push_back(le[j]);</span><br><span class="line">                G[le[j]].push_back(le[i]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    force(<span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>妈的看来我树论完全不行啊，两道树题都没啥分，CSP 也吃了这个亏。</p>
<p>看了看别人写的题解发现 <span class="math inline">\(K=1\)</span> 竟然是一个被我毙掉的做法，<span class="math inline">\(O(2^3 n)\)</span> 的树形 DP ？</p>
<p>看了看知乎这题现场最高 50 分？（暴力 + <span class="math inline">\(K=1\)</span> ）。</p>
<h2 id="noi2019">NOI2019</h2>
<p>0 + 100 + 60 + 40 + 88 + 70 + 36 = 394</p>
<p>集训队线 477 。</p>
<h3 id="回家路线">回家路线</h3>
<p>不难想到对于路线设计一个 DP <span class="math inline">\(f_i\)</span> 表示使用到第 <span class="math inline">\(i\)</span> 条路线的最小代价。朴素转移要枚举起点上所有的路线。</p>
<p>考虑对于当前从 <span class="math inline">\(p\)</span> 开始的第 <span class="math inline">\(i\)</span> 条路径，如果从一个 <span class="math inline">\(q\)</span> 结束，代价为 <span class="math inline">\(t\)</span> 的路线转移，那么转移要最小化</p>
<p><span class="math display">\[A(p-q)^2 + B(p-q) + C + t\]</span></p>
<p>整理得到</p>
<p><span class="math display">\[(Ap^2 + Bp + C) + (Aq^2 - Bq + t) - (2Aq) p\]</span></p>
<p>第一个括号里面只与 <span class="math inline">\(p\)</span> 有关，后面两个括号只与 <span class="math inline">\(p, t\)</span> 有关，可以发现需要最小化的就是用斜率为 <span class="math inline">\(p\)</span> 的直线截 <span class="math inline">\((2Aq, Aq^2 - Bq + t)\)</span> 得到的截距。</p>
<p>那么用个凸包维护转移即可。</p>
<p>凸包里面要维护点的双端队列，我第一次写的时候在右移左端点的同时还左移了右端点，这么大的错竟然还能得 90 分？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">1005</span>, maxn = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxt = <span class="number">1000</span>, inf = <span class="number">2000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route</span> &#123;</span> <span class="keyword">int</span> s, t, p, q, id; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;;</span><br><span class="line">T <span class="keyword">operator</span> - (T a, T b) &#123; <span class="keyword">return</span> &#123;a.x - b.x, a.y - b.y&#125;; &#125;</span><br><span class="line"><span class="function">ll <span class="title">cross</span> <span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l * a.x * b.y - <span class="number">1l</span>l * a.y * b.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hull</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; st;</span><br><span class="line">  <span class="keyword">size_t</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">q</span> <span class="params">(T p, <span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> p.y - k * p.x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (b &gt;= st.size()) <span class="keyword">return</span> inf;</span><br><span class="line">      <span class="keyword">while</span> (b + <span class="number">1</span> &lt; st.size() <span class="keyword">and</span> q(st[b + <span class="number">1</span>], k) &lt;= q(st[b], k))</span><br><span class="line">          ++ b;</span><br><span class="line">     <span class="keyword">return</span> q(st[b], k);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(T p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">auto</span> sp = st.size();</span><br><span class="line">     <span class="keyword">if</span> (sp <span class="keyword">and</span> st[sp - <span class="number">1</span>].x == p.x <span class="keyword">and</span> st[sp - <span class="number">1</span>].y &lt; p.y) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">while</span> (sp &gt;= b + <span class="number">2</span> <span class="keyword">and</span> cross(st[sp - <span class="number">1</span>] - st[sp - <span class="number">2</span>],</span><br><span class="line">                    p - st[sp - <span class="number">1</span>]) &lt;= <span class="number">0</span>) st.pop_back(), -- sp;</span><br><span class="line">        st.push_back(p), ++ sp;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;route&gt; qu[maxt], ad[maxt];</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line">Hull h[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">  freopen(<span class="string">&quot;route.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;route.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = read, m = read, A = read, B = read, C = read;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> s = read, t = read, p = read, q = read;</span><br><span class="line">      qu[p].push_back(&#123;s, t, p, q, i&#125;);</span><br><span class="line">       ad[q].push_back(&#123;s, t, p, q, i&#125;);</span><br><span class="line">       f[i] = inf;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = inf;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= Maxt; t ++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (route r : ad[t]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (r.s == <span class="number">1</span>) f[r.id] = A * r.p * r.p + B * r.p + C;</span><br><span class="line">         <span class="keyword">if</span> (f[r.id] &lt; inf)</span><br><span class="line">                h[r.t].add(&#123;<span class="number">2</span> * A * r.q, A * r.q * r.q - B * r.q + f[r.id]&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (route r : qu[t]) &#123;</span><br><span class="line">         f[r.id] = h[r.s].query(r.p);</span><br><span class="line">          <span class="keyword">if</span> (f[r.id] &lt; inf) f[r.id] += A * r.p * r.p + B * r.p + C;</span><br><span class="line">            <span class="keyword">if</span> (r.t == n <span class="keyword">and</span> f[r.id] &lt; inf) ans = <span class="built_in">std</span>::min(ans, f[r.id] + r.q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人">机器人</h3>
<p>不难想到设计一个区间 DP <span class="math inline">\(f_{l,r,m}\)</span> 表示只考虑区间 <span class="math inline">\([l, r]\)</span> ，所有值不超过 <span class="math inline">\(m\)</span> 的合法方案有多少。转移枚举最靠右的最大值的位置，注意这个位置的数量是 <span class="math inline">\(O(1)\)</span> 的，因此总复杂度 <span class="math inline">\(O(n^2B)\)</span> ，可以得到 50 分。代码略。</p>
<p>对于 <span class="math inline">\(A, B\)</span> 全部相等的情况，不难证明答案是关于 <span class="math inline">\(B - A + 1\)</span> 的 <span class="math inline">\(n\)</span> 次多项式。把 <span class="math inline">\(B - A + 1\)</span> 从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(n\)</span> 的答案都通过上述 DP 算出来再拉格朗日插值即可，结合上述做法可以得到 60 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++) f[i][i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= lim; x ++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; l ++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (L[l] &lt;= x <span class="keyword">and</span> x &lt;= R[l]) ++ f[l][l];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> r = l + <span class="number">1</span>; r &lt;= n; r ++) &#123;</span><br><span class="line">             <span class="keyword">int</span> lm = (l + r - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, rm = (l + r + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lm; i &lt;= rm; i ++)</span><br><span class="line">                  <span class="keyword">if</span> (L[i] &lt;= x <span class="keyword">and</span> x &lt;= R[i])</span><br><span class="line">                      (f[l][r] += f[l][i - <span class="number">1</span>] * f[i + <span class="number">1</span>][r]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[x] = f[<span class="number">1</span>][n];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lage</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">     ll now = tmp[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">               (now *= mod + W - j) %= mod;</span><br><span class="line">              (now *= power(mod + i - j, <span class="number">-1</span>)) %= mod;</span><br><span class="line">           &#125;</span><br><span class="line">        res += now;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line"> freopen(<span class="string">&quot;robot.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;robot.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = read, W = <span class="number">1000000000</span>, test = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(L[i], R[i]), test &amp;= L[i] == <span class="number">1</span> <span class="keyword">and</span> R[i] == W;</span><br><span class="line">    <span class="keyword">if</span> (test)</span><br><span class="line">        dp(n, n), <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lage(n, W));</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     dp(n, <span class="number">10000</span>), <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tmp[<span class="number">10000</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列">序列</h3>
<p>第一眼不难想到一个 <span class="math inline">\(O(n^4)\)</span> 的 DP ，设 <span class="math inline">\(f_{i,j,k,p}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个，<span class="math inline">\(a,b,ab\)</span> 分别选了 <span class="math inline">\(j,k,p\)</span> 个，应该可以得到 28 分。</p>
<p>但不难发现如果确定了 <span class="math inline">\(L\)</span> 个 <span class="math inline">\(ab\)</span> 的选择，那么剩下的就是从大到小选，不妨假定 <span class="math inline">\(a\)</span> 单调不增，此时 DP 状态就没必要记录 <span class="math inline">\(j\)</span> 了，可以得到 40 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> T = read;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = read, K = read, L = read;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(p[i].first);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) read(p[i].second);</span><br><span class="line">     <span class="built_in">std</span>::sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>, <span class="built_in">std</span>::greater&lt;par&gt;());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i <span class="keyword">and</span> j &lt;= L; j ++)</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j + k &lt;= i <span class="keyword">and</span> k &lt;= K - L; k ++) &#123;</span><br><span class="line">                  <span class="keyword">int</span> a = i + L - j &lt;= K ? p[i].first : <span class="number">0</span>;</span><br><span class="line">                  f[i][j][k] = f[i - <span class="number">1</span>][j][k] + a;</span><br><span class="line">                  <span class="keyword">if</span> (j) chkmax(f[i][j][k], f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] + p[i].first + p[i].second);</span><br><span class="line">                    <span class="keyword">if</span> (k) chkmax(f[i][j][k], f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] + a + p[i].second);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n][L][K - L]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更高的分就不会了，写了个假贪心，样例都过不了。</p>
<p>去年同步赛还写了这题 60 分，今年完全想不到 <span class="math inline">\(O(n^2)\)</span> 做法？</p>
<p>正解大概是个模拟费用流吧。</p>
<h3 id="弹跳">弹跳</h3>
<p>题目显然是个最短路模型，需要优化建图，直接用 KDTree 松弛即可，空间线性。但是矩形查询的复杂度是根号的？只能跑 88 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">70005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span> <span class="keyword">int</span> w, L[<span class="number">2</span>], R[<span class="number">2</span>]; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KDT</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> lti, rti;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>], min[<span class="number">2</span>], max[<span class="number">2</span>];</span><br><span class="line">&#125; pool[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> self pool[now]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lt pool[self.lti]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt pool[self.rti]</span></span><br><span class="line"><span class="keyword">int</span> tmp[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;path&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmp_d;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> pool[a].p[cmp_d] &lt; pool[b].p[cmp_d]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    cmp_d = d; <span class="comment">// <span class="doctag">XXX:</span> 卧槽，这都能忘？</span></span><br><span class="line">  <span class="built_in">std</span>::nth_element(tmp + l, tmp + mid, tmp + r + <span class="number">1</span>, cmp);</span><br><span class="line"> <span class="keyword">int</span> now = tmp[mid];</span><br><span class="line">  self.lti = build(l, mid - <span class="number">1</span>, d ^ <span class="number">1</span>);</span><br><span class="line">  self.rti = build(mid + <span class="number">1</span>, r, d ^ <span class="number">1</span>);</span><br><span class="line">  self.min[<span class="number">0</span>] = <span class="built_in">std</span>::min(&#123;self.p[<span class="number">0</span>], lt.min[<span class="number">0</span>], rt.min[<span class="number">0</span>]&#125;);</span><br><span class="line">    self.max[<span class="number">0</span>] = <span class="built_in">std</span>::max(&#123;self.p[<span class="number">0</span>], lt.max[<span class="number">0</span>], rt.max[<span class="number">0</span>]&#125;);</span><br><span class="line">    self.min[<span class="number">1</span>] = <span class="built_in">std</span>::min(&#123;self.p[<span class="number">1</span>], lt.min[<span class="number">1</span>], rt.min[<span class="number">1</span>]&#125;);</span><br><span class="line">    self.max[<span class="number">1</span>] = <span class="built_in">std</span>::max(&#123;self.p[<span class="number">1</span>], lt.max[<span class="number">1</span>], rt.max[<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;par&gt; q;</span><br><span class="line"><span class="keyword">int</span> N, TOT;</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">2</span>], R[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">void</span> _relax (<span class="keyword">int</span> u, <span class="keyword">int</span> di) &#123;</span><br><span class="line">  <span class="keyword">if</span> (di &lt; dis[u]) &#123;</span><br><span class="line">       dis[u] = di;</span><br><span class="line">      q.push(par(-di, u));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relax</span> <span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> di)</span> </span>&#123;</span><br><span class="line">   ++ TOT;</span><br><span class="line">   <span class="keyword">if</span> (R[<span class="number">0</span>] &lt; self.min[<span class="number">0</span>] <span class="keyword">or</span> L[<span class="number">0</span>] &gt; self.max[<span class="number">0</span>] <span class="keyword">or</span></span><br><span class="line">          R[<span class="number">1</span>] &lt; self.min[<span class="number">1</span>] <span class="keyword">or</span> L[<span class="number">1</span>] &gt; self.max[<span class="number">1</span>]) <span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">if</span> (L[<span class="number">0</span>] &lt;= self.min[<span class="number">0</span>] <span class="keyword">and</span> self.max[<span class="number">0</span>] &lt;= R[<span class="number">0</span>] <span class="keyword">and</span></span><br><span class="line">          L[<span class="number">1</span>] &lt;= self.min[<span class="number">1</span>] <span class="keyword">and</span> self.max[<span class="number">1</span>] &lt;= R[<span class="number">1</span>])</span><br><span class="line">       <span class="keyword">return</span> _relax(now, di);</span><br><span class="line">  <span class="keyword">if</span> (L[<span class="number">0</span>] &lt;= self.p[<span class="number">0</span>] <span class="keyword">and</span> self.p[<span class="number">0</span>] &lt;= R[<span class="number">0</span>] <span class="keyword">and</span></span><br><span class="line">          L[<span class="number">1</span>] &lt;= self.p[<span class="number">1</span>] <span class="keyword">and</span> self.p[<span class="number">1</span>] &lt;= R[<span class="number">1</span>])</span><br><span class="line">       _relax(now + N, di);</span><br><span class="line">  relax(self.lti, di);</span><br><span class="line">  relax(self.rti, di);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">   freopen(<span class="string">&quot;jump.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"> freopen(<span class="string">&quot;jump.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> read(N);</span><br><span class="line">  <span class="keyword">int</span> M = read;</span><br><span class="line">    pool[<span class="number">0</span>].min[<span class="number">0</span>] = read;</span><br><span class="line">    pool[<span class="number">0</span>].min[<span class="number">1</span>] = read;</span><br><span class="line">    pool[<span class="number">0</span>].max[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   pool[<span class="number">0</span>].max[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">1</span>; now &lt;= N; now ++) &#123;</span><br><span class="line">       read(self.p[<span class="number">0</span>], self.p[<span class="number">1</span>]);</span><br><span class="line">       tmp[now] = now;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">     <span class="keyword">int</span> s = read, w = read, l = read, r = read, d = read, u = read;</span><br><span class="line">      G[s].push_back(&#123;w, &#123;l, d&#125;, &#123;r, u&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> root = build(<span class="number">1</span>, N, <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">std</span>::fill(dis, dis + N + N + <span class="number">1</span>, <span class="number">2000000000</span>);</span><br><span class="line">    q.push(par(dis[N + <span class="number">1</span>] = <span class="number">0</span>, N + <span class="number">1</span>));</span><br><span class="line">   <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().second, d = q.top().first;</span><br><span class="line">     q.pop();</span><br><span class="line">      <span class="keyword">if</span> (d &gt; dis[now]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (now &gt; N) &#123;</span><br><span class="line">           <span class="keyword">int</span> u = now - N;</span><br><span class="line">         <span class="keyword">for</span> (path p : G[u]) &#123;</span><br><span class="line">               L[<span class="number">0</span>] = p.L[<span class="number">0</span>];</span><br><span class="line">                L[<span class="number">1</span>] = p.L[<span class="number">1</span>];</span><br><span class="line">                R[<span class="number">0</span>] = p.R[<span class="number">0</span>];</span><br><span class="line">                R[<span class="number">1</span>] = p.R[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">/* int bak = TOT; */</span></span><br><span class="line">             relax(root, dis[now] + p.w);</span><br><span class="line">              <span class="comment">/* debug(&quot;%d\n&quot;, TOT - bak); */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (self.lti) _relax(self.lti, dis[now]);</span><br><span class="line">            <span class="keyword">if</span> (self.rti) _relax(self.rti, dis[now]);</span><br><span class="line">            _relax(now + N, dis[now]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[N + i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斗主地">斗主地</h3>
<p>仔细分析洗牌的选牌概率，事实上这个洗牌就是在保证相对顺序的前提下的均匀随机打乱。</p>
<p>暴力计算出第 <span class="math inline">\(i\)</span> 个位置洗牌后到第 <span class="math inline">\(j\)</span> 个位置的概率构成的矩阵，然后作矩阵乘法，统计答案，可以得到 40 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mat <span class="title">make</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mat a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            a.x[i][j] = C(j - <span class="number">1</span>, i - <span class="number">1</span>) * C(N - j, x - i) % mod * iC(N, x) % mod;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            a.x[i][j] = C(j - <span class="number">1</span>, i - x - <span class="number">1</span>) * C(N - j, N - i) % mod * iC(N, x) % mod;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line"> freopen(<span class="string">&quot;landlords.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;landlords.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    read(N);</span><br><span class="line">  <span class="keyword">int</span> m = read, t = read;</span><br><span class="line">  <span class="keyword">bool</span> same = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) read(A[i]), same &amp;= A[i] == A[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">100</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"> ifac[N] = power(fac[N], <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i --) ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line"></span><br><span class="line"> mat P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            P.x[i][j] = i == j;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (same) &#123;</span><br><span class="line">     mat B = make(A[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">while</span> (m) &#123;</span><br><span class="line">         <span class="keyword">if</span> (m &amp; <span class="number">1</span>) P *= B;</span><br><span class="line">           B *= B;</span><br><span class="line">           m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            P *= make(A[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            (ans[j] += P.x[i][j] * ll(t == <span class="number">1</span> ? i : i * i)) %= mod;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> q = read;</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="keyword">int</span>(read)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打个表找找规律，可以惊奇地发现 <span class="math inline">\(t=1\)</span> 时无论怎样洗牌，最后的答案序列始终是等差数列！由于该等差数列的和始终不变，只需要考虑维护它的公差。再找找规律，又可以惊奇地发现一个参数为 <span class="math inline">\(X\)</span> 的洗牌就是把公差乘上 <span class="math inline">\(\frac{\binom{N-2}{X}+\binom{N-2}{X-2}}{\binom{N}{X}}\)</span> ！结合上面的暴力做法可以得到 70 分。</p>
<p>以下代码只有 <span class="math inline">\(t=1\)</span> 的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">  freopen(<span class="string">&quot;landlords.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;landlords.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    read(N);</span><br><span class="line">  <span class="keyword">int</span> m = read, t = read;</span><br><span class="line">  <span class="keyword">bool</span> same = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) read(A[i]), same &amp;= A[i] == A[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"> ifac[N] = power(fac[N], <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i --) ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line">   ll coe = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> ll d = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">     (d *= C(N - <span class="number">2</span>, A[i]) + C(N - <span class="number">2</span>, A[i] - <span class="number">2</span>)) %= mod;</span><br><span class="line">        (d *= iC(N, A[i])) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll rem = <span class="number">1l</span>l * N * (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        ans[i] = i * d % mod, rem += mod - ans[i];</span><br><span class="line">    rem = rem % mod * power(N, <span class="number">-1</span>) % mod;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        (ans[i] += rem) %= mod;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> q = read;</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[<span class="keyword">int</span>(read)] * coe % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以进一步做出猜想，<span class="math inline">\(t=2\)</span> 时无论怎么洗牌答案序列始终是二次多项式。但是探究一次洗牌对该二次多项式的影响就很诡异，远远不是一个乘积那么简单？</p>
<h3 id="i-君的探险">I 君的探险</h3>
<p>容易想到暴力修改每个点然后逐一验证每条边，操作实现得精细一点就可以得到 20 分。</p>
<p>接下来对于 A 部分，这个图是个匹配，容易想到二进制分组，对于每个二进制只修改一半的点，通过查询就可以直到每个点的匹配点在该二进制位对应的值。这个部分不卡交互次数的常数，顺手。结合上一个部分一共 36 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FORCE &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span>;</span><br><span class="line">   <span class="keyword">bool</span> las[maxn];</span><br><span class="line">  <span class="keyword">bool</span> link[maxn][maxn];</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">          modify(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">                <span class="keyword">if</span> (link[j][i] <span class="keyword">or</span> j == i)</span><br><span class="line">                   las[j] ^= <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">              <span class="keyword">bool</span> now = query(j);</span><br><span class="line">             <span class="keyword">if</span> (now != las[j])</span><br><span class="line">                   link[i][j] = <span class="number">1</span>, report(i, j);</span><br><span class="line">             las[j] = now;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MATCH &#123;</span><br><span class="line">    <span class="keyword">int</span> match[maxn];</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; k) &lt; n; k ++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>) modify(i);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">             <span class="keyword">if</span> (query(i) != (i &gt;&gt; k &amp; <span class="number">1</span>))</span><br><span class="line">                  match[i] |= <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>) modify(i);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">         <span class="keyword">if</span> (i &lt; match[i])</span><br><span class="line">             report(i, match[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">explore</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n % <span class="number">10</span> == <span class="number">8</span>) MATCH::main(n, m);</span><br><span class="line">  <span class="keyword">else</span> FORCE::main(n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B 部分那个感觉可以来个二分什么的，因为对一个前缀进行修改操作，就可以直到一个后缀的父亲是否在这段前缀里头。</p>
<h2 id="end">End</h2>
<p>怎么说呢，感觉题目一年比一年难，分数线却一年比一年高。感觉完全不在线，拿不到分。况且今年的选手看起来强得离谱，感觉要去送了？</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日反演</title>
    <url>/2020/07/22/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>拉格朗日反演常用于提取一个幂级数 <span class="math inline">\(A(x)\)</span> 的 <span class="math inline">\(n\)</span> 次项系数。</p>
<p>对于常数项为 0 ，一次项非零的幂级数 <span class="math inline">\(A(x)\)</span> ，设其复合逆为 <span class="math inline">\(F(x)\)</span> ，有</p>
<p><span class="math display">\[[x^n] A(x) = \frac{1}{n} [x^{n-1}] (\frac{x}{F(x)})^n\]</span></p>
<a id="more"></a>
<p>举例，对于 <span class="math inline">\(A(x) = x e^{A(x)}\)</span> 求 <span class="math inline">\([x^n]A(x)\)</span> ，直接从等式下手解 <span class="math inline">\(A(x)\)</span> 比较麻烦，试试拉格朗日反演。</p>
<p>将其复合逆 <span class="math inline">\(F(x)\)</span> 代入等式，得到 <span class="math inline">\(x = F(x) e^x\)</span> ，因此 <span class="math inline">\(F(x) = \frac{x}{e^x}\)</span> 。</p>
<p>于是 <span class="math inline">\([x^n] A(x) = \frac{1}{n} [x^{n-1}] e^{nx} = \frac{n^{n-1}}{n!}\)</span> 。</p>
<p>另外如果 <span class="math inline">\(A(x)\)</span> 常数项不为 0 或者一次项为 0 等等，乘个 <span class="math inline">\(x\)</span> 的整次幂总能转换到一般的情况。</p>
<h2 id="证明">证明</h2>
<p>咕咕咕。</p>
<h2 id="扩展">扩展</h2>
<p>咕咕咕。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>拉格朗日反演</tag>
      </tags>
  </entry>
  <entry>
    <title>万能欧几里得</title>
    <url>/2020/07/19/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    <content><![CDATA[<p>有一类问题可以归结为以下模型：</p>
<p>有一种元素，它们之间可以定义乘法，且乘法满足结合律。给定两个元素 <span class="math inline">\(X, Y\)</span> 和正整数 <span class="math inline">\(n\)</span> ，求</p>
<p><span class="math display">\[F(P, R, Q, n, X, Y) = \prod_{i=0}^n Y^{f(i) - f(i - 1)} X\]</span></p>
<p>其中 <span class="math inline">\(f(x) = \lfloor \frac{xP+R}{Q} \rfloor\)</span> ，特别的 <span class="math inline">\(f(-1)=0\)</span> ，也就是说第 <span class="math inline">\(i\)</span> （从 <span class="math inline">\(0\)</span> 开始）个 <span class="math inline">\(X\)</span> 前面都有恰好 <span class="math inline">\(f(i)\)</span> 个 Y 。</p>
<p>不难发现所有类欧几里得都可以归结为该模型。</p>
<a id="more"></a>
<h2 id="解法">解法</h2>
<p>直奔主题，讲怎么做，其中奥妙自行体会。</p>
<p>以下把连乘展开构成的字符串称作 <span class="math inline">\(S\)</span> 。</p>
<p>首先 <span class="math inline">\(n = 0\)</span> 的时候可以直接求解，接下来假定 <span class="math inline">\(n \ge 1\)</span> 。</p>
<p>如果 <span class="math inline">\(R \ge Q\)</span> ，也就是 <span class="math inline">\(f(0) \ge 1\)</span> ，那么可以把 <span class="math inline">\(S\)</span> 开头的 <span class="math inline">\(Y\)</span> 全部提出来，有</p>
<p><span class="math display">\[F(P, R, Q, n, X, Y) = Y^{\lfloor \frac{R}{Q} \rfloor} F(P, R \bmod Q, Q, n, X, Y)\]</span></p>
<p>接下来假定 <span class="math inline">\(R &lt; Q\)</span> ，那么 <span class="math inline">\(S\)</span> 的开头一定是个 <span class="math inline">\(X\)</span> 。</p>
<hr />
<p>然后就可以来一波辗转相除，<span class="math inline">\(P \ge Q\)</span> 时把 <span class="math inline">\(P\)</span> 转换为 <span class="math inline">\(P \bmod Q\)</span> ，否则交换 <span class="math inline">\(P, Q\)</span> ，具体方法如下。</p>
<p>如果 <span class="math inline">\(P \ge Q\)</span> ，不难发现把 <span class="math inline">\(S\)</span> 中每相邻两个 <span class="math inline">\(X\)</span> 之间都有至少一个 <span class="math inline">\(Y\)</span> ，把这个 <span class="math inline">\(Y\)</span> 绑在后面的 <span class="math inline">\(X\)</span> 上，不断绑定，但是注意到第一个 <span class="math inline">\(X\)</span> 是没法绑定的，把这个 <span class="math inline">\(X\)</span> 提出来，有</p>
<p><span class="math display">\[F(P, R, Q, n, X, Y) = X F(P \bmod Q, R + P \bmod Q, Q, n - 1, Y^{\lfloor \frac{P}{Q} \rfloor} X, Y)\]</span></p>
<hr />
<p>否则考虑交换 <span class="math inline">\(P, Q\)</span> 的地位，如果放在二维平面上，就是翻转坐标系，由于懒得扯上数形结合，这里来点数学推导。</p>
<p>将 <span class="math inline">\(S\)</span> 中的 <span class="math inline">\(X, Y\)</span> 都从 <span class="math inline">\(0\)</span> 开始编号，根据 <span class="math inline">\(F\)</span> 的定义编号为 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(X\)</span> 左边的 <span class="math inline">\(Y\)</span> 的数量恰为 <span class="math inline">\(f(i)\)</span> ，<span class="math inline">\(f\)</span> 是个线性函数向下取整的形式。那么考虑第编号为 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(Y\)</span> 左边的 <span class="math inline">\(X\)</span> 的数量，设其为 <span class="math inline">\(g(i)\)</span> ，不难发现 <span class="math inline">\(g\)</span> 同样是个线性函数向下取整的形式！这意味着可以简单地交换 <span class="math inline">\(X, Y\)</span> 的地位，从而交换 <span class="math inline">\(P, Q\)</span> 。需要注意的是 <span class="math inline">\(S\)</span> 的末尾有若干 <span class="math inline">\(X\)</span> 需要特殊考虑。</p>
<p>那么现在的问题就是求 <span class="math inline">\(g(i)\)</span> ，根据定义有</p>
<p><span class="math display">\[
\begin{aligned}
g(i) &amp;= \sum_{j \ge 0} [f(j) \le i] \\\\
&amp;= \sum_{j \ge 0} [\lfloor \frac{Pj+R}{Q} \rfloor \le i] \\\\
&amp;= \sum_{j \ge 0} [Pj + R - Q + 1 \le Qi] \\\\
&amp;= \sum_{j \ge 0} [j \le \lfloor \frac{Qi-R+Q-1}{P} \rfloor] \\\\
&amp;= \lfloor \frac{Qi+P-R+Q-1}{P} \rfloor
\end{aligned}
\]</span></p>
<p>于是，稍加整理，不难得到</p>
<p><span class="math display">\[F(P, R, Q, n, X, Y) = F(Q, P - R + Q - 1, P, t - 1, Y, X) X^{n - \lfloor \frac{Qt-R-1}{P} \rfloor}\]</span></p>
<p>其中 <span class="math inline">\(t\)</span> 是 <span class="math inline">\(S\)</span> 内 <span class="math inline">\(Y\)</span> 的数量，有 <span class="math inline">\(t = \lfloor \frac{nP+R}{Q} \rfloor\)</span> ，注意 <span class="math inline">\(t=0\)</span> 的边界情况。</p>
<h2 id="实例">实例</h2>
<p>咕咕咕。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>拟阵和贪心</title>
    <url>/2020/07/16/%E6%8B%9F%E9%98%B5%E5%92%8C%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h2 id="理论基础">理论基础</h2>
<p>一个拟阵是一个二元组 <span class="math inline">\(M = (U, I)\)</span> ，其中 <span class="math inline">\(U\)</span> 是一个<strong>有限</strong>集合，一般是待研究元素的全集，<span class="math inline">\(I\)</span> 是 <span class="math inline">\(U\)</span> 的一些子集的集合，一般是满足给定限制的子集的集合。</p>
<p>另外，拟阵要满足两个性质：</p>
<ul>
<li>遗传性： <span class="math inline">\(\forall S \in I, T \subseteq S\)</span> 满足 <span class="math inline">\(T \in I\)</span> 。</li>
<li>交换性： <span class="math inline">\(\forall A \in I, B \in I, |A| &lt; |B|\)</span> 满足 <span class="math inline">\(\exists x \in B, x \notin A\)</span> 使得 <span class="math inline">\(A \cup \{x\} \in I\)</span> 。</li>
</ul>
<p>有一部分贪心可以为这样的形式：给定一个映射 <span class="math inline">\(f: U \rightarrow R\)</span> ，要在 <span class="math inline">\(I\)</span> 中找到一个 <span class="math inline">\(S\)</span> 使得 <span class="math inline">\(\sum_{x \in S} f(x)\)</span> 最大。</p>
<p>这类贪心都可以用如下流程解决：</p>
<ol type="1">
<li>设 <span class="math inline">\(U_0 := U\)</span> 表示可选集合，<span class="math inline">\(S := \varnothing\)</span> 表示要求的集合。</li>
<li>在集合 <span class="math inline">\(U_0\)</span> 中找出 <span class="math inline">\(f(x)\)</span> 最大的元素 <span class="math inline">\(x\)</span> 。</li>
<li>如果 <span class="math inline">\(S \cup \{x\} \in I\)</span> ，令 <span class="math inline">\(S := S \cup \{x\}\)</span> 。</li>
<li>令 <span class="math inline">\(U_0 := U_0 \setminus \{x\}\)</span> ，若 <span class="math inline">\(U_0\)</span> 非空，返回第 2 步。</li>
</ol>
<a id="more"></a>
<h2 id="证明">证明</h2>
<p>咕咕咕。</p>
<h2 id="例子-1">例子 1</h2>
<p>Kruskal 求最小生成树。</p>
<p>咕咕咕。</p>
<h2 id="例子-2">例子 2</h2>
<p>CQOI2013 新 Nim 游戏。</p>
<p>咕咕咕。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>最大权闭合子图</title>
    <url>/2020/07/16/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="概念">概念</h2>
<p>一个有向图 <span class="math inline">\(G = (V, E)\)</span> 的闭合子图是一个导出子图 <span class="math inline">\(G_0 = (V_0, E_0)\)</span> ，满足 <span class="math inline">\(\forall u \in V_0, (u, x) \in E\)</span> 有 <span class="math inline">\(x \in V_0\)</span> 成立。</p>
<p>最大权闭合子图即点权和最大的闭合子图。</p>
<a id="more"></a>
<h2 id="网络流模型">网络流模型</h2>
<p>注意到对于任意两个点 <span class="math inline">\(u, v\)</span> 满足 <span class="math inline">\(u\)</span> 能到达 <span class="math inline">\(v\)</span> ，闭合子图必须满足以下两个限制之一：</p>
<ul>
<li><span class="math inline">\(u\)</span> 不在该闭合子图中</li>
<li><span class="math inline">\(v\)</span> 在该闭合子图中</li>
</ul>
<p>容易联想到“割”，建源点 <span class="math inline">\(S\)</span> 连向所有点，所有点连向汇点 <span class="math inline">\(T\)</span> 。割掉 <span class="math inline">\((u, T)\)</span> 表示 <span class="math inline">\(u\)</span> 在闭合子图中，割掉 <span class="math inline">\((S, u)\)</span> 表示 <span class="math inline">\(u\)</span> 不在闭合子图中。那么新图的一组合法割就对应了原图的一个闭合子图。</p>
<p>求最大权闭合子图就只要给新图定义合适的边权，使得最大权闭合子图的权值等于一个定值 <span class="math inline">\(K\)</span> 减去新图最小割。</p>
<p>容易想到令原图边边权为 <span class="math inline">\(+\infty\)</span> ，<span class="math inline">\((S, u)\)</span> 的边权为 <span class="math inline">\(u\)</span> 的点权，<span class="math inline">\((u, T)\)</span> 的边权为 <span class="math inline">\(0\)</span> 。那么上述的定值 <span class="math inline">\(K\)</span> 就是点权和。但是 <span class="math inline">\(u\)</span> 的点权可能为负数，这样定权会导致负权边的出现。常规操作，对于点权为 <span class="math inline">\(-X (X &gt; 0)\)</span> 的点 <span class="math inline">\(u\)</span> ，不妨先“预流”一条 <span class="math inline">\(S -&gt; u -&gt; T\)</span> 的流量为 <span class="math inline">\(-X\)</span> 的路径，这样 <span class="math inline">\((S, u)\)</span> 的边权变为 <span class="math inline">\(0\)</span> ，<span class="math inline">\((u, T)\)</span> 的边权变为 <span class="math inline">\(X\)</span> 。算上“预流”的流量，此时 <span class="math inline">\(K\)</span> 是所有正权点的权值和。此时就可以简单地应用网络流解决这个问题。</p>
<h2 id="最大密度子图">最大密度子图</h2>
<p>对于无向图 <span class="math inline">\(G = (V, E)\)</span> ，其非空导出子图 <span class="math inline">\(G_0 = (V_0, E_0)\)</span> 的密度定义为边数与点数的比值，即 <span class="math inline">\(\frac{|E_0|}{|V_0|}\)</span> 。</p>
<p>最大密度子图即密度最大的导出子图。</p>
<p>问题实际上是一个分数规划，不难想到二分密度 <span class="math inline">\(X\)</span> 然后判断是否存在 <span class="math inline">\(G_0\)</span> 满足 <span class="math inline">\(|E_0| - X |V_0| &gt; 0\)</span> 。</p>
<p>令每条边的权值为 <span class="math inline">\(1\)</span> ，每个点的权值为 <span class="math inline">\(-X\)</span> ，那么问题就是要求一个点权和加边权和最大的导出子图。</p>
<p>注意到一条边出现在导出子图中当且仅当它的两个端点都在该导出子图中，根据这个限制关系可以把原图的边都抽象成点然后建新的有向图。判断新图的最大权导出子图的权值是否为<strong>正数</strong>即可。</p>
<p>需要注意的是，空集也是一个导出子图，其密度是没有定义的，却始终满足 <span class="math inline">\(|E_0| - X |V_0| = 0\)</span> ，因此二分的判断条件一定是严格大于而不是大于等于。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>最长反链长</title>
    <url>/2020/07/15/%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E9%95%BF/</url>
    <content><![CDATA[<p><del>去年写过的东西加点补充就算做今天写的了</del></p>
<h2 id="基本概念">基本概念</h2>
<p>首先得知道链和反链是什么。</p>
<p>在 <strong>有向无环图（ DAG ）</strong> 中，<br />
链是满足任意两点 x, y 要么 x 可以到达 y 要么 y 可以到达 x 的<strong>点集</strong> （即使只有一个点），<br />
反链是任意两点没有路径的 <strong>点集</strong> 。</p>
<p>那么最长反链，就是点的个数最多的反链。</p>
<a id="more"></a>
<h2 id="定理">定理</h2>
<p>不加证明地丢出两个定理：</p>
<ol type="1">
<li>最长反链长度 = 最小链覆盖（用最少的链覆盖所有顶点）</li>
<li>最长链长度 = 最小反链覆盖（用最少的反链覆盖所有顶点）</li>
</ol>
<p>那么要求的其实是最小链覆盖。</p>
<h2 id="不相交">不相交</h2>
<p>假设最小链覆盖不会相交，怎么求出这个最小链覆盖？</p>
<p>把每个点 i 拆成 i1 和 i2 ，考虑建立二分图。<br />
如果存在一条边 (x, y) ，那么就在二分图中建立 (x1, y2) 的边。<br />
这样建立二分图之后，原图的点数 - 二分图最大匹配 = 原图的最小链覆盖<br />
（链不相交）。</p>
<p>这样为什么是对的呢？<br />
一个点也可以看作是一个链，因此可以将每个点独立来看做初始状态。<br />
然后每次在二分图中选出一条边，就是将两条链连接成一条链，<br />
使用的链数就减少一个。</p>
<p>而链不会相交，所以在二分图中选出的边也是不相交的，也就是二分图的最大匹配。</p>
<h2 id="栗子">栗子</h2>
<p>如果链可以相交呢？</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 &#x2F;&#x2F; 五个点四条边</span><br><span class="line">1 3 &#x2F;&#x2F; 1 连向 3</span><br><span class="line">2 3 &#x2F;&#x2F; 2 连向 3</span><br><span class="line">3 4 &#x2F;&#x2F; 3 连向 4</span><br><span class="line">3 5 &#x2F;&#x2F; 3 连向 5</span><br></pre></td></tr></table></figure>
<p>这里不相交的最小链覆盖是 3 ，而实际的最小链覆盖是 2 。</p>
<p>观察不相交的最小链覆盖 {1-3-5, 2, 4} 与最小链覆盖 {1-3-5, 2-3-4} 。</p>
<p>发现由于不能相交， 1-3-5 这条链把 2-3-4 这条链切断了，<br />
分成 2 和 4 两条链，因此比最小链覆盖多了一条链。</p>
<p>如果可以让 2 跨过 1-3-5 与 4 相连呢？</p>
<h2 id="相交">相交</h2>
<p>将原图做一次 Floyd ，<br />
之后就可以知道任意两点 x, y ，x 是否能到达 y 。</p>
<p>把建立二分图的方法改造了一下，只要 x 能到达 y ，<br />
就直接连一条边 (x, y)，这样就可以“跨过”其它链来连接两条链了。</p>
<p>这个时候，原图最长反链长度 = 最小链覆盖 = 原图点数 - 二分图最大匹配。</p>
<h2 id="方案">方案</h2>
<p>《 [CTSC2008] 祭祀》一题中需要具体地求出一组最长反链方案。</p>
<p>对于上述的二分图，考虑求出其任意一组最大独立集，那么所有满足 x1 和 x2 都在最大独立集中的点 x 就构成了原图的一组最长反链。</p>
<p>由于最大独立集和最小点覆盖互为补集，问题就是要在二分图上求一组最小点覆盖。</p>
<p>从一组可行的点覆盖开始增广，最初的一组可行的点覆盖就是二分图左边的点的集合。</p>
<p>先求出一组最大匹配。然后从左边所有非匹配点沿非匹配边 - 匹配边 - 非匹配边 - 匹配边开始 dfs ，也就是找増广路，但事实上最大 匹配是不存在増广路的，因此 dfs 出来的路径只能是“伪増广路”，然后标记所有“伪増广路”到达过的点。注意到一条“伪増广路”一定包含 奇数个点，并且左边的点数比右边的点数多一，那么把所有被标记的左边的点删掉，把所有被标记的右边的点加上，每一条“伪増广路”都 会使得当前点覆盖的大小尽可能变小，事实上这样最终就能得到一组最小点覆盖。</p>
<p>严格的证明的话，利用最小点覆盖 = 最大匹配的这个条件，分别证明其是最小的以及是点覆盖即可，略。</p>
<p>祭祀还要求所有最长反链的并，也就是要对于每个点判断其是否存在于任意一组最长反链中，钦定之重新求最长反链，如果重新求出来的 最长反链长恰为原图最长反链长就说明该点存在于一组最长反链中。</p>
<p>（这玩意不画图一点都不直观）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最长反链</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>最小环</title>
    <url>/2020/06/19/%E6%9C%80%E5%B0%8F%E7%8E%AF/</url>
    <content><![CDATA[<p>给定一张图，求边权和最小的简单环的大小。</p>
<p>无向图或者有向图都可以做，需要注意的是无向图直接转成有向图会得到不合法的重边二元环。</p>
<p>以下讨论用 <span class="math inline">\(n, m\)</span> 分别表示图的点数和边数，为了方便，只讨论简单无向图，其他情况不难扩展。</p>
<p>并且只考虑边权非负的情况。</p>
<a id="more"></a>
<h2 id="一般解法">一般解法</h2>
<p>对于一般图，可以使用 Floyd 算法。这里要利用到 Floyd 算法的一个性质，最外层循环枚举松弛 点 <span class="math inline">\(K\)</span> 更新后，最短路数组 <span class="math inline">\(dis_{u, v}\)</span> 的值实际上是 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> （不包括 <span class="math inline">\(u, v\)</span> ）仅经过 编号在 <span class="math inline">\([1, k]\)</span> 中的点的最短路。</p>
<p>根据以上性质，在 Floyd 使用点 <span class="math inline">\(k\)</span> 松弛之前，枚举所有小于 k 的 <span class="math inline">\(dis_{i, j}\)</span> 即可求出以 <span class="math inline">\(k\)</span> 为最大编号节点的最小环大小。</p>
<h2 id="稀疏图做法">稀疏图做法</h2>
<p>对于图较为稀疏的情况，即 <span class="math inline">\(O(n) \le O(m) &lt; O(n^2)\)</span> ，存在更优秀的解法，可以求出数组 <span class="math inline">\(f\)</span> ，其中 <span class="math inline">\(f_u\)</span> 表示包含 <span class="math inline">\(u\)</span> 节点的最小的环的长度。</p>
<p>考虑计算 <span class="math inline">\(f_u\)</span> ，以 <span class="math inline">\(u\)</span> 为根，建出一颗最短路树，然后枚举非树边 <span class="math inline">\((x, y)\)</span> ，满足 <span class="math inline">\(lca(x, y) = u\)</span> ， 对于所有这样的非树边，有 <span class="math inline">\(f_u = min\{dis_x + len_{x, y} + dis_y\}\)</span> 。</p>
<p>总复杂度 <span class="math inline">\(O(n m \log n)\)</span> ，如果边权很小，最大为 <span class="math inline">\(W\)</span> ，可以 bfs 求短路，复杂度 <span class="math inline">\(O(nmW)\)</span> 。</p>
<p>如果只要单次求 <span class="math inline">\(f_u\)</span> ，这个做法也很合适，复杂度可以少一个 <span class="math inline">\(n\)</span> 。</p>
<p>还有一个很有意思的单次求 <span class="math inline">\(f_u\)</span> 的做法，把与 <span class="math inline">\(u\)</span> 相连的点二进制分组，然后对于每一个划分方式跑多源最短路， 复杂度 <span class="math inline">\(O(m \log n \log D)\)</span> 或 <span class="math inline">\(O(m W \log D)\)</span> ，其中 <span class="math inline">\(D\)</span> 是 <span class="math inline">\(u\)</span> 的度数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小环</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>HNOI2020</title>
    <url>/2020/06/16/HNOI2020/</url>
    <content><![CDATA[<p>标题就取 HNOI2020 吧，最后是游记还是退役记，也难说。</p>
<p>本来是对 5 月初省选做准备的，结果省选时间因为疫情一推再推。5 月初的一个星期参加了正睿的线上集训，考了几次，状态 不错，甚至有些超常，这段时间左右大概是状态最佳的一段时期，或许这时候省选我能占优势吧。</p>
<p>可惜后来慢慢地状态在下跌，直到省选时间终于敲定，就只剩两个星期了，争取能把状态提起来吧。</p>
<p>关于省选这回事，过去两年没有什么压力，进了就进了，没进就没进，可是到了高二感觉完全不同，毕竟是关乎到退役以及参 加最后一次（对我而言也是唯一一次） NOI 的机会的。因此最近总是会突然感到紧张，心跳莫名的加速，甚至控制情绪都变得 困难起来。这大概是什么焦虑症吧，不过也无所谓，毕竟能这样焦虑的机会也不多。</p>
<p>我参考了很多数据，也有认真思考过今年有多大把握进入省队。听说北京省选取消了，直接按 CSP 成绩划分，然后我也认真看 了看湖南去年的 CSP ，发现自己排在二十名开外（不过倒是有北京队线），因此这次省选我是不占优势的，起手就比别人低， 想要进队，还是需要不少的进步的。很迷茫，我并不知道这半年来的进步到底够不够，我很希望能用自己的实力赢得我想要的， 而不是靠运气，虽然运气的确是一个很重要的因素，但我不喜欢自己的命运完全被运气这种虚无缥缈的东西左右。</p>
<p>说起运气，我似乎也曾被运气眷顾过，那是初三的 NOIP ，我学了几个月就意外地拿到了提高一等奖，这是完全出乎意料的，也 正是这个一等奖，直接促使我选择了坚持走 OI 这条路。至于后来的重要的几次考试，主要是有各种失误，那都是后话了。</p>
<p>另外，学 OI 学得越久，见识到越多，就越发地认识到自己能力的不足，有些人实在就是强的离谱，实力超乎想象，那些我都不 曾敢去想象的高度就是能被他们轻松达到。这是客观事实，也许只能坦然接受，好在我并不必要去和他们相争，我没有那么大的 野心，但却也有自己的目标和想法，如果能实现自己的梦想，便也能心满意足了，尽管在部分人看来可能微不足道。</p>
<p>以上，考前焦虑的 Kewth 在省选前的一些乱七八糟的杂想。</p>
<a id="more"></a>
<h2 id="day-5">Day-5</h2>
<p>上午和晚上连打两场 VP ，降智严重。</p>
<h2 id="day-4">Day-4</h2>
<p>上午模拟赛，全是原题，全没做过，DRA 全做过，打了 50 + 50 + 100 就感觉不会太差，成绩一出惊了，普遍高分，掉到组里 中游去了（组里二十来人）。</p>
<p>晚上 VP ，秒了 AB 就进了 rk20 ，刚想出 C 波儿子就跑过来把我电脑关了，无语，C 也被降智了很久，A 掉后已经掉到 rk50 ， 然后看 D 仔细想想发现并不难，但是时间不够了，打完 A 掉已经结束了 10min ，最后 rk70+ 。</p>
<p>算了算，如果波狗不关我电脑并且 C 能早 AC 10 分钟，大概就可以 rk30+ 。</p>
<h2 id="day-3">Day-3</h2>
<p>上午模拟赛，又是原题，又都没做过。服了，本来打算把这两天模拟赛当做省选的全真模拟的，结果，就这？省选前最后两次 模拟赛搞这个？我直接他妈被搞自闭。</p>
<p>现在我能做的大概只有放开心态了。</p>
<p>今天是没有 VP 的一天，花了不少时间做上午的考试题。</p>
<p>看了看 noi.ac 的省选模拟，嗯，完全不会呢。</p>
<h2 id="day-2">Day-2</h2>
<p>全机房出去玩了一天，中间路过一座寺庙，跟着进去拜了拜。虽说自认为是个无神论者，但是到了这个时刻，终归还是希望有菩萨 什么之类的保佑我，人还是需要信仰，哪怕它虚无缥缈，甚至从事实上压根不存在，但是作为一种精神寄托，亦或是心理安慰，在 困难的时刻还是能让信仰者倍感坦然。</p>
<p>庙里的大师还说 master 颇有佛缘，拉着谈了许多。</p>
<h2 id="day-1">Day-1</h2>
<p>完全不知道该怎么准备，看了看以前做过的题，理了理思路。</p>
<p>逛 LOJ 的时候看到 BJOI2020 的一道题？看了看题，不难，写了写一遍过，算是给自己涨了涨自信。</p>
<p>最后还是 <a href="https://www.cnblogs.com/Lskkkno1">Lskkkno1</a> 比较猛，这就是大佬的底气吗？！</p>
<p>那么，今日早睡，明日进队。</p>
<h2 id="day1">Day1</h2>
<p>佛了。</p>
<p>开场开 T2 ，第一次推出来的东西要算逆元，大概是有个这样的递推式：</p>
<p><span class="math display">\[f_i = \frac{1}{x+1} ((n - i + 1) (f_{i-1} - g_{i-1}) + x g_i)\]</span></p>
<p>这模数不是质数啊，还想 CRT 想了好久。</p>
<p>冷静下来后把 <span class="math inline">\(g\)</span> 的递推式也写了出来： <span class="math inline">\(g_i = \frac{n-i+1}{x} g_{i-1}\)</span> 。</p>
<p><del>艹，我设的这 <span class="math inline">\(g\)</span> 有个寂寞用啊。</del></p>
<p>然后就过了 2h+ ，回头看 T1 ，卧槽线段树二分啊，写完后跑了跑 5.5s ，我。。。。</p>
<p>直接放弃卡常，肝 T3 ，屁也没肝出来，最后 rush 了一发贪心，在 12:57 调完，然后成功。。。</p>
<p>。。。成功发现贪心假了。</p>
<p>出来水 UOJ 群把我给水自闭了。</p>
<h2 id="day2">Day2</h2>
<p>佛了。</p>
<p>Day1 妥妥劣势，想着靠 Day2 翻盘。</p>
<p>结果，这题目我咋翻啊。。。</p>
<p>T1 一看状压，啪啦啪啦写完发现 23 卡空间卡时间，直接 skip 放弃卡常。</p>
<p>T2 一看 01 Trie 树，啪啦啪啦写完一遍过了大样例。</p>
<p>T3 一看这 gcd 卧槽无脑莫反，然后就是求生成树的权值和的和，用个代数余子式和伴随矩阵的 trick 就可以做到一个玄学复杂度。</p>
<p>（好像也不需要余子式直接无脑矩阵树就可以？）</p>
<p>写完 280pts 后一看时间还没到 12:00 。。。沃日，搁这搞 noip 呢？这翻 P 啊。</p>
<p>然后三道题一道道写暴力对拍，嗯，T3 果然打挂了，调了调算是拍上了。</p>
<p>这咋办啊，到头来还是得看运气吧，还是挺不甘心的，害。</p>
<p>问题不大，问题不大，问题不大，也不是完全没有希望？</p>
<p>晚上发现 D2T2 犯了傻逼错误 RE 了，明明写之前还提醒了自己，写的时候忘得干干净净，滚粗了。</p>
<h2 id="end">End</h2>
<p>出成绩了再更，进不了省队就搞文化课吧，至于校队，如果省队线能比 440 低再考虑吧，否则没有实力去参加屁的 NOI 。</p>
<p>update:</p>
<p>进队了，运气还是眷顾了我吧，靠着数据湿度还是水了一点分。</p>
<figure>
<img src="/images/hnoi2020.png" alt="hnoi2020" /><figcaption aria-hidden="true">hnoi2020</figcaption>
</figure>
<figure>
<img src="/images/hnoi2020_2.png" alt="hnoi2020_2" /><figcaption aria-hidden="true">hnoi2020_2</figcaption>
</figure>
<p>感谢佛祖，感谢上帝，感谢过去的自己，终于算是达到了这段时间的目标。</p>
<p>但是看到这么多人退役，还挺不是滋味的。这次一中总体考的很差，不少人筐了瓢，即使进队还是被隔壁学校被卡校线的人踩了。</p>
<p>总结一下吧，这次联合省选无疑比往年 HNOI 简单了许多，感觉主要考察三个方面：</p>
<ul>
<li>稳定发挥（题目相对较为简单的情况下，稳定地拿到该拿的分成了关键）</li>
<li>时空常数因子 (D1T1, D2T1)</li>
<li>对于冷门算法的掌握 (D1T3)</li>
</ul>
<p>稳定发挥这部分算是占到了，但是常数和冷门算法就完全不行，两天的常数分一分都没去拿，D1T3 只靠贪心水了 15 分。</p>
<p>以前做题总看不起卡常数这个行为，现在看来掌握较为优秀的实现方式也是很重要的一个方面。</p>
<p>接下来的路还很难走，还需要努力啊。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title>syzoj-二次开发笔记</title>
    <url>/2020/05/14/syzoj-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="nameplate">nameplate</h2>
<p>syzoj 的数据库的 user 表有 nameplate 这个属性，代码里面也有关于 nameplate 的处理， 但是不知道为啥前端并没有给出任何关于 nameplate 的接口，自己写个前端接口就好了。</p>
<p>比如在 <code>views/user_edit.ejs</code> 里面添加关于 nameplate 的修改，然后在 <code>modules/user.js</code> 实现具体的修改即可。</p>
<p>当然不希望在前段开放接口的话也可以直接在数据库里操作。</p>
<a id="more"></a>
<h2 id="网站图标">网站图标</h2>
<p>配置里面似乎没有？</p>
<p>在 <code>views/header.ejs</code> 自行添加 <code>&lt;link rel="icon" href="XXXXXXXX" sizes="32x32"&gt;</code> 即可。</p>
<h2 id="一言">一言</h2>
<p>syzoj 的一言只选取了动画这一类，可以在 <code>views/index.ejs</code> 里修改，修改方式见一言官网。</p>
<h2 id="添加新属性">添加新属性</h2>
<p>例如给 problem 添加一个新的属性，容易想到在数据库里直接加一列。</p>
<p>但是这样的话每次重启服务该列会被清空，似乎每次 typeORM 会检查多余的列并删除。</p>
<p>在 <code>models/problem.ts</code> 和里面依葫芦画瓢加入新增的属性，然后 yarn 一遍即可。</p>
<h2 id="更精细的权限管理">更精细的权限管理</h2>
<p>syzoj 题目的状态分为两种：公开和未公开；用户对于题目的权限也只有两种：普通用户和管理员。</p>
<p>有特殊需求的话这可能不太够，为了实现更加精细的权限管理，就需要在 problem 添加新属性，修改 <code>models/problem.ts</code> ， 并且修改其中一些关于权限判定的函数。</p>
<p>这样不符合权限要求的就看不到题了，但是还是能看提交记录，为此还需要修改 <code>models/judge_state.ts</code> 的权限判定函数。</p>
<p>但是如果需求更特殊，需要限制管理员的权限的话，就更难搞。 因为管理员权限的优先级是很高的，有些地方的逻辑是只要用户有管理题目的权限就通行，而不会判断题目和用户具体的关系。</p>
<p>最麻烦的可能是 <code>modules/submission.js</code> ，事实上这里也没法逐个判断题目和用户具体的关系，所以要限制提交记录的查询， 就必须在 <code>judge_state</code> 上做出限制，原声版本只有 <code>is_public</code> 这个唯一的限制，需要更精细的话还要加上更多。</p>
<h2 id="批量修改-tag">批量修改 tag</h2>
<p>直接写 sql 语句修改 <code>problem_tag_map</code> 这张表，改完后会发现有一些玄学问题。</p>
<p>翻了源码，发现题目的标签是有缓存的，要立即生效必须清除缓存，修改 <code>config.json</code> 的 <code>cache_size</code> 后重启即可。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>syzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>一类不公平博弈总结</title>
    <url>/2020/05/09/%E4%B8%80%E7%B1%BB%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%8D%9A%E5%BC%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>以下简称超现实数 Surreal Numbers 为 SN 。</p>
<p>超现实数完整的理论很复杂，这里不详细给出。</p>
<a id="more"></a>
<h2 id="超现实数与游戏">超现实数与游戏</h2>
<p>一个 SN 可以表示为 <span class="math inline">\(P = \{S_L|S_R\}\)</span> ，其中 <span class="math inline">\(S_L\)</span> 和 <span class="math inline">\(S_R\)</span> 都是 SN 的集合。</p>
<p>若 <span class="math inline">\(P\)</span> 是 SN ，需要满足一个公理：</p>
<p><span class="math display">\[\forall X \in S_L, Y \in S_R, X \ngeq Y\]</span></p>
<p>这样定义 SN 的偏序关系，<span class="math inline">\(P = \{S_L|S_R\} \le Q = \{T_L|T_R\}\)</span> 当且仅当以下两点同时成立：</p>
<p><span class="math display">\[\forall X \in S_L, X \ngeq Q\]</span> <span class="math display">\[\forall Y \in T_R, Y \nleq P\]</span></p>
<p>一个游戏 <span class="math inline">\(P\)</span> 可以类似地对应到一个 SN ，其中 <span class="math inline">\(S_L\)</span> 是左玩家能够转移到的游戏的集合，<span class="math inline">\(S_R\)</span> 是右玩家能够转移到的集合。</p>
<h2 id="简单的情况">简单的情况</h2>
<p>不加证明的给出以下重要的性质，实践中往往将 SN 用普通的实数表示，当然不是所有 SN 都能对应到一个实数的，实数域只是超现实数域的一个子集。</p>
<ul>
<li>对于 SN <span class="math inline">\(P = \{|\}\)</span> ，有 <span class="math inline">\(P = 0\)</span> ，即加法单位元。</li>
<li>对于 SN <span class="math inline">\(P = \{S_L | S_R\}\)</span> ，如果集合 <span class="math inline">\(S_L\)</span> 存在最大值 <span class="math inline">\(P_L\)</span> ，则 <span class="math inline">\(P = \{P_L | S_R\}\)</span> 。</li>
<li>对于 SN <span class="math inline">\(P = \{S_L | S_R\}\)</span> ，如果集合 <span class="math inline">\(S_R\)</span> 存在最小值 <span class="math inline">\(P_R\)</span> ，则 <span class="math inline">\(P = \{S_L | P_R\}\)</span> 。</li>
<li>对于 SN <span class="math inline">\(P = \{P_L | P_R\}\)</span> ，<span class="math inline">\(P\)</span> 的值可以由一颗特殊的树确定，<span class="math inline">\(P\)</span> 是值在 <span class="math inline">\(P_L\)</span> 和 <span class="math inline">\(P_R\)</span> 之间的最浅的点（不包括 <span class="math inline">\(P_L, P_R\)</span> ），这棵树长这样：</li>
</ul>
<p><img src="/images/tree.png" /></p>
<ul>
<li>对于 SN <span class="math inline">\(P = \{P_L |\}\)</span> ，<span class="math inline">\(P\)</span> 是值大于 <span class="math inline">\(P_L\)</span> 的最浅的点。</li>
<li>对于 SN <span class="math inline">\(P = \{| P_R\}\)</span> ，<span class="math inline">\(P\)</span> 是值小于 <span class="math inline">\(P_R\)</span> 的最浅的点。</li>
</ul>
<!--而对于两个 SN $\frac{a_1}{2^{k_1}}$ 和 $\frac{a_2}{2^{k_2}}$ 的深度的比较，以 $k$ 为第一关键字 $a$ 的绝对值为第二关键字比较即可，特别的，$0$ 是深度最浅的点。-->
<p>直观上，可以将一个能对应到实数的 SN 理解为左玩家可以自由操作的次数减去右玩家可以自由操作的次数。</p>
<p>一个游戏可以看做一个 SN <span class="math inline">\(P\)</span> ：</p>
<ul>
<li>如果 <span class="math inline">\(P &gt; 0\)</span> ，那么左玩家必胜。</li>
<li>如果 <span class="math inline">\(P &lt; 0\)</span> ，那么右玩家必胜。</li>
<li>如果 <span class="math inline">\(P = 0\)</span> ，那么先手必败。</li>
<li>如果 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(0\)</span> 没有偏序关系，那么先手必胜（这个情况稍后讨论）。</li>
</ul>
<p>以上四点的逆命题也是成立的。</p>
<p>如果一个游戏 <span class="math inline">\(P\)</span> 可以划分为若干互不影响的子游戏 <span class="math inline">\(P_1, P_2 ... P_n\)</span> ，那么 <span class="math inline">\(P = P_1 + P_2 + ... + P_n\)</span> 。</p>
<p>和 0 可以确定偏序关系的 <span class="math inline">\(P\)</span> 可以简单的加起来，但是和 0 没法确定偏序关系的一些 <span class="math inline">\(P\)</span> 的加法比较特殊。</p>
<p>例如公平博弈下的 SG 定理，子游戏的加是 SG 值的异或，事实上公平博弈的游戏对应的 SN 只能是 0 或者是与 0 没有偏序关系的数。</p>
<p>其他的一些性质：</p>
<ul>
<li>对于 SN <span class="math inline">\(P = \{P_L|P_R\}\)</span> ，其加法逆（相反数）为 <span class="math inline">\(-P = \{-P_R|-P_L\}\)</span> 。</li>
</ul>
<h2 id="更复杂的情况">更复杂的情况</h2>
<p>之前提到过，有些游戏状态对应的 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(0\)</span> 没有偏序关系。</p>
<p>这里要引入三个基本的量：<span class="math inline">\(\star = \{0|0\}, \uparrow = \{0|\star\}, \downarrow = \{\star|0\}\)</span> 。</p>
<p>不难看出 <span class="math inline">\(\star\)</span> 实际上就不满足 SN 的公理，但是这三个量确实对应于一些游戏的状态，因此为了更好的研究这类特殊的博弈，这些量的引入是必须的。</p>
<p>不加证明的给出以下性质：</p>
<ul>
<li><p><span class="math inline">\(\star\)</span> 小于所有正实数且大于所有负实数，与 0 没有偏序关系。</p></li>
<li><p><span class="math inline">\(\uparrow\)</span> 小于所有正实数且大于 0 。</p></li>
<li><p><span class="math inline">\(\downarrow\)</span> 大于所有负实数且小于 0 。</p></li>
<li><p><span class="math inline">\(\star + \star = 0\)</span> ，也就是说 <span class="math inline">\(\star\)</span> 的逆是其本身。</p></li>
<li><p><span class="math inline">\(\{\uparrow|\downarrow\} = \{\uparrow|0\} = \{0|\downarrow\} = \star\)</span></p></li>
<li><p><span class="math inline">\(\{\downarrow|\uparrow\} = 0\)</span></p></li>
<li><p><span class="math inline">\(\forall X \in R, \{X|X\} = X + \star\)</span> ，通常记做 <span class="math inline">\(X\star\)</span> ，<span class="math inline">\(X = 0\)</span> 时与 0 没有偏序关系，否则 <span class="math inline">\(X\star &gt; 0\)</span> 当且仅当 <span class="math inline">\(X &gt; 0\)</span> 。</p></li>
</ul>
<p>另外，对于 SG 值为 <span class="math inline">\(X\)</span> 的公平博弈，其值可以记做 <span class="math inline">\(\star X\)</span> ，它的加法就是 <span class="math inline">\(X\)</span> 的异或，<span class="math inline">\(X\)</span> 不为 0 时该数与 0 没有偏序关系。</p>
<p>可以从这些量的角度研究博弈，同样可以从博弈的角度研究这些量。</p>
<p>例如要证明 <span class="math inline">\(\{\uparrow|\downarrow\} = \star\)</span> ，可以证明其等价命题 <span class="math inline">\(\{\uparrow|\downarrow\} + \star = 0\)</span> ，即证明该游戏先手必败，这通过简单的博弈归纳是很容易证明的。</p>
<p>其他的一些性质：</p>
<ul>
<li><span class="math inline">\(\{0|\uparrow\} = \uparrow + \uparrow + \star\)</span></li>
<li><span class="math inline">\(\{\downarrow|0\} = \downarrow + \downarrow + \star\)</span></li>
</ul>
<h2 id="更更复杂的情况">更更复杂的情况</h2>
<p>然而即使有了 <span class="math inline">\(\star\)</span> ，许多游戏仍然无法被表示，例如 <span class="math inline">\(\{1|-1\}\)</span> ，它也有一些性质，例如它的加法逆是它本身。</p>
<p>由于游戏 <span class="math inline">\(P\)</span> 对应的 <span class="math inline">\(\{S_L|S_R\}\)</span> 与超现实数不同，不受公理的限制，这似乎预示了不是无法所有问题都能拿超现实数获得满意的结果的，超现实数能解决的终究是一部分较为特殊的问题。</p>
<p>例如 Nim 游戏的 mex 规则和 SG 定理，这些东西直接拿超现实数或是 <span class="math inline">\(\star\)</span> 这些东西是无法解释的。</p>
<p>因此，还是要具体问题具体分析。</p>
<h2 id="推荐读物">推荐读物</h2>
<p>这里只是总结，希望具体了解超现实数和博弈的关系的话可以去看这些东西。</p>
<p><a href="www.matrix67.com/blog/archives/6333">实数、超实数和博弈游戏：数学的结构之美 -- Matrix</a></p>
<p><a href="https://vdisk.weibo.com/s/ujrfywKpDcaZ9">通俗数学名著译丛21-稳操胜券（上册）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>不公平博弈</tag>
        <tag>超现实数</tag>
      </tags>
  </entry>
  <entry>
    <title>集合幂级数</title>
    <url>/2020/05/06/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<p>对于两个集合幂级数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> ，定义其和 <span class="math inline">\(h\)</span> ：</p>
<p><span class="math display">\[ h_S = f_S + g_S \]</span></p>
<p>对于两个集合幂级数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> ，定义其乘积 <span class="math inline">\(h\)</span> ：</p>
<p><span class="math display">\[ h_S = \sum_{T \subseteq S} f_T \times g_{S \setminus T} \]</span></p>
<p>即常说的子集卷积。</p>
<a id="more"></a>
<p>那么定义了乘法和加法，就能进一步定义更多运算。</p>
<p>在这之前先引入集合占位幂级数。</p>
<h2 id="集合占位幂级数">集合占位幂级数</h2>
<p>对于集合幂级数 <span class="math inline">\(f\)</span> ，其占位幂级数 <span class="math inline">\(P(f)\)</span> 的每一位实际是一个多项式，满足：</p>
<p><span class="math display">\[ P(f)_S = f_S x^{|S|} \pmod{x^{|S|+1}} \]</span></p>
<p>有了占位幂级数，就可以很容易地把集合幂级数的乘法转换为并卷积，即通过莫比乌斯变换可以很好处理两个集合幂级数的乘法。</p>
<p>具体的，对于集合幂级数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> ，求出幂级数 <span class="math inline">\(p\)</span> 满足：</p>
<p><span class="math display">\[ P(h)_S = \sum_{A \cup B = S} P(f)_A \times P(g)_B \]</span></p>
<p>其中 <span class="math inline">\(P(f)_A \times P(g)_B\)</span> 就是多项式卷积。</p>
<p>那么根据集合并卷积的性质可以知道：</p>
<p><span class="math display">\[ FMT(P(h))_S = FMT(P(f))_S \times FMT(P(g))_S \]</span></p>
<p>update: 这里的“等于”并不是严格意义上的等于，而是一种整体上的等价。</p>
<p>暴力进行多项式卷积，一次乘法的复杂度为 <span class="math inline">\(O(2^n n^2)\)</span> ，其中 <span class="math inline">\(n\)</span> 是全集的大小。</p>
<h2 id="求逆">求逆</h2>
<p>对于集合幂级数 <span class="math inline">\(f\)</span> ，定义其逆元 <span class="math inline">\(g\)</span> 为满足 <span class="math inline">\(f \times g = e\)</span> 的集合幂级数。</p>
<p>其中 <span class="math inline">\(e\)</span> 是集合幂级数的单位元，满足 <span class="math inline">\(\forall f, f \times e = f\)</span> 。</p>
<p>可以知道 <span class="math inline">\(\forall S, FMT(P(e))_S = 1\)</span> 。</p>
<p>那么就有 <span class="math inline">\(\forall S, FMT(P(g))_S = FMT(P(f))_S^{-1} \pmod{x^{|S|+1}}\)</span> 。</p>
<p>暴力多项式求逆，复杂度 <span class="math inline">\(O(2^n n^2)\)</span> ，其中 <span class="math inline">\(n\)</span> 是全集的大小。</p>
<h2 id="开根">开根</h2>
<p>对于集合幂级数 <span class="math inline">\(f\)</span> ，定义其平方根 <span class="math inline">\(g\)</span> 为满足 <span class="math inline">\(g \times g = f\)</span> 的集合幂级数。</p>
<p>可以知道 <span class="math inline">\(\forall S, FMT(P(g))_S^2 = FMT(P(f))_S \pmod{x^{|S|+1}}\)</span> 。</p>
<p>暴力多项式开根，复杂度 <span class="math inline">\(O(2^n n^2)\)</span> ，其中 <span class="math inline">\(n\)</span> 是全集的大小。</p>
<h2 id="其他">其他</h2>
<p>类似的也可以定义 <span class="math inline">\(\exp\)</span> 和 <span class="math inline">\(\ln\)</span> 。</p>
<p>update: exp 的定义可以利用泰勒展开式：<span class="math inline">\(e^A = \sum_{i\ge{0}} \frac{A^i}{i!}\)</span> ，对应的可以定义 ln 。</p>
<p>不难发现所有集合幂级数的运算都可以转换莫比乌斯变换后占位幂级数的多项式运算。</p>
<p>暴力做多项式运算，复杂度都是 <span class="math inline">\(O(2^n n^2)\)</span> ，理论上可以做到 <span class="math inline">\(O(2^n n \log n)\)</span> 。</p>
<p>但是考虑到对占位幂级数做莫比乌斯变换的复杂度就要 <span class="math inline">\(O(2^n n^2)\)</span> 。 且由于集合幂级数运算的运算的瓶颈主要在于 <span class="math inline">\(O(2^n)\)</span> ，<span class="math inline">\(n\)</span> 往往很小。 此时 <span class="math inline">\(O(n \log n)\)</span> 的多项式运算带来的常数因子影响是很大的，因此集合幂级数的运算往往使用 <span class="math inline">\(O(n^2)\)</span> 的暴力运算。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>多维卷积</title>
    <url>/2020/05/06/%E5%A4%9A%E7%BB%B4%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<p><del>异或卷积的本质就是 <span class="math inline">\(n\)</span> 维循环卷积。</del></p>
<h2 id="二维卷积">二维卷积</h2>
<p>可以理解为对于二维数组 <span class="math inline">\(f\)</span> 和二维数组 <span class="math inline">\(g\)</span> 求二维数组 <span class="math inline">\(h\)</span> ：</p>
<p><span class="math display">\[h_{i,j} = \sum_{a+b=i} \sum_{c+d=j} f_{a,c} \times g_{b,d}\]</span></p>
<p>这个 <span class="math inline">\(h\)</span> 就是 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 的二维卷积。</p>
<p>构造生成函数数组 <span class="math inline">\({F_i}, {G_i}, {H_i}\)</span> ，满足 <span class="math inline">\(F_i = \sum_{j} f_{i,j} x^j\)</span> ，类似地定义 <span class="math inline">\({G_i}\)</span> 和 <span class="math inline">\({H_i}\)</span> ，那么有：</p>
<p><span class="math display">\[H_i = \sum_{a+b=i} F_a \times G_b\]</span></p>
<a id="more"></a>
<p>其中 <span class="math inline">\(F_a \times G_b\)</span> 就是多项式卷积。</p>
<p>不妨把 <span class="math inline">\(F, G, H\)</span> 的每一位所对应的多项式看做普通的元素，那么 <span class="math inline">\(H\)</span> 就是 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(G\)</span> 的卷积，傅里叶变换在这里仍然是可以定义的。</p>
<h2 id="高维卷积">高维卷积</h2>
<p>二维卷积的做法完全可以推广到高维卷积，对于两个从向量到数的映射 <span class="math inline">\(F, G\)</span> ，定义其卷积 <span class="math inline">\(H\)</span> 满足：</p>
<p><span class="math display">\[H_c = \sum_{a+b=c} F_a \times G_b\]</span></p>
<p>其中 <span class="math inline">\(a, b, c\)</span> 都是高维向量。</p>
<p>事实上异或卷积就是一个高维卷积（循环卷积），每一维的长度都是二，根据异或卷积的实现不难推广到所有高维卷积的实现。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>卢卡斯定理</title>
    <url>/2020/04/29/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>简单来说就是快速计算 <span class="math inline">\(\binom{n}{m} \bmod p\)</span> 。</p>
<h2 id="卢卡斯定理">卢卡斯定理</h2>
<p>如果 <span class="math inline">\(p\)</span> 是质数，有 <span class="math inline">\(\binom{n}{m} \equiv \binom{n \bmod p}{m \bmod p} \binom{n/p}{m/p} \pmod{p}\)</span> ，其中 <span class="math inline">\(n/p\)</span> 和 <span class="math inline">\(m/p\)</span> 表示整除。</p>
<p>直接递归调用，预处理阶乘，单次询问时间复杂度 <span class="math inline">\(O(p + \frac{\log n}{\log p})\)</span> 。</p>
<a id="more"></a>
<h2 id="扩展卢卡斯">扩展卢卡斯</h2>
<p>这已经不能算定理了，从头到尾就是一个算法。</p>
<p>对于 <span class="math inline">\(p\)</span> 不是质数的情况，考虑将 <span class="math inline">\(p\)</span> 质因数分解，对于每个质因子 <span class="math inline">\(x^k\)</span> ，求出 <span class="math inline">\(\binom{n}{m} \bmod x^k\)</span> 后扩展中国剩余定理合并。</p>
<p>那么问题转换为对于质数 <span class="math inline">\(x\)</span> 和指数 <span class="math inline">\(k\)</span> 求 <span class="math inline">\(\binom{n}{m} \bmod x^k\)</span> 。</p>
<p>考虑组合数的通项公式 <span class="math inline">\(\binom{n}{m} = \frac{n!}{m!(n-m)!}\)</span> ，分别求出 <span class="math inline">\(n!\)</span>, <span class="math inline">\(m!\)</span>, <span class="math inline">\((n-m)!\)</span> ，特别地，由于它们可能是 <span class="math inline">\(x\)</span> 的倍数，需要将 <span class="math inline">\(x\)</span> 单独提出来。 也就是要求 <span class="math inline">\(n! = x^a b\)</span> 中的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 。</p>
<p>将 <span class="math inline">\(n! = 1 \times 2 \times 3 ... \times n\)</span> 中 <span class="math inline">\(x\)</span> 的倍数单独提出来，这些部分都除掉一个 <span class="math inline">\(x\)</span> 就是 <span class="math inline">\(\lfloor \frac{n}{x} \rfloor!\)</span> ，递归计算。 对于其他部分，每 <span class="math inline">\(x^k\)</span> 分为一块，每一个完整的块的乘积相同，算出一个完整的块的乘积（也就是 <span class="math inline">\((x^k-1)!\)</span> ）后再算零散部分的乘积即可。</p>
<p>预处理阶乘，单次询问时间复杂度 <span class="math inline">\(O(p + \frac{\log n}{\log p})\)</span> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>组合数学</tag>
        <tag>卢卡斯定理</tag>
      </tags>
  </entry>
  <entry>
    <title>常系数齐次线性递推</title>
    <url>/2020/04/19/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p>问题是这样的：</p>
<p>对于一个无穷大的递推数列 <span class="math inline">\(\{h_i\}\)</span> 和长度为 <span class="math inline">\(k\)</span> 的已知数列 <span class="math inline">\(\{a_i\}\)</span>，满足<span class="math inline">\(\forall n, h_n = \sum_{i=1}^k a_i h_{n-i}\)</span> 。 已知 <span class="math inline">\(h_i (0 \le i &lt; k)\)</span> 求 <span class="math inline">\(h_n\)</span> 。</p>
<p>直接递推复杂度 <span class="math inline">\(O(nk)\)</span> ，矩阵快速幂可以做到 <span class="math inline">\(O(k^3 logn)\)</span> 的复杂度，这里介绍一个更优秀的做法。</p>
<h2 id="结论">结论</h2>
<p>便于以后复习，先给出结论。</p>
<ol type="1">
<li>构造多项式 <span class="math inline">\(F(x) = x^k - \sum_{i=1}^k a_i x^{k-i}\)</span> 。</li>
<li>求出多项式 <span class="math inline">\(G(x) = \sum_{i=0}^{k-1} c_i x^i = x^n \bmod F(x)\)</span> 。</li>
<li>有 <span class="math inline">\(h_n = \sum_{i=0}^{k-1} c_i h_i\)</span> 。</li>
</ol>
<p>第一步和第三步都是 <span class="math inline">\(O(k)\)</span> 的，而第二步通过多项式快速幂和多项式取模可以做到 <span class="math inline">\(O(k\log k\log n)\)</span> 的复杂度。</p>
<p>当然暴力做多项式快速幂和多项式取模也能做到 <span class="math inline">\(O(k^2 \log n)\)</span> 的复杂度，大多时候这就足够了。</p>
<a id="more"></a>
<h2 id="直观理解">直观理解</h2>
<p>不会线性代数也没关系，上面的做法其实有很简单的直观理解。</p>
<p>上述做法的关键在于第二部分，观察 <span class="math inline">\(H(x) = x^n\)</span> 在对 <span class="math inline">\(F(x)\)</span> 取模时的过程，<br />
可以发现任意时刻，都有 <span class="math inline">\(h_n = \sum_i [x^i]H(x) h_i\)</span> 。</p>
<p>也就是说总有以下命题成立，<span class="math inline">\(H(x)\)</span> 的 <span class="math inline">\(i\)</span> 次项系数就是 <span class="math inline">\(h_i\)</span> 对 <span class="math inline">\(h_n\)</span> 的贡献系数。<br />
这一点不会因减去了若干倍 <span class="math inline">\(F(x)\)</span> 发生改变。<br />
原因也很简单，每次将 <span class="math inline">\(H(x)\)</span> 减去 <span class="math inline">\(x^i F(x)\)</span> ，就相当于把 <span class="math inline">\(h_{k+i}\)</span> 换成了 <span class="math inline">\(\sum_{j=1}^k a_j h_{k+i-j}\)</span> 。<br />
本质上是由于 <span class="math inline">\(F(x) \equiv 0 \pmod{F(x)}\)</span> 等价于 <span class="math inline">\(x_k \equiv \sum_{i=1}^k a_i x^{k-i} \pmod{F(x)}\)</span> 。</p>
<p>其实自己列竖式算一算 <span class="math inline">\(x^n \bmod F(x)\)</span> 就能很容易发现这一点。</p>
<h2 id="线代意义">线代意义</h2>
<p>线代基础不行，只能先行告退。🕊🕊🕊🕊🕊</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>code-trick</title>
    <url>/2020/01/16/code-trick/</url>
    <content><![CDATA[<p>总结一些 code-trick ，这种东西看看别人的代码，有时能够大开眼界。</p>
<a id="more"></a>
<h2 id="nttfft">NTT/FFT</h2>
<h3 id="预处理原根">预处理原根</h3>
<p>普通 NTT 每次长度改变都需要调用若干次快速幂来计算原根，差不多长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      ll Gn = power(<span class="number">3</span>, (mod - <span class="number">1</span>) / (m &lt;&lt; <span class="number">1</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m) &#123;</span><br><span class="line">         ll G = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">               ll a0 = a[k], a1 = a[k + m] * G;</span><br><span class="line">              a[k] = (a0 + a1) % mod;</span><br><span class="line">               a[k + m] = (a0 + mod - a1) % mod;</span><br><span class="line">             (G *= Gn) %= mod;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上可以预处理数组 <span class="math inline">\(G\)</span> 满足当前枚举的 <span class="math inline">\((m, k, i)\)</span> 需要用到的原根就是 <code>G[m + k - i]</code> ，<br />
每一层需要 <span class="math inline">\(m\)</span> 个位置，由于每次 <span class="math inline">\(m\)</span> 倍长，<span class="math inline">\(O(n)\)</span> 的空间是能存下的。<br />
而且只需要递推 <span class="math inline">\(m\)</span> 最大的一层，剩下的由于 <span class="math inline">\(W_m^k = W_{2m}^{2k}\)</span> ，可以知道 <code>G[m + k] = G[m * 2 + k * 2]</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ll g = power(<span class="number">3</span>, (mod - <span class="number">1</span>) / maxl);</span><br><span class="line">    G[maxl &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = (maxl &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>; i &lt;= maxl; i ++)</span><br><span class="line">      G[i] = G[i - <span class="number">1</span>] * g % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (maxl &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i; i --)</span><br><span class="line">     G[i] = G[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">               ll a0 = a[k], a1 = a[k + m] * G[m + k - i] % mod;</span><br><span class="line">             a[k] = (a0 + a1) % mod;</span><br><span class="line">               a[k + m] = (a0 + mod - a1) % mod;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的道理 rev 数组也是能预处理的。</p>
<h3 id="逆变换">逆变换</h3>
<p>逆变换实际只要 reverse 一遍做正变换然后除以 <span class="math inline">\(n\)</span> 即可。</p>
<p>除以 <span class="math inline">\(n\)</span> 往往需要计算逆元，但是由于 <span class="math inline">\(n\)</span> 是二的整次幂，且 NTT 模数必须是 <span class="math inline">\(2^k * s + 1\)</span> ，<br />
除了预处理以外 <span class="math inline">\(n\)</span> 的逆元有更好的 <span class="math inline">\(O(1)\)</span> 计算方法，因为找到一个满足 <span class="math inline">\(nx \equiv -1\)</span> 的数 <span class="math inline">\(x\)</span> 是很容易的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::reverse(a + <span class="number">1</span>, a + n);</span><br><span class="line"> DFT(a, n);</span><br><span class="line">    <span class="keyword">int</span> invn = mod - (mod - <span class="number">1</span>) / n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">      (a[i] *= invn) %= mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模数">模数</h3>
<p>当模数比较小以至于 <span class="math inline">\(p^2\log n\)</span> 不会爆 <code>long long</code> 或者 <code>unsigned long long</code> 的时候，NTT 的蝴蝶变换可以在最后取模，实测会快很多。</p>
<p>比如一般 <code>167772161</code> 就是这样一个模数。另外 <code>998244353</code> 在长度不超过 <span class="math inline">\(2^{18}\)</span> 可以用 <code>unsigned long long</code> 存来卡这个取模。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __d(ll &amp;x) &#123; <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">               ll a0 = a[k], a1 = a[k + m] * G[m + k - i] % mod;</span><br><span class="line">             a[k] = a0 + a1;</span><br><span class="line">               a[k + m] = a0 - a1;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) __d(a[i] %= mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fft-两次变一次-1">FFT 两次变一次 1</h3>
<p>这是 myy 提出的一个优秀的 FFT trick ，能够一次 FFT 处理两个多项式，但缺点是精度会进一步降低。</p>
<p>前提是两个多项式的系数在 FFT 前虚部为 0 ，这个条件在 DFT 中往往是能满足的。</p>
<p>例如要给两个多项式 <span class="math inline">\(A, B\)</span> 做 FFT ，考虑构造两个多项式：</p>
<p><span class="math display">\[P(x) = A(x) + i B(x)\]</span> <span class="math display">\[Q(x) = A(x) - i B(x)\]</span></p>
<p>那么由于 <span class="math inline">\(A, B\)</span> 的虚部都为 0 ，<span class="math inline">\(P, Q\)</span> 的每一项系数都互为共轭，同样 <span class="math inline">\(FFT(P), FFT(Q)\)</span> 的每一项系数都互为共轭。<br />
那么只需对 <span class="math inline">\(P\)</span> 做一次 FFT ，就可以通过共轭 <span class="math inline">\(O(n)\)</span> 求出 <span class="math inline">\(FFT(Q)\)</span> 的系数。<br />
然后通过 <span class="math inline">\(FFT(P), FFT(Q)\)</span> 求 <span class="math inline">\(FFT(A), FFT(B)\)</span> 就是解上面的二元一次方程组，也是可以 <span class="math inline">\(O(n)\)</span> 做到的。</p>
<h3 id="fft-两次变一次-2">FFT 两次变一次 2</h3>
<p>这是 myy 提出的一个优秀的 FFT trick ，能够一次 FFT 处理两个多项式，但缺点是精度会进一步降低。</p>
<p>前提是两个多项式的系数在 FFT 后虚部为 0 ，这个条件在 IDFT 中往往是能满足的。</p>
<p>例如要给两个多项式 <span class="math inline">\(A, B\)</span> 做 FFT ，构造多项式 <span class="math inline">\(P\)</span> 满足：</p>
<p><span class="math display">\[P(x) = A(x) + i B(x)\]</span></p>
<p>求出 <span class="math inline">\(FFT(P)\)</span> ，同样有 <span class="math inline">\(FFT(P)(x) = FFT(A)(x) + i FFT(B)(x)\)</span> ，而 <span class="math inline">\(FFT(A), FFT(B)\)</span> 系数的虚部都是 0 。</p>
<p>那么 <span class="math inline">\(FFT(P)\)</span> 的实部就是 <span class="math inline">\(FFT(A)\)</span> ，虚部就是 <span class="math inline">\(FFT(B)\)</span> 。</p>
<h2 id="线段树">线段树</h2>
<p>同时需要记录区间最大值 max 和区间取 min 标记 tag 时，直接用 max 代替掉 tag 即可。<br />
比如区间取 min 和区间求和的吉司机线段树（segment tree beats）。</p>
<h2 id="stl">STL</h2>
<p>将数组降序排序不需要写 <code>cmp</code> ，只需要 <code>std::sort(a, a + n, std::greater&lt;int&gt;());</code> 即可。<br />
<code>std::greater</code> 包含在头文件 <code>functional</code> 中，这同样适用于结构体排序。<br />
另外如果要用小根堆，可以使用 <code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt;</code> 。<br />
与 <code>std::greater</code> 对应的是 <code>std::less</code> 。</p>
<p><code>std::set</code> 插入后返回的迭代器可以直接获取：<code>auto iter = set.insert(x).second</code> 。</p>
<p><code>std::valarray</code> 可以很快速并且很方便地进行许多批量操作，使用用来存方程组之类的东西。</p>
<h2 id="位运算">位运算</h2>
<h3 id="预处理-bitcount">预处理 bitcount</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    bitcount[i] = bitcount[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="预处理-highbit">预处理 highbit</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">    highbit[i] = highbit[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="语法">语法</h2>
<p>利用语法糖可以写出一些骚操作，比如下面这个快读模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inputer</span> &#123;</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>], *p;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">int</span>(strtol(p, &amp;p, <span class="number">10</span>)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> strtoll(p, &amp;p, <span class="number">10</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T &amp;x)</span> </span>&#123; x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">  template&lt;class T, class ...A&gt; inline void operator () (T &amp;x, A &amp;...a)</span><br><span class="line">   &#123; x = *<span class="keyword">this</span>; <span class="keyword">this</span> -&gt; <span class="keyword">operator</span> ()(a...); &#125;</span><br><span class="line"> Inputer() &#123; fread(buffer, <span class="number">1</span>, <span class="keyword">sizeof</span> buffer, <span class="built_in">stdin</span>); &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"><span class="keyword">char</span> *Inputer::p = Inputer::buffer;</span><br><span class="line"><span class="keyword">char</span> Inputer::buffer[] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>它有多种用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = read;</span><br><span class="line"></span><br><span class="line">  ll b = read;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">   read(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">   ll e, f;</span><br><span class="line">  read(d, e, f);</span><br><span class="line"></span><br><span class="line">  foo(read);</span><br><span class="line"></span><br><span class="line">  read.<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ll g = <span class="keyword">int</span>(read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且可以自定义各种类型的读入，编译器能够根据类型正确调用对应的输入函数（在没有歧义的前提下），或者自己在调用时直接给出类型。</p>
<p>ps: 这个 trick 不是学的，是我自己原创的，也是我一直在使用的快读模板。:)</p>
<p>事实上由于大多时候不需要快读，我平时用的输入模板是这样子的（用法完全相同）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; ll x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x), x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(T &amp;x)</span> </span>&#123; x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">  template&lt;class T, class ...A&gt; inline void operator () (T &amp;x, A &amp;...a)</span><br><span class="line">   &#123; x = *<span class="keyword">this</span>; <span class="keyword">this</span> -&gt; <span class="keyword">operator</span> () (a...); &#125;</span><br><span class="line">&#125; read;</span><br></pre></td></tr></table></figure>
<h2 id="取模优化">取模优化</h2>
<p>众所周知取模很慢，于是有了各种各样的取模优化。</p>
<p>当 <span class="math inline">\(P\)</span> 以内的数做减法时，可以判断结果是不是负数，如果是负数就加上 <span class="math inline">\(P\)</span> ，但是众所周知使用 <code>if</code> 分支结构可能会带来一定的惩罚，于是可以用到一个 trick ，对于一个 <code>int</code> 存储的数 <code>x</code> ，它为负数时有 <code>x &gt;&gt; 31 == -1</code> ，非负时有 <code>x &gt;&gt; 31 = 0</code> ，于是可以这样写（加法同理），实测在不开启编译优化时效果显著，开启优化时没有啥用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __d (<span class="keyword">int</span> &amp;x) &#123; x += (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br><span class="line"><span class="keyword">void</span> __a (<span class="keyword">int</span> &amp;x) &#123; x += -P + (x &gt;&gt; <span class="number">31</span>) &amp; P; &#125;</span><br></pre></td></tr></table></figure>
<p>当要算多个 <span class="math inline">\(P^2\)</span> 内的数的和时，常规做法每次加都要取模，但事实上可以用 <code>long long</code> 存储，只在最后一次取模，优化效果显著：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">  __a(sum += <span class="number">1l</span>l * a[i] * b[i]);</span><br><span class="line">sum %= P;</span><br></pre></td></tr></table></figure>
<p>更高级的取模优化可以参加论文哥的板子，或者 min25 的相关文章。</p>
<h2 id="零碎">零碎</h2>
<p>拓扑排序可以用栈模拟，可以在同时求出拓扑序序列。</p>
<p>但实际上栈是不必要的，一个实时的拓扑序序列可以代替掉栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++) &#123;</span><br><span class="line">   <span class="keyword">int</span> u = topsort[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u])</span><br><span class="line">      <span class="keyword">if</span> ((-- deg[v]) == <span class="number">0</span>)</span><br><span class="line">            topsort[++ tot] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛57</title>
    <url>/2020/01/10/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B57/</url>
    <content><![CDATA[<p>咕咕咕我又来写总结啦。</p>
<p>第一次打牛客，一进牛客发现还有 30s 就有一场比赛，就报了名。<br />
一开始只是打算玩玩，看看牛客的题来着。</p>
<figure>
<img src="/images/nowcoder.com.png" alt="牛客" /><figcaption aria-hidden="true">牛客</figcaption>
</figure>
<p>一不小心上瘾了，可惜不计 rating 。<br />
（另外 %%% <span class="citation" data-cites="CYJian">@CYJian</span> 喜提 rank1 ）</p>
<a id="more"></a>
<p>先看 A 题挺签到的，花几分钟过了，然而交 WA 了一次，原因竟然是下标 0, 1 开头混用了，感觉自己很蠢。</p>
<p>然后想着玩玩嘛，就直接开 F 了。</p>
<p>嗯看着是道数学题？这个求和方式是个组合数嘛，询问就是一个这玩意：</p>
<p><span class="math display">\[\sum_{i=l}^r a_i C_{r-l}^{i-l}\]</span></p>
<p>我猜这个个组合数展开成阶乘然后配卷积，然后推式子，推了一年没有半点用，连个卷积的影子都没有。</p>
<p>然后打算根据组合意义算，就是在一个三角形上走的路径数，<br />
三角形有 <span class="math inline">\(O(n^2)\)</span> 个点，每个点可以 <span class="math inline">\(O(1)\)</span> 递推 (<span class="math inline">\(A_{i,j} = A_{i-1,j} + A_{i-1,j-1}\)</span>) ，<br />
询问就是询问一个点的值 (<span class="math inline">\(A_{r,r-l}\)</span>) 。<br />
但同时根据组合数的性质，每个点可以 <span class="math inline">\(O(k)\)</span> 地由该点底下 k 层的 k 个点递推出来。<br />
暴力预处理是 <span class="math inline">\(O(n^2+q)\)</span> 的，暴力询问是 <span class="math inline">\(O(n+qn)\)</span> 的，这看着就是要在两者之间求得平衡。</p>
<p>于是我想到了分块，只要预处理三角形若干排，然后询问就可以找到比较近的已经处理的一排暴力算。</p>
<p>如果两排的间距是 <span class="math inline">\(B\)</span> ，那么询问复杂度就是 <span class="math inline">\(O(B)\)</span> 的。</p>
<p>然而怎么预处理？每个点拿组合数直接算复杂度仍然是 <span class="math inline">\(O(n^2)\)</span> 的 🤔 。</p>
<p>然后卡这里又卡了一年，后来灵光一现发现两排之间的生成函数就是乘一个 <span class="math inline">\((1+x)\)</span> ，<br />
用 NTT 即可在两排之间快速预处理，乘一个 <span class="math inline">\((1+x)^B\)</span> 就行了。<br />
<del><span class="math inline">\((1+x)^B\)</span> 不就是是组合数的生成函数吗？这都没想到感觉自己很睿智。</del></p>
<p>那么预处理的复杂度为 <span class="math inline">\(O(nlogn\frac{n}{B})\)</span> 的，和询问的复杂度均衡一下就可以得到一个 <span class="math inline">\(O(n\sqrt{nlogn})\)</span> 的做法。<br />
（假定 <span class="math inline">\(n, q\)</span> 同阶）</p>
<p>然后就开始码，码完 T 了，T 了两次，经 <span class="citation" data-cites="CYJian">@CYJian</span> 指点发现 <span class="math inline">\(B\)</span> 设小了，导致带 log 的卷积部分跑得很慢。<br />
改完就 A 了，过了 1.5h 竟然还拿了一血。<br />
这个时候没记错是 rank140 左右。</p>
<p>然后开了一眼 D 感觉就是个马拉车，打完发现疯狂 WA ，仔细读题发现要求找两个子串，是恰好两个，用一个都不行 wdnmd 😡 。</p>
<p>A 掉 D 就开始飘了， B 题细节题屑的一批，C 题是个 FWT 。</p>
<p>结果 C 题也疯狂 WA ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">       <span class="comment">// ....</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">          <span class="keyword">if</span>(w[i] &gt; W) &#123;</span><br><span class="line">               <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因竟然是这个特判，它的 continue 只对 for 有效。。。<br />
都打了两三年代码竟然犯这个错误。。。</p>
<p>最后打完就只有几分钟了，竟然上了 rank4 ，罚时高出天际。</p>
<p>没有被抽中 😭 😭 😭 😔 😔 😔 。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>miller-rabin 和 pollard-rho</title>
    <url>/2020/01/06/miller-rabin-%E5%92%8C-pollard-rho/</url>
    <content><![CDATA[<h2 id="miller-rabin">miller-rabin</h2>
<p>用于快速测试一个数 <span class="math inline">\(n\)</span> 是否为质数，有概率出错。</p>
<p>不妨假设 <span class="math inline">\(n\)</span> 是奇数，此外 miller-rabin 需要随意选取一个小质数 <span class="math inline">\(p\)</span> 。</p>
<h4 id="理论">理论</h4>
<p>miller-rabin 用到的两个基本定理：</p>
<ul>
<li><p>费马小定理：如果 <span class="math inline">\(n\)</span> 为质数，一定有 <span class="math inline">\(p^n \equiv p \pmod{n}\)</span> ，即 <span class="math inline">\(p^{n-1} \equiv 1\)</span> 。</p></li>
<li><p>二次探测定理：如果 <span class="math inline">\(n\)</span> 为质数，对于 <span class="math inline">\(a^2 \equiv 1 \pmod{n}\)</span> 一定有 <span class="math inline">\(a \equiv -1\)</span> 或 <span class="math inline">\(a \equiv n - 1\)</span> 。</p></li>
</ul>
<a id="more"></a>
<p>如果 <span class="math inline">\(p^{n-1} \equiv 1\)</span> 不成立，根据费马小定理， <span class="math inline">\(n\)</span> 一定不为质数，<br />
否则令 <span class="math inline">\(x = n - 1\)</span> ，<span class="math inline">\(x\)</span> 一定是偶数，那么可以计算 <span class="math inline">\(y = p^{\frac{x}{2}}\)</span> ，<br />
由于 <span class="math inline">\(p^x \equiv 1\)</span> ，那么根据二次探测定理，如果 <span class="math inline">\(y \equiv 1\)</span> 和 <span class="math inline">\(y \equiv n - 1\)</span> 都不成立，<span class="math inline">\(n\)</span> 一定不为质数。<br />
否则如果 <span class="math inline">\(y \equiv 1\)</span> ，令 <span class="math inline">\(x = \frac{x}{2}\)</span> 继续判断，<br />
直到 <span class="math inline">\(y \equiv n - 1\)</span> 或者 <span class="math inline">\(x\)</span> 为奇数，此时 <span class="math inline">\(n\)</span> 通过了测试，但无法保证 <span class="math inline">\(n\)</span> 是质数还是合数。</p>
<p>如果仅仅通过一次测试就认为 <span class="math inline">\(n\)</span> 是质数的话错误的概率很大，<br />
实践中往往选取多个质数 <span class="math inline">\(p\)</span> 测试多次，全部通过才认为 <span class="math inline">\(n\)</span> 是质数。<br />
实践证明，只要取前 9 个质数，就能准确判断 <span class="math inline">\(10^{18}\)</span> 内的所有数。</p>
<h4 id="实现">实现</h4>
<p>参考实现（经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll x, ll y, ll mod)</span> </span>&#123;</span><br><span class="line">    ll tmp = x * y - ll((<span class="keyword">long</span> <span class="keyword">double</span>)x / mod * y + <span class="number">0.5</span>) * mod;</span><br><span class="line">    <span class="keyword">return</span> tmp &lt; <span class="number">0</span> ? tmp + mod : tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">power</span><span class="params">(ll x, ll k, ll mod)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            res = mul(res, x, mod);</span><br><span class="line">        x = mul(x, x, mod);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller</span><span class="params">(ll n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (power(p, n - <span class="number">1</span>, n) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ll x = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span>(x &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ll y = power(p, x, n);</span><br><span class="line">        <span class="keyword">if</span> (y == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> p[len] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (n == p[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> miller(n, p[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化">优化</h4>
<p>事实上 miller-rabin 中进行的多次快速幂是没有必要的。</p>
<p>将 <span class="math inline">\(n\)</span> 表示为 <span class="math inline">\(n=2^s t + 1\)</span> 的形式，其中 <span class="math inline">\(t\)</span> 为奇数，<br />
那么 miller-rabin 中可能用到的所有快速幂，都是 <span class="math inline">\(p^{2^it} (0 \leq i &lt; s)\)</span> 的形式。<br />
原本 <span class="math inline">\(x\)</span> 是从 <span class="math inline">\(2^s t\)</span> 到 <span class="math inline">\(t\)</span> ，考虑倒着进行，<span class="math inline">\(x\)</span> 从 <span class="math inline">\(t\)</span> 到 <span class="math inline">\(2^s t\)</span> ，<br />
这样只需要一次快速幂计算 <span class="math inline">\(y = p^t\)</span> ，每次 <span class="math inline">\(x\)</span> 扩大一倍时将 <span class="math inline">\(y\)</span> 平方即可。</p>
<p>参考实现（经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller</span><span class="params">(ll n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">   ll t = n - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(!(t &amp; <span class="number">1</span>)) t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   ll y = power(p, t, n), ny;</span><br><span class="line">    <span class="keyword">while</span>((t &lt;&lt; <span class="number">1</span>) &lt; n) &#123;</span><br><span class="line">      ny = mul(y, y, n);</span><br><span class="line">        <span class="keyword">if</span>(ny == <span class="number">1</span> <span class="keyword">and</span> !(y == <span class="number">1</span> <span class="keyword">or</span> y == n - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        y = ny;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">9</span>, p[len] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>&#125;;</span><br><span class="line"> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) <span class="keyword">if</span>(n == p[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) <span class="keyword">if</span>(!miller(n, p[i])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pollard-rho">pollard-rho</h2>
<p>用于快速找到一个数 <span class="math inline">\(n\)</span> 的一个非平凡因子，常应用于大数的质因数分解。</p>
<p>这玩意大家似乎都是背代码，很难找到关于原理以及复杂度的证明，学习资料很少，如果有误，还请指正。</p>
<h4 id="非平凡因子">非平凡因子</h4>
<p>关于非平凡因子：如果 <span class="math inline">\(d\)</span> 能整除 <span class="math inline">\(n\)</span> 且满足 <span class="math inline">\(1 &lt; d &lt; n\)</span> ，则称 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(n\)</span> 的非平凡因子。</p>
<p>从定义可以看出质数是没有非平凡因子的，事实上质数直接拿来做 pollard-rho 会陷入死循环，<br />
因此 pollard-rho 常常需要配合 miller-rabin 使用，在一个数为质数时停止分解。</p>
<p>因此以下讨论假定 <span class="math inline">\(n\)</span> 是合数。</p>
<h4 id="随机实验">随机实验</h4>
<p>随机一个正整数 <span class="math inline">\(d(d &lt; n)\)</span> ，如果 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(n\)</span> 的因子，那么就找到了 <span class="math inline">\(n\)</span> 的一个非平凡因子 <span class="math inline">\(d\)</span> 。<br />
然而这样的概率很小，最坏情况下是 <span class="math inline">\(\frac{1}{n}\)</span> 的。</p>
<p>随机一个正整数 <span class="math inline">\(v(v &lt; n)\)</span> ，求出 <span class="math inline">\(d = \gcd(v, n)\)</span> ，如果 <span class="math inline">\(d &gt; 1\)</span> 那么就找到了 <span class="math inline">\(n\)</span> 的一个非平凡因子 <span class="math inline">\(d\)</span> 。<br />
这样成功的概率就大得多，最坏是 <span class="math inline">\(\frac{1}{\sqrt{n}}\)</span> 的。</p>
<p>证明：<br />
设 <span class="math inline">\(p = minp(n)\)</span> 是合数 <span class="math inline">\(n\)</span> 的最小质因子，那么 <span class="math inline">\(p \leq \sqrt{n}\)</span> ，而 <span class="math inline">\(p\)</span> 的倍数有 <span class="math inline">\(\lfloor\frac{n}{p}\rfloor\)</span> 个，<br />
因此概率的一个下界是 <span class="math inline">\(\frac{1}{p}\)</span> ，这是取到 <span class="math inline">\(p\)</span> 的倍数的概率。<br />
而这个下界是可以达到的，当 <span class="math inline">\(n = p^2\)</span> 且时，概率恰为 <span class="math inline">\(\frac{1}{p}\)</span> ，也就是 <span class="math inline">\(\frac{1}{\sqrt{n}}\)</span> 。</p>
<p>以下讨论中均有 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(n\)</span> 的最小质因子。</p>
<h4 id="生日悖论">生日悖论</h4>
<p>然而这个概率还是很小，期望下需要随机 <span class="math inline">\(O(p)\)</span> 次才能成功（这是个上界）。</p>
<p>根据生日悖论可以提供一个优化思路，<br />
随机 <span class="math inline">\(\sqrt{p}\)</span> 个数 <span class="math inline">\(v\)</span> ，其中有 <span class="math inline">\(\frac{1}{2}\)</span> 的概率存在两个数 <span class="math inline">\(v_1, v_2\)</span> 模 <span class="math inline">\(p\)</span> 同余，<br />
也就是说存在两个数的差是 <span class="math inline">\(p\)</span> 的倍数。<br />
但是如果两两作差与 <span class="math inline">\(n\)</span> 取 gcd ，期望复杂度仍然是 <span class="math inline">\(O(p)\)</span> 的。</p>
<!-- 算上 gcd 的复杂度，可以在期望复杂度 $O(\sqrt{p}\log n)$ 的时间找到 $n$ 的一个非平凡因子。  
但事实上可以每次取 $O(\sqrt{p})$ 个数为一组，每次对求一组数的乘积 $k$ ，求 $gcd(n, k)$ 即可。  
而根据 $gcd(x, n) = gcd(x \% n, n)$ ，这个 $k$ 可以是模 $n$ 意义下的。  
这样期望复杂度 $O(\sqrt{p} + \log n)$ 。 -->
<h4 id="rho">rho</h4>
<p>pollard-rho 用到了一个特殊的伪随机数列 <span class="math inline">\(\{a\}\)</span> ，对于参数 <span class="math inline">\(c\)</span> ，其满足：</p>
<p><span class="math display">\[ a_{i+1} = (a_i^2 + c) \bmod n \]</span></p>
<p>这个数列是个 <span class="math inline">\(\rho\)</span>(rho) 形，这也是 pollard-rho 的名字由来。<br />
换言之，存在链长 <span class="math inline">\(T\)</span> 和环长 <span class="math inline">\(M\)</span> ，满足 <span class="math inline">\(\forall i,k&gt;0: a_{T+i} = a_{T+i+kM}\)</span> 。<br />
如果把 <span class="math inline">\(a\)</span> 两两不同的前缀部分近似看做真随机数列，那么根据生日悖论，这个长度 <span class="math inline">\(T + M\)</span> 是期望 <span class="math inline">\(O(\sqrt{n})\)</span> 的。<br />
也就是说 <span class="math inline">\(T\)</span> 和 <span class="math inline">\(M\)</span> 期望都是在 <span class="math inline">\(O(\sqrt{n})\)</span> 以内的。</p>
<p>令 <span class="math inline">\(b_i = a_i \bmod p\)</span> ，当然由于 <span class="math inline">\(p\)</span> 未知，<span class="math inline">\(b\)</span> 这个数列实际上是未知的。<br />
那么同样的道理，<span class="math inline">\(b\)</span> 的链长和环长 <span class="math inline">\(t, m\)</span> 是期望 <span class="math inline">\(O(\sqrt{p})\)</span> 的。</p>
<p>现在要做的是通过对 <span class="math inline">\(a\)</span> 作差来间接对 <span class="math inline">\(b\)</span> 作差，目标是选到两个下标 <span class="math inline">\(i, j\)</span> 满足 <span class="math inline">\(b_i = b_j\)</span> ，<br />
这样的话，<span class="math inline">\(|a_i - a_j|\)</span> 就是 <span class="math inline">\(p\)</span> 的倍数，也就是说 <span class="math inline">\(\gcd(n, |a_i - a_j|) \geq p\)</span> 。<br />
关键在于环长，如果只选取下标 <span class="math inline">\((i, 2i)\)</span> 作差，那么当 <span class="math inline">\(i \geq t\)</span> 且 <span class="math inline">\(i=km\)</span> 时，<br />
根据 <span class="math inline">\(b_i = b_{t+(i-t)} = b_{t+(i-t)+km} = b_{t+(i-t)+i} = b_{2i}\)</span> ，<br />
可以确定此时一定有 <span class="math inline">\(b_i = b_{2i}\)</span> ，<br />
而上面提到过 <span class="math inline">\(t, m\)</span> 期望都是 <span class="math inline">\(O(\sqrt{p})\)</span> 的，那么第一个这样的 <span class="math inline">\(i\)</span> 的大小也是期望 <span class="math inline">\(O(\sqrt{p})\)</span> 的。</p>
<p>一个期望复杂度 <span class="math inline">\(O(\sqrt{p})\)</span> 的 pollard-rho 基本思想大抵如此。</p>
<h4 id="实践">实践</h4>
<p>算法流程就是随机一个生成序列的参数 <span class="math inline">\(c\)</span> 。<br />
然后枚举 <span class="math inline">\(i\)</span> ，同时通过递推维护 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{2i}\)</span> ，<br />
当 <span class="math inline">\(\gcd(n, |a_i - a_{2i}|) &gt; 1\)</span> 时就得到了一个非平凡因子。<br />
直接做考虑 gcd 期望复杂度 <span class="math inline">\(O(\sqrt{p} \log n)\)</span> 。<br />
但这个 gcd 很好优化，设 <span class="math inline">\(v_i = |a_i - a_{2i}|\)</span> ，把 <span class="math inline">\(v\)</span> 相邻 <span class="math inline">\(k\)</span> 个乘起来再和 <span class="math inline">\(n\)</span> 做 gcd ，<br />
根据 <span class="math inline">\(\gcd(x, n) = \gcd(x \bmod n, n)\)</span> ，乘积可以是模 <span class="math inline">\(n\)</span> 意义下的。<br />
理论上只要 <span class="math inline">\(k &gt; O(\log n)\)</span> ，复杂度就能做到 <span class="math inline">\(O(\sqrt{p} + k + \log n)\)</span> ，<br />
一般认为 <span class="math inline">\(p\)</span> 足够大，此时复杂度就是 <span class="math inline">\(O(\sqrt{p})\)</span> ，最坏情况下就是 <span class="math inline">\(O(n^{\frac{1}{4}})\)</span> 。<br />
实践中往往采用倍增的方式，起初 <span class="math inline">\(k\)</span> 不断成倍增大，增大到 128 时保持不变。<br />
这样可以保证在 <span class="math inline">\(p\)</span> 很小的时候不用算 <span class="math inline">\(\log n\)</span> 次就能得到非平凡因子，减小常数。</p>
<p>有一些需要注意的地方：</p>
<ul>
<li><p>有小概率 <span class="math inline">\(M\)</span> 与 <span class="math inline">\(m\)</span> 恰好相等，在 <span class="math inline">\(b_i = b_{2i}\)</span> 的时候恰好有 <span class="math inline">\(a_i = a_{2i}\)</span> ，此时应该更换参数 <span class="math inline">\(c\)</span> 重新进行算法。</p></li>
<li><p>当 <span class="math inline">\(v\)</span> 的乘积模 <span class="math inline">\(n\)</span> 为 0 时需要及时退出，否则算法会返回 <span class="math inline">\(n\)</span> ，而 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(n\)</span> 的非平凡因子。</p></li>
<li><p><span class="math inline">\(n = 4\)</span> 时 无论怎么取参数 <span class="math inline">\(c\)</span> 和序列初值，<span class="math inline">\(M = m\)</span> 恒成立，需要特判。</p></li>
</ul>
<p>参考实现（经过测试，上接 miller-rabin 的部分）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">nxt</span><span class="params">(ll x, ll c, ll n)</span> </span>&#123;</span><br><span class="line"> ll res = mul(x, x, n) + c;</span><br><span class="line">    <span class="keyword">return</span> res &gt;= n ? res - n : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pollard</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    ll c = <span class="number">1l</span>l * rand() * rand() % n;</span><br><span class="line"> ll a = nxt(rand(), c, n);</span><br><span class="line"> ll a2 = nxt(a, c, n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> lim = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">while</span>(a != a2) &#123;</span><br><span class="line">        ll v = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim <span class="keyword">and</span> a != a2; i ++) &#123;</span><br><span class="line">            ll tov = mul(v, <span class="built_in">std</span>::<span class="built_in">abs</span>(a - a2), n);</span><br><span class="line">         <span class="keyword">if</span>(!tov) <span class="keyword">return</span> <span class="built_in">std</span>::__gcd(v, n);</span><br><span class="line">         v = tov;</span><br><span class="line">          a = nxt(a, c, n);</span><br><span class="line">         a2 = nxt(nxt(a2, c, n), c, n);</span><br><span class="line">        &#125;</span><br><span class="line">        ll d = <span class="built_in">std</span>::__gcd(v, n);</span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">      <span class="keyword">if</span>(lim &lt; <span class="number">128</span>) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pollard(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用">应用</h4>
<p>求最小质因数，最大质因数，质因数分解等，<br />
都只需要每次找到 <span class="math inline">\(n\)</span> 的非平凡因子 <span class="math inline">\(d\)</span> 然后不断令 <span class="math inline">\(n\)</span> 除以 <span class="math inline">\(d\)</span> 转换为子问题，<br />
需要注意的是 <span class="math inline">\(d\)</span> 不一定是质数，也要递归处理。<br />
终止条件是 <span class="math inline">\(n\)</span> 为质数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>miller-rabin</tag>
        <tag>pollard-rho</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学玄学操作</title>
    <url>/2020/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%8E%84%E5%AD%A6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>以下公式均不给出证明，目的是为了让结论一目了然。</p>
<a id="more"></a>
<h2 id="组合数相关">组合数相关</h2>
<p><span class="math display">\[ C_n^m C_m^k = C_n^k C_{n-k}^{m-k} \]</span></p>
<p>基本递推式 <span class="math display">\[ C_n^m = C_{n-1}^{m-1} + C_{n-1}^m \]</span></p>
<p>二项式定理 <span class="math display">\[ (a+b)^n = \sum_{i=0}^n C_n^i a^i b^{n-i} \]</span></p>
<p><span class="math display">\[ \sum_{i=0}^n (C_n^i)^2 = C_{2n}^n \]</span></p>
<p><span class="math display">\[ C_{n+m}^k = \sum_{i=0}^k C_n^i C_m^{k-i} \]</span></p>
<p>卢卡斯定理（要求 <span class="math inline">\(p\)</span> 是质数） <span class="math display">\[ C_n^m \% p = C_{n/p}^{m/p} C_{n \% p}^{m \% p} \% p \]</span></p>
<h2 id="第一类斯特林数相关">第一类斯特林数相关</h2>
<p><span class="math display">\[ s_n^m = s_{n-1}^{m-1} + (n-1) s_{n-1}^m \]</span></p>
<p><span class="math display">\[ x^{\overline{n}} = \sum_{m} s_n^m x^m \]</span></p>
<h2 id="第二类斯特林数相关">第二类斯特林数相关</h2>
<p><span class="math display">\[ S_n^m = S_{n-1}^{m-1} + m S_{n-1}^m \]</span></p>
<p><span class="math display">\[ n^m = \sum_{k=0}^m S_m^k C_n^k k! \]</span></p>
<p>上式的二项式反演，组合数拆开后可转换为卷积形式 <span class="math display">\[ S_n^m = \frac{1}{m!} \sum_{k=0}^m (-1)^{m-k} C_m^k k^n \]</span></p>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛</title>
    <url>/2020/01/02/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<p>杜教筛一般用于求一类数论函数的前缀和。</p>
<p>假设要求数论函数 <span class="math inline">\(f(x)\)</span> 的前缀和 <span class="math inline">\(S(n) = \sum_{i=1}^n f(i)\)</span> 。</p>
<p>杜教筛的关键在于构造两个合适的函数 <span class="math inline">\(g, h\)</span> 满足 <span class="math inline">\(h = f \cdot g\)</span> 。</p>
<p>这里的函数相乘指的是狄利克雷卷积。</p>
<a id="more"></a>
<h2 id="理论">理论</h2>
<p>则由 <span class="math inline">\(h = f \cdot g\)</span> 可得（以下除号表示整除）：</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\sum_{i=1}^n h(i) &amp;= \sum_{i=1}^n\sum_{d|i}f(\frac{i}{d})g(d) \\\\
&amp;= \sum_{d=1}^ng(d)\sum_{i=d}^nf(\frac{i}{d})[i|d] \\\\
&amp;= \sum_{d=1}^ng(d)\sum_{i=1}^{n/d}f(i) \\\\
&amp;= \sum_{d=1}^ng(d)S(\frac{n}{d}) \\\\
&amp;= g(1)S(n) + \sum_{d=2}^ng(d)S(\frac{n}{d}) \\\\
\end{aligned}
\end{equation}
\]</span></p>
<p>所以 <span class="math inline">\(S(n) = \sum_{i=1}^n h(i) - \sum_{d=2}^n g(d)S(\frac{n}{d})\)</span> 。</p>
<p>前提是每个 <span class="math inline">\(\sum_{i=1}^n h(i)\)</span> 很容易求，那么接下来不考虑 <span class="math inline">\(h\)</span> ，<br />
对于后面的部分可以整除分块，还需要快速求出 <span class="math inline">\(g\)</span> 的一段区间和，<br />
然后就可以递推，由于形如 <span class="math inline">\(\lfloor\frac{n}{d}\rfloor\)</span> 的数只有 <span class="math inline">\(O(\sqrt{n})\)</span> 个，<br />
可以只递推这 <span class="math inline">\(O(\sqrt{n})\)</span> 个 <span class="math inline">\(S\)</span> ，不考虑 <span class="math inline">\(g, h\)</span> 的计算复杂度，复杂度为 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 。</p>
<p>update: 根据 16 年的集训队论文，直接计算的复杂度是 <span class="math inline">\(O(n^{\frac{3}{4}})\)</span> ，<br />
要保证复杂度的话需要线性筛预处理 <span class="math inline">\(n^{\frac{2}{3}}\)</span> 以内的 <span class="math inline">\(S\)</span> 。<br />
证明后面有提到。</p>
<p>关于如何存储 <span class="math inline">\(S\)</span> ，直接用数组存需要 <span class="math inline">\(O(n)\)</span> 的空间，开 map 每次取用带一个 log ，<br />
普通的离散化也会带一个 log 。</p>
<p>观察 <span class="math inline">\(\frac{n}{d}\)</span> 的分布，当 <span class="math inline">\(d \leq \sqrt{n}\)</span> 时， <span class="math inline">\(\frac{n}{d}\)</span> 的值两两不同。<br />
而当 <span class="math inline">\(d &gt; \sqrt{n}\)</span> 时， <span class="math inline">\(\frac{n}{d}\)</span> 的值都不超过 <span class="math inline">\(\sqrt{n}\)</span> 。<br />
设 <span class="math inline">\(m\)</span> 是 <span class="math inline">\(\frac{n}{d}\)</span> 的不同取值个数，那么可以用如下的函数对 <span class="math inline">\(x = \frac{n}{d}\)</span> 进行离散化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;= sqrt_of_n ? x : m - (n / x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实践">实践</h2>
<p>举个简单的栗子：求 <span class="math inline">\(\mu\)</span> 的前缀和。</p>
<p>首先根据 <span class="math inline">\(\mu\)</span> 的性质不难想到 <span class="math inline">\(\mu \cdot I = \epsilon\)</span> 。</p>
<p>那么就将 <span class="math inline">\(f = \mu, g = I, h = \epsilon\)</span> 代入上去，得到：</p>
<p><span class="math display">\[S(n) = \sum_{i=1}^n \mu(i) = \sum_{i=1}^n \epsilon(i) - \sum_{d=2}^n I(d) \cdot S(\frac{n}{d})\]</span></p>
<p>即</p>
<p><span class="math display">\[S(n) = 1 - \sum_{d=2}^n S(\frac{n}{d})\]</span></p>
<h2 id="扩展">扩展</h2>
<p>但有时候无法构造合适的 <span class="math inline">\(h = f \cdot g\)</span> 使得 <span class="math inline">\(g, h\)</span> 的前缀和可以 <span class="math inline">\(O(1)\)</span> 算出。<br />
这时候杜教筛是否就毫无用武之地呢？不见得。</p>
<p>观察递推式，利用整除分块，设 <span class="math inline">\(S_f, S_g, S_h\)</span> 分别表示 <span class="math inline">\(f, g, h\)</span> 的前缀和，那么：</p>
<p><span class="math display">\[S_f(n) = S_h(n) - \sum_{i=2}^m (S_g(r_i) - S_g(r_{i-1})) S_f(\frac{n}{r_i})\]</span></p>
<p>其中 <span class="math inline">\(m\)</span> 是 <span class="math inline">\(\frac{n}{d}\)</span> 的不同取值个数， <span class="math inline">\(r_i\)</span> 是整除分块后对应第 <span class="math inline">\(i\)</span> 块的右端点。</p>
<p>首先不难发现需要用到的 <span class="math inline">\(S_h\)</span> 也都是形如 <span class="math inline">\(\frac{n}{d}\)</span> 的数，<br />
那么只需要如果 <span class="math inline">\(S_h\)</span> 能够杜教筛（或者其他筛）筛出来就行了。</p>
<p>再考虑 <span class="math inline">\(S_g\)</span> 需要的取值，由整除分块中的 <span class="math inline">\(r = n / (n / l)\)</span> 可知，<span class="math inline">\(r_i\)</span> 的取值也都是形如 <span class="math inline">\(\frac{n}{d}\)</span> 的数，<br />
同理只要能筛 <span class="math inline">\(S_g\)</span> 就行了，不一定要 <span class="math inline">\(O(1)\)</span> 算。</p>
<h2 id="复杂度">复杂度</h2>
<p>发现之前对杜教筛的复杂度理解有问题。</p>
<p>假设已经预处理（或者可以 <span class="math inline">\(O(1)\)</span> 计算）需要的 <span class="math inline">\(S_g, S_h\)</span> ，<br />
那么需要计算的 <span class="math inline">\(S(\frac{n}{d})\)</span> 有 <span class="math inline">\(O(\sqrt{n})\)</span> 个。<br />
将他们分为两类：</p>
<ol type="1">
<li><span class="math inline">\(d \leq \sqrt{n}\)</span>: 这部分有 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
<li><span class="math inline">\(d \geq \sqrt{n}, \frac{n}{d} \leq \sqrt{n}\)</span>: 这部分同样有 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
</ol>
<p>计算单个 <span class="math inline">\(S(x)\)</span> 需要枚举 <span class="math inline">\(\frac{x}{d}\)</span> ，复杂度为 <span class="math inline">\(O(\sqrt{x})\)</span> 。</p>
<p>对于两部分分别计算复杂度，总复杂度就是：</p>
<p><span class="math display">\[ \sum_{i=1}^{\sqrt{n}} O(\sqrt{i}) + \sum_{i=1}^{\sqrt{n}} O(\sqrt{\frac{n}{i}}) \]</span></p>
<p>对于前者：</p>
<p><span class="math display">\[ \sum_{i=1}^{\sqrt{n}} O(\sqrt{i}) = O(\int_{0}^{\sqrt{n}}\sqrt{x}dx) = O(n^{\frac{3}{4}}) \]</span></p>
<p>对于后者：</p>
<p><span class="math display">\[ \sum_{i=1}^{\sqrt{n}} O(\sqrt{\frac{n}{i}}) = O(\int_{0}^{\sqrt{n}}\sqrt{\frac{n}{x}}dx) = O(n^{\frac{3}{4}}) \]</span></p>
<p>如果预处理 <span class="math inline">\(k\)</span> 以内的 <span class="math inline">\(S\)</span> 且 <span class="math inline">\(k \geq \sqrt{n}\)</span> ，预处理部分复杂度为 <span class="math inline">\(O(k)\)</span> ，杜教筛部分前者也可以被预处理。</p>
<p>对于后者：</p>
<p><span class="math display">\[ \sum_{i=1}^{\frac{n}{k}} O(\sqrt{\frac{n}{i}}) = O(\int_{0}^{\frac{n}{k}}\sqrt{\frac{n}{x}}dx) = O(\frac{n}{\sqrt{k}}) \]</span></p>
<p>当 <span class="math inline">\(k = \frac{n}{\sqrt{k}}\)</span> 时，总复杂度达到最优，<br />
此时 <span class="math inline">\(k = n^{\frac{2}{3}}\)</span> ，总复杂度 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值法</title>
    <url>/2019/12/27/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    <content><![CDATA[<p>这里只介绍关于多项式的拉格朗日插值法，对于一般函数的拟合当做一个多项式就好了。</p>
<h2 id="插点值">插点值</h2>
<p>已知多项式 <span class="math inline">\(f(x)\)</span> 的 <span class="math inline">\(n\)</span> 个点值 <span class="math inline">\((x_i, y_i = f(x_i))\)</span> ，求 <span class="math inline">\(f(k)\)</span> 。</p>
<p>拉格朗日插值法的思路在于： 对于每个 <span class="math inline">\((x_i, y_i)\)</span> 找到 <span class="math inline">\(L_i(x)\)</span> 使得 <span class="math inline">\(L_i(x_i) = y_i, L_i(x_j) = 0\)</span> ， 其中 <span class="math inline">\(x_j\)</span> 是已知的 <span class="math inline">\(x\)</span> 中任意一个不等于 <span class="math inline">\(x_i\)</span> 的 <span class="math inline">\(x\)</span> 。</p>
<p>而由 <span class="math inline">\(L\)</span> 的定义可知，<span class="math inline">\(f(k) = \sum_{i=1}^n L_i(k)\)</span> 。<br />
代入上式即可求解。</p>
<a id="more"></a>
<p>现在问题在于构造 <span class="math inline">\(L\)</span> 。 下面的 <span class="math inline">\(L\)</span> 可以满足定义：</p>
<p><span class="math display">\[L_i(x) = y_i \cdot \prod\limits_{j \ne i}\frac{x_j-x}{x_j-x_i}\]</span></p>
<p>代入可得这对于任意 <span class="math inline">\(x_i\)</span> 可以使得 <span class="math inline">\(L_i(x_i) = y_i, L_i(x_j) = 0\)</span></p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>特别地，如果已知的点值横坐标是一段连续的整数，该做法可以优化到线性，略。</p>
<h2 id="插系数">插系数</h2>
<p>已知多项式 <span class="math inline">\(f(x)\)</span> 的 <span class="math inline">\(n\)</span> 个点值，求 <span class="math inline">\(f(x)\)</span> 的第 <span class="math inline">\(k\)</span> 次项系数 。</p>
<p>先考虑插出一项 <span class="math inline">\(x^k\)</span> 的系数。</p>
<p>首先依次考虑每个 <span class="math inline">\(L_i(x)\)</span> 的 <span class="math inline">\(x^k\)</span> 系数，最后累加即可。</p>
<p>注意到分母和 <span class="math inline">\(y_i\)</span> 是常数可以直接算，考虑提出来，</p>
<p><span class="math display">\[ L_i(x) = (y_i \cdot \prod\limits_{j \ne i}\frac{1}{x_j-x_i})
    (\prod\limits_{j \ne i} (x_j - x)) \]</span></p>
<p>左边的常数是一堆逆元相乘再乘上 <span class="math inline">\(y_i\)</span> ，逆元往往不是 <span class="math inline">\(O(1)\)</span> 计算的，<br />
事实上可以先把分母中所有 <span class="math inline">\(x-x_j\)</span> 乘起来再一起求逆元，这样就只需要计算 1 次逆元，此时一般可以忽略逆元对复杂度的影响。</p>
<p>那么只需要算分子部分，即上式右边的 <span class="math inline">\(\prod\)</span> 的 <span class="math inline">\(x^k\)</span> 系数即可。</p>
<p>假设把这个连乘暴力拆开，其实 <span class="math inline">\(x^k\)</span> 的系数就是在之中选 <span class="math inline">\(n - k - 1\)</span> 个常数。<br />
DP 预处理 <span class="math inline">\(pre(i, k)\)</span> 表示在 <span class="math inline">\(\prod\limits_{j \leq i} (x - x_j)\)</span> 中选 k 个常数的系数和，<br />
同理 <span class="math inline">\(suf(i, k)\)</span> 表示在 <span class="math inline">\(\prod\limits_{j \geq i} (x - x_j)\)</span> 中选 k 个常数的系数和。<br />
那么枚举 <span class="math inline">\(p + q = n - k - 1\)</span> 求 <span class="math inline">\(pre(i - 1, p)\)</span> 乘 <span class="math inline">\(suf(i + 1, q)\)</span> 的和就是上式的 <span class="math inline">\(x^k\)</span> 系数了。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>参考实现（未经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插出 L_i(x) 的 x^k 系数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">la</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">     <span class="keyword">if</span>(i != j)</span><br><span class="line">           A *= X[i] - X[j];</span><br><span class="line"> <span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= n - k - <span class="number">1</span>; l ++)</span><br><span class="line">     B += pre[i - <span class="number">1</span>][l] * suf[i + <span class="number">1</span>][n - k - <span class="number">1</span> - l];</span><br><span class="line">   <span class="keyword">return</span> B / A * X[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 suf 和 pre */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">      pre[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">         pre[i][j] = pre[i - <span class="number">1</span>][j] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i; i --) &#123;</span><br><span class="line">      suf[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i + <span class="number">1</span>; j ++)</span><br><span class="line">         suf[i][j] = suf[i + <span class="number">1</span>][j] - suf[i + <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插多项式">插多项式</h2>
<p>已知 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(f(x)\)</span> 的 <span class="math inline">\(n\)</span> 个点值，求 <span class="math inline">\(f(x)\)</span> 的所有系数 。</p>
<p>直接将所有暴力多项式相乘计算所有 <span class="math inline">\(L_i(x)\)</span> ，或者使用 <span class="math inline">\(n\)</span> 次上述的插系数，复杂度 <span class="math inline">\(O(n^3)\)</span> ，难以接受。</p>
<p>点值比较特殊的情况下可以使用 FFT 或者 NTT ，但有失一般性。</p>
<p>沿用上述分离常数的方法，考虑 <span class="math inline">\(O(n)\)</span> 求出每个 <span class="math inline">\(L_i(x)\)</span> 的所有系数：</p>
<p><span class="math display">\[L_i(x) = (y_i \cdot \prod\limits_{j \ne i}\frac{1}{x_j-x_i})
    (\prod\limits_{j \ne i} (x_j - x))\]</span></p>
<p>左边的常数还是同样地处理，不同的是对于右边的多项式现在要求的不是某一项的系数而是所有系数。</p>
<p>对于右边的多项式部分，可以看做：</p>
<p><span class="math display">\[\frac{\prod_{j=1}^n (x_j - x)}{x_i - x}\]</span></p>
<p>其分子是个与 <span class="math inline">\(i\)</span> 无关的多项式，可以 <span class="math inline">\(O(n^2)\)</span> 暴力预处理，而其分母是个简单的一次二项式。<br />
那么可以用短除法来进行多项式除二项式，复杂度 <span class="math inline">\(O(n)\)</span> 。</p>
<p>总时间复杂度为 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>参考实现（未经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">la</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> tmp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// tmp 表示 n 个二项式相乘的多项式</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">      tmp[i] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j; j --)</span><br><span class="line">         tmp[j] = tmp[j - <span class="number">1</span>] - X[i] * tmp[j];</span><br><span class="line">      tmp[<span class="number">0</span>] *= - X[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">      ll A = <span class="number">1</span>; <span class="comment">// A 表示 L_i 的常数部分</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">         <span class="keyword">if</span>(i != j)</span><br><span class="line">               A *= X[i] - X[j];</span><br><span class="line">     A = Y[i] / A;</span><br><span class="line"></span><br><span class="line">       tmp2[n] = tmp[n]; <span class="comment">// tmp2 表示将 tmp 除以一个二项式的结果</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j; j --) &#123;</span><br><span class="line">          ll t = tmp2[j];</span><br><span class="line">           get[j - <span class="number">1</span>] += t * A; <span class="comment">// get 表示 f(x) 的系数</span></span><br><span class="line">          tmp2[j - <span class="number">1</span>] = tmp[j - <span class="number">1</span>] + t * X[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此时应有 tmp2[0] = 0 ，否则说明除法有余数</span></span><br><span class="line">       assert(tmp2[<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>THUWC2020</title>
    <url>/2019/12/06/THUWC2020/</url>
    <content><![CDATA[<h2 id="day--inf-12.06">Day -inf (12.06)</h2>
<p>thuwc 的报名网站反应是真的慢，中午特意请假去机房填表，结果被这反应速度折服了，一中午还没填完。<br />
好事是，借着这个，我得以手动翘掉了下午的语文课，又跑去机房填表，<br />
网站太慢了，就趁着加载的间隙打了一道题，边听歌边填表边打题，十分舒适。<br />
然后实在是太慢了一节语文课还是不够，算上盖章一不小心把物理课也翘了一半，回来的时候正好全班人围在门口看老师做实验。<br />
目测今年分数线不高，就迷之自信地在 12.06 这个时候就开坑写游记了。</p>
<a id="more"></a>
<h2 id="day--1-12.19">Day -1 (12.19)</h2>
<p>上午突然搞模拟面试？</p>
<p>有点懵逼，随便准备了一下自我介绍，还是中英双份的。</p>
<p>英语面试简直全程懵逼，问的问题基本都是这样回答的：</p>
<p>Q: blablablabla ? A: emm...emm.. （沉默） maybe...emm...</p>
<p>然后被要求读短文，发现好多词不认识，就瞎读，好不容易读完了，突然问我：<br />
这篇文章讲了什么？<br />
卧槽我刚才一直在纠结这个单词那个单词怎么读压根就没有去看文章本身啊。<br />
然后 emm 了一下，就默默低下头又看了一遍。。。</p>
<h2 id="day-0-12.20">Day 0 (12.20)</h2>
<p>提前一天来到北京，说起来这是第 3 次了。</p>
<p>下午先去了 PKU 转了转（PKUWC 的同学今天下午报到），见到了学长，然后就回到宾馆快乐颓废。<br />
事实上并不是宾馆，西郊宾馆早没地了，住的是公寓楼。<br />
租了两个套间，一开始为了不与教练住分组猜拳，最后 3 个人跟教练住，4 个人跟家长住。<br />
我就是那 3 个人中的一个。<br />
但是超级奈斯啊，最后教练压根就不住这，这里 3 人住 3 个房间，另外一边 5 人住 3 房间。<br />
颓到 11:30 左右就睡了。</p>
<h2 id="day-1-12.21">Day 1 (12.21)</h2>
<p>报到，发了一个紫色的包（为啥 THU 如此钟情于紫色？）。</p>
<p>下午一试，汉堡没 ACM 的好吃，差评。</p>
<p>T1 是个签到题，对于每个维度离散化一下用个扫描线 + 树状数组就差不多了，1h 做了，</p>
<p>T2 不会，打暴力。</p>
<ul>
<li><span class="math inline">\(q \cdot s = 10^7\)</span> 以及 <span class="math inline">\(m \cdot w = 10^7\)</span> 意味着跳的次数是十分有限的，直接模拟就好了。 (16')</li>
<li>数据随机我不知道意味着什么，但是我的暴力莫名其妙就过了 pretest 。 (8')</li>
<li><span class="math inline">\(w=10^{18}\)</span> 意味着边永远不会断，直接倍增维护每个点走 <span class="math inline">\(2^k\)</span> 步后的点即可。 (12')</li>
<li><span class="math inline">\(m=n-1\)</span> 是颗根向树，只会往根上跳，树剖+线段树维护边权，当前重链无法跳到顶的时候倍增或者二分来确定跳的位置。 (13')</li>
</ul>
<p>T3 一开始看到题目名“某科学的动态仙人掌”就懵逼了，还好是标题党，可是还是不会，打暴力。</p>
<ul>
<li><span class="math inline">\(n, m, x\)</span> 极小的直接暴力搜。 (4')</li>
<li><span class="math inline">\(x=n-1\)</span> 说明任意两个点都是可以相连的，输出 1 。 (4')</li>
<li><span class="math inline">\(x=1\)</span> 的话就是计算联通块数量，大概离线下来然后扫描线+树状数组可做，但是没时间写。 (0')</li>
<li>树退化为链的情况我搞了一个莫队，复杂度 <span class="math inline">\(O(n\sqrt{n}logn)\)</span> ，跑极限数据 7s+ ，时限 6s ， 本来链是有 16' 的，但是实在卡不过，最后只过了 <span class="math inline">\(l=1\)</span> 的那一档，此时莫队复杂度为 <span class="math inline">\(O(nlogn)\)</span> 。 (4')</li>
</ul>
<p>pretest 100 + 49 + 20 = 169.</p>
<p>晚上快乐颓废，1 点才睡。</p>
<h2 id="day2-12.22">Day2 (12.22)</h2>
<h3 id="上">上</h3>
<p>上午二试。</p>
<p>T1 不会正解，打暴力。</p>
<ul>
<li><span class="math inline">\(n=10\)</span> 的直接阶乘爆搜。 (13')</li>
<li><span class="math inline">\(c=0\)</span> 以及 <span class="math inline">\(a=0\)</span> 的都可以状压集合中可以得到的最权值和最大值来求最后的答案。</li>
<li><span class="math inline">\(a=0\)</span> 时在确定顺序的前提下最后答案是关于 s 的一次函数，没有分段，因此 s 始终只需保留两个最值。 (19')</li>
<li><span class="math inline">\(c=0\)</span> 时最优决策只与 s 的绝对值有关，考场上我似乎是晓得为什么只需要保留最值的，但现在忘了。 (23')</li>
<li>正解不会，但是不知道为什么上面的状压做法能过所有 pretest 。 (45')</li>
</ul>
<p>T2 不会，打暴力。</p>
<ul>
<li><span class="math inline">\(n, q, m=10^3\)</span> 的直接暴力搜。 (20')</li>
<li><span class="math inline">\(m=n\)</span> 说明非树边是唯一的，询问只需要对这条唯一的非树边分类讨论来确定它带来的影响即可，没有非树边之间的相互影响。 (11')</li>
</ul>
<p>T3 推了好久，想了好几个假做法，然而还是只能打暴力。</p>
<ul>
<li><span class="math inline">\(k=0\)</span> 说明根本就不进行排序，直接输出 1 。 (1')</li>
<li><span class="math inline">\(n=10\)</span> 的直接阶乘枚举所有可能长度的所有全排列，然后用康拓展开把排列 hash 一下，处理出所有排列的答案即可。 (4'+3')</li>
</ul>
<p>pretest 100 + 31 + 8 = 139.</p>
<p>鉴于昨晚睡得太晚，本来打算下午补觉的。<br />
真香，饥荒真好玩。</p>
<h3 id="下">下</h3>
<p>晚上三试，学习题，身败名裂。</p>
<p>这次是要简单地模拟 Cache 的底层工作。</p>
<p>我 (wo) 带 (diao) 你 (ni) 们 (ma) 打 (de)。</p>
<p>学习手册看得我一脸懵逼，看了整整 1 个小时才大概看懂意思，到这时候还没开始打代码。</p>
<p>然后看 T1 直接就是 Cache 一致性协议，出现在学习手册的最后一页，好像还综合了只读、替换、读写一堆乱七八糟的。<br />
最骚的是不久后管理发了通知：</p>
<figure>
<img src="/images/thuwc.png" alt="通知" /><figcaption aria-hidden="true">通知</figcaption>
</figure>
<p>这是暗示啊！这直接让我以为 T1 是最难的，果断弃掉，开始码 T2 。</p>
<p>码了前面 6 个子任务，把实现逻辑优化了一下，同样的逻辑用同样的调用，<br />
只有不同的逻辑（也就是使用的替换算法 R ）用 6 个不同的函数，<br />
框架打完后写起来就贼方便，敲完了 6 个子任务后就先弃了第 7 个去肝交互了。</p>
<p>T3 交互直接在 T2 的框架上魔改，然后 6 个函数加个参数照样用，过了两个样例然而不停 WA 。<br />
真的自闭了，后面一直在 debug 查错，肝到最后 5min 深感绝望，此时我还只有 T2 的 40' ，<br />
大概是凉了吧。</p>
<p>好在最后 3min 的时候通过静态差错发现魔改的时候漏了一个地方，T2 是没有 index 的，默认都是 0 ，<br />
而在 R = 1 的最简单的那个子任务上 index 仍然默认是 0 没有改过来，哇塞这 B 玩意害死我了，改成 index 后就成功过了 pretest 。</p>
<p>最后 pretest 40 + 32 = 72 。<br />
考完后一问，好像大家都 100+ ，高如韬神 150+ <del>，低如 master 都有 90+</del>。<br />
究其原因，是因为大家都只花了 1h 不到打了 T1 的 40' 。。。</p>
<p>好吧，我自闭了，整个 thuwc 就栽在这场学习题上了。</p>
<p>晚上快乐颓废，想着明天不考试，颓到了 1:30 ，饥荒真好玩，然而我活个 18d 就因为各种奇奇怪怪的东西狗带了。</p>
<h2 id="day3-12.24">Day3 (12.24)</h2>
<p>早上 6:40 就被家长的电话吵醒，说我进面试了，赶紧起来收拾行李直接去西郊宾馆。</p>
<p>我擦？我才睡 5h 诶？</p>
<p>没办法，昨晚的咖啡还没喝完，一口闷了下去，收拾收拾就出发了。</p>
<p>面试人好多啊，目测 100+ ，数座位就有 150 左右。</p>
<p>面试，自我介绍先理性自吹一波，感觉说自己的竞赛成绩太千篇一律了，比我强的人多了去了，<br />
于是我就有很大一部分讲了自己的辉煌的小程序历史，诸如 yzzl, pychat, retest ，还有折腾的 keoj, keblog 等等。<br />
还提到到了 tuna 。<br />
然后面试基本就是针对自我介绍问的，一开始问我文化课成绩，然后就问我写的小程序最满意的是哪一个，<br />
<del>都挺满意的</del>这时候不能犹豫，抱着情怀我说了 yzzl ，然后对于 yzzl 的整个游戏规划，<br />
包括已经实现的和有想法实现但是咕咕咕的侃侃而谈。<br />
然后有问我有没有 tuna 的线下活动，emm 我一草民只是平时用用镜像水水帖子刷刷聊天室，那谈得上线下活动？</p>
<p>最后还问我对于昨天学习题的看法。</p>
<p>这个我有话说！我可以说上一整天！<br />
时间少，题目多，分数设置得极其不合理。<br />
学习资料写得真是牛皮，尤其是给的那三张示意图我的天啊没有任何解释你还指望那这三张几乎一毛一样图来描述 cache 与主存的关系，<br />
这图让我误解一脸懵逼，本来对 index, tag, offset 的解释就是一句话带过，<br />
在图上就更迷了，直接就是 [x:y:z] 下面一排 tag, index, offset ，<br />
尤其是 offset 这个东西我至始至终不知道是个啥，盲猜是个可以忽略的东西，<br />
可以它又特么出现在输入数据中，占了两个二进制位啊你要我怎么办，<br />
我又只能通过盲猜输入的地址中保证 offset=0 并且找到学习手册的一句话“保证给出的地址已经对齐”来解释这个猜想。 等等等等。。。<br />
死在这上面真的让人非常不服气。</p>
<p>所以我最后的回答是：</p>
<p><strong>我觉得设置的很好，很考验选手的理解能力和实现能力。</strong></p>
<p>:joy:</p>
<p>最后阅读英语短文，还是懵逼，硬着头皮乱念。</p>
<p>颁奖，二等奖。<br />
<!--
然而这个奖严重缩水，进了面试的 100 来号人都有奖，没进的也有一部分有奖，目测一共发了 200 个左右，  
据我所知一等奖至少有 50 来个，按以往的标准来算，一等约似乎是无条件降一本的。  
我真是服了，现在我真的感觉我拿回去一张废纸，  
现在不是签约了，给你发奖大面积圈人，你要这个奖还是得向 tp 做出保证，  
然而 tp 并不会对你做出任何保证，只是发给你一张纸，上面半句没提到你会得到怎样的优惠政策。  
妙啊。
--> （数据已删除）</p>
<p>晚上回去，订 11 点多的机票不知道是怎么想的，到了凌晨 1 点多才到长沙，<br />
一个人回到寝室，大家都已经睡了，默默放下行李箱和背包，小心翼翼地走到床上，盖好被子，舒一口气。<br />
结束了。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>WC</tag>
        <tag>THU</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019</title>
    <url>/2019/11/17/CSP2019/</url>
    <content><![CDATA[<h2 id="day1">Day1</h2>
<p>体验极差，真的就是极差，做梦都没想到 Day1 竟然是这样的。</p>
<p>开考花 30min 交完前面两题，看看时间还剩 3h 。<br />
我觉得换谁在这个处境都会觉得稳得一批，我有三个小时你 Day1T3 能秒我？<br />
我时间都规划好了，花 2h 肝 T3 ，拿 1h 对拍测试检查细节。</p>
<ul>
<li>30min 后：我有一个贪心想法，似乎有理有据</li>
<li>1h 后：终于打完了，过了样例，nice 稳了，测测大样例， woc 怎么全 WA 了</li>
<li>1.5h 后：（写暴力造数据对拍）妈呀贪心假了，这个只需要怎么怎么随便就卡掉了，这也能过样例</li>
<li>2h 后：只剩一个小时了，我要不要写一写链和菊花的暴力啊？算了前面两题应该不会挂，继续肝</li>
<li>2.5h 后：（濒临崩溃）我一道联赛题只会 10 分怕不是不要混了，算了还是写暴力吧</li>
<li>考试结束 3min 前：（自闭）我 !@#@!%$!@%@@ 暴力怎么这么难打？链的数据怎么死循环啊</li>
</ul>
<p>考完还听别人说 T1 卡 long long ，我靠，凉凉。<br />
（话说回来考试前一天晚上我还在 OI-Wiki 上偶然翻到了格雷码，看着好复杂心想这玩意学了肯定没用就没看了）</p>
<a id="more"></a>
<h2 id="day2">Day2</h2>
<p>发现 Day1 普遍不会 T3 后心态稍微好了点，但是 T1 挂了还是影响很大的。</p>
<p>想着今天稳健一点，然后真就安心打了三题暴力。。。<br />
（其实是因为开场看了 30min 题意识到自己一题都不会做）</p>
<p>T1 看着就是要枚举超过一半的菜去容斥，而超过一半的菜最多只会同时有一个，用 dp 是很好处理的，<br />
写了个 <span class="math inline">\(O(n^3m)\)</span> 的 dp 交了，看着有 84 分，觉得先往后做比较妥，就没管了。<br />
（后来听说那个 dp 稍微对状态做个小优化就是 <span class="math inline">\(O(n^2m)\)</span> 的了。。）</p>
<p>T2 看着就是个 <span class="math inline">\(O(n^3)\)</span> 的大暴力 dp ，诶不行 36 分不太够啊，然后猜想 + 打表发现 dp 的决策点单调，<br />
然后这怎么优化到 <span class="math inline">\(O(n^2)\)</span> ？不会，只晓得搞分治 dp ，好像带一个不满的 log ，实测大数据 1.0 s 。<br />
（听别人说根据单调性可以直接优化到 <span class="math inline">\(O(n^2)\)</span> ？不懂，告辞）</p>
<p>T3 看着就是个枚举断边暴力算重心，想着今天的目标定为打满暴力算了，<br />
然后就认认真真地打了链的部分分（链上的重心可以 <span class="math inline">\(O(1)\)</span> 计算）和完全二叉树的部分分（本质不同的断边只有 <span class="math inline">\(O(logn)\)</span> 个）。<br />
前所未有地耐心打暴力，不知道怎么坚持下来的，可能是终于认识到自己实力弱菜吧。</p>
<h2 id="end">End</h2>
<p>12.01</p>
<p>两周没碰电脑了，今天补补总结。</p>
<p>洛谷自测 438 ，D1T3 水了 35 分。<br />
到牛客上就只有 408 了。</p>
<p>csp 数据还算良心吧，D1T1 没有太丧心病狂（像洛谷牛客那样没写 unsigned 就被卡二三十分是真的想死），<br />
只放在最后一个点卡了 5 分，这被卡了也服气，可以接受，权当买了个教训。<br />
但数据强度还是有的，D2T2 搞分治还是被卡了一个点 4 分（然而如果开 O2 就过了），也行，技不如人甘拜下风。<br />
最后的成绩拿官方数据自测就是 424 了，比去年高了一点点，没长进啊。</p>
<p>那么接下来就是冬令营了，坐标新华都，母校再会。</p>
<p><del>话说没进冬令营岂不身败名裂</del></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>csp</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-14</title>
    <url>/2019/11/08/cometoj-14/</url>
    <content><![CDATA[<p>万年卡 E 题系列。</p>
<p>这次 A 竟然不是字符串，<del>开始我已经准备了字符串的输入输出等一堆东西结果发现没卵用</del><br />
花 1min49 AC ，好像在这之前已经有 12 个人 A 了。</p>
<p>B 第一眼看上去是个 DP ，再看一眼（看成最小值最大）以为是二分，发现是让最大值最大而且还只有三个段后。。。<br />
<strong>大力分类讨论</strong>！<br />
果然是个分类讨论就巨多细节，判无解判边界判大小 blabla ，结果交 WA 了两发，在 16min AC 。<br />
（ B 最快的 6min 就 A 了，16min 这时候 C 的一血都被拿了的说）</p>
<a id="more"></a>
<p>C 维护一个序列？结果每次需要把所有序列复制一份并对复制的那一部分进行修改？<br />
一脸懵逼.jpg<br />
（然而水群的时候大佬们都说这题怎么怎么显然，和什么什么题一模一样）<br />
还好看清楚了数据范围只有 2000 ，就去想单独考虑序列上每个点，这样就很好维护，<br />
一个点每次复制就是权值翻倍，复制的位置被修改就是权值加上 修改值 乘 序列数量。<br />
好像花了和 B 差不多的时间，在 33min AC 。</p>
<p>D 题感觉很神，乍一看什么可追溯化数据结构，可一想哪有对线段树可追溯化的，还是追溯一段操作区间。<br />
然后就感觉很不可做，但<del>看了 E 发现是个图论更不可做</del>还是头铁硬肝。<br />
发现区间覆盖的性质还是很优秀的，然后 yy 了一个扫描线 + set + 树状数组的做法，<br />
树状数组维护每个操作对当前扫描线上的询问的影响，<br />
然后 set 维护一个蛇皮东西，扫描线扫过的操作执行后的区间覆盖长什么样子，<br />
每次区间覆盖就可以直接在 set 上 lower_bound 到位置再换掉旧的覆盖。<br />
（后来听人讲这就是 odt 。。。）</p>
<p>在 81min 打完过了样例，仔细检查了检查，一交，WA 了。<br />
懵逼，静态差错无果，对拍无果，查了半个小时，实在没发现什么错，<br />
还以为我题目读错了，读了四五遍题感觉实在是没有什么坑，<br />
抱着自闭的心态再交了一发， woc AC 了。<br />
一脸懵逼.jpg<br />
我感觉我什么地方都没改啊怎么突然从 WA 到 AC 啊！！！</p>
<p>比完后查了查，发现是这样一句话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">// 等价于 std::cerr &lt;&lt; i &lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure>
<p>神 tm 我输出到标准错误流竟然就 WA 了？！<br />
后面还 test 了一波，发现在 cometoj 上只要有标准错误流就会 WA/RE 。<br />
引以为戒，祭奠为此逝去的半个小时。</p>
<p>最后就在整个后半场卡 E 了，回头看了看每场 cometoj 常规赛都卡 E ，能 A 掉 ABCD ，<br />
发现唯一一次拿到奖是因为那次只有 8 个人 A 掉了 D 。。</p>
<p><del>写总结好累啊，以后打比赛就不写了吧。。</del></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/2019/11/05/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>relearn 了一遍 exCRT ，发现之前学的可能是假的（这种情况出现不止一次了 233 ）。</p>
<p>简单来说，中国剩余定理（以下简称 CRT ）主要用于解线性同余方程组：</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
x \equiv a_1 \pmod{m_1} \\\\
x \equiv a_2 \pmod{m_2} \\\\
... \\\\
x \equiv a_n \pmod{m_n} \\\\
\end{aligned}
\right.
\end{equation}
\]</span></p>
<a id="more"></a>
<h2 id="crt">CRT</h2>
<p>普通的 CRT 用于解决模数两两互质的情况（这个条件比较苛刻，实践中往往需要 exCRT ）。</p>
<p>CRT 的主要思想是构造，对于每个方程组构造一个 <span class="math inline">\(b_i\)</span> 使得 <span class="math inline">\(b_i\)</span> 在其他所有模数下为 0 ，仅在模 <span class="math inline">\(m_i\)</span> 意义下为 1 。<br />
感觉这个构造思路有点想拉格朗日插值法，那么不难得出：</p>
<p><span class="math display">\[ b_i = \prod_{i \ne j} m_j (\prod_{i \ne j} m_j)_{m_i}^{-1} \]</span></p>
<p>其中 <span class="math inline">\((\prod_{i \ne j} m_j)_{m_i}^{-1}\)</span> 是 <span class="math inline">\(\prod_{i \ne j} m_j\)</span> 在模 <span class="math inline">\(m_i\)</span> 意义下的逆元。</p>
<p>那么整个方程组的一个解就是 <span class="math inline">\(\sum_{i=1}^n b_i a_i\)</span> ，通解就是：</p>
<p><span class="math display">\[ x \equiv \sum_{i=1}^n b_i a_i \pmod{\prod_{i=1}^n m_i} \]</span></p>
<h2 id="excrt">exCRT</h2>
<p>CRT 只适用于模数两两互质的情况，因为用到了模数之间的逆元，而模数不互质是没有逆元的。</p>
<p>exCRT 的主要思想是两两合并，考虑 <span class="math inline">\(n=2\)</span> 的情况：</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
x \equiv a_1 \pmod{m_1} \\\\
x \equiv a_2 \pmod{m_2} \\\\
\end{aligned}
\right.
\end{equation}
\]</span></p>
<p>那么此时方程组的解 <span class="math inline">\(x\)</span> 需要满足存在 <span class="math inline">\(i, j\)</span> 使得：</p>
<p><span class="math display">\[ x = a_1 + i m_1 = a_2 + j m_2 \]</span></p>
<p>对于右边的等式 <span class="math inline">\(a_1 + i m_1 = a_2 + j m_2\)</span> ，是关于 <span class="math inline">\(i, j\)</span> 的二元一次方程，<br />
那么用扩展欧几里得解出一组解 <span class="math inline">\(i=i_0, j=j_0\)</span> 再回代到等式中即可求得一个 <span class="math inline">\(x = x_0\)</span> 。<br />
而通解的话，根据 exgcd 的通解 <span class="math inline">\(i \equiv i_0 \pmod{\frac{m_2}{\gcd(m_1, m_2)}}\)</span> ，可以得到 <span class="math inline">\(x\)</span> 的通解：</p>
<p><span class="math display">\[ x \equiv x_0 \pmod{lcm(m_1, m_2)} \]</span></p>
<p>那么据此可以将任意两个同余方程合并为一个，也就可以通过两两合并的方式将整个同余方程组合并为一个方程。</p>
<p>无解的话，当且仅当 exgcd 解 <span class="math inline">\(i, j\)</span> 的时候无解，只要有两个方程无法合并那么整个方程组都无法合并。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>CRT</tag>
        <tag>exCRT</tag>
        <tag>中国剩余定理</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title>快速沃尔什变换</title>
    <url>/2019/11/03/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>快速沃尔什变换，简称 FWT 。</p>
<h2 id="用处">用处</h2>
<p>多项式卷积一般是这样的：</p>
<p><span class="math display">\[ C_i = \sum_{j + k = i} A_j \cdot B_k \]</span></p>
<p>这个可以用 FFT 快速求解。</p>
<p>然而还有一个诡异的卷积：</p>
<p><span class="math display">\[ C_i = \sum_{j \oplus k = i} A_j \cdot B_k \]</span></p>
<p>其中 $ $ 是任意一种位运算。</p>
<p>FWT 便是求这类卷积的快速算法。</p>
<a id="more"></a>
<h2 id="构造">构造</h2>
<p>FFT 的思想是把多项式转换成可以线性相乘的点值表示法 (DFT) ，<br />
再把相乘的结果转换回系数表示法 (IDFT) 。</p>
<p>同样的道理可以用在 FWT 上，用 DWT 将多项式转换成可以线性相乘的形式，即：</p>
<p><span class="math display">\[ DWT(C)_i = DWT(A)_i \cdot DWT(B)_i \]</span></p>
<p>再用 IDWT 将相乘的结果转换回来。</p>
<h2 id="dwt">DWT</h2>
<p>目标是构造一个转移系数函数 f(i, j) ，满足：</p>
<p><span class="math display">\[ DWT(A)_i = \sum_j A_j \cdot f(i, j) \]</span></p>
<p>考虑 f(i, j) 应满足什么样的性质。</p>
<p>首先根据 DWT 的性质：</p>
<p><span class="math display">\[ DWT(C)_i = DWT(A)_i \cdot DWT(B)_i \]</span></p>
<p><span class="math display">\[ \sum_t C_t f(i, t) = \sum_j A_j f(i, j) \sum_k B_k f(i, k) \]</span></p>
<p><span class="math display">\[ \sum_t \sum_{j \oplus k = t} A_j B_k f(i, t) = \sum_j \sum_k A_j f(i, j) B_k f(i, k) \]</span></p>
<p><span class="math display">\[ \sum_t \sum_{j \oplus k = t} A_j B_k f(i, t) = \sum_t \sum_{j \oplus k = t} A_j f(i, j) B_k f(i, k) \]</span></p>
<p>由上式可得出：</p>
<p><span class="math display">\[ \forall i, j, k: f(i, j) f(i, k) = f(i, j \oplus k) \]</span></p>
<p>这样还不够，为了让 DWT 快速进行，f(i, j) 还应满足以下性质：</p>
<p><span class="math display">\[ f(i, j) = \prod_k f(i_k, j_k) \]</span></p>
<p>其中 $ i_k $ 表示 i 二进制下的第 k 位（ 0 或 1 ）。</p>
<p>有了这个性质，就可已通过 f(0, 0), f(0, 1), f(1, 0), f(1, 1) 的值相乘得出所有 f 。<br />
有了这个性质，就可以考虑分治求 DWT ：</p>
<p><span class="math display">\[DWT(A)_i = \sum_{j=0}^{n-1} A_j f(i, j)\]</span></p>
<p><span class="math display">\[ = \sum_{j=0}^{n/2-1} A_j f(i, j) + \sum_{j=n/2}^{n-1} A_j f(i, j) \]</span></p>
<p><span class="math display">\[ = \sum_{j=0}^{n/2-1} A_j \prod_k f(i_k, j_k) + \sum_{j=n/2}^{n-1} A_j \prod_k f(i_k, j_k) \]</span></p>
<p><span class="math display">\[ = \sum_{j=0}^{n/2-1} f(i_0, j_0) A_j \prod_{k \geq 1} f(i_k, j_k) + \sum_{j=n/2}^{n-1} A_j f(i_0, j_0) \prod_{k \geq 1} f(i_k, j_k)\]</span></p>
<p><span class="math display">\[ = f(i_0, 0) \sum_{j=0}^{n/2-1} A_j \prod_k f(i_k, j_k) + f(i_0, 1) \sum_{j=n/2}^{n-1} A_j \prod_k f(i_k, j_k) \]</span></p>
<p>规模减小了一半，递归或迭代地分治下去。<br />
每次将 A 分成左右两半 A0, A1 ：</p>
<p><span class="math display">\[ DWT(A)_i = f(0, 0) DWT(A0)_i + f(0, 1) DWT(A1)_i , i &lt; n / 2 \]</span></p>
<p><span class="math display">\[ DWT(A)_i = f(1, 0) DWT(A0)_i + f(1, 1) DWT(A1)_i , i \geq n / 2 \]</span></p>
<p>想到 FFT 的蝴蝶变换没有？ <del>答：没有</del><br />
迭代的 DWT 这里也有类似的蝴蝶变换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = A[i], y = A[i + k];</span><br><span class="line">A[i] = f00 * x + f01 * y;</span><br><span class="line">A[i + k] = f10 * x + f11 * y;</span><br></pre></td></tr></table></figure>
<p>DWT 的过程就是这样了，甚至不需要构造整个 f ，<br />
只需要 f(0, 0), f(0, 1), f(1, 0), f(1, 1) 即可，<br />
需要满足的就是 $ i, j, k: f(i, j) f(i, k) = f(i, j k) $ 。</p>
<h2 id="idwt">IDWT</h2>
<p>怎么将 DWT 的结果转换回来？ 观察 DWT 的蝴蝶变换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = f00 * x + f01 * y;</span><br><span class="line">b = f10 * x + f11 * y;</span><br></pre></td></tr></table></figure>
<p>DWT 通过 x, y 求出 a, b,<br />
IDWT 就是通过 a, b 求 x, y 。</p>
<p>解二元一次方程就好了：<br />
x = (f11 * a - f01 * b) / (f00 * f11 - f01 * f10)<br />
y = (f10 * a - f00 * b) / (f01 * f10 - f00 * f11)</p>
<p>就是这么简单...</p>
<p>个屁啊。</p>
<p>考虑 f 的构造，<br />
要满足 DWT 的性质把所有的 f 设为 0 不就可以了？<br />
要满足 DWT 的性质把所有的 f 设为 1 不就可以了？</p>
<p>这样且不是对于任何位运算都会有相同的结果？</p>
<p><del>Naive.</del></p>
<p>再看看 IDWT ，分母里边是不是有 (f01 * f11 - f01 * f10) ？<br />
不幸的是把 f 全部设为 0 或者全设为 1 这个分母都是 0 ，<br />
这意味着 IDWT 的二元一次方程无解，转过去就转不回来了。</p>
<p>因此 f 的构造还要满足一个条件： <code>f01 * f11 != f01 * f10</code> 。</p>
<h2 id="f-的构造">f 的构造</h2>
<p>f 需要满足的性质已经讲的很详细了。</p>
<p>这里给出常用位运算中 f 的构造：</p>
<ul>
<li>按位或： f00 = 1, f01 = 0, f10 = 1, f11 = 1</li>
<li>按位与： f00 = 1, f01 = 1, f10 = 0, f11 = 1</li>
<li>异或： f00 = 1, f01 = 1, f10 = 1, f11 = -1</li>
</ul>
<p>可以自行验证，这些 f 满足上述性质。</p>
<h2 id="实际意义">实际意义</h2>
<p>一个多项式 A DFT 后的 <span class="math inline">\(A2_x\)</span> 实际意义就是 A 在 $ W_n^x $ 上的值（点值表示）。</p>
<p>那么 A DWT 后的结果的现实意义呢？<br />
这得分类来说。</p>
<h3 id="按位或">按位或</h3>
<p>A 在做按位或的 DWT 之后得到的 A2 满足： <span class="math display">\[ A2_x = \sum_{i|x=x} A_i \]</span></p>
<p>也就是说 <span class="math inline">\(A2_x\)</span> 表示 x 的每个子集 i 的 <span class="math inline">\(A_i\)</span> 的和。<br />
不难得到，<span class="math inline">\(A2_x \cdot B2_x\)</span> 的结果 <span class="math inline">\(C2_x\)</span> 就是 A, B 卷积后的 C 的变换： <span class="math display">\[ A2_x \cdot B2_x = \sum_{i|x=x} A_i \sum_{j|x=x} B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{i|x=x} \sum_{j|x=x} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k|x=x} \sum_{i|j=k} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k|x=x} C_k \]</span> <span class="math display">\[ A2_x \cdot B2_x = C2_x \]</span></p>
<p>事实上，这也就是子集和变换 FMT （快速莫比乌斯变换） 。</p>
<p><del>感性理解一下</del></p>
<h3 id="按位与">按位与</h3>
<p>和按位或类似的，A 在做按位与的 DWT 之后得到的 A2 满足： <span class="math display">\[ A2_x = \sum_{i\&amp;x=x} A_i \]</span></p>
<p>也就是说 <span class="math inline">\(A2_x\)</span> 表示每个包含 x 的集合 i 的 <span class="math inline">\(A_i\)</span> 的和。<br />
不难得到，<span class="math inline">\(A2_x \cdot B2_x\)</span> 的结果 <span class="math inline">\(C2_x\)</span> 就是 A, B 卷积后的 C 的变换： <span class="math display">\[ A2_x \cdot B2_x = \sum_{i\&amp;x=x} A_i \sum_{j\&amp;x=x} B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{i\&amp;x=x} \sum_{j\&amp;x=x} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k\&amp;x=x} \sum_{i\&amp;j=k} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k\&amp;x=x} C_k \]</span> <span class="math display">\[ A2_x \cdot B2_x = C2_x \]</span></p>
<p><del>和按位或一个模子里刻出来的</del></p>
<h2 id="子集卷积">子集卷积</h2>
<p>两个多项式 A, B 的子集卷积 C 的意义如下：</p>
<p><span class="math display">\[ C(x) = \sum_{y|z=x, y\&amp;z=0} A(y) B(z) \]</span></p>
<p>也就是把 x 划分为两个子集 y, z 的 A(y) * B(z) 的和。</p>
<p>转换成 $ <em>{y|z=x} A(y) B(z) [y &amp; z = 0] $ ，似乎是一个按位或卷积。<br />
再转换成 $ </em>{y|z=x} A(y) B(z) [bitcount(y) + bitcount(z) = bitcount(x)] $ 。</p>
<p>此时需要考虑的就是 bitcount, 也就是集合大小，也就是二进制位中 1 的个数。<br />
集合大小是 $ O(log(n)) $ 的，可以考虑枚举大小，设： <span class="math display">\[ A_i(x) = A(x) [bitcount(x) = i] \]</span> <span class="math display">\[ B_j(x) = B(x) [bitcount(x) = j] \]</span> <span class="math display">\[ C_k(x) = C(x) [bitcount(x) = k] \]</span></p>
<p>那么有： <span class="math display">\[ C_k(x) = \sum_{y|z=x} A_i(y) B_j(z) [i + j = k] \]</span> <span class="math display">\[ C_k(x) = \sum_{i+j=k} \sum_{y|z=x} A_i(y) B_j(z) \]</span></p>
<p>那么枚举 i, j 的值，将 $ A_i $ 和 $ B_j $ 卷积后贡献到 $ C_{i+j} $ 即可。</p>
<p>这样复杂度似乎是 $ O(n log^3n) $ 的，<br />
但是事实上每个 $ A_i, B_j $ 都可以提前 FWT 后 $ O(n) $ 相乘，<br />
再贡献到 C 后不进行逆变换，而是确定了 C 的值后在进行逆变换。</p>
<p>复杂度 $ O(n log^2n) $</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卷积</tag>
        <tag>位运算</tag>
        <tag>FWT</tag>
        <tag>子集卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-13</title>
    <url>/2019/10/25/cometoj-13/</url>
    <content><![CDATA[<p>淦。</p>
<p>Skip 掉 A ，直接开 C1 。</p>
<p>一看卧槽搜索题，果然简单，然后码，然后码挂了，调了一波，在 8min AC 。</p>
<p>然后既然做了 C1 那就继续看 C2 嘛，</p>
<p>一看卧槽煞笔题，果然简单，然后码，然后没码挂，交了一波，<br />
TLE 了 4 个点。。。</p>
<p>回去看 A ，卧槽果然签到题，花 2min A 了。</p>
<p>然而对于 C2 还是一脸懵逼，后来理性分析了复杂度上界，发现用 set 多了个 log ，<br />
想着怎么撸掉这个 log ，卧槽并查集不就行了，几乎重构了一遍，在 41min AC 。</p>
<p>说起来我第一个想到的是用 set 的原因是做过策爷的“基础排序算法练习题”，<br />
那里维护有效点对的方式就是用 set + 二分。<br />
然而这里特殊一点，用过的点不会在出现，直接并查集就好了。</p>
<p><del>学傻了.jpg</del></p>
<a id="more"></a>
<p>开 B 。</p>
<p>一看卧槽模拟题，果然简单，然后码，然后交 WA 了，发现没清除头的位置（忘记测样例 3 了），<br />
改了后在 55min AC 。</p>
<p>看 D 。</p>
<p>一看卧槽二项式定理 + 单位根反演板子题，果然不难，然后码，然后犯煞笔错误，调到 1h21min 才 A 。</p>
<p>不过 D 的难点想必不在二项式定理和单位根反演<del>（因为这太裸了）</del>，<br />
难点在于给定的 a 在模数任意的情况下可能是非二次剩余，不能开根。<br />
然而只要会求二次剩余，就不难想到把 <span class="math inline">\(\sqrt{a}\)</span> 当做虚数单位进行扩域来做复数运算。</p>
<p><del>还好我前几天才学二次剩余</del></p>
<p>话说我一直调的一个错误竟然是复数乘法中的一个乘号打成了加号，一个字符调一年。</p>
<p>对于剩下的 E, F ，就彻底凉了。</p>
<p>剩下 1h40min 都在肝 E, F ，然而并没有什么卵用，<br />
E 题有想法，但是实现巨巨巨麻烦，况且我计算几何渣的一批，就弃了。<br />
F 题看上去是个神奇数据结构题，不会，告辞。</p>
<p>在 1h21min 的时候是 rank31 ，在最后比赛结束仍然狗在 rank33 <del>（可见 E, F 毒瘤）</del> 。</p>
<p><del>并没有拿到裙子，自闭了</del></p>
<p>update on 10.26:</p>
<p>E, F 都改完了， E 的正解在赛时其实就想到了，但是苦于没有实现思路，计几基础太差。<br />
F 分块好题，赛时也的确想到了分块，对于区间左移也想到了块内记偏移量，但是由于对于偏移量的维护没有思路就弃了。<br />
事实上这个偏移量其实很好搞，块内维护一个环状结构而不是普通的链状结构（我猜链状大概也能做，不过要动态增删点之类的？），<br />
这样在整个块左移的时候只需把头指针向右移一个就可以简单地做到整体左移。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余</title>
    <url>/2019/10/21/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
    <content><![CDATA[<p>二次剩余，<del>俗称模意义开根</del>。<br />
也就是对于常数 <span class="math inline">\(n\)</span> 解这样一个方程：</p>
<p><span class="math display">\[x^2 \equiv n \; (mod \; p)\]</span></p>
<p>这里只介绍模数 <span class="math inline">\(p\)</span> 为奇素数的解法，也就是 Cipolla 算法。</p>
<p>以下运算皆指模 <span class="math inline">\(p\)</span> 意义下的运算。</p>
<a id="more"></a>
<h2 id="解的数量">解的数量</h2>
<p>严格来讲，非 0 数 <span class="math inline">\(n\)</span> 是二次剩余当且仅当方程 <span class="math inline">\(x^2 \equiv n\)</span> 有解，也就是能开根。<br />
上述方程无解的非 0 数 <span class="math inline">\(n\)</span> 称作非二次剩余。</p>
<p>对于二次剩余 <span class="math inline">\(n\)</span> ，<span class="math inline">\(x^2 \equiv n\)</span> 有多少解？</p>
<p>假设有多组解，对于任意两个不相等的解 <span class="math inline">\(x_0, x_1\)</span> ，有 <span class="math inline">\(x_0^2 \equiv x_1^2\)</span> 。<br />
移项后平方差，得到 <span class="math inline">\((x_0 - x_1)(x_0 + x_1) \equiv 0\)</span> 。</p>
<p>由于 <span class="math inline">\(p\)</span> 是奇素数，且 <span class="math inline">\(x_0 \ne x_1\)</span> ， <span class="math inline">\(x_0 - x_1\)</span> 在模 <span class="math inline">\(p\)</span> 意义下是不会为 0 的。<br />
故有 <span class="math inline">\(x_0 + x_1 \equiv 0\)</span> ，也就是说两个不相等的解一定是相反数，<br />
换言之，该方程只有两个解，且它们互为相反数。<br />
而当 <span class="math inline">\(p\)</span> 为奇素数时模意义的两个相反数不会相等，因为奇偶性不同。</p>
<p>还可以知道，任意一对相反数都对应一个二次剩余，而且这些二次剩余是两两不同的。<br />
也就说二次剩余的数量恰为 <span class="math inline">\(\frac{p-1}{2}\)</span> ，其他的非 0 数都是非二次剩余，数量也是 <span class="math inline">\(\frac{p-1}{2}\)</span> 。</p>
<h2 id="欧拉准则">欧拉准则</h2>
<p>如何快速判断一个数 <span class="math inline">\(n\)</span> 是否为二次剩余？</p>
<p>以下讨论假定 n 不为 0 。</p>
<p>观察费马小定理 <span class="math inline">\(n^{p-1} \equiv 1\)</span> ，由于 <span class="math inline">\(p\)</span> 是奇素数，可以得到 <span class="math inline">\(n^{2(\frac{p-1}{2})} - 1\equiv 0\)</span> ，<br />
也就是说 <span class="math inline">\(n^{\frac{p-1}{2}}\)</span> 是 1 开根的结果，根据上面所说， 1 开根只有两个解 1 和 -1 。<br />
那么 <span class="math inline">\(n^{\frac{p-1}{2}}\)</span> 只能是 1 或 -1 。</p>
<p>若 <span class="math inline">\(n\)</span> 是二次剩余，则有 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv x^{p-1} \equiv 1\)</span> 。</p>
<p>若 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv 1\)</span> ，将 <span class="math inline">\(n\)</span> 表示为 <span class="math inline">\(g^k\)</span> ， 其中 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p\)</span> 意义下的原根。<br />
那么有 <span class="math inline">\(g^{k\frac{p-1}{2}} \equiv 1\)</span> 由于 <span class="math inline">\(g\)</span> 是原根，必有 <span class="math inline">\(p-1|k\frac{p-1}{2}\)</span> ，<br />
也就是说 <span class="math inline">\(k\)</span> 一定是偶数，那么令 <span class="math inline">\(x \equiv g^{\frac{k}{2}}\)</span> 即是 <span class="math inline">\(n\)</span> 开根的结果，这说明 <span class="math inline">\(n\)</span> 是二次剩余。</p>
<p>也就是说 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv 1\)</span> 与 <span class="math inline">\(n\)</span> 是二次剩余是等价的，<br />
由于 <span class="math inline">\(n^{\frac{p-1}{2}}\)</span> 不为 1 就只能是 -1 ，那么 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv -1\)</span> 与 <span class="math inline">\(n\)</span> 是非二次剩余等价。</p>
<p><em>ps: 网上一堆伪证说若 <span class="math inline">\(n\)</span> 是非二次剩余，不存在 <span class="math inline">\(x\)</span> 使得上式为 1 ，但这只能说明上式为 -1 时 <span class="math inline">\(n\)</span> 是非二次剩余，并不能推翻“当 <span class="math inline">\(n\)</span> 是非二次剩余时上式为 1”</em></p>
<h2 id="cipolla">Cipolla</h2>
<p>对于二次剩余解方程 <span class="math inline">\(x^2 \equiv n\)</span> 。</p>
<p>找到一个 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(a^2 - n\)</span> 是非二次剩余，由于非二次剩余的数量接近 <span class="math inline">\(\frac{p}{2}\)</span> ，<br />
通过随机 + 检验的方式期望约 2 次可以找到这样一个 <span class="math inline">\(a\)</span> 。</p>
<p>接下来定义 <span class="math inline">\(i^2 \equiv a^2 - n\)</span> 。<br />
但是 <span class="math inline">\(a^2 - n\)</span> 不是二次剩余，怎么找得到这样一个 <span class="math inline">\(i\)</span> ？</p>
<p>类比实数域到复数域的推广，定义这样一个 <span class="math inline">\(i\)</span> ，然后可以将所有数表示为 <span class="math inline">\(A+Bi\)</span> 的形式，<br />
其中 <span class="math inline">\(A, B\)</span> 都是模 <span class="math inline">\(p\)</span> 意义下的数，类似于实部和虚部。</p>
<p>那么 <span class="math inline">\((a + i)^{p+1} \equiv n\)</span> ，考虑证明。</p>
<p><strong>引理 1</strong> ： <span class="math inline">\(i^p \equiv -i\)</span> 。</p>
<p>证明： <span class="math inline">\(i^p \equiv i (i^2)^{\frac{p-1}{2}} \equiv i(a^2 - n)^{\frac{p-1}{2}} \equiv -i\)</span></p>
<p><strong>引理 2</strong> ： <span class="math inline">\((A + B)^p \equiv A^p + B^p\)</span> 。</p>
<p>证明：二项式定理展开后，由于 <span class="math inline">\(p\)</span> 是质数，除了 <span class="math inline">\(C_p^0, C_p^p\)</span> 外的组合数分子上的阶乘没法消掉，模 <span class="math inline">\(p\)</span> 都会为 0 ，剩下来的就是 <span class="math inline">\(C_p^0 A^0 B^p + C_p^p A^p B^0\)</span> 。</p>
<p>现在证明上述结论：</p>
<p><span class="math display">\[(a + i)^{p+1} \equiv (a^p + i^p) (a + i) \equiv (a - i) (a + i) \equiv a^2 - i^2 \equiv n\]</span></p>
<p>那么 <span class="math inline">\((a + i)^{\frac{p+1}{2}}\)</span> 即是一个解，其相反数是另一个解。</p>
<p>然而还剩最后一个问题， <span class="math inline">\((a + i)^{\frac{p+1}{2}}\)</span> 的“虚部”一定为 0 吗？</p>
<p>幸运的是，的确如此，假设存在 <span class="math inline">\((A + Bi)^2 \equiv n\)</span> 且 <span class="math inline">\(B \ne 0\)</span> ，<br />
那么有 <span class="math inline">\(A^2 + B^2i^2 + 2ABi \equiv n\)</span> ，即 <span class="math inline">\(A^2 + B^2(a^2 - n) - n \equiv -2ABi\)</span> 。<br />
式子的左边“虚部”为 0 ，那么式子右边的“虚部”也一定为 0 ，也就是说 <span class="math inline">\(AB \equiv 0\)</span> 。<br />
既然假设了 <span class="math inline">\(B \ne 0\)</span> 那么一定是 <span class="math inline">\(A \equiv 0\)</span> ，也就是说 <span class="math inline">\((Bi)^2 \equiv n\)</span> 。<br />
也就是 <span class="math inline">\(i^2 \equiv nB^{-2}\)</span> ，由于 <span class="math inline">\(B^2\)</span> 是个二次剩余，其逆元 <span class="math inline">\(B^{-2}\)</span> 一定也是二次剩余，乘上二次剩余 <span class="math inline">\(n\)</span> 后一定还是二次剩余，这与 <span class="math inline">\(i^2\)</span> 是个非二次剩余产生矛盾。</p>
<h2 id="实现">实现</h2>
<p>实现的时候弄个“复数”类（据说也可以不用）即可。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line">lolong I_mul_I; <span class="comment">// 虚数单位的平方</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">  lolong real, imag;</span><br><span class="line">    <span class="built_in">complex</span>(lolong real = <span class="number">0</span>, lolong imag = <span class="number">0</span>): real(real), imag(imag) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="built_in">complex</span> x, <span class="built_in">complex</span> y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.real == y.real <span class="keyword">and</span> x.imag == y.imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span> * (<span class="built_in">complex</span> x, <span class="built_in">complex</span> y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span>((x.real * y.real + I_mul_I * x.imag % mod * y.imag) % mod,</span><br><span class="line">          (x.imag * y.real + x.real * y.imag) % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">power</span><span class="params">(<span class="built_in">complex</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">complex</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">     x = x * x;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_if_residue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> power(x, (mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;x0, <span class="keyword">int</span> &amp;x1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        x0 = x1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mod = p;</span><br><span class="line"></span><br><span class="line">    lolong a = rand() % mod;</span><br><span class="line">  <span class="keyword">while</span>(!a <span class="keyword">or</span> check_if_residue((a * a + mod - n) % mod))</span><br><span class="line">      a = rand() % mod;</span><br><span class="line"> I_mul_I = (a * a + mod - n) % mod;</span><br><span class="line"></span><br><span class="line">  x0 = <span class="keyword">int</span>(power(<span class="built_in">complex</span>(a, <span class="number">1</span>), (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).real);</span><br><span class="line"> x1 = mod - x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bsgs">BSGS</h2>
<p>值得一提的是，模意义开根（甚至可以推广到开 <span class="math inline">\(k\)</span> 次方根）是可以通过原根转换为求对数问题从而使用 BSGS 的。<br />
不过复杂度 <span class="math inline">\(O(\sqrt{p})\)</span> 远不如 Cipolla 的 <span class="math inline">\(O(logp)\)</span> 优秀，但很多情况下也足够了。</p>
<p>具体地，将 <span class="math inline">\(x\)</span> 表示为 <span class="math inline">\(g^y\)</span> ，其中 <span class="math inline">\(g\)</span> 是原根，方程变为 <span class="math inline">\((g^y)^k \equiv n\)</span> ，即 <span class="math inline">\((g^k)^y \equiv n\)</span> ，解出 <span class="math inline">\(y\)</span> 即可。</p>
<h2 id="非二次剩余开根">非二次剩余开根</h2>
<p>事实上，大多数情况需要开根的数并不是个二次剩余。</p>
<p>比如有一个递推式，为了化简需要开根，但是这时候被开根的数是个任意数。</p>
<p>比如 <a href="https://cometoj.com/contest/72/problem/Ｄ?problem_id=4033">这个</a> 还有 <a href="http://www.51nod.com/Challenge/ProblemSubmitDetail.html#judgeId=826009">这个</a> 。</p>
<p>其实很简单，像 Cipolla 那样直接扩域，把这个非二次剩余设为虚数单位即可。<br />
但当然这仅适用于对仅仅一个非二次剩余开根的情况，如果式子需要同时对若干非二次剩余开根，扩域的代价（大概）会呈指数级别增长，即每一次复数乘法的复杂度会很大。</p>
<h2 id="扩域后指数取模">扩域后指数取模</h2>
<p>（以下前提是模数是质数）</p>
<p>扩域后，费马小定理在复数上是不成立的，也就是说 <span class="math inline">\((A+Bi)^p\)</span> 不一定同余于 <span class="math inline">\(A+Bi\)</span> 。</p>
<p>但有时需要对一个幂的指数取模，还是扩域后的，或者有时候需要对一个扩域后的数求逆元，怎么办？</p>
<p>比如 <a href="http://www.51nod.com/Challenge/ProblemSubmitDetail.html#judgeId=826009">这个</a> 。</p>
<p>根据 Cipolla 中提到的公式 <span class="math inline">\((a + i)^{p+1} \equiv n\)</span> ，推广一下可以得到 <span class="math inline">\((A+Bi)^{p+1} \equiv A^2-B^2i^2\)</span> 。</p>
<p>注意到此时 <span class="math inline">\(A^2 - B^2 i^2\)</span> 虚部为 0 ，设 <span class="math inline">\(x \equiv A^2 - B^2 i^2\)</span> 虚部为零的数是满足费马小定理的，<br />
也就是说 <span class="math inline">\(x^p \equiv x\)</span> ，即 <span class="math inline">\(x^{p-1} \equiv 1\)</span>，那么有 <span class="math inline">\(((A+Bi)^{p+1})^{p-1} \equiv 1\)</span> 。<br />
也就说指数对 <span class="math inline">\(p^2 - 1\)</span> 取模即可，换句话说，扩域后的复数 <span class="math inline">\(x\)</span> 满足：</p>
<p><span class="math display">\[ x^{p^2} \equiv x \]</span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>同余</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title>LGR-061&amp;XR-4</title>
    <url>/2019/10/20/LGR-061-XR-4/</url>
    <content><![CDATA[<p>开场 30min 才反应过来有场比赛。<br />
不知道哪来的自信就去报了 Div.1 。。。</p>
<p>第一次打 IOI 赛制的网络赛，感觉海星，不像 ACM 一样必须 A 题，<br />
打部分分的话就和平时训练的感觉一样，操作起来相对顺手。</p>
<p><del>但是打网络赛为什么要拿部分分呢，当然冲着 A 题去啊是吧</del></p>
<p>然而全场只能做出 A 题。并没有平时打 ACM 赛制的时候有签到题。<br />
不过还好，反正我不适合打手速题。</p>
<p>Skip 掉了 B （还好 Skip 掉了，后来全程肝 B 没肝出来），直接开 C 。<br />
发现 C 的 63' 巨水，打了个神奇剪枝交了一发，我一直感觉这玩意复杂度是 <span class="math inline">\(O(np)\)</span> 的，<br />
但是没用，TLE ，复杂度假了呗，虽然我并不知道原因，但觉得剩下的 37' 性价比不高，就 Skip 掉了。</p>
<p>提答题好评。</p>
<p>洛谷不支持提答题差评。</p>
<p>但是它给的输入文件的坐标都是有理数，小数点后面一堆数我 TM 怎么知道它的具体位置啊，在图里面标注坐标的无理数表示会死吗。。<br />
第一个点蛮简单的，然后第二个点就卡死了。</p>
<p>弃疗，回去肝 B 。</p>
<p>但是我觉得 B 真的难啊，好多细节？反正是没肝出来，最后 173' 狗到 rank21 。</p>
<p>然而这场比赛参加的人少，只有 300+ 个人打，而且好像很多流皮的人都不打洛谷月赛哦，<br />
所以不太理解为什么 XRound 为什么坚持在洛谷办<del>（难道是 py 交易？）</del>，<br />
平心而论对于 XR 这种比赛 CometOJ 应该是个更合适的平台。</p>
<p><span class="math inline">\(\color{white}{事实上，洛谷的确为办一场月赛出了不少钱，出题人的待遇比在 cf 等比赛要高}\)</span></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>XR</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队二次离线</title>
    <url>/2019/10/16/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>莫队算法可以通过单点增量的方式以 <span class="math inline">\(O(n\sqrt{n}K)\)</span> （认为 <span class="math inline">\(n, q\)</span> 同阶）的复杂度离线处理若干区间信息询问。 其中每次单点增量，即每次端点移动的复杂度为 <span class="math inline">\(O(K)\)</span> 。</p>
<p>大多数情况下端点移动的复杂度是 <span class="math inline">\(O(1)\)</span> 的，这样的问题一般是统计区间内的“数”。 而统计区间内的“数对”这样的问题往往难以 <span class="math inline">\(O(1)\)</span> 处理端点移动。</p>
<p>莫队二次离线或许能处理这样的问题。</p>
<h2 id="什么用">什么用</h2>
<p>一般莫队有 <span class="math inline">\(O(n\sqrt{n})\)</span> 次端点移动，如果要用数据结构维护信息的话， 就有 <span class="math inline">\(O(n\sqrt{n})\)</span> 次修改和 <span class="math inline">\(O(n\sqrt{n})\)</span> 次查询。</p>
<p>而莫队二次离线能够优化为成 <span class="math inline">\(O(n)\)</span> 次修改和 <span class="math inline">\(O(n\sqrt{n})\)</span> 次查询， 从而允许使用一些修改复杂度大而查询复杂度小的方式来维护信息。 例如分块，如果能 <span class="math inline">\(O(\sqrt{n})\)</span> 修改和 <span class="math inline">\(O(1)\)</span> 查询的话，总的复杂度就是 <span class="math inline">\(O(n\sqrt{n})\)</span> 。</p>
<p>但是有两个前提：</p>
<ul>
<li>维护的信息有一定可减性，换句话说必须保证每次询问 <span class="math inline">\([l, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献时， 需要能够用 <span class="math inline">\([1, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献减去（或者其他方式）<span class="math inline">\([1, l)\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献代替。</li>
<li>维护的信息有一定可加性，换句话说在每次询问前在不知道当前的 Ans 的情况下可以得到 Ans 的改变量（或某种改变方式）。</li>
</ul>
<h2 id="怎么用">怎么用</h2>
<p>考虑每次右端点右移的过程（右端点左移以及左端点移动是类似的）。</p>
<p>每次右端点 <span class="math inline">\(r\)</span> 从 <span class="math inline">\(r_0\)</span> 移动到 <span class="math inline">\(r_1\)</span> 时，对于其中的每一个 <span class="math inline">\(r\)</span> ，都需要查询 <span class="math inline">\([l, r - 1]\)</span> 与该点产生的贡献。 考虑差分，利用上面提到过的可减性，查询 <span class="math inline">\([1, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献和 <span class="math inline">\([1, l)\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献。</p>
<h4 id="part-1">Part 1</h4>
<p><span class="math inline">\([1, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献只与 <span class="math inline">\(r\)</span> 有关，可以记为 <span class="math inline">\(f_r\)</span> 。 那么预处理 <span class="math inline">\(f_r\)</span> 只需从小到大一个个加点维护当前的 <span class="math inline">\([1, r]\)</span> 并询问出 <span class="math inline">\(f_r\)</span> 。</p>
<p>这个过程需要 <span class="math inline">\(O(n)\)</span> 次修改和 <span class="math inline">\(O(n)\)</span> 次查询。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[i] 是第 i 个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">  f[i] = Query(a[i]);</span><br><span class="line">   Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外如果需要卡常，可以将 <span class="math inline">\(f\)</span> 做一遍前缀和，这样后续查询 <span class="math inline">\([r_0, r_1]\)</span> 总的贡献就可以 <span class="math inline">\(O(1)\)</span> 计算了（不影响复杂度）。</p>
<h4 id="part-2">Part 2</h4>
<p><span class="math inline">\([1, l)\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献可以二次离线，在 <span class="math inline">\(l\)</span> 处存下 <span class="math inline">\(r + 1\)</span> 之后再考虑计算。 这样做的空间复杂度是 <span class="math inline">\(O(n\sqrt{n})\)</span> 的， 但事实上每次只需把 <span class="math inline">\([r_0, r_1]\)</span> 这个区间存进 <span class="math inline">\(l\)</span> 处而不是把每个数存进去就可以做到 <span class="math inline">\(O(n)\)</span> 的空间复杂度了， 这样询问的时候也只需求 <span class="math inline">\([r_0, r_1]\)</span> 整体的贡献，常数上还能少一个 <span class="math inline">\(O(n\sqrt{n})\)</span> 的瓶颈。</p>
<p>离线处理上述的贡献，也和求 <span class="math inline">\(f_r\)</span> 的过程类似，每次从小到大一个个加点维护当前的 <span class="math inline">\([1, l)\)</span> ， 并对于 <span class="math inline">\(l\)</span> 处存下的每一个数逐个询问 <span class="math inline">\([1, l)\)</span> 与其产生的贡献即可。 这个过程需要 <span class="math inline">\(O(n)\)</span> 次修改和 <span class="math inline">\(O(n\sqrt{n})\)</span> 次查询。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line"> <span class="keyword">int</span> L = query[i].l, R = query[i].r; <span class="comment">// 排序后的询问</span></span><br><span class="line">   <span class="keyword">if</span>(r &lt; R) &#123;</span><br><span class="line">      <span class="built_in">vector</span>[l].push_back(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(r + <span class="number">1</span>, R));</span><br><span class="line">      r = R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> par : <span class="built_in">vector</span>[i])</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k = par.first; k &lt;= par.second; k ++)</span><br><span class="line">            Query(a[k]); <span class="comment">// 这里用什么东西存一下结果就好了</span></span><br><span class="line">  Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>亚线性筛</title>
    <url>/2019/10/15/%E4%BA%9A%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>亚线性筛，就是以低于线性的复杂度预处理一些线性信息的筛法统称。</p>
<p>目前我会杜教筛和 min25 还有 powerful number。</p>
<h2 id="杜教筛">杜教筛</h2>
<p>篇幅过长，<a href="/2020/01/02/杜教筛">点击此处</a>。</p>
<h2 id="min25">min25</h2>
<p>min25 筛是扩展埃氏筛，也可以筛一类（更复杂的）<strong>积性函数</strong>的前缀和，并且通常是同类亚线性筛中最快的一个。<br />
而且灵活运用 min25 可以处理一些特殊的关于质因子的问题。</p>
<h3 id="理论">理论</h3>
<p>假设要求 <span class="math inline">\(S(n) = \sum_{i=1}^n f(i)\)</span> 。</p>
<p>min25 筛可大致分为两步。</p>
<a id="more"></a>
<h4 id="step-1">Step 1</h4>
<p>第一步处理的是 <span class="math inline">\(f\)</span> 在质数上的取值的和。<br />
令 <span class="math inline">\(F(x) = [x \in Prime] f(x)\)</span> ，那么这一步的目标是筛出 <span class="math inline">\(F\)</span> 的前缀和。<br />
准确地讲，是 <span class="math inline">\(F\)</span> 的前缀和函数 <span class="math inline">\(S_F\)</span> 在每个形如 <span class="math inline">\(\frac{n}{d}\)</span> 的数上的取值。</p>
<p>首先需要将 <span class="math inline">\(f(i)\)</span> 拆成若干完全积性函数的和，<br />
只需考虑 <span class="math inline">\(F\)</span> ，也就是 <span class="math inline">\(f(p^k)\)</span> 的取值。<br />
如果是关于 <span class="math inline">\(p\)</span> 的多项式，每个单项式对应的就是一个完全积性函数。</p>
<p>假设现在要筛一个完全积性函数 <span class="math inline">\(h\)</span> ，要能快速计算出 <span class="math inline">\(S_h = \sum_{i=1}^n h(i)\)</span> 。<br />
这一步的主要思想是，一个一个枚举质数 <span class="math inline">\(p\)</span> ，筛掉最小质因子为 <span class="math inline">\(p\)</span> 的合数的取值。<br />
而合数 <span class="math inline">\(x\)</span> 的最小质因子为 <span class="math inline">\(p\)</span> 的必要条件是 <span class="math inline">\(p^2 \leq x\)</span> ，即 <span class="math inline">\(p \leq \sqrt{x}\)</span> 。<br />
那么只需要枚举 <span class="math inline">\(\sqrt{n}\)</span> 以内的质数去筛即可。</p>
<p>假设现在筛掉了前 <span class="math inline">\(i - 1\)</span> 个质因子得到一个这个值：</p>
<p><span class="math display">\[g(n, i - 1) = \sum_{x=1}^n [x \in Prime \; or \; minp(x) &gt; P_{i-1}] h(x)\]</span></p>
<p>其中 <span class="math inline">\(P_i\)</span> 表示 <span class="math inline">\(\sqrt{n}\)</span> 以内第 <span class="math inline">\(i\)</span> 个质数。</p>
<p>那么接下来要筛最小质因子为 <span class="math inline">\(P_i\)</span> 的合数：</p>
<p><span class="math display">\[g(n, i) = g(n, i - 1) - \sum_{x=1}^n [minp(x) = P_i \; and \; x \notin Prime] h(x)\]</span></p>
<p>由于 <span class="math inline">\(h\)</span> 是完全积性函数，<span class="math inline">\(P_i\)</span> 可以直接提出来，得到（这里的除号表示整除）：</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
g(n, i) &amp;= g(n, i - 1) - h(P_i) \sum_{x=1}^{n/P_i} [minp(x) \geq P_i] h(x) \\\\
&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{x=1}^{n/P_i} [x \in Prime \; and \; minp(x) &lt; P_i] h(x)) \\\\
&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{j=1}^{i-1} h(P_j)) \\\\
&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - ph_{i - 1}) \\\\
\end{aligned}
\end{equation}
\]</span></p>
<p>其中 <span class="math inline">\(ph_i\)</span> 就是 <span class="math inline">\(h\)</span> 在前 <span class="math inline">\(i\)</span> 个质数上的取值和，注意 <span class="math inline">\(P_i \leq \sqrt{n}\)</span> ，这是可以直接筛的。</p>
<p>那么上面的式子就是 <span class="math inline">\(g\)</span> 的递推式，不难发现第一维的取值都是 <span class="math inline">\(\frac{n}{d}\)</span> 的形式，第二维可以滚动。<br />
直接按照递推式算，就可以在 <span class="math inline">\(O(\sqrt{n} |P|)\)</span> 的时间筛出需要的东西，也就是 <span class="math inline">\(g(n, |P|)\)</span> 。<br />
这还是不够的，需要优化，由于最小质因子的取值在根号以内，所以递推时只需考虑满足 <span class="math inline">\(n \geq P_i^2\)</span> 的 <span class="math inline">\(g(n, i)\)</span> 。<br />
当 <span class="math inline">\(n &lt; P_i^2\)</span> 时，随着 <span class="math inline">\(i\)</span> 的增大 <span class="math inline">\(g(n, i)\)</span> 的值不会改变，由于是滚动数组，直接 skip 掉就好了。</p>
<p>update: 实现中并不需要单独维护 <span class="math inline">\(ph\)</span> ，事实上直接在 <span class="math inline">\(g\)</span> 中就能查到需要的 <span class="math inline">\(ph\)</span> 。</p>
<h4 id="step-2">Step 2</h4>
<p>上面将每个完全积性函数的 <span class="math inline">\(g(n, |P|)\)</span> 加起来，得到 <span class="math inline">\(S_F(n)\)</span> ，表示 <span class="math inline">\(f\)</span> 在质数上的取值 <span class="math inline">\(F\)</span> 的前缀和。</p>
<p>仍然利用最小质因子，不同的是，上一步从所有的取值开始从小到大把对应的最小质因子的合数的贡献给删掉的到质数的取值。<br />
那这一步能不能反过来，从质数的取值开始，从大到小把对应的最小质因子的合数的贡献给加上最后得到所有数的取值？</p>
<p>并不能，事实上是从空值开始，从大到小把对应的最小质因子的数的贡献加上最后得到所有数的取值，<br />
合数可以递推并类似地利用积性函数的性质提出一个因子，质数则直接用上一步预处理的来算。</p>
<p>那么假设现在以及算上了比第 <span class="math inline">\(i\)</span> 个更大的质数为最小质因子的数的值得到了这个：</p>
<p><span class="math display">\[S(n, i) = \sum_{x=1}^n [minp(x) &gt; P_i] f(x)\]</span></p>
<p>不难推导出：</p>
<p><span class="math display">\[S(n, i)=S_F(n) - pf_i + \sum_{P_j &lt; P_k \leq \sqrt{n}} \sum_{e&gt;0,P_k^e \leq n}f(P_k^e)(S(\frac{n}{P_k^e}, k) + [e&gt;1])\]</span></p>
<p>其中 <span class="math inline">\(pf_i\)</span> 就是 <span class="math inline">\(f\)</span> 在前 <span class="math inline">\(i\)</span> 个质数上的取值和，注意 <span class="math inline">\(P_i \leq \sqrt{n}\)</span> ，这是可以直接筛的。</p>
<p>同样地第一维的取值都是 <span class="math inline">\(\frac{n}{d}\)</span> 的形式，但是第二维无法滚动，<br />
但事实上后面的部分直接递归计算即可，以下是参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"><span class="function">lolong <span class="title">S</span><span class="params">(lolong i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(prime[j] &gt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   lolong res = S_F[id(i)] - pf[j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= p <span class="keyword">and</span> <span class="number">1l</span>l * prime[k] * prime[k] &lt;= i; k ++) &#123;</span><br><span class="line">       <span class="keyword">int</span> e = <span class="number">1</span>;</span><br><span class="line">       lolong pr = prime[k];</span><br><span class="line">     <span class="keyword">while</span>(pr &lt;= i) &#123;</span><br><span class="line">         res += (prime[k] ^ e) * (S(i / pr, k) + (e &gt; <span class="number">1</span>));</span><br><span class="line">          pr *= prime[k];</span><br><span class="line">           e ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度似乎是 <span class="math inline">\(O(\frac{n^{\frac{3}{4}}}{\log n})\)</span> ，大概是能跑 <span class="math inline">\(10^{11}\)</span> 的。</p>
<p>另外 min25 筛还有个树状数组的优化版本，也是 min25 本人引入的，复杂度 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> ，<br />
大概能跑 <span class="math inline">\(10^{13}\)</span> ？<br />
但很不常见，网上可供学习的资料很少，有兴趣可以直接看 <a href="https://min-25.hatenablog.com/entry/2018/11/11/172216">min25 的博客</a>。</p>
<h2 id="powerful-number">Powerful number</h2>
<p>这个在 OI 中用得少，我也只是做过两道题，大概提一下。</p>
<p>称 1 和每个质因子次数大于 1 的合数为 Powerful number 。<br />
首先有个性质就是 <span class="math inline">\(n\)</span> 以内的 Powerful number 数量是 <span class="math inline">\(O(\sqrt{n})\)</span> 的。</p>
<p>还是筛数论函数 <span class="math inline">\(f\)</span> 的前缀和 <span class="math inline">\(S\)</span> ，需要构造两个函数 <span class="math inline">\(g, h\)</span> 满足 <span class="math inline">\(f = g \cdot h\)</span> 。<br />
如果 <span class="math inline">\(g\)</span> 只在 Powerful number 上有值并且 <span class="math inline">\(h\)</span> 的前缀和 <span class="math inline">\(S_h\)</span> 容易求或者可以筛的话，<br />
由 <span class="math inline">\(S(n) = \sum_{i=1}^n \sum_{d|x} g(d) h(\frac{d}{x}) = \sum_{d=1}^n G(d) S_h(n/d)\)</span><br />
可以通过枚举 Powerful number 快速计算答案。</p>
<p>至于枚举 Powerful number 的方法，注意到 Powerful number 的质因子都是 <span class="math inline">\(\sqrt{n}\)</span> 以内的，<br />
这可以通过反证法证明，如果有大于 <span class="math inline">\(\sqrt{n}\)</span> 的质因子它的次数不可能超过 1 。<br />
那么筛出 <span class="math inline">\(\sqrt{n}\)</span> 以内的质数，再通过搜索枚举每个质数的次数即可。</p>
<p>如果 <span class="math inline">\(h(x)\)</span> 前缀和可以 <span class="math inline">\(O(1)\)</span> 求的话，复杂度是 <span class="math inline">\(O(n^{\frac{1}{2}})\)</span> 。</p>
<p>如果 <span class="math inline">\(h(x)\)</span> 前缀和可以 <span class="math inline">\(O(\sqrt x)\)</span> 求的话，复杂度是 <span class="math inline">\(O(n^{\frac{1}{2}} \log n)\)</span> ，5s 内 <span class="math inline">\(10^{13}\)</span> 不成问题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>杜教筛</tag>
        <tag>min25</tag>
        <tag>powerful number</tag>
      </tags>
  </entry>
  <entry>
    <title>cf-592div2</title>
    <url>/2019/10/13/cf-592div2/</url>
    <content><![CDATA[<p>自闭。<br />
这大概是我打过最失败的一场比赛。</p>
<p><del>UPDATE: 我还是太 naive 了，比起后面 Div1 爆零，这次还算好的。</del></p>
<p>A 签到题，然而我在 14min 才 A ，我是真的不适合做手速题。</p>
<p>B 行数开大点就是插头 DP ，然而行数只有 2 ，插头只有 3 种，<br />
随便 DP 一下就行了，中间少考虑一种插头 WA 了一发，在 25min AC 。</p>
<p>然后，就没有然后了。</p>
<p>C 题解二元一次方程的整除解，woc 这不扩欧板题嘛，没想太多，直接码上去。<br />
然后很轻松过了样例啊，交 WA 了，哦没判负数，又交 WA 了。。。<br />
静态查错无果，遂对拍，拍了 1000+ 组全是 AC 。</p>
<p>事情好像不太对劲.jpg</p>
<p>skip 掉，直接开 E ，发现了个单调性，没想太多，直接码上去。<br />
还是很轻松过了样例啊，交 WA 了。<br />
静态查错无果，遂回去调 C 。</p>
<p>冷静分析一波后发现 C 题神 tm 会爆 long long 。<br />
这简单，改 int128 ，结果交 CE 了。<br />
然后就到网上蒯 c++ 大整数模板，贴下来后，<br />
样例都过不去了我天，然后我就去调那个模板，也是醉了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Big n = <span class="number">10</span>, x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n - x + x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码第一行输出 10 ，第二行输出 20 。</p>
<p>当时我心态就炸了，简直想去问候那个把模板贴他博客上的祖宗十八代。<br />
写的这玩意连加减法都算不对心里没点 B 数吗也敢往网上放。</p>
<p>服了，还是乖乖想不爆 long long 的解法吧。</p>
<p>9102 年了还有人靠爆 long long 混饭吃。<br />
这样明显卡语言啊，对 c++ 选手毫无公平性可言。</p>
<p>至于正解，自然是没想出来。</p>
<p>最后获得了 rank3400+ 的好成绩，掉分预定。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-12</title>
    <url>/2019/10/13/cometoj-12/</url>
    <content><![CDATA[<p>以后打比赛写总结。</p>
<p><del>话说今天打到短裙好开心啊</del></p>
<p>A 题签到题。</p>
<p>为什么我第一个想的就是 O(1) 的哈希？<br />
表示完全没有去想好写得多的排序，而是直接把三个字符用 int 表示去搞。<br />
然后本地测样例玄学错误，最后发现哈希的数组开小了。<br />
7min 做出 A 题表示自闭。</p>
<p><del>真是可怕交题的时候刷新就有 40+ AC 了</del></p>
<p>B 题还是签到题，以为能在 5min AC 结果打了 9min ，感觉我不适合这种手速题。</p>
<p>然后我 C 题看都没看一眼直接 skip 掉就去开了 D 题。<br />
看了 3min 哇这不数位 DP 吗，现在还没人交，我还有拿一血的想法。<br />
然后打了出来，测样例， woc 过了，这个时候还是 4 提交 0 通过。<br />
我在机房大呼卧槽我要拿一血了，然后自信满满地交了上去。</p>
<p>成功 WA 掉所有点。</p>
<p>再刷新 D 题一血就已经被拿了。</p>
<p>然后我的心路历程是这样的：</p>
<p>我要拿二血。</p>
<p>我要拿三血。</p>
<p>我要拿四血。</p>
<p>算了我凉了还是做好长期打算拿个十血什么的吧。。。</p>
<p>期间各种被 master 嘲讽，各种互怼。</p>
<p>master 走后没人跟我说话了，然后冷静分析了一波，发现限制条件搞错了，<br />
然后随便搓了几行代码就 A 了。</p>
<p><del>所以以后打比赛要远离 master</del><br />
所以以后打比赛还是要在快节奏中冷静下来。</p>
<p>A 完 D 已经是 2h 了，回去看 C ，<del>这 tm 不最短路板题嘛</del>。<br />
然而 C 题有坑，卡了好久，最后在比赛结束前 3min rush 了一发成功 AC 。</p>
<p>然后靠着 4 题 + 罚时 8h 狗进 rank8 <del>拿到短裙啦</del>。</p>
<p>这场比赛绝对是我打的最爽的一场网络赛，感觉 cometoj 的 ACM 比赛才是最刺激的，<br />
题目质量高，节奏快，竞争激烈，尤其是相对于 cf 和 atcoder 来说没有网速杀和题意杀。<br />
体验感极好。<br />
<del>最主要的还是有短裙拿</del></p>
<p>然而拿短裙又没人肯女装，我还是选择拿杯子吧。。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>RMQ</title>
    <url>/2019/10/11/RMQ/</url>
    <content><![CDATA[<p>总结求各种 RMQ 的常用技巧和方法。<br />
RMQ 真是流皮，每次深入思考都会有新的发现，所以有了新的发现会更新。</p>
<p>以下 n 表示数列的大小，q 表示询问的次数，均以最大值为例。</p>
<h2 id="一般性普通做法">一般性普通做法</h2>
<p>线段树当然是可以在线维护的，复杂度 <span class="math inline">\(O(n + qlogn)\)</span> 。<br />
甚至还可以支持单点修改或区间修改。</p>
<p>但是如果只是静态询问的话，可以用 ST 表预处理后 <span class="math inline">\(O(1)\)</span> 在线处理询问，<br />
复杂度 <span class="math inline">\(O(nlogn + q)\)</span> 。</p>
<p>这两个做法烂大街了，是基础中的基础，不是本文讨论重点。</p>
<a id="more"></a>
<h2 id="区间定长特殊做法">区间定长特殊做法</h2>
<p>即所有的询问区间的长度都为与询问无关的定值 <span class="math inline">\(len\)</span> 。<br />
直接当做任意区间做，可以做到 <span class="math inline">\(O(n + qlogn)\)</span> 或 <span class="math inline">\(O(nloglen + q)\)</span> 。</p>
<p>这种情况下有更好理解的预处理方法，只需优先队列。<br />
先把 <span class="math inline">\([1, l]\)</span> 的数扔进优先队列里，之后不断把区间右移，<br />
<span class="math inline">\([l, r]\)</span> 右移的过程相当于加一个点 <span class="math inline">\(r + 1\)</span> 并删掉点 <span class="math inline">\(l\)</span> ，用优先队列维护即可。<br />
复杂度 <span class="math inline">\(O(nlogn + q)\)</span> 。</p>
<p>但这还不够，还有线性的预处理方法，用单调双端队列代替上面的优先队列。<br />
同样是让区间不断右移，单调双端队列中的值是单调不增的， 那么最左边的值一定是最大值。<br />
加点 <span class="math inline">\(r + 1\)</span> 前维护单调性，删点 <span class="math inline">\(l\)</span> 时判断是不是删的最大值， 如果是就删点最左边的点即可。<br />
复杂度 <span class="math inline">\(O(n + q)\)</span> 。</p>
<h2 id="随机询问期望做法">随机询问期望做法</h2>
<p>这种情况下有个 <span class="math inline">\(O(n + q)\)</span> 的在线做法。</p>
<p>考虑分块，设块的大小为 <span class="math inline">\(b\)</span> ， <span class="math inline">\(O(n)\)</span> 预处理每个块的最大值。</p>
<p>那么对于询问 <span class="math inline">\([l, r]\)</span> ，若该区间跨过了多个块，问题就分为两个部分：</p>
<ol type="1">
<li>求跨过的块区间的最大值。</li>
<li>求两端点所在零散的块的最大值。</li>
</ol>
<p>第一个问题就是个子问题，并且数据规模减小到了 <span class="math inline">\(O(\frac{n}{b})\)</span> ，<br />
为了保证询问 <span class="math inline">\(O(1)\)</span> ，可以用上面一般性的普通做法提到的 ST 表，<br />
就可以 <span class="math inline">\(O(\frac{n}{b} log\frac{n}{b})\)</span> 进行预处理然后 <span class="math inline">\(O(1)\)</span> 询问。</p>
<p>第二个问题端点所在零散的块是该块的一段前缀或者后缀，<br />
只需 <span class="math inline">\(O(n)\)</span> 对于每个块预处理前缀最大值和后缀最大值即可 <span class="math inline">\(O(1)\)</span> 询问。</p>
<p>那么若询问区间在同一个块内呢？<br />
自然是暴力扫，但是这样的复杂度是 <span class="math inline">\(O(b)\)</span> 的。<br />
但询问区间随机的情况下，不难得出两个端点在同一个块内的概率是 <span class="math inline">\(\frac{b}{n}\)</span> 。<br />
那么这种情况询问的期望复杂度是 <span class="math inline">\(O(\frac{b^2}{n})\)</span> 的。</p>
<p>总复杂度 <span class="math inline">\(O(n + \frac{n}{b} log\frac{n}{b} + q + q \frac{b^2}{n})\)</span> 。<br />
当 <span class="math inline">\(b\)</span> 至少为 <span class="math inline">\(O(logn)\)</span> 时，预处理的 <span class="math inline">\(O(\frac{n}{b} log\frac{n}{b})\)</span> 不超过 <span class="math inline">\(O(n)\)</span> 。<br />
当 <span class="math inline">\(b\)</span> 至多为 <span class="math inline">\(O(\sqrt{n})\)</span> 时，询问的 <span class="math inline">\(O(q \frac{b^2}{n})\)</span> 不超过 <span class="math inline">\(O(q)\)</span> 。<br />
因此 <span class="math inline">\(b\)</span> 的大小取 <span class="math inline">\(O(logn)\)</span> 到 <span class="math inline">\(O(\sqrt{n})\)</span> 之间即可。</p>
<p>另外，当 <span class="math inline">\(b = \sqrt{n}\)</span> 时，块的个数也是 <span class="math inline">\(O(\sqrt{n})\)</span> 的，<br />
此时根本不需要 ST 表，直接 <span class="math inline">\(O(\sqrt{n}^2)\)</span> 暴力预处理处理所有可能区间的最大值即可。<br />
这样复杂度不变，常数可能还能小一点。</p>
<h4 id="毒瘤活动">毒瘤活动</h4>
<p>值得注意的是，虽然这个做法的复杂度仅适用于询问区间随机的情况，但是一般不会卡。</p>
<p>来点有意思的娱乐活动，考虑怎么卡掉它，以及怎么防止被出题人卡。</p>
<p>想要卡这个做法就要尽量让询问区间在一个块内，卡成 <span class="math inline">\(O(b)\)</span> 的询问复杂度。<br />
但在不知道块的大小的情况下，假设给一个区间长 <span class="math inline">\(len\)</span> 的询问，实际块的大小为 <span class="math inline">\(b\)</span> ，<br />
那么两个端点在同一个块内的概率大概是 <span class="math inline">\(\frac{b-len+1}{b}\)</span> ，期望复杂度就是 <span class="math inline">\(O(\frac{(b-len+1)len}{b})\)</span> 。</p>
<p>现在出题人要在不知道 <span class="math inline">\(b\)</span> 的情况下希望上面的复杂度尽量大，选手要在不知道 <span class="math inline">\(len\)</span> 的情况下希望上面复杂度尽量小。<br />
<del>怎么感觉像博弈论</del></p>
<p>最坏的情况是 <span class="math inline">\(len = \frac{b}{2}\)</span> 的时候，此时询问的期望复杂度为 <span class="math inline">\(O(\frac{b}{4})\)</span> 。<br />
选手希望预处理和询问的复杂度最大值最小，也就是让它们相等，此时 <span class="math inline">\(b\)</span> 的最优取值大致为 <span class="math inline">\(2\sqrt{\frac{n}{q} logn}\)</span> ，<br />
这里说是“大致”，是因为为了方便计算将 <span class="math inline">\(O(log \frac{n}{b})\)</span> 看做了 <span class="math inline">\(O(logn)\)</span> 。<br />
将 <span class="math inline">\(n, q\)</span> 看做同阶的话，上述取值为 <span class="math inline">\(2\sqrt{logn}\)</span> ，此时复杂度为 <span class="math inline">\(O(\frac{n\sqrt{logn}}{2})\)</span> ，<br />
也就是 <span class="math inline">\(O(n\sqrt{logn})\)</span> ，得出结论，在询问区间非随机的情况下，该算法最优可以做到严格 <span class="math inline">\(O(n\sqrt{logn})\)</span> 。</p>
<p>关键这算法常数小，还好写，取 b 为 <span class="math inline">\(O(\sqrt{logn})\)</span> 的话，复杂度 <span class="math inline">\(O((n + q)\sqrt{logn})\)</span> 在绝大多数情况都足够了。</p>
<p>另外，此时没必要维护块内前缀后缀最大值，因为块足够小，询问的时候对零散的块暴力扫就好了，复杂度不变。</p>
<h2 id="一般性较优做法">一般性较优做法</h2>
<p>自己 yy 出来的，权当过渡吧。</p>
<p>上面提到的 <span class="math inline">\(O((n + q)\sqrt{logn})\)</span> 算法中，通过分块将问题规模缩小到了 <span class="math inline">\(\frac{n}{b}\)</span> ，<br />
然后对于这个规模的问题使用 ST 表，预处理复杂度近似看做 <span class="math inline">\(O(\frac{n}{b}logn)\)</span> 。<br />
而既然这是个子问题，为什么还要用 ST 表？能不能继续分块直到 ST 表的预处理复杂度在 <span class="math inline">\(O(n)\)</span> 以内？</p>
<p>当然是可以的，这个时候块的大小又要取多少呢？<br />
取 <span class="math inline">\(b = 2\)</span> 就够了，这个时候，相当于从底层向上建线段树，<br />
第一层有 <span class="math inline">\(n\)</span> 个节点，第二层有 <span class="math inline">\(\frac{n}{2}\)</span> 个节点，第三层有 <span class="math inline">\(\frac{n}{4}\)</span> 个节点，<br />
直到某一层只有 <span class="math inline">\(\frac{n}{logn}\)</span> 个节点时，不再向上建线段树，而是用 ST 表维护这 <span class="math inline">\(\frac{n}{logn}\)</span> 个点，<br />
这样 ST 表的预处理就是 <span class="math inline">\(O(n)\)</span> 的，而此时这个线段树的树高是 <span class="math inline">\(O(loglogn)\)</span> 的。</p>
<p>总时间复杂度 <span class="math inline">\(O(n + qloglogn)\)</span> ，事实上层数可以再少点，使得 ST 表预处理不严格 <span class="math inline">\(O(n)\)</span> 而是与询问复杂度相当，<br />
但这样的话最优的层数难以计算，在此不讨论。</p>
<h4 id="毒瘤活动-1">毒瘤活动</h4>
<p>从下向上建线段树太麻烦了，怕不是要写 zkw ，考虑从上向下建。<br />
由于最上面一层有 <span class="math inline">\(\frac{n}{logn}\)</span> 个节点，每个节点管辖的区间大小为 <span class="math inline">\(logn\)</span> ，<br />
继续考虑分块，以 <span class="math inline">\(b = logn\)</span> 为块大小分块，那么就是块内直接建满的线段树，块间维护 ST 表。</p>
<p><del>卧槽怎么又回到前面的做法了</del></p>
<p>那么这个算法事实上就是通过线段树保证了块间查询严格 <span class="math inline">\(logb\)</span> ，也就是 <span class="math inline">\(loglogn\)</span> 。</p>
<p>既然这样，为什么一定要用线段树呢？在每个块内依然维护 ST 表，复杂度就是 <span class="math inline">\(O(nloglogn + q)\)</span> 。</p>
<p>通过上面的各种讨论，相信读者已经明白分块 RMQ 的强大，以及线段树和 ST 表（尤其是后者）在 RMQ 的重要性。<br />
分块什么这么多东西目的基本就是去平衡 ST 表 / 线段树的询问和预处理的复杂度。</p>
<p>update: 后来知道这玩意叫四个俄罗斯人算法 (Four Russian) 。</p>
<h2 id="一般性标准做法">一般性标准做法</h2>
<p>标准的 <span class="math inline">\(O(n + q)\)</span> RMQ 。</p>
<p>离线的话可以建笛卡尔树将 RMQ 转换为 LCA ，然后用 Tarjan 处理。<br />
明显的缺点是离线，并且空间开销较大。</p>
<p>在线的话，有一个经典的常用做法，还是建笛卡尔树转 LCA ，然后求出树的欧拉序转为 +-1 RMQ 。<br />
而 +-1 RMQ 也是通过分块实现 <span class="math inline">\(O(n + q)\)</span> 复杂度的，<br />
利用的是 +-1 RMQ 的差分数组在每个块内只有 <span class="math inline">\(2^b\)</span> 中可能，其中 <span class="math inline">\(b\)</span> 是块大小，取 <span class="math inline">\(logn\)</span> 。<br />
整个过程较为复杂，在 OI 中实用性较低，具体做法留个坑，到时候再补。</p>
<p>这里重点介绍另一个同样能做到在线 + 线性的 RMQ 算法，并且相对于上面的做法更简单，常数也更优秀。</p>
<h4 id="线性-rmq">线性 RMQ</h4>
<p>该算法改进自之前在随机数据下的分块 RMQ ，<br />
注意到当块大小为 <span class="math inline">\(O(logn)\)</span> 时，该算法唯一的瓶颈在于询问端点在同一个块内时需要暴力 <span class="math inline">\(O(logn)\)</span> 扫。<br />
单独考虑每个块，考虑优化询问端点在该块的情况。<br />
其中块大小为 <span class="math inline">\(b = O(logn)\)</span> 。</p>
<p>利用之前提到的单调队列做法，如果对于每个点暴力存下块的左端点到该点的单调递减队列，<br />
那么对于询问 [l, r] ，拿出 r 上的单调队列，在单调队列上找到第一个不小于 l 的位置，该位置上的值即区间最大值。<br />
由于单调队列的大小是 <span class="math inline">\(O(b)\)</span> 即 <span class="math inline">\(O(logn)\)</span> 的，该做法复杂度 <span class="math inline">\(O((n + q)logn)\)</span> 。</p>
<p>但是该做法有很大优化空间，由于 <span class="math inline">\(b\)</span> 足够小（一般认为它不超过字长 <span class="math inline">\(w\)</span> ），完全可以将每个点的单调队列状压，<br />
这样预处理的时空复杂度就降到了 <span class="math inline">\(O(n)\)</span> 。<br />
然后对于询问一个单调队列上第一个不小于 l 的位置，就是在一个二进制数 <span class="math inline">\(x\)</span> 上询问第一个位数不小于 l 的 1 的位数。<br />
这通过位运算和内置函数可以很好实现，只需将 <span class="math inline">\(x\)</span> 右移 <span class="math inline">\(l mod b\)</span> 位来去掉单调队列上小于 l 的位置，<br />
然后通过 <code>__builtin_ctz</code> <span class="math inline">\(O(1)\)</span> 找到第一个 1 的位置即可。<br />
这样询问的复杂度就降到了 <span class="math inline">\(O(1)\)</span> ，总复杂度 <span class="math inline">\(O(n + q)\)</span> ，常数非常优秀。</p>
<h4 id="完整实现">完整实现</h4>
<p>以 bzoj1699 为例，该题的 rank1 就是用了这个线性 RMQ 做法，本人常数大，但还是狗到了 rank6 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> io &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> SIZE = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - <span class="number">1</span>, c, qu[<span class="number">55</span>]; <span class="keyword">int</span> f, qr, flg;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        fwrite (obuf, <span class="number">1</span>, <span class="keyword">size_t</span>(oS - obuf), <span class="built_in">stdout</span>);</span><br><span class="line">       oS = obuf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span> <span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        *oS ++ = x;</span><br><span class="line">       <span class="keyword">if</span> (oS == oT) flush ();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">int</span> <span class="title">gi</span> (<span class="title">I</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">     <span class="keyword">for</span> (f = <span class="number">1</span>, c = gc(); c != EOF &amp;&amp; (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>); c = gc()) <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">for</span> (flg = x = <span class="number">0</span>; c != EOF &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>; c = gc()) flg = <span class="number">1</span>, x = x * <span class="number">10</span> + (c &amp; <span class="number">15</span>); x *= f;</span><br><span class="line">      <span class="keyword">return</span> flg || c != EOF;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span> (<span class="title">I</span> <span class="title">x</span>) &#123;</span></span><br><span class="line">      <span class="keyword">if</span> (!x) pc (<span class="string">&#x27;0&#x27;</span>); <span class="keyword">if</span> (x &lt; <span class="number">0</span>) pc (<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">       <span class="keyword">while</span> (x) qu[++ qr] = x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>,  x /= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span> (qr) pc (qu[qr --]);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Flusher_</span> &#123;</span>~Flusher_()&#123;flush();&#125;&#125;io_flusher_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> io::gi(x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>, maxs = <span class="number">20005</span>, maxb = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + maxb];</span><br><span class="line"><span class="keyword">int</span> highbit[maxs];</span><br><span class="line"><span class="keyword">int</span> stmax[maxs][maxb], stmin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> premax[maxs][maxb], premin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> sufmax[maxs][maxb], sufmin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> quemax[maxs][maxb], quemin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> stackmax[maxb], stackmin[maxb];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(y &gt; x) x = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(y &lt; x) x = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n = read, q = read;</span><br><span class="line">  <span class="keyword">int</span> B = <span class="keyword">int</span>(log2(n));</span><br><span class="line">   <span class="keyword">int</span> S = (n - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; S; b ++)</span><br><span class="line">      stmin[b][<span class="number">0</span>] = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">       a[i] = read;</span><br><span class="line">      chkmin(stmin[i / B][<span class="number">0</span>], a[i]);</span><br><span class="line">        chkmax(stmax[i / B][<span class="number">0</span>], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> b = S - <span class="number">1</span>; b &gt;= <span class="number">0</span>; b --)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; b + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt; S; k ++) &#123;</span><br><span class="line">          stmin[b][k] = min(stmin[b][k - <span class="number">1</span>], stmin[b + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k - <span class="number">1</span>]);</span><br><span class="line">           stmax[b][k] = max(stmax[b][k - <span class="number">1</span>], stmax[b + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; S; b ++) &#123;</span><br><span class="line">       <span class="keyword">int</span> be = b * B;</span><br><span class="line">      premin[b][<span class="number">0</span>] = premax[b][<span class="number">0</span>] = a[be];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; B; k ++) &#123;</span><br><span class="line">           premin[b][k] = min(premin[b][k - <span class="number">1</span>], a[be + k]);</span><br><span class="line">          premax[b][k] = max(premax[b][k - <span class="number">1</span>], a[be + k]);</span><br><span class="line">      &#125;</span><br><span class="line">        sufmin[b][B - <span class="number">1</span>] = sufmax[b][B - <span class="number">1</span>] = a[be + B - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = B - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k --) &#123;</span><br><span class="line">          sufmin[b][k] = min(sufmin[b][k + <span class="number">1</span>], a[be + k]);</span><br><span class="line">          sufmax[b][k] = max(sufmax[b][k + <span class="number">1</span>], a[be + k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; S; b ++) &#123;</span><br><span class="line">       <span class="keyword">int</span> be = b * B;</span><br><span class="line">      <span class="keyword">int</span> spmin = <span class="number">0</span>, nowmin = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> spmax = <span class="number">0</span>, nowmax = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B; i ++) &#123;</span><br><span class="line">           <span class="keyword">while</span>(spmin <span class="keyword">and</span> a[be + stackmin[spmin]] &gt; a[be + i])</span><br><span class="line">             nowmin ^= <span class="number">1</span> &lt;&lt; stackmin[spmin --];</span><br><span class="line">          <span class="keyword">while</span>(spmax <span class="keyword">and</span> a[be + stackmax[spmax]] &lt; a[be + i])</span><br><span class="line">             nowmax ^= <span class="number">1</span> &lt;&lt; stackmax[spmax --];</span><br><span class="line">          quemin[b][i] = (nowmin ^= <span class="number">1</span> &lt;&lt; (stackmin[++ spmin] = i));</span><br><span class="line">           quemax[b][i] = (nowmax ^= <span class="number">1</span> &lt;&lt; (stackmax[++ spmax] = i));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= S; i ++)</span><br><span class="line">     highbit[i] = highbit[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(q --) &#123;</span><br><span class="line">       <span class="keyword">int</span> l = read - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = read - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> L = l / B, R = r / B;</span><br><span class="line">        <span class="keyword">int</span> li = l % B, ri = r % B;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1000000000</span>, max = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(L == R) &#123;</span><br><span class="line">            chkmin(min, a[l + __builtin_ctz(quemin[R][ri] &gt;&gt; li)]);</span><br><span class="line">         chkmax(max, a[l + __builtin_ctz(quemax[R][ri] &gt;&gt; li)]);</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          chkmin(min, sufmin[L][li]);</span><br><span class="line">           chkmin(min, premin[R][ri]);</span><br><span class="line">           chkmax(max, sufmax[L][li]);</span><br><span class="line">           chkmax(max, premax[R][ri]);</span><br><span class="line">           <span class="keyword">int</span> len = R - L - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">int</span> k = highbit[len];</span><br><span class="line">            <span class="keyword">if</span>(len) &#123;</span><br><span class="line">               chkmin(min, stmin[L + <span class="number">1</span>][k]);</span><br><span class="line">             chkmin(min, stmin[R - (<span class="number">1</span> &lt;&lt; k)][k]);</span><br><span class="line">                chkmax(max, stmax[L + <span class="number">1</span>][k]);</span><br><span class="line">             chkmax(max, stmax[R - (<span class="number">1</span> &lt;&lt; k)][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* printf(&quot;%d\n&quot;, max - min); */</span></span><br><span class="line">       io::print(max - min);</span><br><span class="line">     io::pc(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>O(1)</tag>
        <tag>RMQ</tag>
        <tag>分块</tag>
        <tag>线段树</tag>
        <tag>ST 表</tag>
        <tag>算法扩展</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>O(1)黑科技</title>
    <url>/2019/10/10/O(1)%E9%BB%91%E7%A7%91%E6%8A%80/</url>
    <content><![CDATA[<p><span class="citation" data-cites="CYJian">@CYJian</span> 出了一道黑科技二合一，我就顺便跟着学了学。</p>
<h2 id="o1-gcd">O(1) gcd</h2>
<p>在 O(V) 的预处理后可以做到 O(1) 查询 gcd ，其中 V 是权值的大小。</p>
<p>主要利用到的一个性质是可以将任意 x 分解为三个数 a * b * c ， a, b, c 分别满足以下两个条件之一：</p>
<ol type="1">
<li>不超过 <span class="math inline">\(\sqrt{x}\)</span> 。</li>
<li>是质数。</li>
</ol>
<p>update: 之前写假了，感谢 <span class="citation" data-cites="CYJian">@CYJian</span> 的 hack 。</p>
<p>zzq 把满足这个性质的分解称为“迷之分解”，那我也这么叫吧。</p>
<p>考虑证明一下，顺便构造一个“迷之分解”。</p>
<p>找到 x 的最小质因子 p ，然后假设已知 x / p 的“迷之分解” A, B, C (A &lt;= B &lt;= C) 。<br />
那么把 p 乘到 A 上就可以得到 x 的“迷之分解” A * p, B, C 。<br />
分类讨论，如果 p 不超过 <span class="math inline">\(\sqrt[4]{x}\)</span> ，由于 A 是 A, B, C 三者中最小的，<br />
一定满足 A 不超过 <span class="math inline">\(\sqrt[3]{x/p}\)</span> ，那么可得：</p>
<p><span class="math display">\[A \cdot p \leq \sqrt[3]{x/p} \cdot p = \sqrt[3]{xp^2} \leq \sqrt{x}\]</span></p>
<p>而如果 p 超过 <span class="math inline">\(\sqrt[4]{x}\)</span> ，由于 p 是最小质因子，<br />
那么如果 x 的“迷之分解”有合数 C ， C 至少是 <span class="math inline">\(p^2\)</span> ，超过 <span class="math inline">\(\sqrt{x}\)</span> ，<br />
那么 B 的大小就会比 p 小，与 p 是最小质因子矛盾，<br />
因而此时 x 的“迷之分解”全是质数。</p>
<p>“迷之分解”的分析就是这样，通过线性筛可以很好预处理出 O(V) 内的所有数的“迷之分解”。<br />
只需筛出每个数的最小质因子即可按上述方法递推出“迷之分解”。<br />
然后只需预处理出 <span class="math inline">\(O(\sqrt{V})\)</span> 内两两的 gcd ，为了不带 log ，需要递推预处理。<br />
此时求 gcd(x, y) 只需对于 x 的“迷之分解” A, B, C 依次对 y 求 gcd （每次求 gcd 后把 y 除以该 gcd ），<br />
以 A 为例，如果 A 不超过 <span class="math inline">\(\sqrt{x}\)</span> ，直接查表可以得到 gcd(A, y) （查的是 gcd(A mod y, A) ），<br />
否则 A 为质数，简单讨论一下就可以得到 gcd(A, y) 了。</p>
<p>关键部分参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> magic[maxv][<span class="number">3</span>]; <span class="comment">// 每个数的“迷之分解”</span></span><br><span class="line"><span class="keyword">int</span> gcd[maxb][maxb]; <span class="comment">// 预处理的 gcd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">       <span class="keyword">int</span> X = magic[x][i];</span><br><span class="line">     <span class="keyword">int</span> d;</span><br><span class="line">       <span class="keyword">if</span>(X &lt; maxb)</span><br><span class="line">          d = gcd[X][y % X];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y % X)</span><br><span class="line">          d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         d = X;</span><br><span class="line">        res *= d;</span><br><span class="line">     y /= d;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="o1-快速幂">O(1) 快速幂</h2>
<p>在 <span class="math inline">\(O(\sqrt{p})\)</span> 的预处理后可以做到对于一个固定的底数 O(1) 查询快速幂，<br />
其中 p 是模数（或者上式是 <span class="math inline">\(\sqrt{\phi(p)}\)</span> ），或者是指数的范围。</p>
<p>这个就简单得多，对于每个 <span class="math inline">\(a^k\)</span> 的指数 k 都可以表示为 <span class="math inline">\(a \sqrt{p} + b\)</span> 的形式，<br />
满足 <span class="math inline">\(a, b &lt; \sqrt{p}\)</span> ，分别预处理即可，<br />
即预处理 <span class="math inline">\(a^0, a^1, a^2 ... a^{\sqrt{p}}, a^{2\sqrt{p}}, a^{3\sqrt{p}} ... a^p\)</span> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>gcd/lcm</tag>
        <tag>快速幂</tag>
        <tag>黑科技</tag>
        <tag>O(1)</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分</title>
    <url>/2019/10/10/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>不久前学了整体二分，做了几道题，还在考试上派上用场过几次。<br />
觉得自己大概懂了整体二分，直到一次碰上了强制在线的毒瘤题。。。</p>
<p><del>整体二分：从离线到强制在线</del></p>
<h2 id="基础">基础</h2>
<p>大概讲讲整体二分吧。</p>
<p>整体二分大概用于这样一个场景：<br />
有多组询问，每个询问可以二分，但是每个询问二分的时间不能接受，<br />
而不同询问的二分有共同点，这时就可以用整体二分把多个询问一起二分。<br />
所以这是个离线算法。</p>
<a id="more"></a>
<p>流程大概是这样的：<br />
对于当前确定的区间 [L, R] ，取 M 为区间中点，<br />
对于当前在确定在这个区间的每个询问进行 check ，<br />
然后判断每个询问接下来是到 [L, M] 还是 [M + 1, R] 。<br />
当 L = R 时，就得到了处理到这个区间的询问的答案。</p>
<p>每个询问还是进行了 O(logV) 次 check ，<br />
但是和直接二分不同的是，一般在每个区间内进行预处理后 check 可以做到 O(1) 或者 O(logn) 等，<br />
一般需要数据结构维护（常见的有并查集，树状数组，线段树）。</p>
<h2 id="栗子">栗子</h2>
<p>就说静态区间第 k 大吧，当然可以用主席树搞，但是此处讨论整体二分。</p>
<p>对于每个询问 [l, r] ，可以二分答案 x ，<br />
然后 check 不超过 x 的数量，与 k 进行比较即可得出接下来该询问的答案区间。</p>
<p>直接 check 是 O(V) 的，当然可以直接用数据结构维护，但是此处讨论整体二分。</p>
<p>当前的答案区间是 [L, R] ，有若干询问的答案已经确定在这个区间内，<br />
取中点 M ，维护值在 [L, M] 的每个数，对于每个询问就可以 O(logn) check 了，<br />
然后如果询问 k 的答案在 [M + 1, R] ，那么 k 要减去当前 check 的值，以消去 [L, M] 的影响。<br />
另外处理后要清空 [L, M] 的影响。</p>
<p>这样做复杂度是 <span class="math inline">\(O(q logV logn)\)</span> 的。</p>
<p>另一个实现是维护值在 [1, M] 的每个数，<br />
二分到 [L, M] 前先把 [L, M] 的影响撤销掉，<br />
二分到 [M + 1, R] 前只需在二分 [L, M] 时保证算上了 [L, M] 的贡献即可。<br />
这样做的好处是避开了删除，有些用并查集的操作就可以实现了。</p>
<p>这样做复杂度同样是 <span class="math inline">\(O(q logV logn)\)</span> 的。</p>
<h2 id="带修">带修</h2>
<p>就说带修区间第 k 大。</p>
<p>将修改和查询统称为操作，只需保证操作在二分中的相对顺序，<br />
处理答案在 [L, R] 的区间时按顺序做，碰到修改就修改，碰到查询就 check 。<br />
但是修改哪来的答案？对于修改操作，只需将它放到它能影响的答案区间即可。<br />
例如修改 <span class="math inline">\(a_i = x\)</span> ，分为两个操作：删除 <span class="math inline">\(a_i\)</span> 和添加 <span class="math inline">\(a_i = x\)</span> 。<br />
前者的影响的区间需要包括 <span class="math inline">\(a_i\)</span> ，后者影响的区间需要包括 <span class="math inline">\(x\)</span> 。</p>
<p>同样有两个实现，复杂度都是 <span class="math inline">\(O(q logV logn)\)</span> 。</p>
<h2 id="在线">在线</h2>
<p>毒瘤的地方来了，整体二分做强制在线。<br />
这也是本文的真正讨论重点。</p>
<p>还是拿静态区间第 k 大分别讨论上述的两种实现。</p>
<h3 id="实现-1">实现 1</h3>
<p>单独考虑一个询问 q ，观察它在整体二分中答案区间的移动过程。<br />
假设当前二分到区间 [L, R] ，<br />
q 能在整体二分中 O(logn) check 是因为权值在 [L, R] 的数被维护进了一个数据结构。<br />
那如果 q 到达的所有可能答案区间的数据结构都提前构造好了，<br />
q 就不需要整体二分，而可以直接在线询问。</p>
<p>而所有可能的答案区间事实上形成了一个线段树的结构。<br />
上面已经说到要求每个可能的答案区间的数据结构已经提前维护。<br />
对应在线段树中就是线段树的每个节点都有数据结构维护该节点对应的答案区间。<br />
在本题中就是要权值线段树套区间树状数组，<br />
而为了节省空间开销，需要换成权值线段树套区间线段树。<br />
这样把每个数先按取值找到对应的外层线段树，再按位置加到对应的内层线段树，<br />
每个询问 (l, r, k) 就在外层线段树上二分，在内层线段树查询区间 [l, r] 的数的个数。</p>
<p>时间复杂度依然是 <span class="math inline">\(O(q logV logn)\)</span> 的，但是空间复杂度为 <span class="math inline">\(O(V + n logV logn)\)</span> 。</p>
<p>不难推广到更一般的情况，所有不带修的<strong>整体二分实现 1 + 数据结构 A</strong>， 都可以用<strong>线段树套数据结构 A</strong> 做到在线询问。<br />
时间复杂度不变，但是空间开销会乘上 <span class="math inline">\(O(n)\)</span> ，<br />
而当<strong>数据结构 A</strong> 支持动态开空间，即空间开销与修改次数 <span class="math inline">\(q\)</span> 成函数关系 <span class="math inline">\(O(qk)\)</span> 时，<br />
这样就只会带来 <span class="math inline">\(O(n logV k)\)</span> 的额外空间开销。</p>
<p>另外，这是可以支持带修的，对于修改操作，在线段树上找到影响的节点，<br />
然后直接去修改节点上的<strong>数据结构 A</strong> 即可。</p>
<h3 id="实现-2">实现 2</h3>
<p>还是单独考虑一个询问 q ，此时它在整体二分中答案区间的移动过程固然还是线段树的形式。<br />
但是不同的是，此时线段树的每个节点 [L, R] 需要保存维护 [1, R] 的数据结构，<br />
换言之，不同节点之间相互不独立。<br />
但既然所有需要的数据结构都是维护 [1, K] 这样的前缀形式，<br />
不难想到可持久化，每个维护 [1, K] 的数据结构在维护 [1, K - 1] 的数据结构上修改即可。</p>
<p>具体到静态区间第 k 大，按权值递增的顺序建可持久化区间线段树（树状数组难以可持久化）。<br />
对于每个询问 (l, r, k) 二分答案 x 时只需要在第 x 颗区间线段树上查询 [l, r] 的数的个数。</p>
<p>时间复杂度自然还是 <span class="math inline">\(O(q logV logn)\)</span> 的，空间复杂度为 <span class="math inline">\(O(V + n logn)\)</span> 。</p>
<p>同样可以推广到更一般的情况，所有不带修的<strong>整体二分实现 2 + 数据结构 A</strong>， 都可以用<strong>可持久化数据结构 A</strong> 做到在线询问。<br />
在可持久没有额外时间开销的前提下，时间复杂度不变，<br />
否则若可持久化会带来 <span class="math inline">\(O(k)\)</span> 的额外时间复杂度，这样做的时间复杂度同样需要乘上 <span class="math inline">\(O(k)\)</span> 。<br />
可持久化并查集就是个典型的例子。<br />
同样空间复杂度也要乘上可持久化带来的额外开销。</p>
<p>可惜的是，这不能很好的支持修改，因为每个修改影响到的历史版本是 <span class="math inline">\(O(V)\)</span> 级别的。</p>
<h2 id="总结">总结</h2>
<p>事实上做到在线后，干脆抛弃了整体二分的“整体查询”的思想，其实就和整体二分没什么关系了。<br />
那么整体二分究竟是个什么玩意？<br />
事实上绝大多数整体二分都无法做到比直接数据结构的时间复杂度优秀，<br />
而且经过上述的讨论不难发现绝大多数整体二分都能直接被数据结构替代，<br />
也因此整体二分往往被归在“骗分”，“非正解”一类。</p>
<p>不过整体二分明显的优势在于空间复杂度和实现难度。 不过有时经过整体二分的转换后，就可以使用无法可持久化，或者空间开销大的数据结构，<br />
上面的树状数组就是很好的例子，无论是实现 1 还是实现 2 ，做到在线都必须换成线段树。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法扩展</tag>
        <tag>二分</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>整除分块</title>
    <url>/2019/10/10/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>（以下的除号皆表示整除）</p>
<p>用数论函数计算的时候，总会遇到这样一种问题： <span class="math inline">\(\sum_{i=1}^n f(\frac{n}{i})\)</span> 。 <span class="math inline">\(O(n)\)</span> 求往往无法满足需要。</p>
<p>但是<del>打表</del>可以发现， n/i 的取值对于一段连续的 i 是一致的， 那么可以考虑一块一块求。</p>
<p>设已知当前块的左端点为 l ，如果知道右端点 r（左闭右开），意味着 <span class="math inline">\(\forall l&lt;=i&lt;r, \frac{n}{i} = \frac{n}{l}\)</span> ， 这一块对答案的贡献就是 <span class="math inline">\((r-l) \times f(\frac{n}{l})\)</span> 。</p>
<p>结论是 <span class="math inline">\(r = n / (n / l) + 1\)</span> 。</p>
<p>证明：</p>
<ul>
<li>对于 l 设 <span class="math inline">\(n / l = x\)</span></li>
<li>那么由 <span class="math inline">\(n \bmod l = n - n / l \cdot l = n - l \cdot x\)</span> 可知 $ n - l x  $</li>
<li>那么若 <span class="math inline">\(l + 1\)</span> 满足 <span class="math inline">\(n / (l + 1) = n / l\)</span> ，可知也有 <span class="math inline">\(n - (l + 1) \cdot x \geq 0\)</span></li>
<li>即 <span class="math inline">\(n - l \cdot x \geq x\)</span></li>
<li>对于 k 若 <span class="math inline">\(n / k = n / l\)</span> 而 <span class="math inline">\(n / (k + 1) != n / l\)</span></li>
<li>那么根据上式可得 k 满足 $ 0 n - k x &lt; x$</li>
<li>所以 <span class="math inline">\(n - k \cdot x = n \bmod x = n - n / x \cdot x\)</span></li>
<li>所以 <span class="math inline">\(k = n / x = n / (n / l)\)</span></li>
<li>由 k 的定义 <span class="math inline">\(n / k = n / l \&amp; n / (k + 1) != n / l\)</span> 可知 k+1 即是要求的 r</li>
</ul>
<p>那么可以枚举块，当前 l,r 可以求得，下一个块的 l 显然是当前 r。</p>
<p>有时候会有点变化：</p>
<p>要求 <span class="math inline">\(\sum_{i=1}^{min(n, m)} f(\frac{n}{i}) \cdot f(\frac{m}{i})\)</span> 。</p>
<p>还是会存在 <span class="math inline">\(\forall l \le i &lt; r, \frac{n}{i} = \frac{n}{l} \&amp; \frac{m}{i} = \frac{m}{l}\)</span> 。</p>
<p>所以这样的区间的右端点为：<span class="math inline">\(r = min(n / (n / l), m / (m / l)) + 1\)</span> 。</p>
<p>所以还是可以一块一块的枚举求和。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>类欧几里得</title>
    <url>/2019/10/10/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    <content><![CDATA[<p>这里只是类欧几里得的一种：<br />
快速求下式： <span class="math display">\[f(a, b, c, n) = \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor\]</span></p>
<p>其中 a, b, c, n 都是正整数。</p>
<h2 id="缩小-a-b-规模">缩小 a, b 规模</h2>
<p>首先的目标是让 a, b 小于 c 。</p>
<p>结论 1 ：<br />
<span class="math display">\[\lfloor \frac{Ax+B}{y} \rfloor =
\lfloor \frac{A(x\%y)+B}{y} \rfloor + A\lfloor \frac{x}{y} \rfloor\]</span></p>
<p>证明：<br />
首先用到整除与取模的转换： <span class="math inline">\(\lfloor \frac{x}{y} \rfloor = \frac{x-x\%y}{y}\)</span> 。<br />
得到原命题等价于：<br />
<span class="math display">\[\frac{Ax+B-(Ax+B)\%y}{y} =
\frac{A(x\%y)+B-(Ax+B)\%y}{y} + A\frac{x-x\%y}{y}\]</span> <span class="math display">\[Ax + B - (Ax+B)\%y = A(x\%y) + B - (Ax+B)\%y + A(x-x\%y)\]</span> <span class="math display">\[Ax - (Ax+B)\%y = A(x\%y) - (Ax+B)\%y + A(x-x\%y)\]</span> <span class="math display">\[Ax = A(x\%y) + A(x-x\%y)\]</span> <span class="math display">\[Ax = A(x\%y) + Ax - A(x\%y)\]</span><br />
得证。</p>
<p>那么通过这个结论可以得知：<br />
<span class="math display">\[
\begin{equation}
\begin{aligned}
f(a, b, c, n) &amp;= \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\\\
&amp;= \sum_{i=0}^n (\lfloor \frac{(a\%c)i+b\%c}{c} \rfloor +
i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor) \\\\
&amp;= f(a\%c, b\%c, c, n) + \sum_{i=0}^n (
i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor) \\\\
\end{aligned}
\end{equation}
\]</span></p>
<p>后面那一段就是一个等差数列求和，于是 a, b 被转换为小于 c 。</p>
<h2 id="转换成子问题减小规模">转换成子问题减小规模</h2>
<p>整除除了用取模代替外，还有一种方法。</p>
<p>结论 2 ：<br />
<span class="math display">\[\lfloor \frac{x}{y} \rfloor = \sum_{i=1}^{MAX} [i \leq \frac{x}{y}]\]</span><br />
其中 MAX 是任意一个足够大的值。<br />
证明？相当于从 1 开始数，感性理解即可。</p>
<p>那么通过这个结论可以得知：<br />
<span class="math display">\[
\begin{equation}
\begin{aligned}
f(a, b, c, n) &amp;= \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\\\
&amp;= \sum_{i=0}^n \sum_{j=1}^{(an+b)/c} [j \leq \frac{ai+b}{c}] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [j + 1 \leq \frac{ai+b}{c}] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [cj + c \leq ai+b] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [cj + c - 1 &lt; ai+b] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [\frac{cj+c-b-1}{a} &lt; i] \\\\
&amp;= \sum_{j=0}^{(an+b)/c-1} \sum_{i=0}^n [\frac{cj+c-b-1}{a} &lt; i] \\\\
&amp;= \sum_{j=0}^{(an+b)/c-1}
(n + 1 - \sum_{i=0}^n [i \leq \frac{cj+c-b-1}{a}]) \\\\
&amp;= \sum_{j=0}^{(an+b)/c-1}
(n - \lfloor \frac{cj+c-b-1}{a} \rfloor) \\\\
&amp;= n \lfloor \frac{an+b}{c} \rfloor -
\sum_{j=0}^{(an+b)/c-1} (\lfloor \frac{cj+c-b-1}{a} \rfloor) \\\\
&amp;= n \lfloor \frac{an+b}{c} \rfloor - f(c, c-b-1, a, (an+b)/c-1)
\end{aligned}
\end{equation}
\]</span></p>
<p>那么就得到了一个递归计算 f(a, b, c, n) 的算法，<br />
a = 0 时上式不成立，因为上面的推导有除以 a 的步骤。<br />
因此将 a = 0 作为终止状态，此时 f 的计算是常数数列求和。<br />
复杂度是对数复杂度 log(a)，因为上面的过程规模的减小速度相当于 gcd 。</p>
<h2 id="数形结合">数形结合</h2>
<p>复习的时候看到这么多式子头都大了，但是这个类欧事实上就是数一个三角形内的整点数，第一步很好理解，第二步本质上就是把坐标轴翻转了一下然后用一个正方形的点数减去一个三角形的点数（事实上可以不用这个补集转换），很快就可以得到同样的结论，可以避免冗长的纯式子推导。</p>
<p>放在二维平面上，第一步的本质就是把斜率固定在小于 1 的数，第二步的本质就是翻转坐标轴，翻转后斜率会变为原来的倒数，于是会超过 1 。这样反复进行就可以逐渐数完三角形内的所有整点。</p>
<p>UPD: 准确来说不是三角形，是梯形，但显然两者可以相互转换。</p>
<p>但是更复杂的类欧这个数形结合好像就不管用了，还是得用数学推导。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树分治</title>
    <url>/2019/10/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="作用">作用</h2>
<p>线段树通过维护序列，可以维护一个承载各种操作的时间轴。</p>
<p>通常用于辅助一些不支持删除操作的数据结构（线性基，并查集），<br />
这种情况可以用线段树分治维护操作影响的时间来巧妙地避开删除。</p>
<h2 id="线段树结构">线段树结构</h2>
<p>线段树分治用到的线段树（以下简称线段树）是以询问的时间为键值，<br />
没有权值只有标记的线段树。</p>
<p>也就是线段树的一段区间对应的是一段询问（一段时间）。</p>
<p>这样的线段树只需要支持区间修改（打标记）。<br />
每一个操作都会影响一段时间，对应于线段树的区间修改。</p>
<h2 id="例题">例题</h2>
<p>这玩意需要一个例题才讲的清。<br />
（由于线段树分治用于辅助其他数据结构，再看例题前得先会线性基）</p>
<p>维护一个集合，每次操作可以加入一个数或删除一个已经存在与集合的数。<br />
每次操作后要回答这个集合的最大异或和。<br />
操作次数 1e5 。</p>
<h3 id="暴力线性基">暴力线性基</h3>
<p>如果只有插入没有删除，这题就是一遍线性基。</p>
<p>但是不巧线性基不支持删除，所以只能在每次删除后重构线性基。<br />
复杂度平方带对数，稳 T 。</p>
<h3 id="时间轴">时间轴</h3>
<p>将每次操作看做时间点，假设数 x 在时刻 l 被插入， r 被删除，<br />
那么 x 只存在于 [l, r) 这段时间，<br />
假如每个时刻开一个线性基，那么将 x 插入 [l, r) 的每个线性基，<br />
这样就可以在最后通过线性基询问得到每个时刻的答案，<br />
复杂度还是平方带对数，稳 T 的离线算法。</p>
<h3 id="线段树优化">线段树优化</h3>
<p>比较上述两种算法，<br />
第一种复杂度瓶颈在于重构线性基，实在是没有什么优化空间，<br />
但是第二种算法中，复杂度瓶颈在于将 x 插入到 [l, r) 的每个线性基，<br />
这个操作相当于一个区间修改，可以用线段树优化。</p>
<p>那么一个优秀的算法就出来了：<br />
线段树每个节点维护一个 vector （相当于懒标记），插入 x 将直接加在线段树对应区间的 vector　内。<br />
所有操作过后会得到一个只有懒标记的线段树，<br />
然后考虑如何通过这样一颗线段树得出所有答案。</p>
<h4 id="处理懒标记">处理懒标记</h4>
<p>懒标记下传？<br />
不存在的，因为懒标记是一个 vector, 下传的复杂度并不是 O(1) ，<br />
不难验证下传所有懒标记会使复杂度重回 n 方。</p>
<p>既然不能下传，那就进行 n 次单点查询？<br />
一个道理，单点查询的复杂度并不是 log(n), 这样做同样对复杂度没有优化。</p>
<p><del>那就没救了</del></p>
<h4 id="分治">分治</h4>
<p>线段树分治，不能只有线段树，还要分治啊。</p>
<p>现在需要只把每个懒标记访问一遍就得出所有答案。</p>
<p>dfs 整颗线段树（实际上就是分治），深度是 log 级别的，那么对每一个深度开一个线性基。<br />
如能能让 dfs 每个节点时该深度线性基维护的是这个节点到根的所有懒标记，<br />
最后 dfs 到每个叶子节点就可以得到该叶子节点到根的懒标记的线性基，也就可以求出这个叶子节点的答案。</p>
<p>假设当前 dfs 到 u, 深度为 d, 深度对应的线性基已经是维护其到根的懒标记。<br />
dfs 到一个新点 v 一定会使深度 + 1 ，将当前深度 d 的线性基拷贝到下个深度 d + 1 中。<br />
那么 dfs 到 v 后再将 v 的懒标记加到 d + 1 的线性基中，d + 1 的线性基也就满足了要求。<br />
通过这样的过程就能够做到只访问每个懒标记一遍。</p>
<p>这就是线段树分治了。</p>
<h2 id="真---例题">真 - 例题</h2>
<p>这两道题就没有这么裸了。</p>
<p><a href="https://www.luogu.org/problemnew/show/P3733">洛谷八纵八横</a> （线段树分治 + 线性基）</p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4025">BZOJ 二分图</a> （线段树分治 + 并查集）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合数公式</title>
    <url>/2019/10/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>$ C_n^m $ 在组合数学中的意义：在 n 个元素选 m 个元素的方案数。</p>
<h2 id="公式">公式</h2>
<h3 id="公式-1">公式 1</h3>
<p><span class="math display">\[ C_n^m = \frac{n!}{m! * (n-m)!} \]</span></p>
<p>组合数的通项公式。</p>
<p><strong>当要求组合数模一般模数时</strong> ，通项公式的分母可能没有逆元导致不可行。</p>
<h3 id="公式-2">公式 2</h3>
<p><span class="math display">\[ C_n^m = C_n^{n-m} \]</span></p>
<p>基本性质，可以由通项公式得出。</p>
<h3 id="公式-3">公式 3</h3>
<p><span class="math display">\[ C_n^m * C_m^k = C_n^k * C_{n-k}^{m-k} \]</span></p>
<h3 id="公式-4">公式 4</h3>
<p><span class="math display">\[ C_n^m = C_{n-1}^{m-1} + C_{n-1}^m \]</span></p>
<p>组合数的基本递推式。</p>
<p><strong>当要求组合数模一般模数时</strong> ，常用这种方法预处理组合数。</p>
<h3 id="公式-5">公式 5</h3>
<p><span class="math display">\[ \sum_{i=0}^n C_n^i = 2^n \]</span></p>
<p>组合意义： n 个元素选任意元素的方案数。 每个数都可以选或不选，所以方案数为 $ 2^n $ 。</p>
<p>同样可以由二项式定理： $ (x + 1)^n = _{i=0}^n C_n^i * x^i $ 得出。</p>
<h3 id="公式-6">公式 6</h3>
<p><span class="math display">\[ \sum_{i=0}^n (C_n^i)^2 = C_{2n}^n \]</span></p>
<h3 id="公式-7">公式 7</h3>
<p><span class="math display">\[ C_{n+m}^k = \sum_{i=0}^k C_n^i * C_m^{k-i} \]</span></p>
<p>从组合数学上的定义出发，在 n + m 个元素中选 k 个， 相当于先在前 n 个元素中选 i 个再在后 m 个元素中选 k - i 个。 枚举这个 i 把方案数相加就能得到最终方案数。</p>
<h3 id="公式-8">公式 8</h3>
<p><span class="math display">\[ \sum_{i=0}^n C_{k+i}^k = C_{k+n+1}^n \]</span></p>
<p>进一步可以得到下式：</p>
<p><span class="math display">\[ \sum_{i=0}^n \sum_{j=0}^m C_{i+j}^i = C_{n+m+2}^{m+1} - 1 \]</span></p>
<p>类似的还有：</p>
<p><span class="math display">\[ \sum_{i=0}^n C_{i}^k = C_{n+1}^{k+1} \]</span></p>
<h3 id="lucas-定理">Lucas 定理</h3>
<p><span class="math display">\[ C_n^m \% p = C_{n/p}^{m/p} * C_{n \% p}^{m \% p} \% p \]</span></p>
<p>常用于模数较小的组合数取模。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2019/10/10/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>（以下除号皆表示整除）<br />
对于一些式子复杂度大的数论题，或许用莫比乌斯反演可以高效解决问题。</p>
<p>前置技能：</p>
<ul>
<li><p>基本数论函数</p></li>
<li><p>狄利克雷卷积</p></li>
</ul>
<p>莫比乌斯函数满足 <span class="math inline">\(\mu \times I = \epsilon\)</span></p>
<p>即 <span class="math inline">\(\sum_{d|n}\mu(d) = [n = 1]\)</span></p>
<p>表达式为：</p>
<p><span class="math display">\[ n = 0 : \mu(n) = 1 \]</span> <span class="math display">\[ n = \prod_{p|n\,and\,p\,is\,prime} p : \mu(n)=(-1)^k \]</span> <span class="math display">\[ otherwise : \mu(n)=0 \]</span></p>
<p>证明：<br />
<del>暂时不会</del></p>
<p>莫比乌斯反演：<br />
对于数论函数 <span class="math inline">\(f(n)\)</span> ，设 <span class="math inline">\(F(n) = \sum_{d|n}f(d)\)</span><br />
即 <span class="math inline">\(F = f \times I\)</span><br />
则有 <span class="math inline">\(f(n) = \sum_{d|n}F(d)\cdot\mu(\frac{n}{d})\)</span><br />
即 <span class="math inline">\(f = F \times \mu\)</span></p>
<p>证明：</p>
<p><span class="math display">\[ \because \; F = f\cdot I \]</span> <span class="math display">\[ \therefore \; F\cdot \mu = f\cdot I\cdot \mu \]</span> <span class="math display">\[ \because \; I\cdot \mu = \epsilon \]</span> <span class="math display">\[ \therefore \; F\cdot \mu = f\cdot \epsilon \]</span> <span class="math display">\[ \therefore \; f = F\cdot \mu \]</span></p>
<p>莫比乌斯反演好像主要是用来推式子，F 比 f 好做的话，就可以试试莫比乌斯反演。</p>
<p>另外事实上只需要熟知 <span class="math inline">\(\mu\)</span> 函数的性质，直接推式子就行了，<br />
绝大多数情况下（至少是我遇到的所有情况下）并不需要莫比乌斯反演。</p>
<p>另外莫比乌斯反演有个很简单的 <span class="math inline">\(O(nlogn)\)</span> 实现，不需要筛 <span class="math inline">\(\mu\)</span> ，直接按定义枚举每个数的倍数去筛即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>FFT</title>
    <url>/2019/10/09/FFT/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<p>首先要知道关于 <a href="https://kewth.github.io/blog/2019/01/24/多项式的运算/">多项式</a> 的一些知识。</p>
<p>其次要对复数有一些了解。</p>
<h2 id="点值表示法">点值表示法</h2>
<p>从 <a href="https://kewth.github.io/blog/2019/01/24/多项式的运算/">多项式</a> 中， 已经知道了多项式乘法的朴素算法时间复杂度为 $ O(n^2) $ 。 原因在于多项式是用系数表示法定义的。</p>
<p>重新定义 n 次多项式 a 为满足 $ k (http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform) 。</p>
<h2 id="迭代实现">迭代实现</h2>
<p>上述过程用递归实现常数较大，因而有一个迭代实现 FFT 的快速版本。</p>
<h3 id="蝴蝶操作">蝴蝶操作</h3>
<p>FFT 的每个值都是由子问题的两个值转化而来，且这两个值可以转换成两个需要的值（ FFT 复杂度的保证）。 若用一个数组 a 表示多项式。 那么蝴蝶操作形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span> Wn; <span class="comment">// 单位根的幂</span></span><br><span class="line"><span class="built_in">complex</span> a0 = a[x], a1 = a[y];</span><br><span class="line">a[x] = a0 + a1 * Wn;</span><br><span class="line">a[y] = a1 + a0 * Wn;</span><br></pre></td></tr></table></figure>
<p>这样取出了数组中两个值后再修改相应位置的两个值，就是蝴蝶操作。</p>
<h3 id="rader-排序">Rader 排序</h3>
<p>Rader 排序的目的是让表示多项式的数组可以进行蝴蝶操作。</p>
<p>盗图一张： <img src="https://cdn.luogu.org/upload/pic/23926.png" alt="luogu" /></p>
<p>摘自洛谷：</p>
<pre><code>剩下的问题就是把初始的数组变成最后一层的样子了。
先别急着写一个递归函数暴力把位置换过去。
来观察一下最后序列的编号的二进制表示000, 100, 010, 110, 001, 101, 011, 111，
是不是与原来 000, 001, 010, 011, 100, 101, 110, 111 相比，
每个位置上的二进制位都反过来了？
这样的变化叫做 Rader 排序。</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>逆序对</title>
    <url>/2019/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数列 a 中,逆序对即是满足 <span class="math inline">\(i &lt; j\)</span> 且 <span class="math inline">\(a_i &gt; a_j\)</span> 的数对。 许多情况下你推式子推着推着就推出个 <span class="math inline">\(\sum_{i=1}^n \sum_{j=i+1}^n a_i&gt; a_j\)</span>， 这就是逆序对的数量。</p>
<h2 id="暴力">暴力</h2>
<p>朴素的求法自然是 <span class="math inline">\(O(n^2)\)</span> 地枚举 <span class="math inline">\(i, j\)</span> 统计，这里不再赘述。</p>
<h2 id="归并">归并</h2>
<p>前置技能：归并排序。</p>
<p>这应该是最主流的求逆序对的方法了。</p>
<p>要求一个区间内的逆序对数，假设已经递归求出两个子区间的逆序对数， 接下来要做的就是求一个在左区间，一个在右区间的逆序对数。</p>
<p>考虑归并排序的过程，在两个指针比较大小时进行统计。</p>
<p>设左右区间的当前比较指针（下标）为 p1, p2, 当找到第一个 p2 使 <span class="math inline">\(a_{p1}&lt; a_{p2}\)</span> 时，可知 <span class="math inline">\(\forall i\in [p1max+1, p2),\;a_{p1}&gt; a_{p2}\)</span> 。 那么横跨两个子区间的以 p1 为左端点的逆序对就有 p2-p1max-1 个。 对所有 p1 统计和即可。</p>
<p>值得注意的是，p2&gt;r（区间右端点）退出时， 此时左区间未处理的数对答案都有 r-p1max 的贡献因为此时左区间剩下的数都比右区间所有数大。</p>
<p>复杂度 <span class="math inline">\(O(n \cdot log_2n)\)</span> 。</p>
<h2 id="线段树树状数组">线段树/树状数组：</h2>
<p>前置技能：线段树（或树状数组）。</p>
<p>以线段树为例。</p>
<h3 id="做法-1">做法 1</h3>
<p>用线段树维护区间内有效数的个数。 之所以是有效的数，是因为要从小到大删数。 如果一个数 <span class="math inline">\(a_i\)</span> 是最小的，那么以其为右端点的逆序对就是 1 至 i-1 的数的个数。</p>
<p>接下来呢？ 在线段树中删掉最小的数（单点修改 -1）， 那么第二小的数 <span class="math inline">\(a_j\)</span> 在此时就是最小的数，同样有 1 至 j-1 的数的个数（区间查询）的贡献。 以此类推从小到大一个个删数即可。</p>
<p>复杂度<span class="math inline">\(O(n \cdot log_2n)\)</span>。</p>
<h3 id="做法-2">做法 2</h3>
<p>离散化后用线段树维护一个桶。</p>
<p>从左到右依次计算每个数为右端点的逆序对并加入桶，即对每个数求该数左边比该数大的数的个数。 设第 i 个数左边有 <span class="math inline">\(f_i\)</span> 个比 <span class="math inline">\(a_i\)</span> 大的数，那么 <span class="math inline">\(f_i\)</span> 的值即是当前线段树上 <span class="math inline">\(a_i+1~a_{max}\)</span> 的询问。</p>
<p>同样复杂度是 <span class="math inline">\(O(n \cdot log_2n)\)</span>。</p>
<p>这种做法稍稍改变可以高效解决一种特殊的问题：</p>
<p>对于 01 串求串中 1 的数量比 0 的数量大的区间的数量。</p>
<p>比较容易想到的做法是将 0 看成 -1，区间中 1 比 0(-1) 多等价于区间和大于 0 。 区间和可以转换为前缀和 s，那么 l,r 这一区间和大于 0 等价于 <span class="math inline">\(s_r - s_{l-1} &gt; 0 (r &gt;= l)\)</span>。 移项后即是 <span class="math inline">\(s_r &gt; s_{l-1} (r &gt; l-1)\)</span>，所以题目可以转换为求前缀和的逆序对， 复杂度 <span class="math inline">\(O(n \cdot log_2n)\)</span> 。</p>
<p><strong>但是</strong> 这个问题有特殊性，由 01 串的至可知相邻两个前缀和的差值一定是 1 ， 利用这一个性质可以有更高效的方法。</p>
<p>用做法 2 求逆序对，从左到右依次扫，对于当前 <span class="math inline">\(a_i\)</span> 一定比 <span class="math inline">\(a_{i-1}\)</span> 大 1 或者小 1， 利用到这个差值，比 <span class="math inline">\(a_i\)</span> 大的数相当于当前线段树 <span class="math inline">\(a_i+1\)</span> 到 <span class="math inline">\(a_{max}\)</span> 的询问， 若 <span class="math inline">\(a_i = a_{i-1}+1\)</span> ，那么 <span class="math inline">\(f_{i-1}\)</span> 就是 <span class="math inline">\(a_i\)</span> 到 <span class="math inline">\(a_{maxn}\)</span> 的询问，否则就是 <span class="math inline">\(a_i+2\)</span> 到 <span class="math inline">\(a_{max}\)</span> 的询问。 那么 <span class="math inline">\(f_i\)</span> 与 <span class="math inline">\(f_{i-1}\)</span> 的差只在 <span class="math inline">\(a_i\)</span> 或 <span class="math inline">\(a_i+2\)</span> 中，长度为一， 完全没必要用线段树，用数组维护桶即可。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>数论函数玄学操作</title>
    <url>/2019/10/09/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%8E%84%E5%AD%A6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>数论函数推式子是真的玄学， 乱七八糟的一脸懵逼， 好不容易看懂了转身又 <del>tm</del> 忘了， 这里列出一些我见过的。</p>
<p>持续更新。</p>
<p>update: 证明都删掉了，这是篇整理，目的是让结论更一目了然。<del>需要证明联系我我免费讲解</del></p>
<h2 id="常见数论函数卷积">常见数论函数卷积</h2>
<p><span class="math display">\[ \mu \cdot I = \epsilon \]</span></p>
<p><span class="math display">\[ \phi \cdot I = id \]</span></p>
<p><span class="math display">\[ \mu \cdot id = \phi \]</span></p>
<p><span class="math display">\[ id \cdot I = \sigma \]</span></p>
<h2 id="常见数论函数-fij-化简">常见数论函数 f(ij) 化简</h2>
<p><span class="math display">\[ d(i \cdot j) = \sum_{x|i} \sum_{y|j} [gcd(x, y) = 1] \]</span></p>
<p><span class="math display">\[ \sum_{d|ij} f(i \cdot j) = \sum_{x|i} \sum_{y|j} [gcd(x, y) = 1] f(\frac{iy}{x}) \]</span></p>
<p><span class="math display">\[ \phi(i \cdot j) = \phi(i) \phi(j) \frac{gcd(i, j)}{\phi(gcd(i, j))} \]</span></p>
<h2 id="常见数论函数求和">常见数论函数求和</h2>
<p><span class="math display">\[ \sum_{i=1}^n d(i) = \sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \]</span></p>
<h2 id="互质条件转换">互质条件转换</h2>
<p><span class="math display">\[ [gcd(i, j) = 1] = \sum_{d|i,d|j} \mu(d) \]</span></p>
<p><span class="math display">\[ \sum_{i=1}^n \sum_{j=1}^m f(i, j) [gcd(i, j) = 1]
 = \sum_{d=1}^{min(n, m)} \mu(d) \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} f(id, jd) \]</span></p>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HNOI2019</title>
    <url>/2019/10/01/HNOI2019/</url>
    <content><![CDATA[<p>先喷一句，没有大样例，差评。<br />
再喷一句，数据水，好评。</p>
<p>预计 80' ，实际 110' 。</p>
<p>我真是个奇葩实际分比预计分高。。。</p>
<h2 id="day0-">Day0-</h2>
<p>省选前三天教练每天给我们推一道题，都是主席树应用（教练曰“线段树模板”）。<br />
都是看了题解的思路才做出来的，自己想就找不到用主席树维护的地方。</p>
<p>不知道为什么这三天效率都挺高，这三天我 A 的题目估计有我平常一个星期的 A 题数。。。</p>
<p>然而还没来得及复习每个知识点，省选就来了。</p>
<h2 id="day1">Day1</h2>
<p>预计 70' ，实际 40' 。</p>
<h3 id="fish">fish</h3>
<p>我看到这题的时候就意识到我只能打暴力了。<br />
计算几何？我对这块一片空白。<br />
好吧，硬要说思路我大概想得到枚举线段，按斜率搞个什么数据结构？<br />
然后真的不会，敲暴力滚粗。</p>
<p>预计 20' ，实际 20' 。</p>
<h3 id="jojo">jojo</h3>
<p>前缀和后缀相同？求 KMP 的 fail 数组嘛。<br />
暴力求，一次加几个字符就求几次 fail, 全加起来就是答案。<br />
可持久化？版本树像个 AC 自动机，但是没管这么多，无脑写了个可持久化数组。<br />
因为是把每个字符暴力求的，只能过前 50' 。 结果我后面 30' tm TLE 了？ $ O(n log(n)) $ 的时空复杂度跑 1e5 要 6 秒？</p>
<p>预计 50' ，实际 20' 。</p>
<h3 id="polygon">polygon</h3>
<p>什么鬼畜题啊，简化一波题意。<br />
把线段看做一个区间，除 (x, x + 1) 外每个区间一定可以划分成两个子区间。<br />
然后把每个区间看做一个点，相当于有了一个满二叉树。<br />
然后旋转操作就相当于把一个点 blablabla 换一下位置。<br />
旋转次数可以贪心，方案数不会，大概要 DP ？<br />
然后想着就求旋转次数吧，看看数据范围。。。<br />
沃日 90% 的数据都要求方案数？小 W 的心情得多差啊。。。<br />
当时我还没打其他题，感觉比较亏，就先做前面的题了，结果最后都没打。</p>
<p>预计 0' ，实际 0' 。</p>
<h3 id="watering">Watering</h3>
<p>下午直接去机房颓废，死神 vs 火影真好玩。<br />
还有被 lyy 安利太阳系争夺战，画风清新，内容硬核。</p>
<h2 id="day2">Day2</h2>
<p>emm, 我是来测数据湿度的。。。<br />
结果真被我水过去了。。。</p>
<p>预计 10' ，实际 70' 。</p>
<p>所以说有想法就要实现 <del>不然就没事干了</del> 2333 。</p>
<h3 id="tour">tour</h3>
<p>u = v 或者 s[u] = s[v] 且 u, v 相邻的时候 (u, v) 一定是可行的。<br />
其他点对 (u, v) 可行当且仅当 s[u] = s[v] 且存在 u -&gt; u2, v -&gt; v2 且 (u2, v2) 可行。<br />
DP ？有环。<br />
然后就只能把一个点对看做一个点，对于新的点建图，如果从初始的可行点能跑到 (u, v) 则 (u, v) 可行。<br />
点数 $ O(n^2) $ ，边数 $ O(m^2) $ ，复杂度 $ O(n^2 + m^2 + q) $ 。<br />
然而第一档暴力 m 就有 1e4 ， <strong>纯随机数据开O2</strong> 本地测了一下跑 5s, 真棒。</p>
<p>预计 0' ，实际 30' 。</p>
<h3 id="dance">dance</h3>
<p>好迷啊，看了看 n = 1 有 40' ，就去想 n = 1 怎么做，<br />
推了推就是个式子： $ ans_i = _{j=0} C_L^{i+j k} W^{i+j k} $ 。 把每个 $ C_L^x W^x $ 算一遍，快速幂复杂度 $ O(L log(L)) $ ，<br />
然而 L 有 1e8 。。。<br />
线性都跑不过去吧这，但我实在没别的思路，就想试试线性。<br />
做法就是预处理，预处理 L 以内的逆元和 $ W_i $ ，再线性求一排的组合数。<br />
时空复杂度都是 $ O(L) $ ， <strong>开 O2</strong> 本地测试 17s, 就算不 TLE 都得 MLE 。</p>
<p>预计 0' ，实际 30' （考完后再放本地测可以水 40' woc）。</p>
<p>看了看实际的 L 只有 1e7 到 2e7 左右，真棒。 至于空间，我还算有点脑子搞了波动态开空间，不然直接开 1e8 的数组肯定得炸。</p>
<h3 id="sequence">sequence</h3>
<p>b 是整数的话还能枚举枚举。分数？没救了感觉。<br />
于是只打了 10' 的整数 DP 。</p>
<p>预计 10' ，实际 10' 。</p>
<h3 id="watering-1">Watering</h3>
<p>下午本来打算去黄兴街打游戏的，先去麦克唐纳德吃中饭，吃完后发现就已经 3 点多了没什么时间。<br />
于是放弃了 xbox 又回到机房颓废，死神 vs 火影昨天已经玩熟练了，打起来比较轻松。</p>
<h2 id="day3">Day3+</h2>
<p>省选完了，结果并不想想象的那样，即使运气眷顾了我还是 wei 的一批。<br />
实力不够啊，说啥都是扯淡。</p>
<p>常规欠下的帐也该还了，滚回去学文化课啦，接受作业的洗礼。</p>
<h2 id="one-year-later">One Year Later</h2>
<p>update on 2020.04.08</p>
<p>一年过去了，重新审视了去年的 HNOI ，再次分别总结一下吧。 （从去年省选到现在，这些题碰都没有碰过）</p>
<p>新一轮省选不远了。</p>
<h3 id="fish-1">fish</h3>
<p>咕咕咕。</p>
<h3 id="jojo-1">jojo</h3>
<p>去年，我甚至不知道均摊数据结构是不能可持久化的，打了一个主席树满以为复杂度一个 log 。<br />
可事实上 KMP 的最坏复杂度是 <span class="math inline">\(O(n)\)</span> ，可持久化后复杂度可以到 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>可是现在我还是不会做 jojo ，甚至看题解也看不懂，现在上考场估计也还是 20pts 。</p>
<h3 id="polygon-1">polygon</h3>
<p>这题不难的啊，至少现在我看来如此。<br />
不考虑修改的话就可以分治处理这个问题，考虑上修改就动态维护分治的树状形态即可。<br />
而方案数就是分治树的拓扑序数量。</p>
<p>A 了，现在上考场有信心拿到 100pts ，只不过可能得花上至少 2h 的时间。</p>
<h3 id="tour-1">tour</h3>
<p>思路很妙，同类型的边的偶环是没有意义的，可以删边使得同类型的边偶环不存在进而把边数控制在 <span class="math inline">\(O(n)\)</span> 。<br />
可惜我没能独自得到这个结论，还是看了题解的，看了后有一种恍然大悟的感觉。</p>
<p>现在上考场也许还是只会 <span class="math inline">\(O(m^2)\)</span> 暴力吧，时间足够的话说不定能想到正解，但没有把握，大概拿 30pts 。</p>
<h3 id="dance-1">dance</h3>
<p>现在看来这个式子并不难推，推完后就是对一个多项式求单位根上的点值。<br />
但是在直到看题解前我都完全没听说过 bluestein ，算是技不如人，只能拿 60pts 。</p>
<h3 id="sequence-1">sequence</h3>
<p>花了 30min 打了个 50pts 的暴力 <span class="math inline">\(O(nm)\)</span> ，发现简直白给。<br />
不过 100pts 确实难了不少，我觉得就算考场想到了也无法在考试时间内写对。</p>
]]></content>
  </entry>
  <entry>
    <title>Manjaro 搭建内网博客</title>
    <url>/2019/10/01/Manjaro%20%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%96%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>折腾了大半天，终于在本机搭了一个功能完备的服务器。<br />
当然要记录一下啊。<br />
不过这是搭建成功后的总结，可能有地方遗漏，有问题欢迎提出来。</p>
<h2 id="静态页面博客">静态页面博客</h2>
<p>这个用 hexo 和 jekyll 直接就可以做到，本地跑 server 不成问题，<br />
比较 easy ，不赘述，详见 hexo 或者 jekyll 的官网。</p>
<h2 id="动态页面博客">动态页面博客</h2>
<p>动态页面要能跑 php ，有数据库。</p>
<h2 id="apache">apache</h2>
<p>这里用 apache(httpd) 搭建服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S apache2</span><br></pre></td></tr></table></figure>
<p>执行 <code>sudo httpd</code> 后打开 localhost ，就有一个东西了（虽然是空的）。<br />
在 /srv/http/ 下新建 index.html 随便写点东西，是可以显示的。<br />
路径具体查看 <code>httpd -S</code> 。</p>
<p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start httpd</span><br></pre></td></tr></table></figure>
<h2 id="php">php</h2>
<p>安装 php （ manjaro18.x 预装了 php7.x ，但还是要一些其他的东西）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S php php-apache php-fpm</span><br></pre></td></tr></table></figure>
<p>这时 apache 还是不支持 php 的，需要在配置里加上几行。<br />
打开 /etc/httpd/conf/httpd.conf ，加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule php7_module modules&#x2F;libphp7.so</span><br><span class="line">AddType application&#x2F;x-httpd-php-source .phps</span><br><span class="line">AddType application&#x2F;x-httpd-php .php</span><br><span class="line">DirectoryIndex index.php index.html index.htm</span><br></pre></td></tr></table></figure>
<p>开启 php 服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start php-fpm</span><br></pre></td></tr></table></figure>
<p>编写 index.php 试试，也可以运行了。 如果出了问题，找到配置里的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mpm_event_module modules&#x2F;mod_mpm_event.so</span><br></pre></td></tr></table></figure>
<p>改成（应该就在下面被注释了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mpm_prefork_module modules&#x2F;mod_mpm_prefork.so</span><br></pre></td></tr></table></figure>
<h2 id="mysql">mysql</h2>
<p>我跑 mysql 的服务会卡死，不知道为什么，<br />
所以我用 mariadb （mysql 的一个衍生似乎是）替代。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S mariadb mariadb-client</span><br></pre></td></tr></table></figure>
<p>初始化（注册一个账号）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure>
<p>试试能不能登上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u&lt;用户名&gt; -p</span><br></pre></td></tr></table></figure>
<p>让 php 支持 mysql 的调用，在 /etc/php/php.ini 找到 ;extension=mysqli 把分号去掉就行了。</p>
<h2 id="使用-wordpress">使用 wordpress</h2>
<p>Typecho 用 php7.2 似乎安装会出问题，<br />
还是建议用 wordpress ，更加成熟，<br />
安装方式在 wordpress 官网上把包下下来解压到 /srv/http/ ，<br />
回了正常运行，需要改变 /srv/http 的权限，让 wordpress 能够对其做出修改。<br />
这里不赘述，嫌麻烦可以 <code>chmod 777 -R /srv/http</code> 。</p>
<p>然后进入 localhost 按照步骤来就行了。</p>
]]></content>
  </entry>
  <entry>
    <title>NOIP 2018</title>
    <url>/2019/10/01/NOIP%202018/</url>
    <content><![CDATA[<h2 id="吐槽">吐槽</h2>
<p>一天普及一天省选，弄到一起就出成了一套提高组试题。</p>
<h2 id="day1">Day1</h2>
<p>原题大作战。 然而我一题都没做过。</p>
<p>总的来说 Day1 比去年好像容易点（不然我也不会留出一个多小时给每道题造数据对拍）。</p>
<h3 id="t1">T1</h3>
<p>CCF 直接把 2013 的题原封不动搬到了 Day1T1 。</p>
<p>一开始想着递归，发现会被卡成 <span class="math inline">\(O(n^2)\)</span> ， 再想 DP 的时候简化一下式子就直接可以扫一遍出结果。</p>
<h3 id="t2">T2</h3>
<p>bzoj 权限题。</p>
<p>如果一种货币能被其它若干货币代替，就扔掉。 设 f[i] 表示价值为 i 的货币是否会被代替，做一遍完全背包就好了。</p>
<h3 id="t3">T3</h3>
<p>bzoj 权限题。</p>
<p>听说可以二分加贪心，不过我考场想的比较复杂 <del>是二分答案再 DP ，DP 转移再套一层用链表维护的 DP</del> 。</p>
<p>首先容易想到二分答案，二分一个答案 mid 后求最多可以有多少条赛道满足长度不小于 mid ， 若有不少于 m 条，则答案可行。</p>
<p>求赛道数量可以 DP ，设 f[u] 为 u 的子树中满足条件的赛道的数量， g[u] 表示在满足 f[u] 最大的前提下 u 向下不经过赛道的最长路径长。</p>
<p>转移的时候先把 u 的儿子 v 的 f[v] 累加，同时将所有 g[v]+w 存起来（w 表示 u 到 v 的长度）。</p>
<p>对于 g[v]+w 大于等于 mid 的直接把 f[u]++ 然后扔掉，于是只需要考虑小于 mid 的 g[v]+w 的贡献。</p>
<p>两个不同的 g[v]+w 若大于等于 mid 就同样可以作为一条赛道让 f[u]++ ，先排序然后再次 DP 统计这样的赛道数量， 然后若所有的 g[v]+w 都有另外一个构成赛道， g[u]=0 ，否则 g[u] 等于剩下的最大的 g[v]+w 。</p>
<h2 id="day2">Day2</h2>
<p>Day1 的比赛对我造成了巨大的影响，Day1 考完后信心爆棚， <del>以 AKIOI 的自信</del> 走进 Day2 考场。</p>
<p>结果什么题都死磕正解，到最后连暴力都没打全。</p>
<p>看题，WTF?</p>
<p>看完 T1 我以为是个稠密无向图，想了好久感觉是要求一种特殊的生成树，感觉巨不可做。 顿时有点小慌，突然想到考前教练提醒要看完题，说不定后面的题反而简单。</p>
<p>嗯，有道理，直接翻到 T2 ，推了波结论认定是一道状压 DP，松了口气。</p>
<p>不急，再看 T3 ，哦，好像树形 DP ，但是 m 个询问难住了我。</p>
<p>于是认定 T2 比较容易，开始死磕 T2 ，打完状压后跑了遍 2,2 的样例，诶过了。 再跑一遍 3,3 ，输出 144 ，于是手推了 3,3 的样例发现还是 144 , 意识到推的结论有误，瞬间慌的一批。 推了好久才发现了问题，得到正确的结论后发现对于新结论状压 DP 似乎变得不可行。</p>
<p>这个时候考试已经过了一个小时多了。慌。</p>
<p>换换思路吧，于是去做 T3 , 想了很久 DP 最后写了个平方复杂度的， 跑过了所有样例就没管了，没多少时间了，又回去看 T1 。</p>
<p>往回看了看 T1 里 m 的数据范围我才发现只有树和换套树两种情况。 那还求个鬼生成树，迅速打掉树的 60 部分分，n 看都没看只知道 <span class="math inline">\(O(n)\)</span> 稳了。 再去想换套树，感觉差不多，继续 <span class="math inline">\(O(n)\)</span>做。</p>
<p>结果？一直死磕 T1 的 <span class="math inline">\(O(n)\)</span> 做法，直到最后考试结束都没写出来。</p>
<p>考试听别人说直接枚举删边 <span class="math inline">\(O(n^2)\)</span> 就可以过的时候我才意识到 n 只有 5000 ，整个人懵的。</p>
<p>结果 T1 还是 60' ，T3 不晓得哪里炸掉了爆零， 有意思的是 T2 我错误的打法样例都没过在 ccf 的数据里水到了 45' 。</p>
]]></content>
  </entry>
  <entry>
    <title>NTT</title>
    <url>/2019/10/01/NTT/</url>
    <content><![CDATA[<p>NTT ，快速数论变换，功能与 <a href="">FFT</a> 完全一致，用来求多项式卷积。<br />
NTT 优点在于常数稍微小一点，没有精度误差。<br />
但是 NTT 系数必须是取模意义下的整数，且对模数有特殊要求。</p>
<h2 id="fft-的单位根">FFT 的单位根</h2>
<p>建议前置 <a href="">FFT</a> 。</p>
<p>FFT 可以分治优化复杂度的原因是用到了单位根的如下性质：<br />
<span class="math display">\[ W_{2n}^{2k} = W_n^k \]</span> <span class="math display">\[ W_n^n = 1 \]</span> <span class="math display">\[ W_n^{k + n/2} + W_n^k = 0 \]</span></p>
<p>可是用单位根做 FFT ，需要用到复数和浮点数，常数大而且有精度误差。<br />
还有别的数有这样的性质来替换单位根吗？<br />
遗憾的是，可以证明复数域下只有单位根有这样的性质。</p>
<h2 id="取模">取模</h2>
<p>实际计算多项式卷积时，常常要求对系数取模以避免不必要的麻烦。<br />
那么这时候系数实际上是在模意义下的， FFT 将它转到复数域上运算，似乎没有必要。<br />
模意义下什么数可以有单位根那样的性质？<br />
有的，那就是原根。</p>
<h2 id="原根">原根</h2>
<p>对于某些模数 P ，模 P 意义下的原根 g 满足：<br />
对任意 $ 0 k P - 2 $ ， $ g^k $ 互不相同。 有些模数可能不存在原根，这里先假设模数都有原根。</p>
<p>假设系数是模 P 意义下的，P 是形如 $ 2^k + 1 $ 的质数，其原根为 g ，<br />
设 $ G_n = g^{} mod P $ ，其中 n 是小于 P 的 2 的整次幂 。<br />
那么在模 P 意义下， G 满足：</p>
<p><span class="math display">\[ G_{2n}^{2k} = G_n^k \]</span></p>
<p>由 G 定义可证：<br />
$ G_{2n}^{2k} = g^{2k} = g^{k} = G_n^k$</p>
<p><span class="math display">\[ G_n^n = 1 \]</span></p>
<p>由 G 定义可得：<br />
$ G_n^n = g^{n} = g^{P-1} $<br />
由费马小定理：<br />
$ G_n^n = g^{P-1} = 1 $</p>
<p><span class="math display">\[ G_n^{k + n/2} + G_n^k = 0 \]</span></p>
<p>有第一条性质可得：<br />
$ G_n^{n/2} = G_2^1 = g^{} $<br />
因为 $ (g<sup>{})</sup>2 = g^{P-1} = 1 $<br />
根据原根的性质：<br />
$ g^{} g^{P-1} $<br />
那么 $ g^{} = -1 $ （即 P - 1）。<br />
那么可以证得：<br />
$ G_n^{k + n/2} = G_n^k G_n^{n/2} = G_n^k(-1) $<br />
于是 $ G_n^{k + n/2} + G_n^k = 0 $</p>
<h2 id="ntt">NTT</h2>
<p>于是 NTT 的算法思路就呼之欲出了：把 $ W_n $ 全部替换为 $ G_n $ 即可。<br />
这样就可以算出模 P 意义下的多项式卷积了。<br />
其中 n 必须是 2 的整次幂，不足的补零即可。</p>
<p>现在唯一的问题是，模数 P 要满足什么条件，以及如何求模 P 意义下的原根 g 。<br />
然而我并不想深入展开，大多数情况下模数都是 998244353 ，其原根为 3 。<br />
一般 NTT 只会用这个模数，不会有毒瘤出题人卡这个模数的（我不对这句话负责）。</p>
]]></content>
  </entry>
  <entry>
    <title>i3</title>
    <url>/2019/10/01/i3/</url>
    <content><![CDATA[<h2 id="历程">历程</h2>
<ul>
<li>最先用的是 Ubuntu 16.04 自带的 Unity 。</li>
<li>更新 Ubuntu 后用的 Ubuntu 18.04 自带的 Gnome 。</li>
<li>用了 Gnome 后学会了折腾，各种配置堆上。</li>
<li>后来发现 Gnome 太卡太吃内存，并且才知道系统可以换桌面， 于是在 master 安利下换上 xfce 。</li>
<li>xfce 很稳定很流畅，但是太丑，可玩性太低，于是换上高大上的 KDE 。</li>
<li>中途还换过 enlightenment ，但是 enlightenment 的稳定性实在不敢恭维。</li>
<li>最后用上了 i3 ，原因不详。</li>
</ul>
<p>WARNING:<br />
既然你打算尝试 i3 ，本文假设你有一定的动手能力（说白了就是能折腾）。</p>
<h2 id="安装">安装</h2>
<p><code>sudo aptitude install i3-wm</code> 后注销重进选择 i3 即可。</p>
<p>然后你会发现弹出个窗口，接下来黑屏，没有动静。<br />
WTF ?<br />
其实 i3 已经开了，只是没背景而已，按 win+Enter 打开终端。</p>
<h2 id="配置">配置</h2>
<p>弹出一个菜单给你设置？想多了，要配置就写 ~/.config/i3/config 去吧。</p>
<p>$mod 是 i3 的灵魂，每一个快捷键最好都以 $mod 开头，<br />
一般 $mod 被设置成 Mod4 ，也就是 Win 键。<br />
bindsym 是绑定快捷键，注释很详细，自己看，下面列出一些重要的配置。</p>
<h3 id="方向">方向</h3>
<p>i3 默认把 jkl; 做方向键，也许你会更喜欢 hjkl ，自己替换掉就是了。<br />
另外分号不是 ; 而是 semicolon 。</p>
<h3 id="壁纸">壁纸</h3>
<p>i3 默认没有壁纸，因为它是个平铺式的窗口管理器。<br />
但壁纸是第一生产力啊，不要壁纸怎么行。</p>
<p>下载 feh: <code>sudo aptitude install feh</code>.<br />
<code>feh --bg-fill (YOUR_IMG)</code> 就可以设置壁纸了，至于实现原理，你不会想知道的。</p>
<h3 id="锁屏">锁屏</h3>
<p>i3 默认没有锁屏，为了防机惨，锁屏还是很有必要的。</p>
<p>下载 i3lock: <code>sudo aptitude install i3lock</code>.<br />
直接 <code>i3lcok</code> 就可以锁屏，<code>i3lock -i (YOUR_PNG)</code> 还可以设置锁屏壁纸。<br />
需要快捷键锁屏的话，加上一句配置就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+Tab exec i3lock # Win+Tab 锁屏</span><br></pre></td></tr></table></figure>
<h3 id="工作区">工作区</h3>
<p>i3 对工作区的数量没有限制，工作区的名字甚至可以有字母。<br />
i3 默认配置里只提供了切换到 1 至 10 的快捷键，<br />
但是有时候“切换到下一个工作区”和“切换到上一个工作区”可能更方便。<br />
加上两句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+comma workspace prev # Win+逗号</span><br><span class="line">bindsym $mod+period workspace next # Win+句号</span><br></pre></td></tr></table></figure>
<p>另外，默认配置里，把一个窗口移动到某工作区的时候仍会停留在原工作区，<br />
想改变这点， 把 <code>move container to workspace x</code> 后面加上 <code>; workspace x</code> 即可。</p>
<h3 id="i3bar">i3bar</h3>
<p>个人超喜欢 i3bar ，因为它可以接受任何一个程序的输出。<br />
这意味着你可以完全自由地定制 i3bar 。</p>
<p>找到 <code>bar &#123;</code> 这行。<br />
bar 的模式有三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mode hide # Auto display</span><br><span class="line">mode invisible # Never display</span><br><span class="line">mode dock # Alway display</span><br></pre></td></tr></table></figure>
<p>位置有两种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position top</span><br><span class="line">position bottom</span><br></pre></td></tr></table></figure>
<p>重点来了，定义处理程序这一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_command i3status</span><br></pre></td></tr></table></figure>
<p>可以看到默认使用 i3status 作为处理，i3status 本身也可以配置，<br />
但是如果想自由配置，你可以写个程序，输出一个 json ，接口比较复杂，<br />
在此不赘述，你可以在 ~/.config/i3status/config 里加几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general &#123;</span><br><span class="line">    output_format &#x3D; &quot;i3bar&quot;</span><br><span class="line">    colors &#x3D; true</span><br><span class="line">    interval &#x3D; 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再运行 <code>i3status</code> 依葫芦画瓢就是了。</p>
<h3 id="i3-gaps">i3-gaps</h3>
<p>如果你希望窗口平铺之间会有间隙，i3-gaps 会满足你。<br />
如果你用 Debian, Ubuntu ， 去 github 上搜 i3-gaps-deb clone 下来后运行 i3-gaps-deb 就行了。<br />
如果用 Arch ，软件包管理器里有，直接下。</p>
<h3 id="透明">透明</h3>
<p>也许你给终端模拟器设置了透明度，很遗憾，在 i3 上没用。<br />
解决方案是下载 compton ，运行 <code>compton -b</code> 即可。</p>
<h2 id="接口">接口</h2>
<p>你可以很自由地向 i3 发送命令，<code>i3-msg</code> 提供了一系列接口，<br />
足以帮助完成更复杂的定制。</p>
<p>使用 <code>i3-input</code> 可以直接向 i3 发送一条命令。</p>
]]></content>
  </entry>
  <entry>
    <title>i3lock</title>
    <url>/2019/10/01/i3lock/</url>
    <content><![CDATA[<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/07/2_054-1.png" alt="i3lock-fancy" /><figcaption aria-hidden="true">i3lock-fancy</figcaption>
</figure>
<p>折腾了半天 i3lock ，不写篇博客可惜了。</p>
<p>i3lock 有啥好折腾的？不就是挂个壁纸锁屏嘛。<br />
就是因为 i3lock 太鸡肋了折腾啊。<br />
于是我试过了 i3lock 的各种民间 fork 版本，在此总结。</p>
<h2 id="i3lock"><a href="https://github.com/i3/i3lock">i3lock</a></h2>
<p>官方版本 i3lock ，稳定可靠，但是鸡肋。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install i3lock</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-lixxia"><a href="https://github.com/Lixxia/i3lock">i3lock-lixxia</a></h2>
<p>最友好，最简单的一个 i3lock fork ，<br />
优化了中间显示的圆形框，并支持一些颜色自定义。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Lixxia/i3lock.git</span><br><span class="line"><span class="built_in">cd</span> i3lock</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<p>顺带一提，只有这个 fork 给出了靠谱的源码安装方式，<br />
其他 fork 甚至 i3lock 本身的安装方式都给得很不靠谱。</p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-blur"><a href="https://github.com/karulont/i3lock-blur">i3lock-blur</a></h2>
<p>支持模糊背景，毛玻璃特效。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/karulont/i3lock-blur.git</span><br><span class="line"><span class="built_in">cd</span> i3lock-blur</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<p>再顺带一提，只有这个 fork 直接给出了需要安装那些库。</p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock --fuzzy</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lockr"><a href="https://github.com/owenthewizard/i3lockr">i3lockr</a></h2>
<p>支持模糊背景，毛玻璃特效。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/owenthewizard/i3lockr/releases/download/v1.0.0-final/i3lockr</span><br><span class="line">sudo mv i3lockr /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lockr --blur=25</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-color"><a href="https://github.com/PandorasFox/i3lock-color">i3lock-color</a></h2>
<p>对于颜色的自定义十分全面。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/PandorasFox/i3lock-color</span><br><span class="line"><span class="built_in">cd</span> i3lock-color</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-fancy"><a href="https://github.com/meskarune/i3lock-fancy">i3lock-fancy</a></h2>
<p>重头戏，star 最多的 fork ，甚至比 i3lock 本身更多，被广泛使用。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install i3lock-fancy</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i3lock-fancy</span><br></pre></td></tr></table></figure></p>
<p>依赖 i3lock ，实际上是产生了背景图片再调用 i3lock 。<br />
默认使用模糊背景，用起来没什么问题，但是事实上，<br />
圆形框的颜色并不是最正确的，而是兼容的。</p>
<p>源码里有这样一条： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to use a forked version of i3lock with prepared parameters</span></span><br><span class="line"><span class="keyword">if</span> ! i3lock -n <span class="string">&quot;<span class="variable">$&#123;PARAM[@]&#125;</span>&quot;</span> -i <span class="string">&quot;<span class="variable">$IMAGE</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># We have failed, lets get back to stock one</span></span><br><span class="line">    i3lock -n -i <span class="string">&quot;<span class="variable">$IMAGE</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>bash -x i3lock-fancy 就知道，<br />
if 上的命令往往失败了，执行的是 if 里头的命令。</p>
<p>事实上这需要 i3lock-color 。<br />
那么，安装 i3lock-color 代替 i3lock 后，执行 i3lock-fancy ，<br />
会发现圆形框的颜色与背景更加配了。</p>
<h2 id="关于模糊背景">关于模糊背景</h2>
<p>事实上，如果你用了 compton 再用 i3lock ，效果十分差劲。<br />
解决这个方案，可以在调用 i3lock 前 kill compton ，结束后重新启动 compton 。</p>
<p>拿 i3lock-fancy 举例，把之前展示的代码改成这样： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to use a forked version of i3lock with prepared parameters</span></span><br><span class="line">pkill compton</span><br><span class="line"><span class="keyword">if</span> ! i3lock -n <span class="string">&quot;<span class="variable">$&#123;PARAM[@]&#125;</span>&quot;</span> -i <span class="string">&quot;<span class="variable">$IMAGE</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># We have failed, lets get back to stock one</span></span><br><span class="line">    i3lock -n -i <span class="string">&quot;<span class="variable">$IMAGE</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">compton -i 0.8 -b</span><br></pre></td></tr></table></figure></p>
<p>其次，用模糊背景通常会比较慢，尤其是 i3lock-fancy ，需等上 3 秒左右。<br />
那么如果调用 i3lock-fancy 之后你又做了一些别的操作，比如关闭一个窗口，<br />
这时锁屏了，你会发现背景和原来的不一样。 :)</p>
]]></content>
  </entry>
  <entry>
    <title>终端（娱乐）工具</title>
    <url>/2019/10/01/terminal-tool/</url>
    <content><![CDATA[<h2 id="sl-ls">sl / LS</h2>
<p>在你 ls 打累的时候开小火车。</p>
<h3 id="安装方式">安装方式</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install sl</span><br></pre></td></tr></table></figure>
<h2 id="lolcat">lolcat</h2>
<p>用彩虹为输出着色！</p>
<h3 id="示例">示例</h3>
<figure>
<img src="https://pic4.zhimg.com/v2-3bf6b7552162441dd638ac6d5fb3717b_r.jpg" alt="lolcat" /><figcaption aria-hidden="true">lolcat</figcaption>
</figure>
<h3 id="安装方式-1">安装方式</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install rubygems</span><br><span class="line">gem install lolcat</span><br></pre></td></tr></table></figure>
<h3 id="管道处理">管道处理</h3>
<p>非常有意思的是，将大多数 ncurses 程序的输出通过管道用 lolcat 后仍然可以正常运行！</p>
<p>比如 <code>nano | lolcat</code> 可以打开一个彩虹编辑器；<br />
<code>ncdu | lolcat</code> 可以打开一个彩虹文件查看器；<br />
<code>sl | lolcat</code> 可以开彩虹火车；<br />
<code>nethack | lolcat</code> 可以玩彩虹游戏！</p>
<h2 id="cowsay">cowsay</h2>
<p>让一只奶牛（或者其它乱七八糟的东西）说出一句话！</p>
<h3 id="示例-1">示例</h3>
<p>运行 <code>cowsay hiahiahia</code></p>
<p>然后你会得到像这样的输出：</p>
<pre><code> ___________
&lt; hiahiahia &gt;
 -----------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre>
<p>类似的你也可以用 <code>cowthink</code> 。</p>
<h3 id="安装方式-2">安装方式</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install cowsay</span><br></pre></td></tr></table></figure>
<h2 id="chafa">chafa</h2>
<p>在终端里面打印图片或者视频！</p>
<h3 id="示例-2">示例</h3>
<figure>
<img src="https://pic4.zhimg.com/v2-91254499e2880bbe3068ce2a3e086977_b.gif" alt="chafa" /><figcaption aria-hidden="true">chafa</figcaption>
</figure>
<p>小诀窍：把终端字体调小并开全屏可以让图片更清晰（但是更慢）。<br />
给你一图片自行意会（记住这张图是在终端上打印的！！！）：</p>
<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/03/选区_017.png" alt="chafabig" /><figcaption aria-hidden="true">chafabig</figcaption>
</figure>
<h3 id="安装">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hpjansson/chafa.git &amp;&amp; <span class="built_in">cd</span> chafa</span><br><span class="line">sudo aptitude install libmagickwand-dev</span><br><span class="line">./autogen.sh</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>这个安装过程相对比较麻烦，详细过程见 <a href="https://github.com/hpjansson/chafa">Github</a> 。</p>
<h2 id="img2txt-cacaview">img2txt / cacaview</h2>
<p>在终端里用 ASCII 打印图片！</p>
<p>或者用 cacaview 打开一个窗口查看。</p>
<p>upd: 后来我才知道 w3m 也可以查看图片，和 cacaview 的效果一模一样。</p>
<h3 id="安装-1">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install caca-utils</span><br></pre></td></tr></table></figure>
<h2 id="w3m-lynx-browsh">w3m / lynx / browsh</h2>
<p>在终端浏览网页！</p>
<h3 id="示例-3">示例</h3>
<p>w3m 和 lynx 大同小异，没有什么本质上的区别。 （别喷我，我这么说是拿 browsh 作参照）</p>
<p>但是， browsh 不同，它内部调用 Firefox 渲染网页并处理后打印在终端， 因此 browsh 几乎能 <strong>在终端</strong> 支持任何现代浏览器支持的！</p>
<p>只给出一张 browsh 浏览 youtubu 的图片：</p>
<figure>
<img src="https://oscimg.oschina.net/oscnet/cc8d81d3c93d858a0a3f39e08293e4b6535.jpg" alt="browsh" /><figcaption aria-hidden="true">browsh</figcaption>
</figure>
<h3 id="安装-2">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># w3m</span></span><br><span class="line">sudo aptitude install w3m</span><br><span class="line"><span class="comment"># lynx</span></span><br><span class="line">sudo aptitude install lynx</span><br><span class="line"><span class="comment"># browsh</span></span><br><span class="line">wget https://github.com/browsh-org/browsh/releases/download/v1.5.0/browsh_1.5.0_linux_amd64.deb</span><br><span class="line">sudo dpkg -i ./browsh_1.5.0_linux_amd64.deb</span><br></pre></td></tr></table></figure>
<h2 id="cmatrix">cmatrix</h2>
<p>终端黑客风动画</p>
<p><code>cmatrix | lolcat</code> 简直可以来当屏保。</p>
<h3 id="安装-3">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install cmatrix</span><br></pre></td></tr></table></figure>
<h2 id="typespeed">typespeed</h2>
<p>在终端 <del>玩打字游戏</del> 测试打字速度！</p>
<h3 id="示例-4">示例</h3>
<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/03/选区_027.png" alt="typespeed" /><figcaption aria-hidden="true">typespeed</figcaption>
</figure>
<h3 id="安装-4">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install typespeed</span><br></pre></td></tr></table></figure>
<h3 id="自定义词库">自定义词库</h3>
<p>我是真的爱折腾，竟然自己找出了 typespeed 的词库位置并且自己加了词库。。。</p>
<p>顺便夸一下 typespeed 的扩展性真的好，它考虑到了用户的自定义词库需求。</p>
<p>只需要在 /usr/share/typespeed/words/ 目录下添加 words.xxx 文件（ xxx 随意填），<br />
文件第一行是这个词库的名称，接下来每行一个单词就可以了。</p>
<p>然后进入 typespeed 就能看到你自己的词库啦（ kewth's xxx 就是我自己加的）：</p>
<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/03/选区_028.png" alt="mywords" /><figcaption aria-hidden="true">mywords</figcaption>
</figure>
<h2 id="nethack">nethack</h2>
<p>世界上最棒的终端游戏（绝无夸大）！<br />
nethack 太博大精深了，玩法不赘述。</p>
<p>另外： <code>nethack | lolcat</code> 的效果真的很棒。</p>
<h3 id="安装-5">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install nethack</span><br></pre></td></tr></table></figure>
<h2 id="task">task</h2>
<p>全名 taskwarrior 。</p>
<p>个人认为终端上最好用的 todo list manager 。<br />
功能十分强大，可以简单上手，<br />
如果愿意折腾也可以深入挖掘它的各种功能，最精细地管理你的任务计划。</p>
<h3 id="安装-6">安装</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install taskwarrior</span><br></pre></td></tr></table></figure>
<h3 id="简单上手">简单上手</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task add test1</span><br><span class="line">task add test2</span><br><span class="line">task start 1</span><br><span class="line">task long</span><br><span class="line">task <span class="keyword">done</span> 1</span><br><span class="line">task <span class="keyword">done</span> 2</span><br></pre></td></tr></table></figure>
<h3 id="tasksh">tasksh</h3>
<p>整合 taskwarrior 的交互命令行，里面可以直接敲 <code>add ...</code> 或 <code>list</code> 等命令。</p>
]]></content>
  </entry>
  <entry>
    <title>ncurses</title>
    <url>/2019/10/01/ncurses/</url>
    <content><![CDATA[<p>ncurses 是基于终端的十分强大的图形库。 Vim, screen, sl 等终端程序都用到了这个库（足以见其强大）。</p>
<h2 id="安装">安装</h2>
<p>部分系统默认安装了 ncurses ，手动安装的方式是： <code>sudo aptitude install ncurses-dev</code> 。</p>
<p>使用的程序需要 <code>#include &lt;ncurses.h&gt;</code>　。 编译时需要添加 <code>-lncurses</code> 参数进行链接。</p>
<h2 id="开始和结束">开始和结束</h2>
<p>调用 initscr 初始化窗口，endwin 结束窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">WINDOW *<span class="title">initscr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endwin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<p>调用 initscr 后调用 endwin 前，printf, std::cout 等标准输出不会显示在屏幕上。 而输出到屏幕上需要 ncurses 提供的相应函数。</p>
<h3 id="函数">函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addch</span><span class="params">(<span class="keyword">const</span> chtype char_to_add)</span></span>;   <span class="comment">// 当前位置添加字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *string_to_add)</span></span>;    <span class="comment">// 当前位置添加字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printw</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>;   <span class="comment">// 类似于 printf</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">refresh</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">// 强制刷新物理屏幕</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beep</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">// 终端响铃</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flash</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">// 屏幕闪烁</span></span><br></pre></td></tr></table></figure>
<h2 id="输入">输入</h2>
<p>调用 scanf, getchar, cin 等标准输入函数同样无效。</p>
<h3 id="函数-1">函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cbreak</span><span class="params">()</span></span>;   <span class="comment">// 字符一键入，直接传给程序（不用按下回车）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nocbreak</span><span class="params">()</span></span>;  <span class="comment">// 关闭 cbreak</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">echo</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 开启输入回显</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noecho</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 关闭输入回显</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 读入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanw</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">// 类似于 scanf</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure>
<p>输入函数通常是阻塞的，但是通过调用 nodelay(stdscr, TRUE); 可以关闭阻塞。 此时若输入函数未读取到内容会返回 ERR 。</p>
<h2 id="光标">光标</h2>
<p>控制光标。 调用 initscr 后调用 endwin 前，输出终端控制符改变光标是无效的。</p>
<h3 id="函数及示例">函数及示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// 将光标移动到 [x] 行 [y] 列，左上角为 0 行 0 列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">curs_set</span><span class="params">(<span class="keyword">int</span> visiblility)</span></span>; <span class="comment">// 参数为 0 表示隐藏光标，1 表示显示光标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getyx</span><span class="params">(WINDOW* win, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>; <span class="comment">// 获取指定窗口光标位置，示例如下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span> </span>&#123; <span class="comment">// 将光标上移</span></span><br><span class="line">   <span class="keyword">int</span> x, y;</span><br><span class="line">    getyx(stdscr, x, y); <span class="comment">// stdscr 表示标准屏幕</span></span><br><span class="line">    move(x - <span class="number">1</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定位置输出">指定位置输出</h3>
<p>在指定位置输出不必先 move 再 printw ， ncurses 提供了 mv 函数前缀在指定位置输出。 例如 <code>mvprintw(1, 2, "%d", 2)</code> 在 1 行 2 列输出 3 。 类似的有 mvaddch, mvaddstr 等。</p>
<h2 id="颜色">颜色</h2>
<h3 id="初始化">初始化</h3>
<p>首先需要调用 has_color() 查看当前运行环境是否支持彩色。 调用 start_color() 初始化颜色，成功则返回 OK 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_colors</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_color</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>成功后会初始化全局变量 COLORS 表示终端支持的颜色数量 还会有 COLOT_WHITE, COLOR_RED 等 8 个表示颜色的变量。</p>
<h3 id="使用">使用</h3>
<p>例如希望打印白底黑字的信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *info)</span> </span>&#123;</span><br><span class="line">  init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_WHITE);</span><br><span class="line">       <span class="comment">// 的一个参数表示编号，后面两个分别表示字体和背景颜色</span></span><br><span class="line"> attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// attron 是一个设置函数，COLOR_PAIR 返回指定编号的颜色信息</span></span><br><span class="line"> addstr(info);</span><br><span class="line"> attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">       <span class="comment">// attroff 关闭设置（若接下来需要用其他颜色可以不调用 attroff 而直接使用 attron 覆盖设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误示例">错误示例</h3>
<p>值得注意的是，必须保证 init_pair 的编号不与其他已初始化的编号重复 一个错误的调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;ERROR CODE&quot;</span>;</span><br><span class="line">init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_WHITE);</span><br><span class="line">attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">addstr(info); <span class="comment">// 打印白底黑字</span></span><br><span class="line">init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_RED);</span><br><span class="line">attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">addstr(info); <span class="comment">// 打印白底红字</span></span><br></pre></td></tr></table></figure>
<p>上述代码的期望打印出白字和黑字两种不同的颜色， 但事实上只会打印出红色一种。 解决方案便是将白底红字的 pair 编号设为 2 。</p>
<h2 id="窗口">窗口</h2>
<p>ncurses 有窗口类 WINDOW 并提供了 stdscr 作为默认窗口。 有时一个窗口无法满足需要，此时需要自己新建窗口。</p>
<h3 id="新建窗口">新建窗口</h3>
<p>调用 newwin 来新建窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 ([x], [y]) 开始新建 [line] 行 [column] 列的窗口。</span></span><br><span class="line"><span class="function">WINDOW *<span class="title">newwin</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>新建的窗口</p>
<h3 id="通用输出">通用输出</h3>
<p>addch, printw 等输出方式只输出到 stdscr 。 ncurses 提供了 w 前缀来输出到指定窗口。 例如 <code>wprintw(win, "%d", 1)</code> 在 [win] 窗口输出 1 。 但是自己新建的窗口与 stdscr 不同， 若想在屏幕上显示需要调用 <code>wrefresh(win)</code> 刷新窗口。</p>
<p>若想在窗口中指定位置输出，可以用 mvw 前缀函数。 例如 <code>mvwprintw(win, 1, 2, "%d", 3)</code> 在 [win] 窗口的 1 行 2 列（ <strong>相对位置</strong> ）输出 3 。</p>
<h3 id="子窗口">子窗口</h3>
<p>调用 subwin 创建子窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 ([x], [y]) 开始新建 [line] 行 [column] 列属于 [parent] 的子窗口。</span></span><br><span class="line"><span class="function">WINDOW *<span class="title">subwin</span><span class="params">(WINDOW *parent, <span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>子窗口与普通窗口的区别在于它与其父窗口共用屏幕储存空间， 子窗口修改时父窗口会直接受到影响。 比如新建了 stdscr 的子窗口 win ， 那么输出到 win 后想显示在屏幕不调用 wrefresh 而是调用 touchwin(stdscr) 。 touchwin 用于标记一个窗口被修改。</p>
<h3 id="销毁窗口">销毁窗口</h3>
<p>调用 delwin 销毁窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delwin</span><span class="params">(WINDOW *win)</span></span>; <span class="comment">// 销毁 [win] 窗口</span></span><br></pre></td></tr></table></figure>
<p>窗口销毁后其在屏幕上对应的内容不会改变。</p>
<h2 id="离开">离开</h2>
<p>有时候可能需要离开 ncurses 回到行缓冲模式做些事情而且需要在之后回到 ncurses 。 例如 Vim 里面输入 :!ls 就会退出 ncurses 运行 ls 命令，并在用户敲下回车后回到 ncurses。</p>
<p>调用 def_prog_mode 暂存，调用 reset_prog_mode 恢复。</p>
<h3 id="示例">示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  initscr();</span><br><span class="line">    printw(<span class="string">&quot;Hello World !!!\n&quot;</span>);</span><br><span class="line">    getch(); <span class="comment">// 等待用户输入</span></span><br><span class="line">   def_prog_mode(); <span class="comment">// 存储当前tty 模式</span></span><br><span class="line">   endwin(); <span class="comment">// 退出 ncurses 模式</span></span><br><span class="line">   system(<span class="string">&quot;sh&quot;</span>); <span class="comment">// 返回普通的行缓冲模式</span></span><br><span class="line">    reset_prog_mode(); <span class="comment">// 返回到 def_prog_mode() 存储的 tty 模式</span></span><br><span class="line"> refresh(); <span class="comment">// 刷新屏幕（必须！）</span></span><br><span class="line">  getch(); <span class="comment">// 等待用户输入</span></span><br><span class="line">   endwin(); <span class="comment">// 退出 ncurses 模式</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出中文等非-ascii-字符">输出中文等非 ASCII 字符</h2>
<p>事实上 ncurses 并不支持直接输出中文， 这意味着调用 printw("中文") 会是一堆乱码。 解决方案如下：</p>
<h3 id="安装库">安装库</h3>
<p>这需要另一个库。 通过 <code>sudo aptitude install libncurses5 libncursesw5 libncursesw5-dbg libncursesw5-dev</code> 安装</p>
<h3 id="头文件">头文件</h3>
<p>一定是 <code>#include &lt;ncurses.h&gt;</code> 而不是 <code>#include &lt;curses.h&gt;</code> 。 另外在 main.cpp <code>#include &lt;locale.h&gt;</code> 。</p>
<h3 id="调用">调用</h3>
<p>在调用 initscr() <strong>之前</strong> 调用 setlocale(LC_ALL, "") 。</p>
<h3 id="编译">编译</h3>
<p>将 <code>-lncurses</code> 参数改为 <code>-lncursesw</code> 。</p>
]]></content>
  </entry>
  <entry>
    <title>北京游记</title>
    <url>/2019/10/01/%E5%8C%97%E4%BA%AC%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>Q: 我天天盯着你高考 (gq) 怎么一直没更新啊？<br />
A: 懒。</p>
<p>因此这实际是一篇事后回忆。</p>
<h2 id="day0">Day0</h2>
<p>昨天晚上特意没去学校回了家，想着离高铁站近可以晚点起床，<br />
<del>真相是需要回家拿电脑</del><br />
然而大早上 6 点就被叫了起来，早餐都没吃就直接送到了高铁站，<br />
emm 还有大半个小时才检票，果断拿起颓书开始颓废，<br />
不要问<a href="">为什么不玩电脑</a>，心塞。</p>
<p>高铁上还是贼无聊，幸好准备了颓书，<br />
而且还可以蹭旁边的人看《生活大爆炸》。<br />
还行，比上次去安徽好得多。</p>
<p>出高铁再做地铁去北大，北京地铁线比长沙多得多，<br />
全程没搞清往哪走，迷迷糊糊地跟别人跑。<br />
下了地铁第一反应就是，热，真热，贼 NM 热，<br />
地理菜狗还以为北京纬度高就会比较凉快来着。</p>
<p>至于住的酒店，我敢说这是我住过最差的酒店了，<br />
整一偏僻平房（有点像四合院？），里面要啥没啥，<br />
卫生条件极差，听隔壁德拉说他们床头粘了 10+ *** ，部分带红，估计是 **** 。<br />
水龙头都 tm 生锈了，淋浴喷头竟然对着马桶。<br />
之前住安徽时还喷了那宾馆来着，现在感觉那简直是天堂。</p>
<p>晚上还是很 nice 的，上一届北大的信息组学长们请我们吃饭，<br />
特意选了一家比较符合湖南人口味的饭馆，<br />
吃完饭后被拉到北大到处乱转，<br />
北大确实很漂亮，晚上没什么灯，不是灯火通明的那种喧嚣繁华，比较安静，<br />
还有未名湖，不敢随便形容，不过听说每年都有人不小心掉下去。</p>
<h2 id="day1">Day1</h2>
<p>上午的开幕式已经忘了讲了什么了，<br />
大概是大谈信息学发展，北大的优势和竞赛生在北大的学习方向。</p>
<p>北大食堂贼多，不过我们可以吃的只有三个，农园最近，大家就都去了农园，<br />
还不错，至于消费我跟本没注意，反正看到还行的就拿了。。。发的 100 元的卡应该够用的。</p>
<p>下午的考试，萎出天际，可能是没有找到状态吧，<br />
三道题目一点思路都没有，真的就是只想得到暴力，还是最暴力的暴力，<br />
结果暴力还打挂了，明明过了样例过了自测数据，但是就上去就是使劲 WA 。<br />
正常考试处于崩溃和半放弃的状态，最后得到了 18' 的好成绩。</p>
<p>本来挺乐观的，以为和省选一样，大众分就是几十分，<br />
然而问了一波成绩发现某 Jian 200+ 。。。<br />
好吧是我凉了。</p>
<p>于是颓了一晚上，打 generals ，看敖厂长，本来想打饥荒然而被我的 XP 折服了。</p>
<h2 id="day2">Day2</h2>
<p>上午大师讲座 <del>master 牛逼</del> ，请的外国的一位教授，图灵奖获得者。<br />
这次讲座我感触很深，受益匪浅，得到了一个教训和今后的一个小目标：<br />
好好学英语。<br />
woc 英语菜狗全程懵逼啊，除了黑板上画的图什么都搞不懂。<br />
讲完后还有学生提问题的环节，看着别人和教授谈笑风生，对我就加密了一样。</p>
<p>《论常规课的重要性》</p>
<p>下午考试心态比较佛，已经清楚翻盘无望了，<br />
看了三道题后只感觉有一题可做，题意大概是这样：</p>
<p>给定一颗 n 个点的树，将其放在 m 维空间里，<br />
需要满足每两个点的曼哈顿距离与其在树上的距离相同。<br />
求出一个使 m 最小的放置方案。</p>
<p>一个维度在树上只能管一条链，题目可以转换为最小链覆盖。<br />
然而我考场上的转换方式不太一样，更复杂，每条链要去掉 lca,<br />
于是我就搞了个 dfs 去求这玩意，交上去过了 subtask1 和 subtask3 。<br />
woc? subtask3 是没有限制的，讲道理过了 subtask3 就一定可以过 subtask2 。<br />
仔细分析发现 dfs 儿子的顺序会有影响，没想出来怎么去掉这个影响，于是开始操作。<br />
我 dfs 的时候选择 size 最大的一个儿子去递归，再交，还是一样。<br />
我 dfs 的时候选择叶子数最大的一个儿子去递归，再交，还是一样。<br />
我 dfs 的时候随机选择一个儿子去递归，再交，过了 subtask1 和 subtask2 。<br />
Nice 啊综合一下呗，根据输入数据特判一下，如果是 subtask2 就随机递归，subtask3 就自然递归。<br />
成功 AC ，最后 122' 。</p>
<p>晚上贼颓，因为明天不用考试嘛，于是爆肝小游戏，都是颓过的人，细节自己想都想得出。</p>
<h2 id="day3">Day3</h2>
<p>闭幕式。</p>
<p>出题人出来讲题了，果然是吉司机（和另外一个不知名人士），<br />
题面中全是“九条可怜是个爱...的女孩子”。<br />
但正如他本人所说，这次的确没有什么麻将啊斗地主啊之类的题，<br />
整体偏向思维，没有毒瘤数据结构，没有大模拟。<br />
好吧回想起来比赛质量确实很好，可能在吉司机画的那个图像的最高点附近吧。</p>
<p>颁奖的时候就只能看着了，连个安慰奖都没摸到，自闭了。</p>
<p>中饭进哥请食堂，吃完后就回去了，<br />
高铁上巨颓，拷了两季生活大爆炸后直接开始追剧，<br />
除了中间吃泡面外就没停（包括教练过来查水表）。<br />
感觉被带进坑了。</p>
<p>常规快乐。</p>
]]></content>
  </entry>
  <entry>
    <title>多项式的运算</title>
    <url>/2019/10/01/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<p>简单来说，形如 $ a_0 + a_1X + a_2X^2 + ... + a_nX^n $ 的代数表达式叫做多项式， 可以记作 $ P(X) = a_0 + a_1X + a_2X^2 + ... + a_nX^n $ （系数表示法）， a 叫做多项式的系数，X 是一个不定元，不表示任何值， 不定元在多项式中最大项的次数称作多项式的次数。</p>
<h2 id="加减">加减</h2>
<p>两个多项式 a, b 的和 a + b 是一个多项式 c ，满足： $ x, c(x) = a(x) + b(x) $</p>
<p>两个多项式 a, b 的差 a - b 是一个多项式 c ，满足： $ x, c(x) = a(x) - b(x) $</p>
<p>多项式的加减十分自然，实际运算中也只需要按定义 O(n) 枚举即可。</p>
<h2 id="乘">乘</h2>
<p>两个多项式 a, b 的积 a * b 是一个多项式 c ，满足： $ x, c(x) = a(x) b(x) $</p>
<p>此时将 a, b 的系数按分配率展开求 c 的时间复杂度为 O(n * m) ， n, m 分别为 a, b 的次数，不难得出 c 的次数为 n + m 。</p>
<p>快速求多项式乘积的方法是 $ O(n log_2n) $ 的 <a href="">FFT</a> 或 NTT 。</p>
<h2 id="除">除</h2>
<p>两个多项式 a, b 的商 a / b 是一个多项式 c ，满足： $ x, c(x) = a(x) / b(x) $</p>
<p>众所周知多项式除法可以列竖式求解， 这样做与乘法一样复杂度为 O(n * m) 。</p>
<h2 id="取模">取模</h2>
<p>正如整数除法会有余数，多项式除法也不一定整除， 此时 a / b 会余一个多项式 c ， 正如整数除法中余数小于除数， 此处也要满足 c 的次数小于 b 的次数以保证唯一性。</p>
<p>具体来说，对于多项式 a, b 存在唯一的多项式 c, d 满足： a = b * d + c 且 c 的次数小于 b 的次数， 便称 c 是 b 除 a 的余数，即 a 模 b 的结果， d 是 b 除 a 的商。</p>
<p>值得注意的是，当模数 b 可表示为 $ b(x) = x^k $ 时， a 模 b 相当于将 a 舍弃所有次数大于等于 k 的单项式的结果。</p>
<h2 id="逆元">逆元</h2>
<p>对于多项式 a ，其在 mod p 意义下的逆元 b 满足： a * b mod p = 1 且 b 的次数不比 a 大 （此处的 1 实际上是指只有常数项为 1 而次数为 0 的多项式）， a 的逆元通常记为 $ a^{-1} $ 或 inv(a) 。</p>
<p>那么在 mod p 意义下，有 $ a / b = a b^{-1} $ 。</p>
<h2 id="逆元的求解">逆元的求解</h2>
<p>事实上模数一般是 $ x^n $ 。</p>
<p>此时可以用分治求多项式 a 的逆元 b。</p>
<p>假设已经分治求得了 a 模 $ x^{n/2} $ （此处及以下除法表示向上取整）的逆元 c 。 那么有： <span class="math display">\[ a  \cdot  c \equiv 1 (mod \; x^{n/2}) \;\;\;\;\; (1)\]</span> 由 b 的定义可知： <span class="math display">\[ a  \cdot  b \equiv 1 (mod \; x^n) \;\;\;\;\; (2)\]</span> 转换为： <span class="math display">\[ a  \cdot  b \equiv 1 (mod \; x^{n/2}) \;\;\;\;\; (3)\]</span> (3) - (1) 得： <span class="math display">\[ b - c \equiv 0 (mod \; x^{n/2}) \;\;\;\;\; (4)\]</span> 两边同时平方得： <span class="math display">\[ b^2 - 2bc + c^2 \equiv 0 (mod \; x^n) \;\;\;\;\; (5)\]</span> 两边同时乘 a 得： <span class="math display">\[ b - 2c + c^2a \equiv 0 (mod \; x^n) \;\;\;\;\; (6)\]</span> 移项，整理： <span class="math display">\[ b = (2c - c^2a) \; mod \; x^n \]</span></p>
<ol start="4" type="1">
<li>-&gt; (5) 中模数平方的原因： 左边多项式模 $ x^{n/2} $ 为 0 代表该多项式每一项最低次数为 n / 2 + 1 。 那么该多项平方后最低次数会是 n + 1 或 n + 2 ， 模 $ x^n $ 后仍为 0 。</li>
</ol>
<p>于是乎分治，直到 n == 1 ，此时多项式的取模为一个常数，逆元也就是整数的逆元。</p>
<p>其中乘法使用 FFT ，则最终时间复杂度为 $ O(n log_2n) $ 。</p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 I</title>
    <url>/2019/10/01/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20I/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p>
<p>Day0 to Day4.</p>
<h2 id="day0">Day0</h2>
<p>大清早的就出发了，地铁还是那么挤。<br />
先从长沙坐到南京，高铁上干坐 6 个小时贼贼贼贼贼无聊。</p>
<p>中午幸好提前买了泡面，随便应付一下，坐了一上午不动也不会感觉饿。<br />
%%% 在高铁上一餐吃 70rmb 的 lzk 。</p>
<p>到了南京还得等 1 小时转到芜湖，期间 UNO 现学现玩，<br />
第一把就赢了，一定是传说中的新手的欧气附体，<br />
但是这欧气来得快去的也飞快，后面再也没赢过 ，并且一度成为全场最富（一次拿了 20 张牌也是没谁了）。</p>
<p>再到动车上就累了，睡了一觉。</p>
<p>宾馆感觉一般但也还行，位置不错，旁边就是美食街，<br />
逛一遍发现芜湖的物价似乎比长沙要便宜得多？<br />
这里奶茶只有长沙一半多的价格还巨好喝，还有木桶饭最便宜 8rmb, 最贵也 16rmb, 吃得相当饱，提供的辣椒酱好评。</p>
<p>晚上宾馆自习，我的笔记本实在实在实在是太 tm 旧了 windows xp 实在实在实在是忍不了啊。<br />
宾馆的 wifi 都连不上去我怎么怎么打（kan）代（dian）码（ying）啊？？？<br />
还有我早已练就一身折腾本领，小事，关掉 XP 的沙雕代理轻松解决。<br />
但是网络实在是 suo （也许是我电脑不行？），努力了一晚上都没能成功看上电影。</p>
<h2 id="day1">Day1</h2>
<p>第一天考试，凄惨爆 0 。<br />
考试的时候想不出题啊（<del>我太菜了</del>），比较心不在焉，<br />
才发现打满暴力都是一种困难，水平不够。<br />
%　一 % 成功拿满暴力的 CZZ, orz 。</p>
<p>第一题维护区间历史最小和，玄学转换到二维平面 KD-Tree, 这玩意前几天刚考但是没去学，<br />
<del>我发现冷门算法一考就会连续考几次</del>。</p>
<p>第二题一脸不可做，题目名叫因式分解，我也就真的只会因式分解了。<br />
讲题的时候满分做法爆搜？？？好吧正解还是要个 DP 的。</p>
<p>第三题式子题妙啊妙啊，这什么用 $ _{i=0}^{n-1} A^i =  $ 把 $ A^n $ 换掉的清奇思路谁想得到啊。<br />
还有把 f(i) O(1) 一路推到 f(n) 再用组合数的奇技淫巧把 k 到 n 的枚举换成 1 到 k 谁想得到啊。</p>
<p>还有吐槽一下这套题部分分好少，几乎只有两档：暴力 -&gt; 正解。</p>
<p>然后就是晚上的 <del>自由欢乐时光</del> 认真自习。<br />
终于成功把昨天的电影看了一半。<br />
然后颓了一晚上也是没救了，没办法 T3 被卡常心态爆炸（这就是你颓废的理由？）。</p>
<h2 id="day2">Day2</h2>
<p><del>成功拿到预期的暴力分 30，一大进步。</del></p>
<p>第一题图染色，考场上脑子不清醒，很快想到 $ O(n^2) $ 的建图方式后，<br />
竟然完全没有想到怎么计数，最后 $ O(n^n) $ 枚举染色方案可还行。<br />
于是 40' -&gt; 10'</p>
<p>第二题又是一个计数，AC 自动机？我完全没想到，<br />
我还以为是容斥，但是发现有有 5 种情况，容斥起来要 5 + 10 + 10 + 5 种情况加加减减，<br />
没敢打，不过这次这题部分分给的挺全的，分了 10 个 subtask 还是不错的 ~~虽然我只拿了 20 ~~ 。</p>
<p>第三题玄学最短路，要用最短路树（我想到了但是没啥用），这玩意前几天 czz 才讲，<br />
<del>果然又应验了我昨天说的，一考就连续考几次</del><br />
暴力都很难打啊这题，到最后只能 <code>puts("-1")</code> 了，然而 subtask 数据捆绑。</p>
<p>一考完就被 *** 拉去吃什么网红烤冷面（然而是热的），very nice but 量有点少。<br />
然后 *** 就拉了一堆人去星巴克 666 ，讲真这是我第一次在星巴克喝咖啡，忍痛剁手。<br />
晚上到宾馆就开始颓，终于看完了昨天的电影 <del>壮哉我大火影</del> 。</p>
<h2 id="day3">Day3</h2>
<p>今天的题目巨难，听出题人说是因为他明天赶时间所以把明天的 <del>毒瘤</del> 题全放今天就有更多时间讲。</p>
<p>第一题在 2 * n 的网格图上求一个生成树，我想到有个类似的题（求 2n 的网格图上放一颗树的方案数），<br />
但是那道题我已经忘记怎么做了，而且那是计数，而这题是要求一个最优方案，<br />
反正就是以为可做然而 Naive, 浪费了很多时间最后打了枚举生成树的大暴力。<br />
考场上有一个线性计算当前方案的算法，枚举的时候加一点小剪枝，总复杂度应该是 $ O(6^n n) $ ， 预计 20' ，但是实际上还是只有 10' 。</p>
<p>第二题感觉是什么数据结构题，我按照一种贪心思路敲了线段树，<br />
估摸着有 23' 就没管了，后来出题人放了三个大样例，我一测，第一个就 WA 了，改了一点细节后过掉了，<br />
再测第二个，又 WA 了，然后 debug 了好久才意识到贪心的思路不对，这个时候离考试结束只有 5min, 弃疗。<br />
然后和预计的一样，3' 。</p>
<p>第三题是在一个很奇怪的图上面求最短路为 x 的点对（怎么又是最短路），<br />
大暴力就是跑出每个点对的最短路再统计嘛，这个图发现了一些性质，但是还是不会做，<br />
想着应该不难打就去打 T2 了，然后 T2 打到结束前 5min 所以这题的暴力也没打， 0' 。</p>
<p>今天的部分分还是很少，T2 T3 的暴力都只有 3' ，难受。</p>
<p>中午去一个东北菜馆吃饭，菜上的k慢但是挺好吃，很有特色，<br />
最抢眼的是收银台前面的冰箱，里面一条<strong>巨大</strong>的鱼（完整一条的可能比我还大？）。</p>
<p>下午有洛谷月赛，于是冠冕堂皇地不改题打月赛，洛谷月赛一如既往，除了签到题都只能打暴力。</p>
<p>晚上险些被查水表，我正在听歌教练突然敲门，我当时就以迅雷不及掩耳盗铃儿响叮当仁不让世界感受痛楚汉相争之势拔掉了耳机。<br />
没错，拔掉了耳机，然后 tm 就变成外放了声音贼大，当时就感觉自己真是沙雕了我去，<br />
然后我又以迅雷不及掩耳盗铃儿响叮当仁不让世界感受痛楚汉相争之势插上了耳机（被自己秀死了），这个时候教练已经差不多进来了，然后交代一些事，我耳机就插在笔记本上光明正大地摆桌上，有点小可怕，还好教练没有说什么。。。</p>
<p>从今天开始教练晚上要强制收电脑，于是 10:30 电脑被收后无所事事，<br />
这时候大家都要睡了（比如柠檬 9:30 就交电脑睡了），可是<del>万恶的</del> *** 以睡不着的名义把我拉过去打 UNO,<br />
然后我<del>只能被逼无奈地</del>去打 UNO, 到 11:30 才睡可还行。</p>
<h2 id="day4">Day4</h2>
<p>今天终于 A 了一题，今天终于 A 了一题，今天终于 A 了一题。<br />
还有 % 一 % 全场 rank1 的柠檬。</p>
<p>第一题我手玩了一下得出了一个十分精简的结论，按照这个结论三四十行代码就能解决，<br />
自己都不敢相信啊，今天终于有一道良心签到题了？<br />
于是打出来后不停地调试，手造各种情况的数据都跑一遍，把之前的结论完善一些漏洞之后就交了，<br />
交了之后还是有点慌，生怕哪里出锅。<br />
最后还是成功 AC （四天来唯一一次）。</p>
<p>第二题刚开始看题还觉得可做，感觉像扫描线加线段树那种，<br />
但是看到可能有一面墙回塌后就不这么觉得了。<br />
而且我还看错了样例，这直接导致我误解题意，本来是先选点再有墙塌（考虑方案的时候不知道哪个墙会塌），<br />
我看样例这样跑出来不对（其实是我手玩玩错了），就以为是先塌墙再选点（提前知道哪面墙会塌后考虑方案），<br />
于是 blablabla 后交上去，预计至少有个二三十来分，结果只有大暴力 3' （还好大暴力的数据没卡掉我）。</p>
<p>第三题就感觉完全不可做了，最后暴力都没打， 0' 。<br />
下午讲题的时候才发现这题 25' 的部分分贼容易，就是个排序加贪心。<br />
另外 75' 正解好像是用 dp 做前面 25' 在对后面 75' 的求和用 dp 套 dp, 好巧啊之前朱哥才讲过。</p>
<p>A 了一题心里比较舒服，于是下午就颓了好久，打 Nazo 自力更生到 level 8 就不会了，<br />
在网上找提示后玩到 level 11 后再次卡关。</p>
<p>另外碰到一件玄学的事，我那显示器一碰就断电，然后要不断地调那根线，<br />
直到调到某个位置才可以打开，大概是因为接触不良，<br />
然后一次又黑了，我调了贼久试遍了各种姿势还是然并卵，<br />
没法子了，去找老师实在不行换个位置，<br />
老师了解状况后过来随手一拨，真的是 <strong>随手一拨</strong> ，那显示屏就开了，就开了，开了，了，<br />
emm 不愧是金牌教练，真的 6 。</p>
<p>晚上本来去吃必胜客的，但是没注意到今天周日，人巨多，排队等座位都要半个小时，<br />
几经周折最后去了 KFC ，也还不错。<br />
旁边一家奶茶店搞活动，把一个计时器按到刚好 10s 就能领两大杯奶茶，然而大概是我脸黑，按了 3 次都差的蛮远。 晚上又是 UNO, 和 tyr 无意间相互精准放炮，<br />
连续两次 tyr （下家）只剩一张牌，我掐指一算，猜到了那张牌的颜色，<br />
自信地打出一张其它颜色牌，结果和他数字相同。。。</p>
<h2 id="next">NEXT</h2>
<p><a href="/2019/03/26/安徽游记-ii/">Day5 to Day8</a></p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 II</title>
    <url>/2019/10/01/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20II/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p>
<p>Day5 to Day8.</p>
<h2 id="day5">Day5</h2>
<h3 id="考试">考试</h3>
<p>Nice 大夫今天又 A 掉一题！</p>
<p>第一题是在 DAG 上 q 个询问，每次询问一个子图的路径数量（子图点数和 O(n) ），<br />
我想了想部分分， DAG 上 DP 嘛，但是这样复杂度上界是 $ O(q m) $ ，<br />
瓶颈在于边的枚举（菊花树卡爆），然而子图的点可能很少，<br />
然后想到了更暴力的：邻接矩阵存图然后用枚举点代替枚举边，<br />
事实上邻接矩阵存不下，那就开 set （map 也行）动态加，<br />
这复杂度 $ O(q n^2 log(m)) $ 啊然而，然后我想了好久优化都没想出来，<br />
最后想着得多骗点分，于是就把两个暴力结合在了一起：<br />
每次询问比较 $ n^2 log(m) $ 和 $ m $ 哪个小就跑哪个。。。<br />
看上去很鸡肋，然而我理性分析了一波复杂度卧槽好像是 $ O(q m  log(m)) $ ，<br />
应该能骗蛮多分，于是交了，然后 A 了。。。</p>
<p>第二题又是个计数，感觉像容斥，容斥之后怎么搞就有点迷，<br />
于是写了个 dp ，手玩样例感觉没错，然而一测大样例就 WA 了，<br />
于是手玩了几组数据，才发现 dp 错了，区间相交的情况没考虑好，<br />
最后实在没思路，就打了个大暴力，有 30', 还不错（ 10 倍于前面两天的暴力分 3' ）。</p>
<p>第三题哇塞维护一棵树，一看就感觉是树剖 + 线段树或者 LCT 之类的数据结构题，<br />
然而还是不会，又敲了一发大暴力 10' 走人。。。</p>
<h3 id="讲题">讲题</h3>
<p>下午讲题，一看 ppt 下面一行字：--Claris<br />
woc 今天见到真人了，那位 bzoj 4000+ ac 的神仙！<br />
第一题正解是按度数大小关系连边，出题人说数据难造所以有这种带 log 的算法卡过去了。<br />
第二题果然是容斥，但是要通过一个奇妙的矩形构造转换为轮廓线 DP 。<br />
第三题出题人说并不是数据结构题？blabla 讲了一堆奇妙的做法，<br />
然而有 4 个人用动态 DP 搞过去了，出题人想到了这一点还特意去卡了但是没卡掉。</p>
<h3 id="颓废">颓废</h3>
<p>昨天没吃成必胜客来着，今天再次尝试，又剁一波手。<br />
晚上真是诸事不利，tmd 这笔记本真的让人心累，<br />
要啥没啥，网连续断了好几次，还真就不是网的问题，众人不断就我断，<br />
什么 u 盘硬盘全没用，放我电脑上就读不到，<br />
蓝牙更是做梦，键盘只能插线就算了还一老读不到，<br />
还什么显像管出问题？动不动一些地方就全是红色的跟看恐怖片似的，<br />
说优点倒也有，用个电脑火炉都省了，贼发热，那电风扇的声音时刻提醒你它还活着，<br />
它要是太烫了还会自动关机，把你烤热了再降降温，贴心，<br />
放歌听也很棒，我听快歌，它就一卡一卡的，一个字一个字给你放，根本不用怕听不清。<br />
还能智能存储电量，充电线一拔就晓得要存储电量直接断电，不插上充电线不给开机，保证电池里的电永远满的。<br />
别的什么还有一堆，懒得喷了，难受。</p>
<h2 id="day6">Day6</h2>
<h3 id="考试-1">考试</h3>
<p>前两天把 rp 用完了，今天全暴力都写挂。</p>
<p>第一题我一开始推出个错误的结论，然后一想可以离线排序询问再预处理 dist 根据询问不断删除，删除不好搞换成加边弄个并查集维护联通块，<br />
然而代码打完后一跑样例， WA 了，手玩样例才发现结论错了，这时候已经 9:30 了，凉凉，后面两题还没看。<br />
最后打了大暴力 10'。</p>
<p>第二题题读到一半就感觉是二分，读完题后推了一下发现可以转换成这样一个模型：<br />
二维平面上给定 n 个点，每次将一条平行于 y 轴的直线右边的点都向上平移 dy 单位并回答所有点的斜率 (y / x) 的最大值。<br />
然后就有了 $ o(n^2) $ 的暴力做法，这玩意一脸可以优化的样子，然而想了好久没思路，就交了 60' 。</p>
<p>第三题网格图 DAG, 感觉像要 dp ？但是不会，就打了暴力，结果还打挂了 RE ，爆零。</p>
<h3 id="讲题-1">讲题</h3>
<p>第一题什么神仙 dp $ O(n^4) $ 过 100 可还行，我太菜了没搞懂这个 dp ，<br />
但是出题人提到有枚举端点 + 组合数的做法，我想去看看，一看哇塞简单多了，<br />
而且复杂度优秀的 $ O(n^3) $ ，下午按照这个作法改了一段时间就 A 了（<del>期间没开 long long 一直爆炸</del>）。</p>
<p>第二题好像是可以从我那个模型再转换一下后分块 + 凸包维护，感觉很神仙。</p>
<p>第三题有个神奇的结论：<br />
用两个不同的顺序得到的 dfs 后序，u 可以到 v 当且仅当 v 的两个 dfs 序都比 u 的小。<br />
然后就可以将点按一个 dfs 序排序后按颜色设状态 dp, 把 dp 数组扔进树状数组后得出答案。</p>
<h3 id="颓废-1">颓废</h3>
<p>晚饭兰州拉面，清真的店子就是讲究，还贼好吃。 晚上感觉屁事没干，教练发了一套题要我们做（考试的题都改不完啊），<br />
实在不想做，反正明天收，晚上就几乎一直在颓，找歌听。</p>
<h2 id="day7">Day7</h2>
<h3 id="考试-2">考试</h3>
<p>100 % 纯暴力的一天。</p>
<p>第一题神仙计数题？好难啊感觉，于是想了想了 k 小于等于 3 会不会有什么规律可循，<br />
发现 k = 1 的时候就是 $ 2^{n-1} $ ，就得到了 1 分的好成绩（这分给的真少）。<br />
然后再手玩了一下 k = 2 和 k = 3 的情况，找到了一种计数方式，过了样例，就交了，<br />
然并卵，k = 2 和 k = 3 的情况错了，只有 1' 。</p>
<p>第二题感觉是什么 set 启发式合并，但是合并之后只能暴力搞答案，<br />
没思路，打了暴力，5 分的好成绩。</p>
<p>第三题我靠麻将小模拟大搜索题？感觉很复杂，而且到第三题也没什么时间了，<br />
于是打了一发只有字牌的特殊情况，20 分的好成绩。</p>
<h3 id="讲题-2">讲题</h3>
<p>出题人说这个题目难度是 T1 &gt;= T2 &gt;= T3 。</p>
<p>T3 果然就是搜索，先算出最大答案（就是 9 ）统计面子搭子的数量再减答案。</p>
<p>T2 线段树合并，玄学，还不会。</p>
<p>T1 真有意思，标程生成函数加一大堆什么多项式的优化之类的，复杂，没懂。<br />
但是有位大佬考试 27 分钟后就 A 了这题，出题人叫他上来讲讲，<br />
然后他就开始秀操作：<br />
“我的直觉告诉我 % n 等于 0 的方案和 % n 等于 x 的方案是一样的，然后就可以算出总方案数再除以 n 就可以......” ，<br />
然后抄起笔写出一个式子，就是总方案数，<br />
我靠这式子也贼好懂，全场都笑喷了，这大抵就是“爆踩标程”了吧，复杂度还更优秀。<br />
出题人一脸懵逼，看了眼式子无奈的说了一句好吧那就这样吧。 做法就是考虑每个排列的贡献，枚举颜色的种类再用组合数和第二类斯特灵数算出这样的排列数再乘上贡献。 时间复杂度直接实现都是 $ O(k^2) $ （ k 只有 100 ，可见标程被爆踩），<br />
把斯特灵数那部分的预处理用 NTT 优化复杂度就是 $ O(k logk) $ ，<br />
听说还可以优化到 $ O(k) $ ，不会，但对这题来讲也没必要。</p>
<h3 id="额外肝题">额外肝题</h3>
<p>教练还额外发了一套题来着。<br />
扫了遍题目，感觉第二题比较友好：<br />
交换 i, j 枚举顺序后就把那个斯特灵数求和的部分设为函数 g ，<br />
根据斯特灵数的递推，g 这玩意也是可以递推的，中间需要用到一排斯特灵数。<br />
根据斯特灵数的容斥意义 NTT 预处理一排斯特灵数即可（卧槽这不就是上午 t3 吗）。<br />
<del>代码实现中，还没打完，随时准备被打脸。</del></p>
<p><del>今天晚上竟然没有颓。</del></p>
<h2 id="day8">Day8</h2>
<p><del>咕掉了</del></p>
<h2 id="next">NEXT</h2>
<p><a href="/2019/03/29/安徽游记-iii/">Day9 to END</a></p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 III</title>
    <url>/2019/10/01/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20III/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p>
<p>Day9 to Day12.</p>
<h2 id="day9">Day9</h2>
<h3 id="考试">考试</h3>
<p>炸了，今天出的题好诡异。</p>
<p>第一题一道博弈论，题意好迷，没太看懂就去做后面的题了，<br />
到后面离考试只有 5min 了再回来看 T1, 暴力都好难打，<br />
于是信仰一波 <code>std::cout &lt;&lt; 0 &lt;&lt; std::endl</code> ，水到了 12' 。</p>
<p>第二题是给出将数组 a 变换到 b 的方式，要求用 b 求 a ，<br />
式子里面有按位或、异或、bicount 什么的，莫非是 FWT ?<br />
于是推式子，如果真的是 FWT 的话求出 a 到 b 的变换应该可以推出 b 到 a 的逆变换。<br />
于是乎我花了一个小时搞来搞去，重新推了一遍 FWT （这个式子真的 6 没办法套用常用的位运算卷积），<br />
果然可以从 a 用分治 3 个 for $ O(n log(n)) $ 变换到 b 。<br />
但是和普通的 FWT 最不一样的就是这玩意不能“蝴蝶变换”，仅从 x, y 两个数推不到新的 x, y 。<br />
woc 那我怎么解方程求逆变换？当时有点绝望了开始怀疑 FWT 做不了，<br />
又去看了看 T3 ，不可做啊似乎，于是决定爆肝 T2 。<br />
我就手玩小数据，推推式子再找找规律，搞了大概 1h 发现把 b 做一遍异或逆变换再乘二再把 b[0] 减去原来的 b[0] 好像就是 a ！<br />
我还证明了它在 n 小于 8 的正确性，然后手玩了 n = 8 时的情况，错了。。。<br />
再次绝望，想了好久大概又过了 30min 吧突然发现之前手玩算错了，我靠重新手玩，完全符合规律。<br />
<del>好嗨哟，感觉人生达到了高潮</del><br />
快速敲完 KET （ kewth 变换可还行）交了上去，结果最后爆 long long 了，爆 long long 了， long long 了，了。。。<br />
100' -&gt; 60'</p>
<p>第三题交互题，实在没思路就想着能不能卡掉他的交互器来玄学 AC ，<br />
（以下玄学操作，请勿模仿） 为此我研究了大约 40min 的 syzoj 交互原理。<br />
考场上的提交得不到反馈，我就去同样用 syzoj 的 LOJ 上试着提交一下尝试尝试。<br />
然后第一波提交， CE 。。。<br />
改了一下再次提交， wating, wating, wating....<br />
woc 无限 wating? 感觉不对经，看了看 LOJ 的评测记录，然后。。。<br />
woc 自我 CE 代码后的所有评测全是 wating 不动，当时就懵逼了 loj 被我卡爆了？<br />
事实证明只是 loj 卡了一下，过个 3min 的样子就恢复了。。。<br />
我还读了下下发的交互器，于是我搞懂了这玩意的交互原理，<br />
但是实际的交互程序是另一个程序，下发的交互器只是和你的代码一起编译后和交互程序交互，<br />
看了看交互器最后 AC 的输出，然后在 solve 函数里打了份一样的就 exit(0) ，交了。<br />
结果。。。没过，实际评测的交互器和下发的交互器完全不同。。。（但是确实可以卡，后面会说）</p>
<h3 id="讲题">讲题</h3>
<p>今天的讲题真欢乐，一位大佬屡次上台嘲讽出题人。</p>
<p>T1 就是 dp 啊，加个启发式合并状态，如果不把时间浪费在 T3 说不定能想出来的。</p>
<p>T2 不想说了，心累，在变换过程中做除法就不会爆 long long ， AC 。</p>
<p>T3 随机分治？感觉挺 6 但是没懂。<br />
但是我还是通过奇技淫巧 AC 了。。。</p>
<h3 id="爆掉这辣鸡交互">爆掉这辣鸡交互</h3>
<p>我还真不信这交互器天衣无缝，再次看交互器，<br />
交了几个错误的程序，发现我能得到的信息只有交互程序给出的信息，<br />
再蠢也不会把重要信息放提示信息里头嘛，感觉似乎没办法了。<br />
又交了一次， CE 了。。。<br />
这时转机出现了，我看了眼编译信息， woc nice 大夫 g++ 给的编译信息真详细：</p>
<pre><code>/sandbox/1/a.cpp:5:6: error: &#39;QCNT&#39; was not declared in this scope
out,QCNT,&#39;\n&#39;;
  ^
/sandbox/1/a.cpp:5:6: note: suggested alternative:
In file included from /sandbox/1/a.cpp:2:0:
/sandbox/1/c.h:74:5: note:   &#39;lkjjhkfdlhgkjdfgf5454::QCNT&#39;
int QCNT;</code></pre>
<p>note 那一排暴露啦，这命名空间 lkjjhkfdlhgkjdfgf5454 也是没谁了（另外还发现了源码的位置 /sandbox/ ）。<br />
但是出题人以为套一个乱七八糟的 namespace 就没事了？<br />
然而还是被我发现了哈，于是通过这个 namespace 直接获取了交互器里存的答案，<br />
成功 AC ，辣鸡交互器。</p>
<p>看了看提交记录，我是第二个玄学 AC 的，第一个的 AC 代码提交时还没有那 sb namespace ，<br />
所以说，我是第一个发现这鬼畜 namespace 并通过它 AC 的 :)<br />
然后从我 AC 后就陆续有人玄学 AC, 代码我都看了一遍，大同小异，全是用这 sb namespace 过的（变量名、注释都跟我的长一个样），<br />
开创先河哈。</p>
<p>后面再改改就是 65B 全场最短 AC 代码。</p>
<p>后来又看了看，还有一名大佬用另一种方式爆掉了这辣鸡交互器。<br />
比我 6 多了，竟然直接搞到了交互器判 AC 的方式给写 solve 函数上了， %%% 。</p>
<p>声明：<br />
交互器确实是可以做到无法被爆破的，<br />
我今天成功爆掉交互主要原因是交互的封装方式漏洞百出，<br />
把交互的主要部分直接给 include 进来了，<br />
正确的方式是将交互的关键部分写在真正处理交互的通过输入输出交互的程序里面。<br />
去看看 loj 的交互题，把附加文件下下来，<br />
那附加文件就是封装了一下和交互器的交互方式，你不用都没关系。</p>
<h2 id="day10">Day10</h2>
<h3 id="考试-1">考试</h3>
<p>第一题乍一看要动态维护逆序对？感觉不太可做，后面直接交了暴力， 30 分。</p>
<p>第二题字符串，感觉像是贪心，但是有一些情况不好判断，<br />
最后打了字符串做状态的暴力 DP ，我估摸着复杂度是 $ O(n^3) $ ，<br />
于是就只开了 30' 的部分分的数据的大小的数组 n = 100 ，交了，果然是 30' ，<br />
然而我把数组开到 2000 （ 60' 的范围）后就过了 60' ，这。。。<br />
60' -&gt; 30' <del>论复杂度分析的重要性。</del></p>
<p>第三题式子题，乍一看似乎可做，然后简化简化简化，简化成了这样一个题意：</p>
<pre><code>在正整数范围内解方程 x * phi(x) = 2m ，m 已知。</code></pre>
<p>我一看这么简洁的式子，枚举一下 2m 的因子应该差不多了，<br />
一看数据范围： $ m ^{18} $ ，第一档暴力 10' 范围： $ m ^9 $ 。。。<br />
还多组数据，一共 100000 组。。。<br />
连暴力都过不去啊我去。<br />
最后实在没思路，就预处理了一部分 phi 再暴力去搞，结果爆零。。。</p>
<h3 id="讲题-1">讲题</h3>
<p>第一题其实真的容易，根本不要动态维护逆序对，<br />
题目要求的只是使逆序对最小的一个循环的位置，<br />
考虑一个数从最左边被扔到最右边后对逆序对数量的影响，其实是不会变的，<br />
维护这个影响的数列，那么就是要求一个最小前缀和的位置，<br />
每次修改就是交换两段区间，虽然逆序对数量会改变，但是根本不用管，相对的影响还是不变的，<br />
那这玩意一个平衡树搞上去就好了。</p>
<p>第二题我似乎摸到正解的前一半了，<br />
贪心把能直接求的字母搞出来后对于剩下的求一个字典序最大后缀好像是，<br />
<del>那这玩意一个后缀数组搞上去就好了。</del><br />
然而似乎还是要考虑一些情况，还没改出来。</p>
<p>第三题数论神仙题（我竟然以为 T3 可做），<br />
正解复杂度 $ O(log(m)) $ ，神仙做法，<br />
什么二次剩余什么欧拉定理什么质因数玄学分解都用上了，<br />
好难，出题人讲了两遍都没听懂。</p>
<h2 id="day11">Day11</h2>
<p>倒计时两天。</p>
<h2 id="考试-2">考试</h2>
<p>第一题平面图上随机游走求到 n 的期望路径？<br />
30' 高斯消元暴力分比较容易想到，其他的就没思路了，想着先去打后面的题。<br />
最后回来打 T1 的时候连高斯消元都没打出来（我太菜了）。。<del>其实是改昨天的题去了</del></p>
<p>第二题博弈题？乍一看似乎可做，然后简化简化简化，简化成了这样一个题意：</p>
<p>给定数列 a, b, c, 选 a 中的 x 个数替换成任意数使得 $ i: a_{i-1} + b_{i-1} a_i a_{i-1} + c_{i-1} $ 求最小的 x 。</p>
<p>然后这玩意 $ O(n^2) $ DP 嘛 $ O(n) $ 状态 $ O(n) $ 转移，<br />
我以为可以得 10' + 20' + 30' 三个子任务的分，<br />
结果 subtask2 的数据范围比 subtask3 大，但是是一个特殊情况，判掉就好了，我没打。。。<br />
60' -&gt; 40'</p>
<p>第三题没思路，暴力枚举行枚举列枚举每个位置 24k 纯暴力，拿到了 40' 的好成绩。</p>
<h2 id="讲题-2">讲题</h2>
<p>第一题解方程线性代数 blabla, 但是看了看 Rank1 的代码，<br />
发现就是一个矩阵乘法，卧槽 $ O(n^3) $ 过 3000 ？<br />
经 *** 分析，平面图上的边数是 $ O(n) $ （最大是 3n - 6 ），<br />
所以高斯消元里的矩阵的点数是 $ O(n）$ 的，<br />
然后就可以根据之前 pics 讲过的方法 $ O(n) $ 做矩阵乘法（ n * n 的矩阵与列向量相乘），<br />
做 n 遍，复杂度 $ O(n^2) $ 。</p>
<p>第二题似乎是最难的，我挂到 40' 都能是全场 rank1 。。。<br />
难点主要在简化题意上，简化后出题人说这就是个普及题了（ woc 我是不是不适合学信息），<br />
DP 可以优化，设一些坐标搞到平面上后将转移用线段树维护优化到 $ O(log(n)) $ ，<br />
但是把所有点对应到平面后，还有种更简单的做法就是求出最长下降子序列 x, 答案就是 n - x 。<br />
这个结论的证明折腾了一下午，还是很妙的。</p>
<p>第三题暴力优化 dfs 可以水 90 分？<br />
正解先枚举行再筛选列将单调性用桶存起来再转移大概是，正在改。</p>
<h2 id="爆肝-splay">爆肝 Splay</h2>
<p>这三天都在爆肝 Splay, 突然又对 Splay 的翻转操作有了更深的理解，<br />
也发现 Splay 真不是那么万能的，许多操作用 Splay 做会多一些不必要的麻烦，<br />
尤其是维护不对称信息还要带区间翻转的时候，似乎根本做不了？<br />
硬要做的话就必须强制让维护的信息对称，<br />
比如要是维护最大前缀和，要支持区间翻转就得还同时维护个最大后缀和。<br />
不说了，去他的信仰，正在学无旋 Treap 。</p>
<h2 id="day12">Day12</h2>
<p>最后一天。</p>
<h3 id="考试-3">考试</h3>
<p>第一题已看完题 woc 这不就解方程嘛，手动消消元什么的就行了，<br />
出题人这么良心？于是就开始打，打完后测了测样例， woc 过了。<br />
再把大样例下下来一看， woc 出题人这么良心每道题 5 组大样例？<br />
全都测了一遍，全过了，交了，这个时候考试开始 59min 12s 。。。<br />
但是还是很荒，担心会写炸，然后就对着代码检查检查改了几个细节，<br />
改着改着又测了测时间， woc 要跑 0.9s+ ，这不会被卡常吧？<br />
又慌了起来，但是出题人说不会卡常，还下发了 io 模板，<br />
套上 io 模板后再测 0.2s+ ，松了口气，最后交了一次，<br />
这时候考试开始 101min 15s 。。。<br />
考完后看了下，其实我第一次交就 AC 了，白折腾这么久。。。</p>
<p>第二题神奇题，打了个暴力，期望 60' ，<br />
感觉可以把状态放平面上通过单调性什么之类的优化，<br />
但是没有具体的优化方案（我的计算几何真的是一片空白），<br />
结果最后暴力挂了？只有 10' 啊后面 50' 全 WA 了我一脸懵逼。<br />
还在找错。</p>
<p>第三题哇神仙题，一看就不可做的那种，打完暴力后挣扎了一下，<br />
得到了 30' 的好成绩。</p>
<h3 id="讲题-3">讲题</h3>
<p>今天又被爆踩了，T1 A 了一片，拉不开差距。</p>
<p>第二题果然是计算几何神仙题，什么凸包二分三分，什么半平面交，什么李超线段树。<br />
完全不会，只能等我计算几何基础打好后再来重做这题了。</p>
<p>第三题出题人说打表找规律题？反正我是没看出什么规律，<br />
然后出题人证明了一些结论，有这些结论就能 50 行内解决这题了，<br />
正在试图独立证明这些结论。。。</p>
<h3 id="爆肝-treap">爆肝 Treap</h3>
<p>写完暴力自闭之后就滚去学无旋 Treap 了， 看懂后感觉这 split + merge 的操作很 6 。<br />
然后自己写了写，过程中学到一个新操作： <strong>空指针调用成员函数</strong><br />
woc 发现直接用空指针调函数就只要在函数里判一判，调用端省了无数个 if ，</p>
<p>方便死了，然后上午打完下午交了文艺平衡树，<br />
woc 全部 RE ???<br />
把数据下下来，本地跑了一下， AC 。。。<br />
woc 玄学本地 AC 提交 RE ？<br />
改了细节再交，还是全 RE ，<br />
那到洛谷 IDE 上测一下？一测， AC 。。。<br />
woc 玄学洛谷 IDE AC 提交 RE ？</p>
<p>然后 <a href="https://www.luogu.org/recordnew/lists?uid=Kewth?pid=P3391?status=?sort=0">各种测试</a></p>
<p>最后肝到晚上，终于认识到空指针调成员函数是多么不安全的行为。。。</p>
<p>emm 最后发现 Treap 无论是速度还是码量上都没好到哪去（难道是我实现太烂？），<br />
对于文艺平衡树来说，无旋 Treap 略慢，代码还略长，只是空间消耗略少。</p>
<h2 id="the-end">THE END</h2>
<p>安徽芜湖 12 天，每天都很充实，虽然也有遗憾。</p>
<p>HNOI 2019, RP ++.</p>
]]></content>
  </entry>
</search>
