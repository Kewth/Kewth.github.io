<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二次剩余</title>
    <url>/2019/10/21/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
    <content><![CDATA[<p>二次剩余，<del>俗称模意义开根</del>。<br>也就是对于常数 $n$ 解这样一个方程：</p><p>$$x^2 \equiv n \; (mod \; p)$$</p><p>这里只介绍模数 $p$ 为奇素数的解法，也就是 Cipolla 算法。</p><p>以下运算皆指模 $p$ 意义下的运算。</p><h2 id="解的数量"><a href="#解的数量" class="headerlink" title="解的数量"></a>解的数量</h2><p>严格来讲，非 0 数 $n$ 是二次剩余当且仅当方程 $x^2 \equiv n$ 有解，也就是能开根。<br>上述方程无解的非 0 数 $n$ 称作非二次剩余。</p><a id="more"></a>




<p>对于二次剩余 $n$ ，$x^2 \equiv n$ 有多少解？</p>
<p>假设有多组解，对于任意两个不相等的解 $x_0, x_1$ ，有 $x_0^2 \equiv x_1^2$ 。<br>移项后平方差，得到 $(x_0 - x_1)(x_0 + x_1) \equiv 0$ 。</p>
<p>由于 $p$ 是奇素数，且 $x_0 \ne x_1$ ， $x_0 - x_1$ 在模 $p$ 意义下是不会为 0 的。<br>故有 $x_0 + x_1 \equiv 0$ ，也就是说两个不相等的解一定是相反数，<br>换言之，该方程只有两个解，且它们互为相反数。<br>而当 $p$ 为奇素数时模意义的两个相反数不会相等，因为奇偶性不同。</p>
<p>还可以知道，任意一对相反数都对应一个二次剩余，而且这些二次剩余是两两不同的。<br>也就说二次剩余的数量恰为 $\frac{p-1}{2}$ ，其他的非 0 数都是非二次剩余，数量也是 $\frac{p-1}{2}$ 。</p>
<h2 id="欧拉准则"><a href="#欧拉准则" class="headerlink" title="欧拉准则"></a>欧拉准则</h2><p>如何快速判断一个数 $n$ 是否为二次剩余？</p>
<p>以下讨论假定 n 不为 0 。</p>
<p>观察费马小定理 $n^{p-1} \equiv 1$ ，由于 $p$ 是奇素数，可以得到 $n^{2(\frac{p-1}{2})} - 1\equiv 0$ ，<br>也就是说 $n^{\frac{p-1}{2}}$ 是 1 开根的结果，根据上面所说， 1 开根只有两个解 1 和 -1 。<br>那么 $n^{\frac{p-1}{2}}$ 只能是 1 或 -1 。</p>
<p>若 $n$ 是二次剩余，则有 $n^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv x^{p-1} \equiv 1$ 。</p>
<p>若 $n^{\frac{p-1}{2}} \equiv 1$ ，将 $n$ 表示为 $g^k$ ， 其中 $g$ 是模 $p$ 意义下的原根。<br>那么有 $g^{k\frac{p-1}{2}} \equiv 1$ 由于 $g$ 是原根，必有 $p-1|k\frac{p-1}{2}$ ，<br>也就是说 $k$ 一定是偶数，那么令 $x \equiv g^{\frac{k}{2}}$ 即是 $n$ 开根的结果，这说明 $n$ 是二次剩余。</p>
<p>也就是说 $n^{\frac{p-1}{2}} \equiv 1$ 与 $n$ 是二次剩余是等价的，<br>由于 $n^{\frac{p-1}{2}}$ 不为 1 是只能是 -1 ，那么 $n^{frac{p-1}{2}} \equiv -1$ 与 $n$ 是非二次剩余等价。</p>
<p><em>ps: 网上一堆伪证说若 $n$ 是非二次剩余，不存在 $x$ 使得上式为 1 ，但这只能说明上式为 -1 时 $n$ 是非二次剩余，并不能推翻“当 $n$ 是非二次剩余时上式为 1”</em></p>
<h2 id="Cipolla"><a href="#Cipolla" class="headerlink" title="Cipolla"></a>Cipolla</h2><p>对于二次剩余解方程 $x^2 \equiv n$ 。</p>
<p>找到一个 $a$ 满足 $a^2 - n$ 是非二次剩余，由于非二次剩余的数量接近 $\frac{p}{2}$ ，<br>通过随机 + 检验的方式期望约 2 次可以找到这样一个 $a$ 。</p>
<p>接下来定义 $i^2 \equiv a^2 - n$ 。<br>但是 $a^2 - n$ 不是二次剩余，怎么找得到这样一个 $i$ ？</p>
<p>类比实数域到复数域的推广，定义这样一个 $i$ ，然后可以将所有数表示为 $A+Bi$ 的形式，<br>其中 $A, B$ 都是模 $p$ 意义下的数，类似于实部和虚部。</p>
<p>那么 $(a + i)^{p+1} \equiv n$ ，考虑证明。</p>
<p><strong>引理 1</strong> ： $i^p \equiv -i$ 。</p>
<p>证明： $i^p \equiv i(i^2)^{\frac{p-1}{2}} \equiv i(a^2 - n)^{\frac{p-1}{2}} \equiv -i $</p>
<p><strong>引理 2</strong> ： $(A + B)^p \equiv A^p + B^p$ 。</p>
<p>证明：二项式定理展开后，由于 $p$ 是质数，除了 $C_p^0, C_p^p$ 外的组合数分子上的阶乘没法消掉，模 $p$ 都会为 0 ，剩下来的就是 $C_p^0 A^0 B^p + C_p^p A^p B^0$ 。</p>
<p>现在证明上述结论：</p>
<p>$$(a + i)^{p+1} \equiv (a^p + i^p) (a + i) \equiv (a - i) (a + i) \equiv a^2 - i^2 \equiv n$$</p>
<p>那么 $(a + i)^{\frac{p+1}{2}}$ 即是一个解，其相反数是另一个解。</p>
<p>然而还剩最后一个问题， $(a + i)^{\frac{p+1}{2}}$ 的“虚部”一定为 0 吗？</p>
<p>幸运的是，的确如此，假设存在 $(A + Bi)^2 \equiv n$ 且 $B \ne 0$ ，<br>那么有 $A^2 + B^2i^2 + 2ABi \equiv n$ ，即 $A^2 + B^2(a^2 - n) - n \equiv -2ABi$ 。<br>式子的左边“虚部”为 0 ，那么式子右边的虚部也一定为 0 ，也就是说 $AB \equiv 0$ 。<br>既然假设了 $B \ne 0$ 那么一定是 $A \equiv 0$ ，也就是说 $(Bi)^2 \equiv n$ 。<br>也就是 $i^2 \equiv nB^{-2}$ ，由于 $B^2$ 是个二次剩余，其逆元 $B^{-2}$ 一定也是二次剩余，乘上二次剩余 $n$ 后一定还是二次剩余，这与 $i^2$ 是个非二次剩余产生矛盾。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现的时候弄个“复数”类（据说也可以不用）即可。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line">lolong I_mul_I; <span class="comment">// 虚数单位的平方</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">	lolong real, imag;</span><br><span class="line">	<span class="keyword">complex</span>(lolong real = <span class="number">0</span>, lolong imag = <span class="number">0</span>): real(real), imag(imag) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">complex</span> x, <span class="keyword">complex</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.real == y.real <span class="keyword">and</span> x.imag == y.imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> x, <span class="keyword">complex</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">complex</span>((x.real * y.real + I_mul_I * x.imag % mod * y.imag) % mod,</span><br><span class="line">			(x.imag * y.real + x.real * y.imag) % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">complex</span> <span class="title">power</span><span class="params">(<span class="keyword">complex</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">complex</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">		x = x * x;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_if_residue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> power(x, (mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;x0, <span class="keyword">int</span> &amp;x1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">		x0 = x1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mod = p;</span><br><span class="line"></span><br><span class="line">	lolong a = rand() % mod;</span><br><span class="line">	<span class="keyword">while</span>(!a <span class="keyword">or</span> check_if_residue((a * a + mod - n) % mod))</span><br><span class="line">		a = rand() % mod;</span><br><span class="line">	I_mul_I = (a * a + mod - n) % mod;</span><br><span class="line"></span><br><span class="line">	x0 = <span class="keyword">int</span>(power(<span class="keyword">complex</span>(a, <span class="number">1</span>), (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).real);</span><br><span class="line">	x1 = mod - x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>值得一提的是，模意义开根（甚至可以推广到开 $k$ 次方根）是可以通过原根转换为求对数问题从而使用 BSGS 的。<br>不过复杂度 $O(\sqrt{p})$ 远不如 Cipolla 的 $O(logp)$ 优秀，但很多情况下也足够了。</p>
<p>具体地，将 $x$ 表示为 $g^y$ ，其中 $g$ 是原根，方程变为 $(g^y)^k \equiv n$ ，即 $(g^k)^y \equiv n$ ，解出 $y$ 即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二次剩余</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title>LGR-061&XR-4</title>
    <url>/2019/10/20/LGR-061-XR-4/</url>
    <content><![CDATA[<p>开场 30min 才反应过来有场比赛。<br>不知道哪来的自信就去报了 Div.1 。。。</p><p>第一次打 IOI 赛制的网络赛，感觉海星，不像 ACM 一样必须 A 题，<br>打部分分的话就和平时训练的感觉一样，操作起来相对顺手。</p><p><del>但是打网络赛为什么要拿部分分呢，当然冲着 A 题去啊是吧</del></p><p>然而全场只能做出 A 题。并没有平时打 ACM 赛制的时候有签到题。<br>不过还好，反正我不适合打手速题。</p><a id="more"></a>



<p>Skip 掉了 B （还好 Skip 掉了，后来全程肝 B 没肝出来），直接开 C 。<br>发现 C 的 63’ 巨水，打了个神奇剪枝交了一发，我一直感觉这玩意复杂度是 $O(np)$ 的，<br>但是没用，TLE ，复杂度假了呗，虽然我并不知道原因，但觉得剩下的 37’ 性价比不高，就 Skip 掉了。</p>
<p>提答题好评。</p>
<p>洛谷不支持提答题差评。</p>
<p>但是它给的输入文件的坐标都是有理数，小数点后面一堆数我 TM 怎么知道它的具体位置啊，在图里面标注坐标的无理数表示会死吗。。<br>第一个点蛮简单的，然后第二个点就卡死了。</p>
<p>弃疗，回去肝 B 。</p>
<p>但是我觉得 B 真的难啊，好多细节？反正是没肝出来，最后 173’ 狗到 rank21 。</p>
<p>然而这场比赛参加的人少，只有 300+ 个人打，而且好像很多流皮的人都不打洛谷月赛哦，<br>所以不太理解为什么 XRound 为什么坚持在洛谷办<del>（难道是 py 交易？）</del>，<br>平心而论对于 XR 这种比赛 CometOJ 应该是个更合适的平台。</p>
<p>$\color{white}{事实上，洛谷的确为办一场月赛出了不少钱，出题人的待遇比在 cf 等比赛要高}$</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>XR</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队二次离线</title>
    <url>/2019/10/16/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>莫队算法可以通过单点增量的方式以 $O(n\sqrt{n}K)$ （认为 $n, q$ 同阶）的复杂度离线处理若干区间信息询问。<br>其中每次单点增量，即每次端点移动的复杂度为 $O(K)$ 。<br>大多数情况下端点移动的复杂度是 $O(1)$ 的，这样的问题一般是统计区间内的“数”。<br>而统计区间内的“数对”这样的问题往往难以 $O(1)$ 处理端点移动。</p><a id="more"></a>
<p>莫队二次离线或许能处理这样的问题。</p>
<h2 id="什么用"><a href="#什么用" class="headerlink" title="什么用"></a>什么用</h2><p>一般莫队有 $O(n\sqrt{n})$ 次端点移动，如果要用数据结构维护信息的话，<br>就有 $O(n\sqrt{n})$ 次修改和 $O(n\sqrt{n})$ 次查询。</p>
<p>而莫队二次离线能够优化为成 $O(n)$ 次修改和 $O(n\sqrt{n})$ 次查询，<br>从而允许使用一些修改复杂度大而查询复杂度小的方式来维护信息。<br>例如分块，如果能 $O(\sqrt{n})$ 修改和 $O(1)$ 查询的话，总的复杂度就是 $O(n\sqrt{n})$ 。</p>
<p>但是有两个前提：</p>
<ul>
<li>维护的信息有一定可减性，换句话说必须保证每次询问 $[l, r]$ 与 $r + 1$ 产生的贡献时，<br>需要能够用 $[1, r]$ 与 $r + 1$ 产生的贡献减去（或者其他方式）$[1, l)$ 与 $r + 1$ 产生的贡献代替。</li>
<li>维护的信息有一定可加性，换句话说在每次询问前在不知道当前的 Ans 的情况下可以得到 Ans 的改变量（或某种改变方式）。</li>
</ul>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>考虑每次右端点右移的过程（右端点左移以及左端点移动是类似的）。</p>
<p>每次右端点 $r$ 从 $r_0$ 移动到 $r_1$ 时，对于其中的每一个 $r$ ，都需要查询 $[l, r - 1]$ 与该点产生的贡献。<br>考虑差分，利用上面提到过的可减性，查询 $[1, r]$ 与 $r + 1$ 产生的贡献和 $[1, l)$ 与 $r + 1$ 产生的贡献。</p>
<h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>$[1, r]$ 与 $r + 1$ 产生的贡献只与 $r$ 有关，可以记为 $f_r$ 。<br>那么预处理 $f_r$ 只需从小到大一个个加点维护当前的 $[1, r]$ 并询问出 $f_r$ 。<br>这个过程需要 $O(n)$ 次修改和 $O(n)$ 次查询。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[i] 是第 i 个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	f[i] = Query(a[i]);</span><br><span class="line">	Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外如果需要卡常，可以将 $f$ 做一遍前缀和，这样后续查询 $[r_0, r_1]$ 总的贡献就可以 $O(1)$ 计算了（不影响复杂度）。</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>$[1, l)$ 与 $r + 1$ 产生的贡献可以二次离线，在 $l$ 处存下 $r + 1$ 之后再考虑计算。<br>这样做的空间复杂度是 $O(n\sqrt{n})$ 的，<br>但事实上每次只需把 $[r_0, r_1]$ 这个区间存进 $l$ 处而不是把每个数存进去就可以做到 $O(n)$ 的空间复杂度了，<br>这样询问的时候也只需求 $[r_0, r_1]$ 整体的贡献，常数上还能少一个 $O(n\sqrt{n})$ 的瓶颈。<br>离线处理上述的贡献，也和求 $f_r$ 的过程类似，每次从小到大一个个加点维护当前的 $[1, l)$ ，<br>并对于 $l$ 处存下的每一个数逐个询问 $[1, l)$ 与其产生的贡献即可。<br>这个过程需要 $O(n)$ 次修改和 $O(n\sqrt{n})$ 次查询。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">	<span class="keyword">int</span> L = query[i].l, R = query[i].r; <span class="comment">// 排序后的询问</span></span><br><span class="line">	<span class="keyword">if</span>(r &lt; R) &#123;</span><br><span class="line">		<span class="built_in">vector</span>[l].push_back(<span class="built_in">std</span>::make_pair(r + <span class="number">1</span>, R));</span><br><span class="line">		r = R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> par : <span class="built_in">vector</span>[i])</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = par.first; k &lt;= par.second; k ++)</span><br><span class="line">			Query(a[k]); <span class="comment">// 这里用什么东西存一下结果就好了</span></span><br><span class="line">	Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>亚线性筛</title>
    <url>/2019/10/15/%E4%BA%9A%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>亚线性筛，就是以低于线性的复杂度预处理一些线性信息的筛法统称。</p><p>目前我会杜教筛和 min25 还有 powerful number。</p><h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>杜教筛一般用于求一类数论函数的前缀和。</p><p>假设要求数论函数 $f(x)$ 的前缀和 $S(n) = \sum_{i=1}^n f(i)$ 。</p><p>杜教筛的关键在于构造两个合适的函数 $g, h$ 满足 $h = f \cdot g$ 。</p><a id="more"></a>




<p>这里的函数相乘指的是狄利克雷卷积。</p>
<h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>则由 $h = f \cdot g$ 可得（以下除号表示整除）：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>\sum_{i=1}^n h(i) &amp;= \sum_{i=1}^n\sum_{d|i}f(\frac{i}{d})g(d) \\<br>&amp;= \sum_{d=1}^ng(d)\sum_{i=d}^nf(\frac{i}{d})[i|d] \\<br>&amp;= \sum_{d=1}^ng(d)\sum_{i=1}^{n/d}f(i) \\<br>&amp;= \sum_{d=1}^ng(d)S(\frac{n}{d}) \\<br>&amp;= g(1)S(n) + \sum_{d=2}^ng(d)S(\frac{n}{d}) \\<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>所以 $S(n) = \sum_{i=1}^n h(i) - \sum_{d=2}^n g(d)S(\frac{n}{d})$ 。</p>
<p>前提是每个 $\sum_{i=1}^n h(i)$ 很容易求，那么接下来不考虑 $h$ ，<br>对于后面的部分可以整除分块，还需要快速求出 $g$ 的一段区间和，<br>然后就可以递推，由于形如 $\lfloor\frac{n}{d}\rfloor$ 的数只有 $O(\sqrt{n})$ 个，<br>可以只递推这 $O(\sqrt{n})$ 个 $S$ ，不考虑 $g, h$ 的计算复杂度，复杂度为 $O(n^{\frac{2}{3}})$ 。</p>
<p>关于如何存储 $S$ ，直接用数组存需要 $O(n)$ 的空间，开 map 每次取用带一个 log ，<br>普通的离散化也会带一个 log 。</p>
<p>观察 $\frac{n}{d}$ 的分布，当 $d \leq \sqrt{n}$ 时， $\frac{n}{d}$ 的值两两不同。<br>而当 $d &gt; \sqrt{n}$ 时， $\frac{n}{d}$ 的值都不超过 $\sqrt{n}$ 。<br>设 $m$ 是 $\frac{n}{d}$ 的不同取值个数，那么可以用如下的函数对 $x = \frac{n}{d}$ 进行离散化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt;= sqrt_of_n ? x : m - (n / x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>举个简单的栗子：求 $\mu$ 的前缀和。</p>
<p>首先根据 $\mu$ 的性质不难想到 $\mu \cdot I = \epsilon$ 。</p>
<p>那么就将 $f = \mu, g = I, h = \epsilon$ 代入上去，得到：</p>
<p>$$S(n) = \sum_{i=1}^n \mu(i) = \sum_{i=1}^n \epsilon(i) - \sum_{d=2}^n I \cdot S(\frac{n}{d})$$</p>
<p>即</p>
<p>$$S(n) = 1 - \sum_{d=2}^n S(\frac{n}{d})$$</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>但有时候无法构造合适的 $h = f \cdot g$ 使得 $g, h$ 的前缀和可以 $O(1)$ 算出。<br>这时候杜教筛是否就毫无用武之地呢？不见得。</p>
<p>观察递推式，利用整除分块，设 $S_f, S_g, S_h$ 分别表示 $f, g, h$ 的前缀和，那么：</p>
<p>$$S_f(n) = S_h(n) - \sum_{i=2}^m (S_g(r_i) - S_g(r_{i-1})) S_f(\frac{n}{r_i})$$</p>
<p>其中 $m$ 是 $\frac{n}{d}$ 的不同取值个数， $r_i$ 是整除分块后对应第 $i$ 块的右端点。</p>
<p>首先不难发现需要用到的 $S_h$ 也都是形如 $\frac{n}{d}$ 的数，<br>那么只需要如果 $S_h$ 能够杜教筛（或者其他筛）筛出来就行了。</p>
<p>再考虑 $S_g$ 需要的取值，由整除分块中的 $r = n / (n / l)$ 可知，$r_i$ 的取值也都是形如 $\frac{n}{d}$ 的数，<br>同理只要能筛 $S_g$ 就行了，不一定要 $O(1)$ 算。</p>
<h2 id="min25"><a href="#min25" class="headerlink" title="min25"></a>min25</h2><p>min25 筛是扩展埃氏筛，也可以筛一类（更复杂的）<strong>积性函数</strong>的前缀和，并且通常是同类亚线性筛中最快的一个。<br>而且灵活运用 min25 可以处理一些特殊的关于质因子的问题。</p>
<h4 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h4><p>假设要求 $S(n) = \sum_{i=1}^n f(i)$ 。</p>
<p>min25 筛可大致分为两步。</p>
<h5 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h5><p>第一步处理的是 $f$ 在质数上的取值的和。<br>令 $F(x) = [x \in Prime] f(x)$ ，那么这一步的目标是筛出 $F$ 的前缀和。<br>准确地讲，是 $F$ 的前缀和函数 $S_F$ 在每个形如 $\frac{n}{d}$ 的数上的取值。</p>
<p>首先需要将 $f(i)$ 拆成若干完全积性函数的和，<br>只需考虑 $F$ ，也就是 $f(p^k)$ 的取值。<br>如果是关于 $p$ 的多项式，每个单项式对应的就是一个完全积性函数。</p>
<p>假设现在要筛一个完全积性函数 $h$ ，要能快速计算出 $S_h = \sum_{i=1}^n h(i)$ 。<br>这一步的主要思想是，一个一个枚举质数 $p$ ，筛掉最小值因子为 $p$ 的合数的取值。<br>而合数 $x$ 的最小质因子为 $p$ 的必要条件是 $p^2 \leq x$ ，即 $p \leq \sqrt{x}$ 。<br>那么只需要枚举 $\sqrt{n}$ 以内的质数去筛即可。</p>
<p>假设现在筛掉了前 $i - 1$ 个质因子得到一个这个值：</p>
<p>$$g(n, i - 1) = \sum_{x=1}^n [x \in Prime \; or \; minp(x) &gt; P_{i-1}] h(x)$$</p>
<p>其中 $P_i$ 表示 $\sqrt{n}$ 以内第 $i$ 个质数。</p>
<p>那么接下来要筛最小值因子为 $P_i$ 的数：</p>
<p>$$g(n, i) = g(n, i - 1) - \sum_{x=1}^n [minp(x) = P_i] h(x)$$</p>
<p>由于 $h$ 是完全积性函数，$P_i$ 可以直接提出来，得到：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>g(n, i) &amp;= g(n, i - 1) - h(P_i) \sum_{x=1}^{n/P_i} [minp(x) \geq P_i] h(x) \\<br>&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{x=1}^{n/P_i} [x \in Prime \; and \; minp(x) &lt; P_i] h(x)) \\<br>&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{j=1}^{i-1} h(P_j)) \\<br>&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - ph_{i - 1}) \\<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>其中 $ph_i$ 就是 $h$ 在前 $i$ 个质数上的取值和，注意 $P_i \leq \sqrt{n}$ ，这是可以直接筛的。</p>
<p>那么上面的式子就是 $g$ 的递推式，不难发现第一维的取值都是 $\frac{n}{d}$ 的形式，第二维可以滚动。<br>直接按照递推式算，就可以在 $O(\sqrt{n} |P|)$ 的时间筛出需要的东西，也就是 $g(n, |P|)$ 。<br>这还是不够的，需要优化，由于最小质因子的取值在根号以内，所以递推时只需考虑满足 $n \geq P_i^2$ 的 $g(n, i)$ 。<br>当 $n &lt; P_i^2$ 时，随着 $i$ 的增大 $g(n, i)$ 的值不会改变，由于是滚动数组，直接 skip 掉就好了。</p>
<h5 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h5><p>上面将每个完全积性函数的 $g(n, |P|)$ 加起来，得到 $S_F(n)$ ，表示 $f$ 在质数上的取值 $F$ 的前缀和。</p>
<p>仍然利用最小质因子，不同的是，上一步从所有的取值开始从小到大把对应的最小质因子的合数的贡献给删掉的到质数的取值。<br>那这一步能不能反过来，从质数的取值开始，从大到小把对应的最小质因子的合数的贡献给加上最后得到所有数的取值？</p>
<p>并不能，事实上是从空值开始，从大到小把对应的最小质因子的数的贡献加上最后得到所有数的取值，<br>合数可以递推并类似地利用积性函数的性质提出一个因子，质数则直接用上一步预处理的来算。</p>
<p>那么假设现在以及算上了比第 $i$ 个更大的质数为最小质因子的数的值得到了这个：</p>
<p>$$S(n, i) = \sum_{x=1}^n [minp(x) &gt; P_i] f(x)$$</p>
<p>不难推导出：</p>
<p>$$S(n, i)=S_F(n) - pf_i + \sum_{P_j &lt; P_k \leq \sqrt{n}} \sum_{e&gt;0,P_k^e \leq n}f(P_k^e)(S(\frac{n}{P_k^e}, k) + [e&gt;1])$$</p>
<p>其中 $pf_i$ 就是 $f$ 在前 $i$ 个质数上的取值和，注意 $P_i \leq \sqrt{n}$ ，这是可以直接筛的。</p>
<p>同样地第一维的取值都是 $\frac{n}{d}$ 的形式，但是第二维无法滚动，<br>但事实上后面的部分直接递归计算即可，以下是参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"><span class="function">lolong <span class="title">S</span><span class="params">(lolong i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prime[j] &gt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	lolong res = S_F[id(i)] - pf[j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= p <span class="keyword">and</span> <span class="number">1l</span>l * prime[k] * prime[k] &lt;= i; k ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> e = <span class="number">1</span>;</span><br><span class="line">		lolong pr = prime[k];</span><br><span class="line">		<span class="keyword">while</span>(pr &lt;= i) &#123;</span><br><span class="line">			res += (prime[k] ^ e) * (S(i / pr, k) + (e &gt; <span class="number">1</span>));</span><br><span class="line">			pr *= prime[k];</span><br><span class="line">			e ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度似乎是 $O(\frac{n^{\frac{3}{4}}}{logn})$ 。</p>
<h2 id="Powerful-number"><a href="#Powerful-number" class="headerlink" title="Powerful number"></a>Powerful number</h2><p>这个在 OI 中用得少，我也只是做过一道题，大概提一下。</p>
<p>称 1 和每个质因子次数大于 1 的合数为 Powerful number 。<br>首先有个性质就是 $n$ 以内的 Powerful number 数量是 $O(\sqrt{n})$ 的。</p>
<p>还是筛数论函数 $f$ 的前缀和 $S$ ，需要构造两个函数 $g, h$ 满足 $f = g \cdot h$ 。<br>如果 $g$ 只在 Powerful number 上有值并且 $h$ 的前缀和 $S_h$ 容易求或者可以筛的话，<br>由 $S(n) = \sum_{i=1}^n \sum_{d|x} g(d) h(\frac{d}{x}) = \sum_{d=1}^n G(d) S_h(n/d)$<br>可以通过枚举 Powerful number 快速计算答案。</p>
<p>至于枚举 Powerful number 的方法，注意到 Powerful number 的质因子都是 $\sqrt{n}$ 以内的，<br>这可以通过反证法证明，如果有大于 $\sqrt{n}$ 的质因子它的次数不可能超过 1 。<br>那么筛出 $\sqrt{n}$ 以内的质数，再通过搜索枚举每个质数的次数即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>杜教筛</tag>
        <tag>min25</tag>
      </tags>
  </entry>
  <entry>
    <title>cf-592div2</title>
    <url>/2019/10/13/cf-592div2/</url>
    <content><![CDATA[<p>自闭。<br>这大概是我打过最失败的一场比赛。</p><p>A 签到题，然而我在 14min 才 A ，我是真的不适合做手速题。</p><p>B 行数开大点就是插头 DP ，然而行数只有 2 ，插头只有 3 种，<br>随便 DP 一下就行了，中间少考虑一种插头 WA 了一发，在 25min AC 。</p><p>然后，就没有然后了。</p><p>C 题解二元一次方程的整除解，woc 这不扩欧板题嘛，没想太多，直接码上去。<br>然后很轻松过了样例啊，交 WA 了，哦没判负数，又交 WA 了。。。<br>静态查错无果，遂对拍，拍了 1000+ 组全是 AC 。</p><a id="more"></a>




<p>事情好像不太对劲.jpg</p>
<p>skip 掉，直接开 E ，发现了个单调性，没想太多，直接码上去。<br>还是很轻松过了样例啊，交 WA 了。<br>静态查错无果，遂回去调 C 。</p>
<p>冷静分析一波后发现 C 题神 tm 会爆 long long 。<br>这简单，改 int128 ，结果交 CE 了。<br>然后就到网上蒯 c++ 大整数模板，贴下来后，<br>样例都过不去了我天，然后我就去调那个模板，也是醉了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Big n = <span class="number">10</span>, x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n - x + x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码第一行输出 10 ，第二行输出 20 。</p>
<p>当时我心态就炸了，简直想去问候那个把模板贴他博客上的祖宗十八代。<br>写的这玩意连加减法都算不对心里没点 B 数吗也敢往网上放。</p>
<p>服了，还是乖乖想不爆 long long 的解法吧。</p>
<p>9102 年了还有人靠爆 long long 混饭吃。<br>这样明显卡语言啊，对 c++ 选手毫无公平性可言。</p>
<p>至于正解，自然是没想出来。</p>
<p>最后获得了 rank3400+ 的好成绩，掉分预定。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-12</title>
    <url>/2019/10/13/cometoj-12/</url>
    <content><![CDATA[<p>以后打比赛写总结。</p><p><del>话说今天打到短裙好开心啊</del></p><p>A 题签到题。</p><p>为什么我第一个想的就是 O(1) 的哈希？<br>表示完全没有去想好写得多的排序，而是直接把三个字符用 int 表示去搞。<br>然后本地测样例玄学错误，最后发现哈希的数组开小了。<br>7min 做出 A 题表示自闭。</p><p><del>真是可怕交题的时候刷新就有 40+ AC 了</del></p><p>B 题还是签到题，以为能在 5min AC 结果打了 9min ，感觉我不适合这种手速题。</p><a id="more"></a>





<p>然后我 C 题看都没看一眼直接 skip 掉就去开了 D 题。<br>看了 3min 哇这不数位 DP 吗，现在还没人交，我还有拿一血的想法。<br>然后打了出来，测样例， woc 过了，这个时候还是 4 提交 0 通过。<br>我在机房大呼卧槽我要拿一血了，然后自信满满地交了上去。</p>
<p>成功 WA 掉所有点。</p>
<p>再刷新 D 题一血就已经被拿了。</p>
<p>然后我的心路历程是这样的：</p>
<p>我要拿二血。</p>
<p>我要拿三血。</p>
<p>我要拿四血。</p>
<p>算了我凉了还是做好长期打算拿个十血什么的吧。。。</p>
<p>期间各种被 master 嘲讽，各种互怼。</p>
<p>master 走后没人跟我说话了，然后冷静分析了一波，发现限制条件搞错了，<br>然后随便搓了几行代码就 A 了。</p>
<p><del>所以以后打比赛要远离 master</del><br>所以以后打比赛还是要在快节奏中冷静下来。</p>
<p>A 完 D 已经是 2h 了，回去看 C ，<del>这 tm 不最短路板题嘛</del>。<br>然而 C 题有坑，卡了好久，最后在比赛结束前 3min rush 了一发成功 AC 。</p>
<p>然后靠着 4 题 + 罚时 8h 狗进 rank8 <del>拿到短裙啦</del>。</p>
<p>这场比赛绝对是我打的最爽的一场网络赛，感觉 cometoj 的 ACM 比赛才是最刺激的，<br>题目质量高，节奏快，竞争激烈，尤其是相对于 cf 和 atcoder 来说没有网速杀和题意杀。<br>体验感极好。<br><del>最主要的还是有短裙拿</del></p>
<p>然而拿短裙又没人肯女装，我还是选择拿杯子吧。。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>RMQ</title>
    <url>/2019/10/11/RMQ/</url>
    <content><![CDATA[<p>总结求各种 RMQ 的常用技巧和方法。<br>RMQ 真是流皮，每次深入思考都会有新的发现，所以有了新的发现会更新。</p><p>以下 n 表示数列的大小，q 表示询问的次数，均以最大值为例。</p><h2 id="一般性普通做法"><a href="#一般性普通做法" class="headerlink" title="一般性普通做法"></a>一般性普通做法</h2><p>线段树当然是可以在线维护的，复杂度 $O(n + qlogn)$ 。<br>甚至还可以支持单点修改或区间修改。</p><p>但是如果只是静态询问的话，可以用 ST 表预处理后 $O(1)$ 在线处理询问，<br>复杂度 $O(nlogn + q)$ 。</p><a id="more"></a>



<p>这两个做法烂大街了，是基础中的基础，不是本文讨论重点。</p>
<h2 id="区间定长特殊做法"><a href="#区间定长特殊做法" class="headerlink" title="区间定长特殊做法"></a>区间定长特殊做法</h2><p>即所有的询问区间的长度都为与询问无关的定值 $len$ 。<br>直接当做任意区间做，可以做到 $O(n + qlogn)$ 或 $O(nloglen + q)$ 。</p>
<p>这种情况下有更好理解的预处理方法，只需优先队列。<br>先把 $[1, l]$ 的数扔进优先队列里，之后不断把区间右移，<br>$[l, r]$ 右移的过程相当于加一个点 $r + 1$ 并删掉点 $l$ ，用优先队列维护即可。<br>复杂度 $O(nlogn + q)$ 。</p>
<p>但这还不够，还有线性的预处理方法，用单调双端队列代替上面的优先队列。<br>同样是让区间不断右移，单调双端队列中的值是单调不增的，<br>那么最左边的值一定是最大值。<br>加点 $r + 1$ 前维护单调性，删点 $l$ 时判断是不是删的最大值，<br>如果是就删点最左边的点即可。<br>复杂度 $O(n + q)$ 。</p>
<h2 id="随机询问期望做法"><a href="#随机询问期望做法" class="headerlink" title="随机询问期望做法"></a>随机询问期望做法</h2><p>这种情况下有个 $O(n + q)$ 的在线做法。</p>
<p>考虑分块，设块的大小为 $b$ ， $O(n)$ 预处理每个块的最大值。</p>
<p>那么对于询问 $[l, r]$ ，若该区间跨过了多个块，问题就分为两个部分：</p>
<ol>
<li>求跨过的块区间的最大值。</li>
<li>求两端点所在零散的块的最大值。</li>
</ol>
<p>第一个问题就是个子问题，并且数据规模减小到了 $O(\frac{n}{b})$ ，<br>为了保证询问 $O(1)$ ，可以用上面一般性的普通做法提到的 ST 表，<br>就可以 $O(\frac{n}{b} log\frac{n}{b})$ 进行预处理然后 $O(1)$ 询问。</p>
<p>第二个问题端点所在零散的块是该块的一段前缀或者后缀，<br>只需 $O(n)$ 对于每个块预处理前缀最大值和后缀最大值即可 $O(1)$ 询问。</p>
<p>那么若询问区间在同一个块内呢？<br>自然是暴力扫，但是这样的复杂度是 $O(b)$ 的。<br>但询问区间随机的情况下，不难得出两个端点在同一个块内的概率是 $\frac{b}{n}$ 。<br>那么这种情况询问的期望复杂度是 $O(\frac{b^2}{n})$ 的。</p>
<p>总复杂度 $O(n + \frac{n}{b} log\frac{n}{b} + q + q \frac{b^2}{n})$ 。<br>当 $b$ 至少为 $O(logn)$ 时，预处理的 $O(\frac{n}{b} log\frac{n}{b})$ 不超过 $O(n)$ 。<br>当 $b$ 至多为 $O(\sqrt{n})$ 时，询问的 $O(q \frac{b^2}{n})$ 不超过 $O(q)$ 。<br>因此 $b$ 的大小取 $O(logn)$ 到 $O(\sqrt{n})$ 之间即可。</p>
<p>另外，当 $b = \sqrt{n}$ 时，块的个数也是 $O(\sqrt{n})$ 的，<br>此时根本不需要 ST 表，直接 $O(\sqrt{n}^2)$ 暴力预处理处理所有可能区间的最大值即可。<br>这样复杂度不变，常数可能还能小一点。</p>
<h4 id="毒瘤活动"><a href="#毒瘤活动" class="headerlink" title="毒瘤活动"></a>毒瘤活动</h4><p>值得注意的是，虽然这个做法的复杂度仅适用于询问区间随机的情况，但是一般不会卡。</p>
<p>来点有意思的娱乐活动，考虑怎么卡掉它，以及怎么防止被出题人卡。</p>
<p>想要卡这个做法就要尽量让询问区间在一个块内，卡成 $O(b)$ 的询问复杂度。<br>但在不知道块的大小的情况下，假设给一个区间长 $len$ 的询问，实际块的大小为 $b$ ，<br>那么两个端点在同一个块内的概率大概是 $\frac{b-len+1}{b}$ ，期望复杂度就是 $O(\frac{(b-len+1)len}{b})$ 。</p>
<p>现在出题人要在不知道 $b$ 的情况下希望上面的复杂度尽量大，选手要在不知道 $len$ 的情况下希望上面复杂度尽量小。<br><del>怎么感觉像博弈论</del></p>
<p>最坏的情况是 $len = \frac{b}{2}$ 的时候，此时询问的期望复杂度为 $O(\frac{b}{4})$ 。<br>选手希望预处理和询问的复杂度最大值最小，也就是让它们相等，此时 $b$ 的最优取值大致为 $2\sqrt{\frac{n}{q} logn}$ ，<br>这里说是“大致”，是因为为了方便计算将 $O(log \frac{n}{b})$ 看做了 $O(logn)$ 。<br>将 $n, q$ 看做同阶的话，上述取值为 $2\sqrt{logn}$ ，此时复杂度为 $O(\frac{n\sqrt{logn}}{2})$ ，<br>也就是 $O(n\sqrt{logn})$ ，得出结论，在询问区间非随机的情况下，该算法最优可以做到严格 $O(n\sqrt{logn})$ 。</p>
<p>关键这算法常数小，还好写，取 b 为 $O(\sqrt{logn})$ 的话，复杂度 $O((n + q)\sqrt{logn})$ 在绝大多数情况都足够了。</p>
<p>另外，此时没必要维护块内前缀后缀最大值，因为块足够小，询问的时候对零散的块暴力扫就好了，复杂度不变。</p>
<h2 id="一般性较优做法"><a href="#一般性较优做法" class="headerlink" title="一般性较优做法"></a>一般性较优做法</h2><p>自己 yy 出来的，权当过渡吧。</p>
<p>上面提到的 $O((n + q)\sqrt{logn})$ 算法中，通过分块将问题规模缩小到了 $\frac{n}{b}$ ，<br>然后对于这个规模的问题使用 ST 表，预处理复杂度近似看做 $O(\frac{n}{b}logn)$ 。<br>而既然这是个子问题，为什么还要用 ST 表？能不能继续分块直到 ST 表的预处理复杂度在 $O(n)$ 以内？</p>
<p>当然是可以的，这个时候块的大小又要取多少呢？<br>取 $b = 2$ 就够了，这个时候，相当于从底层向上建线段树，<br>第一层有 $n$ 个节点，第二层有 $\frac{n}{2}$ 个节点，第三层有 $\frac{n}{4}$ 个节点，<br>直到某一层只有 $\frac{n}{logn}$ 个节点时，不再向上建线段树，而是用 ST 表维护这 $\frac{n}{logn}$ 个点，<br>这样 ST 表的预处理就是 $O(n)$ 的，而此时这个线段树的树高是 $O(loglogn)$ 的。</p>
<p>总时间复杂度 $O(n + qloglogn)$ ，事实上层数可以再少点，使得 ST 表预处理不严格 $O(n)$ 而是与询问复杂度相当，<br>但这样的话最优的层数难以计算，在此不讨论。</p>
<h4 id="毒瘤活动-1"><a href="#毒瘤活动-1" class="headerlink" title="毒瘤活动"></a>毒瘤活动</h4><p>从下向上建线段树太麻烦了，怕不是要写 zkw ，考虑从上向下建。<br>由于最上面一层有 $\frac{n}{logn}$ 个节点，每个节点管辖的区间大小为 $logn$ ，<br>继续考虑分块，以 $b = logn$ 为块大小分块，那么就是块内直接建满的线段树，块间维护 ST 表。</p>
<p><del>卧槽怎么又回到前面的做法了</del></p>
<p>那么这个算法事实上就是通过线段树保证了块间查询严格 $logb$ ，也就是 $loglogn$ 。</p>
<p>既然这样，为什么一定要用线段树呢？在每个块内依然维护 ST 表，复杂度就是 $O(nloglogn + q)$ 。</p>
<p>通过上面的各种讨论，相信读者已经明白分块 RMQ 的强大，以及线段树和 ST 表（尤其是后者）在 RMQ 的重要性。<br>分块什么这么多东西目的基本就是去平衡 ST 表 / 线段树的询问和预处理的复杂度。</p>
<h2 id="一般性标准做法"><a href="#一般性标准做法" class="headerlink" title="一般性标准做法"></a>一般性标准做法</h2><p>标准的 $O(n + q)$ RMQ 。</p>
<p>离线的话可以建笛卡尔树将 RMQ 转换为 LCA ，然后用 Tarjan 处理。<br>明显的缺点是离线，并且空间开销较大。</p>
<p>在线的话，大致提一下，还是建笛卡尔树转 LCA ，然后求出树的欧拉序转为 +-1 RMQ 。<br>而 +-1 RMQ 也是通过分块实现 $O(n + q)$ 复杂度的。<br>整个过程较为复杂，在 OI 中实用性较低，具体做法留个坑，到时候再补。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>O(1)</tag>
        <tag>RMQ</tag>
        <tag>分块</tag>
        <tag>线段树</tag>
        <tag>ST 表</tag>
        <tag>算法扩展</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>搬迁</title>
    <url>/2019/10/10/%E6%90%AC%E8%BF%81/</url>
    <content><![CDATA[<p>没什么好说的，动态博客用烦了，搞了好多花里胡哨的东西，<br>还是沉下心来，好好写博客，<br>既然如此，就不打算做什么美化了，基本能用就行，勿喷。</p>
<p>另外 hexo 的公式渲染有点 shit ，哪里的公式挂了还请提醒。</p>
<p><del>可是我控制不住我记几啊，总感觉不顺眼，实在忍不住去折腾 QwQ</del></p>
]]></content>
  </entry>
  <entry>
    <title>拉格朗日插值法</title>
    <url>/2019/10/10/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    <content><![CDATA[<p>原来拉格朗日插值不仅能插点值，还能插系数。</p><h2 id="插点值"><a href="#插点值" class="headerlink" title="插点值"></a>插点值</h2><p>已知函数 f(x) 上 n 个点 $(x_i, y_i)$ ，求 f(k) 。</p><p>拉格朗日插值法的思路在于：<br>对于每个 $(x_i, y_i)$ 找到 $L_i(x)$ 使得 $L_i(x_i) = y_i, L_i(x_j) = 0$ ，<br>其中 $ x_j $ 是已知的 x 中任意一个不等于 $ x_i $ 的 x 。</p><a id="more"></a>


<p>n 个点无法求出 f 这个函数，<br>但可以求出一个 n - 1 次多项式，<br>可以认为这个多项式近似于 f 。</p>
<p>而由 L 的定义可知，<br>这个多项式 g 满足 $ g(x) = \sum_{i=1}^n L_i(x) $ 。<br>那么 f(k) 就可以近似地认为是 g(k) ，<br>代入上式即可 $ O(n^2) $ 求解。</p>
<p>现在问题在于求 L 。<br>下面的 L 可以满足定义：</p>
<p>$$ L_i(x) = y_i \cdot \prod\limits_{j≠i}\frac{x_j-x}{x_j-x_i} $$</p>
<p>代入可得这对于任意 $ x_i $<br>可以使得 $ L_i(x_i)=y_i,L_i(x_j) = 0 $</p>
<h2 id="插系数"><a href="#插系数" class="headerlink" title="插系数"></a>插系数</h2><p>已知多项式 f(x) 的 n 个点值，求 f(x) 。</p>
<p>点值比较特殊的情况下可以使用 FFT 或者 NTT ，但有失一般性。</p>
<p>先考虑插出一项 $x^k$ 的系数。</p>
<p>首先依次考虑每个 $L_i(x)$ 的 $x^k$ 系数，最后累加即可。</p>
<p>注意到分母和 $y_i$ 是常数可以直接算，考虑提出来，</p>
<p>$$ L_i(x) = (y_i \cdot \prod\limits_{j≠i}\frac{1}{x_j-x_i})<br>    (\prod\limits_{j≠i} (x_j - x)) $$</p>
<p>那么只需要算分子部分，即上式右边的 $\prod$ 的 $x^k$ 系数即可。</p>
<p>假设把这个连乘暴力拆开，其实 $x^k$ 的系数就是在之中选 $n - k - 1$ 个常数。<br>DP 预处理 $pre(i, j)$ 表示在 $\prod\limits_{j \leq i} (x - x_j)$ 中选 k 个常数的系数和，<br>同理 $suf(i, j)$ 表示在 $\prod\limits_{j \geq i} (x - x_j)$ 中选 k 个常数的系数和。<br>那么把 $pre(i - 1, k)$ 和 $suf(i + 1, k)$ 相乘就是上式的 $x^k$ 系数了。</p>
<p>参考实现（未经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插出 L_i(x) 的 x^k 系数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">la</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">		<span class="keyword">if</span>(i != j)</span><br><span class="line">			A *= X[i] - X[j];</span><br><span class="line">	<span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= n - k - <span class="number">1</span>; l ++)</span><br><span class="line">		B += pre[i - <span class="number">1</span>][l] * suf[i + <span class="number">1</span>][n - k - <span class="number">1</span> - l];</span><br><span class="line">	<span class="keyword">return</span> B / A * X[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 suf 和 pre */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		pre[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">			pre[i][j] = pre[i - <span class="number">1</span>][j] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i; i --) &#123;</span><br><span class="line">		suf[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i + <span class="number">1</span>; j ++)</span><br><span class="line">			suf[i][j] = suf[i + <span class="number">1</span>][j] - suf[i + <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>O(1)黑科技</title>
    <url>/2019/10/10/O(1)%E9%BB%91%E7%A7%91%E6%8A%80/</url>
    <content><![CDATA[<p>@CYJian 出了一道黑科技二合一，我就顺便跟着学了学。</p><h2 id="O-1-gcd"><a href="#O-1-gcd" class="headerlink" title="O(1) gcd"></a>O(1) gcd</h2><p>在 O(V) 的预处理后可以做到 O(1) 查询 gcd ，其中 V 是权值的大小。</p><p>主要利用到的一个性质是可以将任意 x 分解为三个数 a * b * c ， a, b, c 分别满足以下两个条件之一：</p><ol>
<li>不超过 $\sqrt{x}$ 。</li>
<li>是质数。</li>
</ol><a id="more"></a>



<p>update: 之前写假了，感谢 @CYJian 的 hack 。</p>
<p>zzq 把满足这个性质的分解称为“迷之分解”，那我也这么叫吧。</p>
<p>考虑证明一下，顺便构造一个“迷之分解”。</p>
<p>找到 x 的最小质因子 p ，然后假设已知 x / p 的“迷之分解” A, B, C (A &lt;= B &lt;= C) 。<br>那么把 p 乘到 A 上就可以得到 x 的“迷之分解” A * p, B, C 。<br>分类讨论，如果 p 不超过 $\sqrt[4]{x}$ ，由于 A 是 A, B, C 三者中最小的，<br>一定满足 A 不超过 $\sqrt[3]{x/p}$ ，那么可得：</p>
<p>$$A \cdot p \leq \sqrt[3]{x/p} \cdot p = \sqrt[3]{xp^2} \leq \sqrt{x}$$</p>
<p>而如果 p 超过 $\sqrt[4]{x}$ ，由于 p 是最小质因子，<br>那么如果 x 的“迷之分解”有合数 C ， C 至少是 $p^2$ ，超过 $\sqrt{x}$ ，<br>那么 B 的大小就会比 p 小，与 p 是最小质因子矛盾，<br>因而此时 x 的“迷之分解”全是质数。</p>
<p>“迷之分解”的分析就是这样，通过线性筛可以很好预处理出 O(V) 内的所有数的“迷之分解”。<br>只需筛出每个数的最小质因子即可按上述方法递推出“迷之分解”。<br>然后只需预处理出 $O(\sqrt{V})$ 内两两的 gcd ，为了不带 log ，需要递推预处理。<br>此时求 gcd(x, y) 只需对于 x 的“迷之分解” A, B, C 依次对 y 求 gcd （每次求 gcd 后把 y 除以该 gcd ），<br>以 A 为例，如果 A 不超过 $\sqrt{x}$ ，直接查表可以得到 gcd(A, y) （查的是 gcd(A mod y, A) ），<br>否则 A 为质数，简单讨论一下就可以得到 gcd(A, y) 了。</p>
<p>关键部分参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> magic[maxv][<span class="number">3</span>]; <span class="comment">// 每个数的“迷之分解”</span></span><br><span class="line"><span class="keyword">int</span> gcd[maxb][maxb]; <span class="comment">// 预处理的 gcd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> X = magic[x][i];</span><br><span class="line">		<span class="keyword">int</span> d;</span><br><span class="line">		<span class="keyword">if</span>(X &lt; maxb)</span><br><span class="line">			d = gcd[X][y % X];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(y % X)</span><br><span class="line">			d = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			d = X;</span><br><span class="line">		res *= d;</span><br><span class="line">		y /= d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="O-1-快速幂"><a href="#O-1-快速幂" class="headerlink" title="O(1) 快速幂"></a>O(1) 快速幂</h2><p>在 $O(\sqrt{p})$ 的预处理后可以做到对于一个固定的底数 O(1) 查询快速幂，<br>其中 p 是模数（或者上式是 $\sqrt{\phi(p)}$ ），或者是指数的范围。</p>
<p>这个就简单得多，对于每个 $a^k$ 的指数 k 都可以表示为 $a \sqrt{p} + b$ 的形式，<br>满足 $a, b &lt; \sqrt{p}$ ，分别预处理即可，<br>即预处理 $a^0, a^1, a^2 … a^{\sqrt{p}}, a^{2\sqrt{p}}, a^{3\sqrt{p}} … a^p$ 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>gcd/lcm</tag>
        <tag>快速幂</tag>
        <tag>黑科技</tag>
        <tag>O(1)</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分</title>
    <url>/2019/10/10/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>不久前学了整体二分，做了几道题，还在考试上派上用场过几次。<br>觉得自己大概懂了整体二分，直到一次碰上了强制在线的毒瘤题。。。</p><p><del>整体二分：从离线到强制在线</del></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>大概讲讲整体二分吧。</p><p>整体二分大概用于这样一个场景：<br>有多组询问，每个询问可以二分，但是每个询问二分的时间不能接受，<br>而不同询问的二分有共同点，这时就可以用整体二分把多个询问一起二分。<br>所以这是个离线算法。</p><a id="more"></a>



<p>流程大概是这样的：<br>对于当前确定的区间 [L, R] ，取 M 为区间中点，<br>对于当前在确定在这个区间的每个询问进行 check ，<br>然后判断每个询问接下来是到 [L, M] 还是 [M + 1, R] 。<br>当 L = R 时，就得到了处理到这个区间的询问的答案。</p>
<p>每个询问还是进行了 O(logV) 次 check ，<br>但是和直接二分不同的是，一般在每个区间内进行预处理后 check 可以做到 O(1) 或者 O(logn) 等，<br>一般需要数据结构维护（常见的有并查集，树状数组，线段树）。</p>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>就说静态区间第 k 大吧，当然可以用主席树搞，但是此处讨论整体二分。</p>
<p>对于每个询问 [l, r] ，可以二分答案 x ，<br>然后 check 不超过 x 的数量，与 k 进行比较即可得出接下来该询问的答案区间。</p>
<p>直接 check 是 O(V) 的，当然可以直接用数据结构维护，但是此处讨论整体二分。</p>
<p>当前的答案区间是 [L, R] ，有若干询问的答案已经确定在这个区间内，<br>取中点 M ，维护值在 [L, M] 的每个数，对于每个询问就可以 O(logn) check 了，<br>然后如果询问 k 的答案在 [M + 1, R] ，那么 k 要减去当前 check 的值，以消去 [L, M] 的影响。<br>另外处理后要清空 [L, M] 的影响。</p>
<p>这样做复杂度是 $O(q logV logn)$ 的。</p>
<p>另一个实现是维护值在 [1, M] 的每个数，<br>二分到 [L, M] 前先把 [L, M] 的影响撤销掉，<br>二分到 [M + 1, R] 前只需在二分 [L, M] 时保证算上了 [L, M] 的贡献即可。<br>这样做的好处是避开了删除，有些用并查集的操作就可以实现了。</p>
<p>这样做复杂度同样是 $O(q logV logn)$ 的。</p>
<h2 id="带修"><a href="#带修" class="headerlink" title="带修"></a>带修</h2><p>就说带修区间第 k 大。</p>
<p>将修改和查询统称为操作，只需保证操作在二分中的相对顺序，<br>处理答案在 [L, R] 的区间时按顺序做，碰到修改就修改，碰到查询就 check 。<br>但是修改哪来的答案？对于修改操作，只需将它放到它能影响的答案区间即可。<br>例如修改 $a_i = x$ ，分为两个操作：删除 $a_i$ 和添加 $a_i = x$ 。<br>前者的影响的区间需要包括 $a_i$ ，后者影响的区间需要包括 $x$ 。</p>
<p>同样有两个实现，复杂度都是 $O(q logV logn)$ 。</p>
<h2 id="在线"><a href="#在线" class="headerlink" title="在线"></a>在线</h2><p>毒瘤的地方来了，整体二分做强制在线。<br>这也是本文的真正讨论重点。</p>
<p>还是拿静态区间第 k 大分别讨论上述的两种实现。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现 1"></a>实现 1</h3><p>单独考虑一个询问 q ，观察它在整体二分中答案区间的移动过程。<br>假设当前二分到区间 [L, R] ，<br>q 能在整体二分中 O(logn) check 是因为权值在 [L, R] 的数被维护进了一个数据结构。<br>那如果 q 到达的所有可能答案区间的数据结构都提前构造好了，<br>q 就不需要整体二分，而可以直接在线询问。</p>
<p>而所有可能的答案区间事实上形成了一个线段树的结构。<br>上面已经说到要求每个可能的答案区间的数据结构已经提前维护。<br>对应在线段树中就是线段树的每个节点都有数据结构维护该节点对应的答案区间。<br>在本题中就是要权值线段树套区间树状数组，<br>而为了节省空间开销，需要换成权值线段树套区间线段树。<br>这样把每个数先按取值找到对应的外层线段树，再按位置加到对应的内层线段树，<br>每个询问 (l, r, k) 就在外层线段树上二分，在内层线段树查询区间 [l, r] 的数的个数。</p>
<p>时间复杂度依然是 $O(q logV logn)$ 的，但是空间复杂度为 $O(V + n logV logn)$ 。</p>
<p>不难推广到更一般的情况，所有不带修的<strong>整体二分实现 1 + 数据结构 A</strong>，<br>都可以用<strong>线段树套数据结构 A</strong> 做到在线询问。<br>时间复杂度不变，但是空间开销会乘上 $O(n)$ ，<br>而当<strong>数据结构 A</strong> 支持动态开空间，即空间开销与修改次数 $q$ 成函数关系 $O(qk)$ 时，<br>这样就只会带来 $O(n logV k)$ 的额外空间开销。</p>
<p>另外，这是可以支持带修的，对于修改操作，在线段树上找到影响的节点，<br>然后直接去修改节点上的<strong>数据结构 A</strong> 即可。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现 2"></a>实现 2</h3><p>还是单独考虑一个询问 q ，此时它在整体二分中答案区间的移动过程固然还是线段树的形式。<br>但是不同的是，此时线段树的每个节点 [L, R] 需要保存维护 [1, R] 的数据结构，<br>换言之，不同节点之间相互不独立。<br>但既然所有需要的数据结构都是维护 [1, K] 这样的前缀形式，<br>不难想到可持久化，每个维护 [1, K] 的数据结构在维护 [1, K - 1] 的数据结构上修改即可。</p>
<p>具体到静态区间第 k 大，按权值递增的顺序建可持久化区间线段树（树状数组难以可持久化）。<br>对于每个询问 (l, r, k) 二分答案 x 时只需要在第 x 颗区间线段树上查询 [l, r] 的数的个数。</p>
<p>时间复杂度自然还是 $O(q logV logn)$ 的，空间复杂度为 $O(V + n logn)$ 。</p>
<p>同样可以推广到更一般的情况，所有不带修的<strong>整体二分实现 2 + 数据结构 A</strong>，<br>都可以用<strong>可持久化数据结构 A</strong> 做到在线询问。<br>在可持久没有额外时间开销的前提下，时间复杂度不变，<br>否则若可持久化会带来 $O(k)$ 的额外时间复杂度，这样做的时间复杂度同样需要乘上 $O(k)$ 。<br>可持久化并查集就是个典型的例子。<br>同样空间复杂度也要乘上可持久化带来的额外开销。</p>
<p>可惜的是，这不能很好的支持修改，因为每个修改影响到的历史版本是 $O(V)$ 级别的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事实上做到在线后，干脆抛弃了整体二分的“整体查询”的思想，其实就和整体二分没什么关系了。<br>那么整体二分究竟是个什么玩意？<br>事实上绝大多数整体二分都无法做到比直接数据结构的时间复杂度优秀，<br>而且经过上述的讨论不难发现绝大多数整体二分都能直接被数据结构替代，<br>也因此整体二分往往被归在“骗分”，“非正解”一类。</p>
<p>不过整体二分明显的优势在于空间复杂度和实现难度。<br>不过有时经过整体二分的转换后，就可以使用无法可持久化，或者空间开销大的数据结构，<br>上面的树状数组就是很好的例子，无论是实现 1 还是实现 2 ，做到在线都必须换成线段树。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法扩展</tag>
        <tag>二分</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>整除分块</title>
    <url>/2019/10/10/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>（以下的除号皆表示整除）</p><p>用数论函数计算的时候，总会遇到这样一种问题：<br>$ \sum_{i=1}^n f(\frac{n}{i}) $。<br>$ O(n) $ 求往往无法满足需要。</p><p>但是<del>打表</del>可以发现， n/i 的取值对于一段连续的 i 是一致的，<br>那么可以考虑一块一块求。</p><p>设已知当前块的左端点为 l ，如果知道右端点 r（左闭右开），意味着<br>$ \forall l&lt;=i&lt;r, \frac{n}{i} = \frac{n}{l} $ ，<br>这一块对答案的贡献就是<br>$ (r-l) \cdot f(\frac{n}{l}) $。</p><a id="more"></a>



<p>结论是 $r = n / (n / l) + 1$ 。</p>
<p>证明：</p>
<ul>
<li>对于 l 设 $ n / l = x $</li>
<li>那么由 $ n \; mod \; l = n - n / l  \cdot  l = n - l  \cdot  x $ 可知 $ n - l  \cdot  x \geq 0 $</li>
<li>那么若 l + 1 满足 $ n / (l + 1) = n / l $ ，可知也有 $ n - (l + 1)  \cdot  x \geq 0 $</li>
<li>即 $ n - l  \cdot  x \geq x $</li>
<li>对于 k 若 $ n / k = n / l $ 而 $ n / (k + 1) != n / l $</li>
<li>那么根据上式可得 k 满足 $ 0 \leq n - k  \cdot  x &lt; x $</li>
<li>所以 $ n - k  \cdot  x = n \; mod \; x = n - n / x  \cdot  x $</li>
<li>所以 $ k = n / x = n / (n / l) $</li>
<li>由 k 的定义 $ n / k = n / l \; and \; n / (k + 1) != n / l $ 可知 k+1 即是要求的 r</li>
</ul>
<p>那么可以枚举块，当前 l,r 可以求得，下一个块的 l 显然是当前 r。</p>
<p>有时候会有点变化：</p>
<p>要求 $ \sum_{i=1}^{min(n, m)} f(\frac{n}{i})  \cdot  f(\frac{m}{i}) $ 。</p>
<p>还是会存在 $ \forall l&lt;=i&lt;r, \frac{n}{i} = \frac{n}{l} \&amp; \frac{m}{i} = \frac{m}{l} $ 。</p>
<p>所以这样的区间的右端点为：$ r = min(n / (n / l), m / (m / l)) + 1 $ 。</p>
<p>所以还是可以一块一块的枚举求和。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>类欧几里得</title>
    <url>/2019/10/10/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    <content><![CDATA[<p>这里只是类欧几里得的一种：<br>快速求下式：<br>$$f(a, b, c, n) = \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor$$</p><p>其中 a, b, c, n 都是正整数。</p><h2 id="缩小-a-b-规模"><a href="#缩小-a-b-规模" class="headerlink" title="缩小 a, b 规模"></a>缩小 a, b 规模</h2><p>首先的目标是让 a, b 小于 c 。</p><p>结论 1 ：<br>$$\lfloor \frac{Ax+B}{y} \rfloor =<br>\lfloor \frac{A(x\%y)+B}{y} \rfloor + A\lfloor \frac{x}{y} \rfloor$$</p><a id="more"></a>



<p>证明：<br>首先用到整除与取模的转换：<br>$\lfloor \frac{x}{y} \rfloor = \frac{x-x\%y}{y}$ 。<br>得到原命题等价于：<br>$$\frac{Ax+B-(Ax+B)\%y}{y} =<br>\frac{A(x\%y)+B-(Ax+B)\%y}{y} + A\frac{x-x\%y}{y}$$<br>$$Ax + B - (Ax+B)\%y = A(x\%y) + B - (Ax+B)\%y + A(x-x\%y)$$<br>$$Ax - (Ax+B)\%y = A(x\%y) - (Ax+B)\%y + A(x-x\%y)$$<br>$$Ax = A(x\%y) + A(x-x\%y)$$<br>$$Ax = A(x\%y) + Ax - A(x\%y)$$<br>得证。</p>
<p>那么通过这个结论可以得知：<br>$$<br>\begin{equation}<br>\begin{aligned}<br>f(a, b, c, n) &amp;= \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\<br>&amp;= \sum_{i=0}^n (\lfloor \frac{(a\%c)i+b\%c}{c} \rfloor +<br>i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor) \\<br>&amp;= f(a\%c, b\%c, c, n) + \sum_{i=0}^n (<br>i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor) \\<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>后面那一段就是一个等差数列求和，于是 a, b 被转换为小于 c 。</p>
<h2 id="转换成子问题减小规模"><a href="#转换成子问题减小规模" class="headerlink" title="转换成子问题减小规模"></a>转换成子问题减小规模</h2><p>整除除了用取模代替外，还有一种方法。</p>
<p>结论 2 ：<br>$$\lfloor \frac{x}{y} \rfloor = \sum_{i=1}^{MAX} [i \leq \frac{x}{y}]$$<br>其中 MAX 是任意一个足够大的值。<br>证明？相当于从 1 开始数，感性理解即可。</p>
<p>那么通过这个结论可以得知：<br>$$<br>\begin{equation}<br>\begin{aligned}<br>f(a, b, c, n) &amp;= \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\<br>&amp;= \sum_{i=0}^n \sum_{j=1}^{(an+b)/c} [j \leq \frac{ai+b}{c}] \\<br>&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [j + 1 \leq \frac{ai+b}{c}] \\<br>&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [cj + c \leq ai+b] \\<br>&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [cj + c - 1 &lt; ai+b] \\<br>&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [\frac{cj+c-b-1}{a} &lt; i] \\<br>&amp;= \sum_{j=0}^{(an+b)/c-1} \sum_{i=0}^n [\frac{cj+c-b-1}{a} &lt; i] \\<br>&amp;= \sum_{j=0}^{(an+b)/c-1}<br>(n + 1 - \sum_{i=0}^n [i \leq \frac{cj+c-b-1}{a}]) \\<br>&amp;= \sum_{j=0}^{(an+b)/c-1}<br>(n - \lfloor \frac{cj+c-b-1}{a} \rfloor) \\<br>&amp;= n \lfloor \frac{an+b}{c} \rfloor -<br>\sum_{j=0}^{(an+b)/c-1} (\lfloor \frac{cj+c-b-1}{a} \rfloor) \\<br>&amp;= n \lfloor \frac{an+b}{c} \rfloor - f(c, c-b-1, a, (an+b)/c-1)<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>那么就得到了一个递归计算 f(a, b, c, n) 的算法，<br>a = 0 时上式不成立，因为上面的推导有除以 a 的步骤。<br>因此将 a = 0 作为终止状态，此时 f 的计算是常数数列求和。<br>复杂度是对数复杂度 log(a)，因为上面的过程规模的减小速度相当于 gcd 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树分治</title>
    <url>/2019/10/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>线段树通过维护序列，可以维护一个承载各种操作的时间轴。  </p><p>通常用于辅助一些不支持删除操作的数据结构（线性基，并查集），<br>这种情况可以用线段树分治维护操作影响的时间来巧妙地避开删除。</p><h2 id="线段树结构"><a href="#线段树结构" class="headerlink" title="线段树结构"></a>线段树结构</h2><p>线段树分治用到的线段树（以下简称线段树）是以询问的时间为键值，<br>没有权值只有标记的线段树。</p><p>也就是线段树的一段区间对应的是一段询问（一段时间）。</p><a id="more"></a>



<p>这样的线段树只需要支持区间修改（打标记）。<br>每一个操作都会影响一段时间，对应于线段树的区间修改。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>这玩意需要一个例题才讲的清。<br>（由于线段树分治用于辅助其他数据结构，再看例题前得先会线性基）</p>
<p>维护一个集合，每次操作可以加入一个数或删除一个已经存在与集合的数。<br>每次操作后要回答这个集合的最大异或和。<br>操作次数 1e5 。</p>
<h3 id="暴力线性基"><a href="#暴力线性基" class="headerlink" title="暴力线性基"></a>暴力线性基</h3><p>如果只有插入没有删除，这题就是一遍线性基。</p>
<p>但是不巧线性基不支持删除，所以只能在每次删除后重构线性基。<br>复杂度平方带对数，稳 T 。</p>
<h3 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h3><p>将每次操作看做时间点，假设数 x 在时刻 l 被插入， r 被删除，<br>那么 x 只存在于 [l, r) 这段时间，<br>假如每个时刻开一个线性基，那么将 x 插入 [l, r) 的每个线性基，<br>这样就可以在最后通过线性基询问得到每个时刻的答案，<br>复杂度还是平方带对数，稳 T 的离线算法。</p>
<h3 id="线段树优化"><a href="#线段树优化" class="headerlink" title="线段树优化"></a>线段树优化</h3><p>比较上述两种算法，<br>第一种复杂度瓶颈在于重构线性基，实在是没有什么优化空间，<br>但是第二种算法中，复杂度瓶颈在于将 x 插入到 [l, r) 的每个线性基，<br>这个操作相当于一个区间修改，可以用线段树优化。</p>
<p>那么一个优秀的算法就出来了：<br>线段树每个节点维护一个 vector （相当于懒标记），插入 x 将直接加在线段树对应区间的 vector　内。<br>所有操作过后会得到一个只有懒标记的线段树，<br>然后考虑如何通过这样一颗线段树得出所有答案。</p>
<h4 id="处理懒标记"><a href="#处理懒标记" class="headerlink" title="处理懒标记"></a>处理懒标记</h4><p>懒标记下传？<br>不存在的，因为懒标记是一个 vector, 下传的复杂度并不是 O(1) ，<br>不难验证下传所有懒标记会使复杂度重回 n 方。</p>
<p>既然不能下传，那就进行 n 次单点查询？<br>一个道理，单点查询的复杂度并不是 log(n), 这样做同样对复杂度没有优化。</p>
<p><del>那就没救了</del></p>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>线段树分治，不能只有线段树，还要分治啊。</p>
<p>现在需要只把每个懒标记访问一遍就得出所有答案。</p>
<p>dfs 整颗线段树（实际上就是分治），深度是 log 级别的，那么对每一个深度开一个线性基。<br>如能能让 dfs 每个节点时该深度线性基维护的是这个节点到根的所有懒标记，<br>最后 dfs 到每个叶子节点就可以得到该叶子节点到根的懒标记的线性基，也就可以求出这个叶子节点的答案。</p>
<p>假设当前 dfs 到 u, 深度为 d, 深度对应的线性基已经是维护其到根的懒标记。<br>dfs 到一个新点 v 一定会使深度 + 1 ，将当前深度 d 的线性基拷贝到下个深度 d + 1 中。<br>那么 dfs 到 v 后再将 v 的懒标记加到 d + 1 的线性基中，d + 1 的线性基也就满足了要求。<br>通过这样的过程就能够做到只访问每个懒标记一遍。</p>
<p>这就是线段树分治了。</p>
<h2 id="真-例题"><a href="#真-例题" class="headerlink" title="真 - 例题"></a>真 - 例题</h2><p>这两道题就没有这么裸了。</p>
<p><a href="https://www.luogu.org/problemnew/show/P3733" target="_blank" rel="noopener">洛谷八纵八横</a> （线段树分治 + 线性基）</p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4025" target="_blank" rel="noopener">BZOJ 二分图</a> （线段树分治 + 并查集）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合数公式</title>
    <url>/2019/10/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>$ C_n^m $ 在组合数学中的意义：在 n 个元素选 m 个元素的方案数。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式 1"></a>公式 1</h3><p>$$ C_n^m = \frac{n!}{m! * (n-m)!} $$</p><p>组合数的通项公式。</p><p><strong>当要求组合数模一般模数时</strong> ，通项公式的分母可能没有逆元导致不可行。</p><h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式 2"></a>公式 2</h3><p>$$ C_n^m = C_n^{n-m} $$</p><p>基本性质，可以由通项公式得出。</p><a id="more"></a>





<h3 id="公式-3"><a href="#公式-3" class="headerlink" title="公式 3"></a>公式 3</h3><p>$$ C_n^m * C_m^k = C_n^k * C_{n-k}^{m-k} $$</p>
<h3 id="公式-4"><a href="#公式-4" class="headerlink" title="公式 4"></a>公式 4</h3><p>$$ C_n^m = C_{n-1}^{m-1} + C_{n-1}^m $$</p>
<p>组合数的基本递推式。</p>
<p><strong>当要求组合数模一般模数时</strong> ，常用这种方法预处理组合数。</p>
<h3 id="公式-5"><a href="#公式-5" class="headerlink" title="公式 5"></a>公式 5</h3><p>$$ \sum_{i=0}^n C_n^i = 2^n $$</p>
<p>组合意义： n 个元素选任意元素的方案数。<br>每个数都可以选或不选，所以方案数为 $ 2^n $ 。</p>
<p>同样可以由二项式定理： $ (x + 1)^n = \sum_{i=0}^n C_n^i * x^i $ 得出。</p>
<h3 id="公式-6"><a href="#公式-6" class="headerlink" title="公式 6"></a>公式 6</h3><p>$$ \sum_{i=0}^n (C_n^i)^2 = C_{2n}^n $$</p>
<h3 id="公式-7"><a href="#公式-7" class="headerlink" title="公式 7"></a>公式 7</h3><p>$$ C_{n+m}^k = \sum_{i=0}^k C_n^i * C_m^{k-i} $$</p>
<p>从组合数学上的定义出发，在 n + m 个元素中选 k 个，<br>相当于先在前 n 个元素中选 i 个再在后 m 个元素中选 k - i 个。<br>枚举这个 i 把方案数相加就能得到最终方案数。</p>
<h3 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h3><p>$$ C_n^m % p = C_{n/p}^{m/p} * C_{n % p}^{m % p} % p $$</p>
<p>常用于模数较小的组合数取模。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2019/10/10/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>（以下除号皆表示整除）<br>对于一些式子复杂度大的数论题，或许用莫比乌斯反演可以高效解决问题。</p><p>前置技能：</p><ul>
<li>基本数论函数</li>
<li>狄利克雷卷积</li>
</ul><p>莫比乌斯函数满足 $\mu * I = \epsilon $<br>即 $ \sum_{d|n}\mu(d) = [n = 1] $</p><p>表达式为：</p><p>$$ n = 0 : \mu(n) = 1 $$<br>$$ n = \prod_{p|n\&amp;p\,is\,prime} p : \mu(n)=(-1)^k $$<br>$$ otherwise : \mu(n)=0 $$</p><a id="more"></a>





<p>证明：<br><del>暂时不会</del></p>
<p>莫比乌斯反演：<br>对于数论函数 f(n)，设 $ F(n) = \sum_{d|n}f(d) $<br>即 $ F = f * I $<br>则有 $ f(n) = \sum_{d|n}F(d)*\mu(\frac{n}{d}) $<br>即 $ f = F * \mu $</p>
<p>证明：</p>
<p>$$ \because \; F = f*I $$<br>$$ \therefore \; F*\mu = f*I*\mu $$<br>$$ \because \; I*\mu = \epsilon $$<br>$$ \therefore \; F*\mu = f*\epsilon $$<br>$$ \therefore \; f = F*\mu $$</p>
<p>莫比乌斯反演好像主要是用来推式子，F 比 f 好做的话，就可以试试莫比乌斯反演。</p>
<p>另外事实上只需要熟知 $\mu$ 函数的性质，直接推式子就行了，<br>绝大多数情况下（至少是我遇到的所有情况下）并不需要莫比乌斯反演。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>FFT</title>
    <url>/2019/10/09/FFT/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>首先要知道关于 <a href="https://kewth.github.io/blog/2019/01/24/多项式的运算/" target="_blank" rel="noopener">多项式</a> 的一些知识。</p><p>其次要对复数有一些了解。</p><h2 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h2><p>从 <a href="https://kewth.github.io/blog/2019/01/24/多项式的运算/" target="_blank" rel="noopener">多项式</a> 中，<br>已经知道了多项式乘法的朴素算法时间复杂度为 $ O(n^2) $ 。<br>原因在于多项式是用系数表示法定义的。</p><p>重新定义 n 次多项式 a 为满足<br> $ \forall k \in [0, n), a(x_k) = y_k $<br> 的多项式，于是可以用 n 个点 $ (x_k, y_k) $ 表示这个多项式 a ，<br>这种表示方法叫点值表示法。</p><a id="more"></a>



<p>点值表示法有什么优点呢？</p>
<p>考虑用点值表示法的 n 次多项式 a, b 相乘的积 c ，满足：</p>
<p>$$ \forall k \in [0, n), cy_k = c(cx_k) = a(ax_k) * b(bx_k) = ay_k * by_k $$</p>
<p>发现这样按定义计算 c 的复杂度为 O(n) 。</p>
<p>于是 FFT 的基本思路诞生了：<br>把系数表示法的多项式 a, b 转换成点值表示法，<br>在点值表示法的定义下求出 a, b 的积 c ，<br>最后将 c 转换为系数表示法。</p>
<h2 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h2><p>将系数表示法转换成点值表示法的方法就是 DFT 。</p>
<p>设要转换的是 $ n = 2^m $ 次多项式 A （次数不足用 0 补）。<br>利用到单位根的性质，<br>目标是求出  n 个形如 $ (w_n^k, A(w_n^k)) $ 的点值<br>（ $ w_n $ 表示 n 次单位根）。</p>
<p>$ w_n^k $ 的性质：<br>在复平面里对应的向量的倾斜角 x 为 $ 2 \pi \frac{k}{n} $ ，<br>根据欧拉公式，其值为</p>
<p>$$ w_n^k = e^{x i} = cos(x) + i * sin(x) ;, ; x = 2 \pi \frac{k}{n} $$</p>
<p>考虑按次数的奇偶将 A 分成两个多项式 A1, A2 。</p>
<p>$$ A1(x) = \sum_{k=0}^{n/2} a_{2k+1} x^{2k+1} = x \sum_{k=0}^{n/2} a_{2k+1} x^k = x S1(x^2) $$</p>
<p>$$ A2(x) = \sum_{k=0}^{n/2} a_{2k} x^{2k} = \sum_{k=0}^{n/2} a_{2k} x^k = S2(x^2) $$</p>
<p>那么有 $ A(x) = A1(x) + A2(x) = x S1(x^2) + S2(x^2) $ 。</p>
<p>考虑分治处理，假设已经分治求出 S1, S2 在 $ w_{n/2}, w_{n/2}^2, w_{n/2}^3, …, w_{n/2}^{n/2}$<br>的点值。那么根据 A 与 S1, S2 的关系可以求出 A 在<br>$ w_{n/2}^{1/2}, w_{n/2}^{2/2}, w_{n/2}^{3/2}, …, w_{n/2}^{n/4} $ 的点值。</p>
<p>根据单位根的性质有 $ w_{n/2}^k = w_n^{2k} $ ，<br>那么相当于直接求出了 A 在<br>$ w_n, w_n^2, w_n^3, …, w_n^{n/2} $ 的点值：</p>
<p>$$ A(w_n^k) = w_n^k S1(w_{n/2}^k) + S2(w_{n/2}^k) $$</p>
<p>这只解决了一半，也就是 k 在 1 到 n / 2 的点值，<br>考虑 <del>用奇技淫巧</del> 求出 k 在 n / 2 + 1 到 n 的点值。<br>单位根的性质可以给出一个奇技淫巧：<br> $ w_n^{n/2+k} = -w_n^k $ ，那么就有：</p>
<p>$$ A(w_n^{n/2+k}) = w_n^{n/2+k} S1(w_{n/2}^{n/2+k}) + S2(w_{n/2}^{n/2+k}) = - w_n^k S1(w_{n/2}^k) + S2(w_{n/2}^k) $$</p>
<p>Ojbk, 分治过程完成。</p>
<h2 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h2><p>将点值表示法转换成系数表示法的方法就是 IDFT 。</p>
<p>贴个结论：<br>IDFT 的过程相当于 DFT 的过程中把所有单位根沿 x 轴对称得出的结果在最后除以 n 。</p>
<p><del>原因不详</del> ，<br>可以去膜拜一下 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" target="_blank" rel="noopener">Miskcoo</a> 。</p>
<h2 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h2><p>上述过程用递归实现常数较大，因而有一个迭代实现 FFT 的快速版本。</p>
<h3 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h3><p>FFT 的每个值都是由子问题的两个值转化而来，且这两个值可以转换成两个需要的值（ FFT 复杂度的保证）。<br>若用一个数组 a 表示多项式。<br>那么蝴蝶操作形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">complex</span> Wn; <span class="comment">// 单位根的幂</span></span><br><span class="line"><span class="keyword">complex</span> a0 = a[x], a1 = a[y];</span><br><span class="line">a[x] = a0 + a1 * Wn;</span><br><span class="line">a[y] = a1 + a0 * Wn;</span><br></pre></td></tr></table></figure>

<p>这样取出了数组中两个值后再修改相应位置的两个值，就是蝴蝶操作。</p>
<h3 id="Rader-排序"><a href="#Rader-排序" class="headerlink" title="Rader 排序"></a>Rader 排序</h3><p>Rader 排序的目的是让表示多项式的数组可以进行蝴蝶操作。</p>
<p>盗图一张： <img src="https://cdn.luogu.org/upload/pic/23926.png" alt="luogu"></p>
<p>摘自洛谷：</p>
<pre><code>剩下的问题就是把初始的数组变成最后一层的样子了。
先别急着写一个递归函数暴力把位置换过去。
来观察一下最后序列的编号的二进制表示000, 100, 010, 110, 001, 101, 011, 111，
是不是与原来 000, 001, 010, 011, 100, 101, 110, 111 相比，
每个位置上的二进制位都反过来了？
这样的变化叫做 Rader 排序。</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>逆序对</title>
    <url>/2019/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数列 a 中,逆序对即是满足 $i &lt; j$ 且 $a_i &gt; a_j$ 的数对。<br>许多情况下你推式子推着推着就推出个 $\sum_{i=1}^n \sum_{j=i+1}^n a_i&gt; a_j$，<br>这就是逆序对的数量。</p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>朴素的求法自然是 $O(n^2)$ 地枚举 $i, j$ 统计，这里不再赘述。</p><a id="more"></a>

<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>前置技能：归并排序。</p>
<p>这应该是最主流的求逆序对的方法了。</p>
<p>要求一个区间内的逆序对数，假设已经递归求出两个子区间的逆序对数，<br>接下来要做的就是求一个在左区间，一个在右区间的逆序对数。</p>
<p>考虑归并排序的过程，在两个指针比较大小时进行统计。</p>
<p>设左右区间的当前比较指针（下标）为 p1, p2,<br>当找到第一个 p2 使 $a_{p1}&lt; a_{p2}$ 时，可知 $\forall i\in [p1max+1, p2),;a_{p1}&gt; a_{p2}$ 。<br>那么横跨两个子区间的以 p1 为左端点的逆序对就有 p2-p1max-1 个。<br>对所有 p1 统计和即可。</p>
<p>值得注意的是，p2&gt;r（区间右端点）退出时，<br>此时左区间未处理的数对答案都有 r-p1max 的贡献因为此时左区间剩下的数都比右区间所有数大。</p>
<p>复杂度 $O(n \cdot log_2n)$ 。</p>
<h2 id="线段树-树状数组："><a href="#线段树-树状数组：" class="headerlink" title="线段树/树状数组："></a>线段树/树状数组：</h2><p>前置技能：线段树（或树状数组）。</p>
<p>以线段树为例。</p>
<h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法 1"></a>做法 1</h3><p>用线段树维护区间内有效数的个数。<br>之所以是有效的数，是因为要从小到大删数。<br>如果一个数 $a_i$ 是最小的，那么以其为右端点的逆序对就是 1 至 i-1 的数的个数。</p>
<p>接下来呢？<br>在线段树中删掉最小的数（单点修改 -1），<br>那么第二小的数 $a_j$ 在此时就是最小的数，同样有 1 至 j-1 的数的个数（区间查询）的贡献。<br>以此类推从小到大一个个删数即可。</p>
<p>复杂度$O(n \cdot log_2n)$。</p>
<h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法 2"></a>做法 2</h3><p>离散化后用线段树维护一个桶。</p>
<p>从左到右依次计算每个数为右端点的逆序对并加入桶，即对每个数求该数左边比该数大的数的个数。<br>设第 i 个数左边有 $f_i$ 个比 $a_i$ 大的数，那么 $f_i$ 的值即是当前线段树上 $a_i+1~a_{max}$ 的询问。</p>
<p>同样复杂度是 $O(n \cdot log_2n)$。</p>
<p>这种做法稍稍改变可以高效解决一种特殊的问题：</p>
<p>对于 01 串求串中 1 的数量比 0 的数量大的区间的数量。</p>
<p>比较容易想到的做法是将 0 看成 -1，区间中 1 比 0(-1) 多等价于区间和大于 0 。<br>区间和可以转换为前缀和 s，那么 l,r 这一区间和大于 0 等价于 $s_r - s_{l-1} &gt; 0 (r &gt;= l)$。<br>移项后即是 $s_r &gt; s_{l-1} (r &gt; l-1)$，所以题目可以转换为求前缀和的逆序对，<br>复杂度 $O(n \cdot log_2n)$ 。</p>
<p><strong>但是</strong> 这个问题有特殊性，由 01 串的至可知相邻两个前缀和的差值一定是 1 ，<br>利用这一个性质可以有更高效的方法。</p>
<p>用做法 2 求逆序对，从左到右依次扫，对于当前 $a_i$ 一定比 $a_{i-1}$ 大 1 或者小 1，<br>利用到这个差值，比 $a_i$ 大的数相当于当前线段树 $a_i+1$ 到 $a_{max}$ 的询问，<br>若 $a_i = a_{i-1}+1$ ，那么 $f_{i-1}$ 就是 $a_i$ 到 $a_{maxn}$ 的询问，否则就是 $a_i+2$ 到 $a_{max}$ 的询问。<br>那么 $f_i$ 与 $f_{i-1}$ 的差只在 $a_i$ 或 $a_i+2$ 中，长度为一，<br>完全没必要用线段树，用数组维护桶即可。</p>
<p>复杂度 $O(n)$。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>最长反链长</title>
    <url>/2019/10/09/%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E9%95%BF/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先得知道链和反链是什么。</p><p>在 <strong>有向无环图（ DAG ）</strong> 中，<br>链是满足任意两点 x, y 要么 x 可以到达 y 要么 y 可以到达 x 的<strong>点集</strong> （即使只有一个点），<br>反链是任意两点没有路径的 <strong>点集</strong> 。</p><p>那么最长反链，就是点的个数最多的反链。</p><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>不加证明地丢出两个定理：</p><ol>
<li>最长反链长度 = 最小链覆盖（用最少的链覆盖所有顶点）</li>
<li>最长链长度 = 最小反链覆盖（用最少的反链覆盖所有顶点）</li>
</ol><a id="more"></a>




<p>那么要求的其实是最小链覆盖。</p>
<h2 id="不相交"><a href="#不相交" class="headerlink" title="不相交"></a>不相交</h2><p>假设最小链覆盖不会相交，怎么求出这个最小链覆盖？</p>
<p>把每个点 i 拆成 i1 和 i2 ，考虑建立二分图。<br>如果存在一条边 (x, y) ，那么就在二分图中建立 (x1, y2) 的边。<br>这样建立二分图之后，原图的点数 - 二分图最大匹配 = 原图的最小链覆盖<br>（链不相交）。</p>
<p>这样为什么是对的呢？<br>一个点也可以看作是一个链，因此可以将每个点独立来看做初始状态。<br>然后每次在二分图中选出一条边，就是将两条链连接成一条链，<br>使用的链数就减少一个。</p>
<p>而链不会相交，所以在二分图中选出的边也是不相交的，也就是二分图的最大匹配。</p>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>如果链可以相交呢？</p>
<p>举个栗子：</p>
<pre><code>5 4 // 五个点四条边
1 3 // 1 连向 3
2 3 // 2 连向 3
3 4 // 3 连向 4
3 5 // 3 连向 5</code></pre><p>这里不相交的最小链覆盖是 3 ，而实际的最小链覆盖是 2 。</p>
<p>观察不相交的最小链覆盖 {1-3-5, 2, 4} 与最小链覆盖 {1-3-5, 2-3-4} 。</p>
<p>发现由于不能相交， 1-3-5 这条链把 2-3-4 这条链切断了，<br>分成 2 和 4 两条链，因此比最小链覆盖多了一条链。</p>
<p>如果可以让 2 跨过 1-3-5 与 4 相连呢？</p>
<h2 id="相交"><a href="#相交" class="headerlink" title="相交"></a>相交</h2><p>将原图做一次 Floyd ，<br>之后就可以知道任意两点 x, y ，x 是否能到达 y 。</p>
<p>把建立二分图的方法改造了一下，只要 x 能到达 y ，<br>就直接连一条边 (x, y)，这样就可以“跨过”其它链来连接两条链了。</p>
<p>这个时候，原图最长反链长度 = 最小链覆盖 = 二分图最大匹配。</p>
]]></content>
  </entry>
  <entry>
    <title>数论函数玄学操作</title>
    <url>/2019/10/09/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%8E%84%E5%AD%A6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>数论函数推式子是真的玄学，<br>乱七八糟的一脸懵逼，<br>好不容易看懂了转身又 <del>tm</del> 忘了，<br>这里列出一些我见过的。</p><h2 id="莫比乌斯函数与恒等函数卷积"><a href="#莫比乌斯函数与恒等函数卷积" class="headerlink" title="莫比乌斯函数与恒等函数卷积"></a>莫比乌斯函数与恒等函数卷积</h2><p>$$ \mu * I = \epsilon $$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>莫比乌斯函数的构造意义。</p><h2 id="欧拉函数与恒等函数卷积"><a href="#欧拉函数与恒等函数卷积" class="headerlink" title="欧拉函数与恒等函数卷积"></a>欧拉函数与恒等函数卷积</h2><p>$$ \phi * I = id $$</p><h2 id="单位函数与恒等函数卷积"><a href="#单位函数与恒等函数卷积" class="headerlink" title="单位函数与恒等函数卷积"></a>单位函数与恒等函数卷积</h2><p>$$ id * I = \sigma $$</p><a id="more"></a>




<h2 id="互质条件转换为莫比乌斯函数求和"><a href="#互质条件转换为莫比乌斯函数求和" class="headerlink" title="互质条件转换为莫比乌斯函数求和"></a>互质条件转换为莫比乌斯函数求和</h2><p>$$ [gcd(i, j) == 1] = \sum_{d|i,d|j} \mu(d) $$</p>
<p>$$ \sum_{i=1}^n \sum_{j=1}^m f(i, j) [gcd(i, j) == 1]<br> = \sum_{d=1}^{min(n, m)} \mu(d) \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} f(id, jd) $$</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明 1"></a>证明 1</h3><p>$$ \because [gcd(i, j) == 1] = \epsilon(gcd(i, j)) $$<br>$$ \because \epsilon = \mu * I $$<br>$$ \therefore [gcd(i, j) == 1] = \sum_{d|gcd(i, j)} \mu(d) $$<br>$$ \therefore [gcd(i, j) == 1] = \sum_{d|i,d|j} \mu(d) $$</p>
<h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明 2"></a>证明 2</h3><p>通过容斥原理和莫比乌斯函数的定义可以得出。</p>
<h2 id="约数个数函数转换为互质数对求和"><a href="#约数个数函数转换为互质数对求和" class="headerlink" title="约数个数函数转换为互质数对求和"></a>约数个数函数转换为互质数对求和</h2><p>$$ d(i * j) = \sum_{x|i} \sum_{y|j} [gcd(x, y) == 1] $$</p>
<h2 id="约数个数函数求和"><a href="#约数个数函数求和" class="headerlink" title="约数个数函数求和"></a>约数个数函数求和</h2><p>$$ \sum_{i=1}^n d(i) = \sum_{i=1}^n \frac{n}{i} $$</p>
]]></content>
  </entry>
  <entry>
    <title>快速沃尔什变换</title>
    <url>/2019/10/09/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>快速沃尔什变换，简称 FWT ，目前在 OI 中十分冷门。</p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>多项式卷积一般是这样的：</p><p>$$ C_i = \sum_{j + k = i} A_j \cdot B_k $$</p><p>这个可以用 FFT 快速求解。</p><p>然而还有一个诡异的卷积：</p><p>$$ C_i = \sum_{j \oplus k = i} A_j \cdot B_k $$</p><a id="more"></a>





<p>其中 $ \oplus $ 是任意一种位运算。</p>
<p>FWT 便是求这类卷积的快速算法。</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>FFT 的思想是把多项式转换成可以线性相乘的点值表示法 (DFT) ，<br>再把相乘的结果转换回系数表示法 (IDFT) 。</p>
<p>同样的道理可以用在 FWT 上，用 DWT 将多项式转换成可以线性相乘的形式，即：</p>
<p>$$ DWT(C)_i = DWT(A)_i \cdot DWT(B)_i $$</p>
<p>再用 IDWT 将相乘的结果转换回来。</p>
<h2 id="DWT"><a href="#DWT" class="headerlink" title="DWT"></a>DWT</h2><p>目标是构造一个转移系数函数 f(i, j) ，满足：</p>
<p>$$ DWT(A)_i = \sum_j A_j \cdot f(i, j) $$</p>
<p>考虑 f(i, j) 应满足什么样的性质。</p>
<p>首先根据 DWT 的性质：</p>
<p>$$ DWT(C)_i = DWT(A)_i \cdot DWT(B)_i $$</p>
<p>$$ \sum_t C_t f(i, t) = \sum_j A_j f(i, j) \sum_k B_k f(i, k) $$</p>
<p>$$ \sum_t \sum_{j \oplus k = t} A_j B_k f(i, t) = \sum_j \sum_k A_j f(i, j) B_k f(i, k) $$</p>
<p>$$ \sum_t \sum_{j \oplus k = t} A_j B_k f(i, t) = \sum_t \sum_{j \oplus k = t} A_j f(i, j) B_k f(i, k) $$</p>
<p>由上式可得出：</p>
<p>$$ \forall i, j, k: f(i, j) f(i, k) = f(i, j \oplus k) $$</p>
<p>这样还不够，为了让 DWT 快速进行，f(i, j) 还应满足以下性质：</p>
<p>$$ f(i, j) = \prod_k f(i_k, j_k) $$</p>
<p>其中 $ i_k $ 表示 i 二进制下的第 k 位（ 0 或 1 ）。</p>
<p>有了这个性质，就可已通过 f(0, 0), f(0, 1), f(1, 0), f(1, 1) 的值相乘得出所有 f 。<br>有了这个性质，就可以考虑分治求 DWT ：</p>
<p>$$ DWT(A)<em>i = \sum</em>{j=0}^{n-1} A_j f(i, j) $$</p>
<p>$$ = \sum_{j=0}^{n/2-1} A_j f(i, j) + \sum_{j=n/2}^{n-1} A_j f(i, j) $$</p>
<p>$$ = \sum_{j=0}^{n/2-1} A_j \prod_k f(i_k, j_k) + \sum_{j=n/2}^{n-1} A_j \prod_k f(i_k, j_k) $$</p>
<p>$$ = \sum_{j=0}^{n/2-1} f(i_0, j_0) A_j \prod_{k \geq 1} f(i_k, j_k) + \sum_{j=n/2}^{n-1} A_j f(i_0, j_0) \prod_{k \geq 1} f(i_k, j_k)$$</p>
<p>$$ = f(i_0, 0) \sum_{j=0}^{n/2-1} A_j \prod_k f(i_k, j_k) + f(i_0, 1) \sum_{j=n/2}^{n-1} A_j \prod_k f(i_k, j_k) $$</p>
<p>规模减小了一半，递归或迭代地分治下去。<br>每次将 A 分成左右两半 A0, A1 ：</p>
<p>$$ DWT(A)_i = f(0, 0) DWT(A0)_i + f(0, 1) DWT(A1)_i , i &lt; n / 2 $$</p>
<p>$$ DWT(A)_i = f(1, 0) DWT(A0)_i + f(1, 1) DWT(A1)_i , i \geq n / 2 $$</p>
<p>想到 FFT 的蝴蝶变换没有？ <del>答：没有</del><br>迭代的 DWT 这里也有类似的蝴蝶变换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = A[i], y = A[i + k];</span><br><span class="line">A[i] = f00 * x + f01 * y;</span><br><span class="line">A[i + k] = f10 * x + f11 * y;</span><br></pre></td></tr></table></figure>

<p>DWT 的过程就是这样了，甚至不需要构造整个 f ，<br>只需要 f(0, 0), f(0, 1), f(1, 0), f(1, 1) 即可，<br>需要满足的就是 $ \forall i, j, k: f(i, j) f(i, k) = f(i, j \oplus k) $ 。</p>
<h2 id="IDWT"><a href="#IDWT" class="headerlink" title="IDWT"></a>IDWT</h2><p>怎么将 DWT 的结果转换回来？<br>观察 DWT 的蝴蝶变换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = f00 * x + f01 * y;</span><br><span class="line">b = f10 * x + f11 * y;</span><br></pre></td></tr></table></figure>

<p>DWT 通过 x, y 求出 a, b,<br>IDWT 就是通过 a, b 求 x, y 。</p>
<p>解二元一次方程就好了：<br>x = (f11 * a - f01 * b) / (f00 * f11 - f01 * f10)<br>y = (f10 * a - f00 * b) / (f01 * f10 - f00 * f11)  </p>
<p>就是这么简单…</p>
<p>个屁啊。</p>
<p>考虑 f 的构造，<br>要满足 DWT 的性质把所有的 f 设为 0 不就可以了？<br>要满足 DWT 的性质把所有的 f 设为 1 不就可以了？</p>
<p>这样且不是对于任何位运算都会有相同的结果？</p>
<p><del>Naive.</del></p>
<p>再看看 IDWT ，分母里边是不是有 (f01 * f11 - f01 * f10) ？<br>不幸的是把 f 全部设为 0 或者全设为 1 这个分母都是 0 ，<br>这意味着 IDWT 的二元一次方程无解，转过去就转不回来了。</p>
<p>因此 f 的构造还要满足一个条件： <code>f01 * f11 != f01 * f10</code> 。</p>
<h2 id="f-的构造"><a href="#f-的构造" class="headerlink" title="f 的构造"></a>f 的构造</h2><p>f 需要满足的性质已经讲的很详细了。</p>
<p>这里给出常用位运算中 f 的构造：</p>
<ul>
<li>按位或： f00 = 1, f01 = 0, f10 = 1, f11 = 1</li>
<li>按位与： f00 = 1, f01 = 1, f10 = 0, f11 = 1</li>
<li>异或： f00 = 1, f01 = 1, f10 = 1, f01 = -1</li>
</ul>
<p>可以自行验证，这些 f 满足上述性质。</p>
<h2 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h2><p>一个多项式 A FFT 后的 A2(x) 实际意义就是 A 在 $ W_n^x $ 上的值（点值表示）。</p>
<p>那么 A FWT 后的结果的现实意义呢？<br>这得分类来说。</p>
<h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h3><p>A 在做按位或的 FWT 之后得到的 A2 满足：<br>$$ A2(x) = \sum_{i|x=x} A(i) $$</p>
<p>也就是说 A2(x) 表示 x 的每个子集 i 的 A(i) 的和。<br>不难得到，A2(x) * B2(x) 的结果 C2(x) 就是 A, B 卷积后的 C 的变换：<br>$$ A2(x) * B2(x) = \sum_{i|x=x} A(i) \sum_{j|x=x} B(j) $$<br>$$ A2(x) * B2(x) = \sum_{i|x=x} \sum_{j|x=x} A(i) B(j) $$<br>$$ A2(x) * B2(x) = \sum_{k|x=x} \sum_{i|j=k} A(i) B(j) $$<br>$$ A2(x) * B2(x) = \sum_{k|x=x} C(k) $$<br>$$ A2(x) * B2(x) = C2(x) $$</p>
<p>事实上，这也就是子集和变换。</p>
<p><del>感性理解一下</del></p>
<h3 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h3><p>和按位或类似的，A 在做按位与的 FWT 之后得到的 A2 满足：<br>$$ A2(x) = \sum_{i&amp;x=x} A(i) $$</p>
<p>也就是说 A2(x) 表示每个包含 x 的集合 i 的 A(i) 的和。<br>不难得到，A2(x) * B2(x) 的结果 C2(x) 就是 A, B 卷积后的 C 的变换：<br>$$ A2(x) * B2(x) = \sum_{i&amp;x=x} A(i) \sum_{j&amp;x=x} B(j) $$<br>$$ A2(x) * B2(x) = \sum_{i&amp;x=x} \sum_{j&amp;x=x} A(i) B(j) $$<br>$$ A2(x) * B2(x) = \sum_{k&amp;x=x} \sum_{i&amp;j=k} A(i) B(j) $$<br>$$ A2(x) * B2(x) = \sum_{k&amp;x=x} C(k) $$<br>$$ A2(x) * B2(x) = C2(x) $$</p>
<p><del>和按位或一个模子里刻出来的</del></p>
<h2 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h2><p>两个多项式 A, B 的子集卷积 C 的意义如下：</p>
<p>$$ C(x) = \sum_{y|z=x, y&amp;z=0} A(y) B(z) $$</p>
<p>也就是把 x 划分为两个子集 y, z 的 A(y) * B(z) 的和。</p>
<p>转换成 $ \sum_{y|z=x} A(y) B(z) [y &amp; z = 0] $ ，似乎是一个按位或卷积。<br>再转换成 $ \sum_{y|z=x} A(y) B(z) [bitcount(y) + bitcount(z) = bitcount(x)] $ 。</p>
<p>此时需要考虑的就是 bitcount, 也就是集合大小。<br>集合大小是 $ O(log(n)) $ 的，可以考虑枚举大小，设：<br>$$ A_i(x) = A(x) [bitcount(x) = i] $$<br>$$ B_j(x) = B(x) [bitcount(x) = j] $$<br>$$ C_k(x) = C(x) [bitcount(x) = k] $$</p>
<p>那么有：<br>$$ C_k(x) = \sum_{y|z=x} A_i(y) B_j(z) [i + j = k] $$<br>$$ C_k(x) = \sum_{i+j=k} \sum_{y|z=x} A_i(y) B_j(z) $$</p>
<p>那么枚举 i, j 的值，将 $ A_i $ 和 $ B_j $ 卷积后贡献到 $ C_{i+j} $ 即可。</p>
<p>这样复杂度似乎是 $ O(n log^3n) $ 的，<br>但是事实上每个 $ A_i, B_j $ 都可以提前 FWT 后 $ O(n) $ 相乘，<br>再贡献到 C 后不进行逆变换，而是确定了 C 的值后在进行逆变换。</p>
<p>复杂度 $ O(n log^2n) $</p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 I</title>
    <url>/2019/10/09/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20I/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p><p>Day0 to Day4.</p><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>大清早的就出发了，地铁还是那么挤。<br>先从长沙坐到南京，高铁上干坐 6 个小时贼贼贼贼贼无聊。</p><p>中午幸好提前买了泡面，随便应付一下，坐了一上午不动也不会感觉饿。<br>%%% 在高铁上一餐吃 70rmb 的 lzk 。</p><p>到了南京还得等 1 小时转到芜湖，期间 UNO 现学现玩，<br>第一把就赢了，一定是传说中的新手的欧气附体，<br>但是这欧气来得快去的也飞快，后面再也没赢过 ，并且一度成为全场最富（一次拿了 20 张牌也是没谁了）。</p><a id="more"></a>




<p>再到动车上就累了，睡了一觉。</p>
<p>宾馆感觉一般但也还行，位置不错，旁边就是美食街，<br>逛一遍发现芜湖的物价似乎比长沙要便宜得多？<br>这里奶茶只有长沙一半多的价格还巨好喝，还有木桶饭最便宜 8rmb, 最贵也 16rmb, 吃得相当饱，提供的辣椒酱好评。</p>
<p>晚上宾馆自习，我的笔记本实在实在实在是太 tm 旧了 windows xp 实在实在实在是忍不了啊。<br>宾馆的 wifi 都连不上去我怎么怎么打（kan）代（dian）码（ying）啊？？？<br>还有我早已练就一身折腾本领，小事，关掉 XP 的沙雕代理轻松解决。<br>但是网络实在是 suo （也许是我电脑不行？），努力了一晚上都没能成功看上电影。</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>第一天考试，凄惨爆 0 。<br>考试的时候想不出题啊（<del>我太菜了</del>），比较心不在焉，<br>才发现打满暴力都是一种困难，水平不够。<br>%　一 % 成功拿满暴力的 CZZ, orz 。</p>
<p>第一题维护区间历史最小和，玄学转换到二维平面 KD-Tree, 这玩意前几天刚考但是没去学，<br><del>我发现冷门算法一考就会连续考几次</del>。</p>
<p>第二题一脸不可做，题目名叫因式分解，我也就真的只会因式分解了。<br>讲题的时候满分做法爆搜？？？好吧正解还是要个 DP 的。</p>
<p>第三题式子题妙啊妙啊，这什么用 $ \sum_{i=0}^{n-1} A^i = \frac{A^n-1}{A-1} $  把 $ A^n $ 换掉的清奇思路谁想得到啊。<br>还有把 f(i) O(1) 一路推到 f(n) 再用组合数的奇技淫巧把 k 到 n 的枚举换成 1 到 k 谁想得到啊。</p>
<p>还有吐槽一下这套题部分分好少，几乎只有两档：暴力 -&gt; 正解。</p>
<p>然后就是晚上的 <del>自由欢乐时光</del> 认真自习。<br>终于成功把昨天的电影看了一半。<br>然后颓了一晚上也是没救了，没办法 T3 被卡常心态爆炸（这就是你颓废的理由？）。</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p><del>成功拿到预期的暴力分 30，一大进步。</del></p>
<p>第一题图染色，考场上脑子不清醒，很快想到 $ O(n^2) $ 的建图方式后，<br>竟然完全没有想到怎么计数，最后 $ O(n^n) $ 枚举染色方案可还行。<br>于是 40’ -&gt; 10’</p>
<p>第二题又是一个计数，AC 自动机？我完全没想到，<br>我还以为是容斥，但是发现有有 5 种情况，容斥起来要 5 + 10 + 10 + 5 种情况加加减减，<br>没敢打，不过这次这题部分分给的挺全的，分了 10 个 subtask 还是不错的 <del>虽然我只拿了 20 ~</del> 。</p>
<p>第三题玄学最短路，要用最短路树（我想到了但是没啥用），这玩意前几天 czz 才讲，<br><del>果然又应验了我昨天说的，一考就连续考几次</del><br>暴力都很难打啊这题，到最后只能 <code>puts(&quot;-1&quot;)</code> 了，然而 subtask 数据捆绑。</p>
<p>一考完就被 *** 拉去吃什么网红烤冷面（然而是热的），very nice but 量有点少。<br>然后 *** 就拉了一堆人去星巴克 666 ，讲真这是我第一次在星巴克喝咖啡，忍痛剁手。<br>晚上到宾馆就开始颓，终于看完了昨天的电影 <del>壮哉我大火影</del> 。</p>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>今天的题目巨难，听出题人说是因为他明天赶时间所以把明天的 <del>毒瘤</del> 题全放今天就有更多时间讲。</p>
<p>第一题在 2 * n 的网格图上求一个生成树，我想到有个类似的题（求 2n 的网格图上放一颗树的方案数），<br>但是那道题我已经忘记怎么做了，而且那是计数，而这题是要求一个最优方案，<br>反正就是以为可做然而 Naive, 浪费了很多时间最后打了枚举生成树的大暴力。<br>考场上有一个线性计算当前方案的算法，枚举的时候加一点小剪枝，总复杂度应该是 $ O(6^n n) $ ，<br>预计 20’ ，但是实际上还是只有 10’ 。</p>
<p>第二题感觉是什么数据结构题，我按照一种贪心思路敲了线段树，<br>估摸着有 23’ 就没管了，后来出题人放了三个大样例，我一测，第一个就 WA 了，改了一点细节后过掉了，<br>再测第二个，又 WA 了，然后 debug 了好久才意识到贪心的思路不对，这个时候离考试结束只有 5min, 弃疗。<br>然后和预计的一样，3’ 。</p>
<p>第三题是在一个很奇怪的图上面求最短路为 x 的点对（怎么又是最短路），<br>大暴力就是跑出每个点对的最短路再统计嘛，这个图发现了一些性质，但是还是不会做，<br>想着应该不难打就去打 T2 了，然后 T2 打到结束前 5min 所以这题的暴力也没打， 0’ 。</p>
<p>今天的部分分还是很少，T2 T3 的暴力都只有 3’ ，难受。</p>
<p>中午去一个东北菜馆吃饭，菜上的k慢但是挺好吃，很有特色，<br>最抢眼的是收银台前面的冰箱，里面一条<strong>巨大</strong>的鱼（完整一条的可能比我还大？）。</p>
<p>下午有洛谷月赛，于是冠冕堂皇地不改题打月赛，洛谷月赛一如既往，除了签到题都只能打暴力。</p>
<p>晚上险些被查水表，我正在听歌教练突然敲门，我当时就以迅雷不及掩耳盗铃儿响叮当仁不让世界感受痛楚汉相争之势拔掉了耳机。<br>没错，拔掉了耳机，然后 tm 就变成外放了声音贼大，当时就感觉自己真是沙雕了我去，<br>然后我又以迅雷不及掩耳盗铃儿响叮当仁不让世界感受痛楚汉相争之势插上了耳机（被自己秀死了），这个时候教练已经差不多进来了，然后交代一些事，我耳机就插在笔记本上光明正大地摆桌上，有点小可怕，还好教练没有说什么。。。</p>
<p>从今天开始教练晚上要强制收电脑，于是 10:30 电脑被收后无所事事，<br>这时候大家都要睡了（比如柠檬 9:30 就交电脑睡了），可是<del>万恶的</del> *** 以睡不着的名义把我拉过去打 UNO,<br>然后我<del>只能被逼无奈地</del>去打 UNO,  到 11:30 才睡可还行。</p>
<h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>今天终于 A 了一题，今天终于 A 了一题，今天终于 A 了一题。<br>还有 % 一 % 全场 rank1 的柠檬。</p>
<p>第一题我手玩了一下得出了一个十分精简的结论，按照这个结论三四十行代码就能解决，<br>自己都不敢相信啊，今天终于有一道良心签到题了？<br>于是打出来后不停地调试，手造各种情况的数据都跑一遍，把之前的结论完善一些漏洞之后就交了，<br>交了之后还是有点慌，生怕哪里出锅。<br>最后还是成功 AC （四天来唯一一次）。</p>
<p>第二题刚开始看题还觉得可做，感觉像扫描线加线段树那种，<br>但是看到可能有一面墙回塌后就不这么觉得了。<br>而且我还看错了样例，这直接导致我误解题意，本来是先选点再有墙塌（考虑方案的时候不知道哪个墙会塌），<br>我看样例这样跑出来不对（其实是我手玩玩错了），就以为是先塌墙再选点（提前知道哪面墙会塌后考虑方案），<br>于是 blablabla 后交上去，预计至少有个二三十来分，结果只有大暴力 3’ （还好大暴力的数据没卡掉我）。</p>
<p>第三题就感觉完全不可做了，最后暴力都没打， 0’ 。<br>下午讲题的时候才发现这题 25’ 的部分分贼容易，就是个排序加贪心。<br>另外 75’ 正解好像是用 dp 做前面 25’ 在对后面 75’ 的求和用 dp 套 dp, 好巧啊之前朱哥才讲过。</p>
<p>A 了一题心里比较舒服，于是下午就颓了好久，打 Nazo 自力更生到 level 8 就不会了，<br>在网上找提示后玩到 level 11 后再次卡关。</p>
<p>另外碰到一件玄学的事，我那显示器一碰就断电，然后要不断地调那根线，<br>直到调到某个位置才可以打开，大概是因为接触不良，<br>然后一次又黑了，我调了贼久试遍了各种姿势还是然并卵，<br>没法子了，去找老师实在不行换个位置，<br>老师了解状况后过来随手一拨，真的是 <strong>随手一拨</strong> ，那显示屏就开了，就开了，开了，了，<br>emm 不愧是金牌教练，真的 6 。</p>
<p>晚上本来去吃必胜客的，但是没注意到今天周日，人巨多，排队等座位都要半个小时，<br>几经周折最后去了 KFC ，也还不错。<br>旁边一家奶茶店搞活动，把一个计时器按到刚好 10s 就能领两大杯奶茶，然而大概是我脸黑，按了 3 次都差的蛮远。<br>晚上又是 UNO, 和 tyr 无意间相互精准放炮，<br>连续两次 tyr （下家）只剩一张牌，我掐指一算，猜到了那张牌的颜色，<br>自信地打出一张其它颜色牌，结果和他数字相同。。。</p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="/2019/03/26/安徽游记-ii/">Day5 to Day8</a></p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 III</title>
    <url>/2019/10/09/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20III/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p><p>Day9 to Day12.</p><h2 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h2><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><p>炸了，今天出的题好诡异。</p><p>第一题一道博弈论，题意好迷，没太看懂就去做后面的题了，<br>到后面离考试只有 5min 了再回来看 T1, 暴力都好难打，<br>于是信仰一波 <code>std::cout &lt;&lt; 0 &lt;&lt; std::endl</code> ，水到了 12’ 。</p><a id="more"></a>



<p>第二题是给出将数组 a 变换到 b 的方式，要求用 b 求 a ，<br>式子里面有按位或、异或、bicount 什么的，莫非是 FWT ?<br>于是推式子，如果真的是 FWT 的话求出 a 到 b 的变换应该可以推出 b 到 a 的逆变换。<br>于是乎我花了一个小时搞来搞去，重新推了一遍 FWT （这个式子真的 6 没办法套用常用的位运算卷积），<br>果然可以从 a 用分治 3 个 for $ O(n log(n)) $ 变换到 b 。<br>但是和普通的 FWT 最不一样的就是这玩意不能“蝴蝶变换”，仅从 x, y 两个数推不到新的 x, y 。<br>woc 那我怎么解方程求逆变换？当时有点绝望了开始怀疑 FWT 做不了，<br>又去看了看 T3 ，不可做啊似乎，于是决定爆肝 T2 。<br>我就手玩小数据，推推式子再找找规律，搞了大概 1h 发现把 b 做一遍异或逆变换再乘二再把 b[0] 减去原来的 b[0] 好像就是 a ！<br>我还证明了它在 n 小于 8 的正确性，然后手玩了 n = 8 时的情况，错了。。。<br>再次绝望，想了好久大概又过了 30min 吧突然发现之前手玩算错了，我靠重新手玩，完全符合规律。<br><del>好嗨哟，感觉人生达到了高潮</del><br>快速敲完 KET （ kewth 变换可还行）交了上去，结果最后爆 long long 了，爆 long long 了， long long 了，了。。。<br>100’ -&gt; 60’</p>
<p>第三题交互题，实在没思路就想着能不能卡掉他的交互器来玄学 AC ，<br>（以下玄学操作，请勿模仿）<br>为此我研究了大约 40min 的 syzoj 交互原理。<br>考场上的提交得不到反馈，我就去同样用 syzoj 的 LOJ 上试着提交一下尝试尝试。<br>然后第一波提交， CE 。。。<br>改了一下再次提交， wating, wating, wating….<br>woc 无限 wating? 感觉不对经，看了看 LOJ 的评测记录，然后。。。<br>woc 自我 CE 代码后的所有评测全是 wating 不动，当时就懵逼了 loj 被我卡爆了？<br>事实证明只是 loj 卡了一下，过个 3min 的样子就恢复了。。。<br>我还读了下下发的交互器，于是我搞懂了这玩意的交互原理，<br>但是实际的交互程序是另一个程序，下发的交互器只是和你的代码一起编译后和交互程序交互，<br>看了看交互器最后 AC 的输出，然后在 solve 函数里打了份一样的就 exit(0) ，交了。<br>结果。。。没过，实际评测的交互器和下发的交互器完全不同。。。（但是确实可以卡，后面会说）</p>
<h3 id="讲题"><a href="#讲题" class="headerlink" title="讲题"></a>讲题</h3><p>今天的讲题真欢乐，一位大佬屡次上台嘲讽出题人。</p>
<p>T1 就是 dp 啊，加个启发式合并状态，如果不把时间浪费在 T3 说不定能想出来的。</p>
<p>T2 不想说了，心累，在变换过程中做除法就不会爆 long long ， AC 。</p>
<p>T3 随机分治？感觉挺 6 但是没懂。<br>但是我还是通过奇技淫巧 AC 了。。。</p>
<h3 id="爆掉这辣鸡交互"><a href="#爆掉这辣鸡交互" class="headerlink" title="爆掉这辣鸡交互"></a>爆掉这辣鸡交互</h3><p>我还真不信这交互器天衣无缝，再次看交互器，<br>交了几个错误的程序，发现我能得到的信息只有交互程序给出的信息，<br>再蠢也不会把重要信息放提示信息里头嘛，感觉似乎没办法了。<br>又交了一次， CE 了。。。<br>这时转机出现了，我看了眼编译信息， woc nice 大夫 g++ 给的编译信息真详细：</p>
<pre><code>/sandbox/1/a.cpp:5:6: error: &apos;QCNT&apos; was not declared in this scope
out,QCNT,&apos;\n&apos;;
  ^
/sandbox/1/a.cpp:5:6: note: suggested alternative:
In file included from /sandbox/1/a.cpp:2:0:
/sandbox/1/c.h:74:5: note:   &apos;lkjjhkfdlhgkjdfgf5454::QCNT&apos;
int QCNT;</code></pre><p>note 那一排暴露啦，这命名空间 lkjjhkfdlhgkjdfgf5454 也是没谁了（另外还发现了源码的位置 /sandbox/ ）。<br>但是出题人以为套一个乱七八糟的 namespace 就没事了？<br>然而还是被我发现了哈，于是通过这个 namespace 直接获取了交互器里存的答案，<br>成功 AC ，辣鸡交互器。</p>
<p>看了看提交记录，我是第二个玄学 AC 的，第一个的 AC 代码提交时还没有那 sb namespace ，<br>所以说，我是第一个发现这鬼畜 namespace 并通过它 AC 的 :)<br>然后从我 AC 后就陆续有人玄学 AC, 代码我都看了一遍，大同小异，全是用这 sb namespace 过的（变量名、注释都跟我的长一个样），<br>开创先河哈。</p>
<p>后面再改改就是 65B 全场最短 AC 代码。</p>
<p>后来又看了看，还有一名大佬用另一种方式爆掉了这辣鸡交互器。<br>比我 6 多了，竟然直接搞到了交互器判 AC 的方式给写 solve 函数上了， %%% 。</p>
<p>声明：<br>交互器确实是可以做到无法被爆破的，<br>我今天成功爆掉交互主要原因是交互的封装方式漏洞百出，<br>把交互的主要部分直接给 include 进来了，<br>正确的方式是将交互的关键部分写在真正处理交互的通过输入输出交互的程序里面。<br>去看看 loj 的交互题，把附加文件下下来，<br>那附加文件就是封装了一下和交互器的交互方式，你不用都没关系。</p>
<h2 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h2><h3 id="考试-1"><a href="#考试-1" class="headerlink" title="考试"></a>考试</h3><p>第一题乍一看要动态维护逆序对？感觉不太可做，后面直接交了暴力， 30 分。</p>
<p>第二题字符串，感觉像是贪心，但是有一些情况不好判断，<br>最后打了字符串做状态的暴力 DP ，我估摸着复杂度是 $ O(n^3) $ ，<br>于是就只开了 30’ 的部分分的数据的大小的数组 n = 100 ，交了，果然是 30’ ，<br>然而我把数组开到 2000 （ 60’ 的范围）后就过了 60’ ，这。。。<br>60’ -&gt; 30’ <del>论复杂度分析的重要性。</del></p>
<p>第三题式子题，乍一看似乎可做，然后简化简化简化，简化成了这样一个题意：</p>
<pre><code>在正整数范围内解方程 x * phi(x) = 2m ，m 已知。</code></pre><p>我一看这么简洁的式子，枚举一下 2m 的因子应该差不多了，<br>一看数据范围： $ m \leq 10^{18} $ ，第一档暴力 10’ 范围： $ m \leq 10^9 $ 。。。<br>还多组数据，一共 100000 组。。。<br>连暴力都过不去啊我去。<br>最后实在没思路，就预处理了一部分 phi 再暴力去搞，结果爆零。。。</p>
<h3 id="讲题-1"><a href="#讲题-1" class="headerlink" title="讲题"></a>讲题</h3><p>第一题其实真的容易，根本不要动态维护逆序对，<br>题目要求的只是使逆序对最小的一个循环的位置，<br>考虑一个数从最左边被扔到最右边后对逆序对数量的影响，其实是不会变的，<br>维护这个影响的数列，那么就是要求一个最小前缀和的位置，<br>每次修改就是交换两段区间，虽然逆序对数量会改变，但是根本不用管，相对的影响还是不变的，<br>那这玩意一个平衡树搞上去就好了。</p>
<p>第二题我似乎摸到正解的前一半了，<br>贪心把能直接求的字母搞出来后对于剩下的求一个字典序最大后缀好像是，<br><del>那这玩意一个后缀数组搞上去就好了。</del><br>然而似乎还是要考虑一些情况，还没改出来。</p>
<p>第三题数论神仙题（我竟然以为 T3 可做），<br>正解复杂度 $ O(log(m)) $ ，神仙做法，<br>什么二次剩余什么欧拉定理什么质因数玄学分解都用上了，<br>好难，出题人讲了两遍都没听懂。</p>
<h2 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h2><p>倒计时两天。</p>
<h2 id="考试-2"><a href="#考试-2" class="headerlink" title="考试"></a>考试</h2><p>第一题平面图上随机游走求到 n 的期望路径？<br>30’ 高斯消元暴力分比较容易想到，其他的就没思路了，想着先去打后面的题。<br>最后回来打 T1 的时候连高斯消元都没打出来（我太菜了）。。<del>其实是改昨天的题去了</del></p>
<p>第二题博弈题？乍一看似乎可做，然后简化简化简化，简化成了这样一个题意：</p>
<p>给定数列 a, b, c, 选 a 中的 x 个数替换成任意数使得 $ \forall i: a_{i-1} + b_{i-1} \leq a_i \geq a_{i-1} + c_{i-1} $<br>求最小的 x 。</p>
<p>然后这玩意 $ O(n^2) $ DP 嘛 $ O(n) $ 状态 $ O(n) $ 转移，<br>我以为可以得 10’ + 20’ + 30’ 三个子任务的分，<br>结果 subtask2 的数据范围比 subtask3 大，但是是一个特殊情况，判掉就好了，我没打。。。<br>60’ -&gt; 40’</p>
<p>第三题没思路，暴力枚举行枚举列枚举每个位置 24k 纯暴力，拿到了 40’ 的好成绩。</p>
<h2 id="讲题-2"><a href="#讲题-2" class="headerlink" title="讲题"></a>讲题</h2><p>第一题解方程线性代数 blabla, 但是看了看 Rank1 的代码，<br>发现就是一个矩阵乘法，卧槽 $ O(n^3) $ 过 3000 ？<br>经 *** 分析，平面图上的边数是 $ O(n) $ （最大是 3n - 6 ），<br>所以高斯消元里的矩阵的点数是 $ O(n）$ 的，<br>然后就可以根据之前 pics 讲过的方法 $ O(n) $ 做矩阵乘法（ n * n 的矩阵与列向量相乘），<br>做 n 遍，复杂度 $ O(n^2) $ 。</p>
<p>第二题似乎是最难的，我挂到 40’ 都能是全场 rank1 。。。<br>难点主要在简化题意上，简化后出题人说这就是个普及题了（ woc 我是不是不适合学信息），<br>DP 可以优化，设一些坐标搞到平面上后将转移用线段树维护优化到 $ O(log(n)) $ ，<br>但是把所有点对应到平面后，还有种更简单的做法就是求出最长下降子序列 x, 答案就是 n - x 。<br>这个结论的证明折腾了一下午，还是很妙的。</p>
<p>第三题暴力优化 dfs 可以水 90 分？<br>正解先枚举行再筛选列将单调性用桶存起来再转移大概是，正在改。</p>
<h2 id="爆肝-Splay"><a href="#爆肝-Splay" class="headerlink" title="爆肝 Splay"></a>爆肝 Splay</h2><p>这三天都在爆肝 Splay, 突然又对 Splay 的翻转操作有了更深的理解，<br>也发现 Splay 真不是那么万能的，许多操作用 Splay 做会多一些不必要的麻烦，<br>尤其是维护不对称信息还要带区间翻转的时候，似乎根本做不了？<br>硬要做的话就必须强制让维护的信息对称，<br>比如要是维护最大前缀和，要支持区间翻转就得还同时维护个最大后缀和。<br>不说了，去他的信仰，正在学无旋 Treap 。</p>
<h2 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h2><p>最后一天。</p>
<h3 id="考试-3"><a href="#考试-3" class="headerlink" title="考试"></a>考试</h3><p>第一题已看完题 woc 这不就解方程嘛，手动消消元什么的就行了，<br>出题人这么良心？于是就开始打，打完后测了测样例， woc 过了。<br>再把大样例下下来一看， woc 出题人这么良心每道题 5 组大样例？<br>全都测了一遍，全过了，交了，这个时候考试开始 59min 12s 。。。<br>但是还是很荒，担心会写炸，然后就对着代码检查检查改了几个细节，<br>改着改着又测了测时间， woc 要跑 0.9s+ ，这不会被卡常吧？<br>又慌了起来，但是出题人说不会卡常，还下发了 io 模板，<br>套上 io 模板后再测 0.2s+ ，松了口气，最后交了一次，<br>这时候考试开始 101min 15s 。。。<br>考完后看了下，其实我第一次交就 AC 了，白折腾这么久。。。</p>
<p>第二题神奇题，打了个暴力，期望 60’ ，<br>感觉可以把状态放平面上通过单调性什么之类的优化，<br>但是没有具体的优化方案（我的计算几何真的是一片空白），<br>结果最后暴力挂了？只有 10’ 啊后面 50’ 全 WA 了我一脸懵逼。<br>还在找错。</p>
<p>第三题哇神仙题，一看就不可做的那种，打完暴力后挣扎了一下，<br>得到了 30’ 的好成绩。</p>
<h3 id="讲题-3"><a href="#讲题-3" class="headerlink" title="讲题"></a>讲题</h3><p>今天又被爆踩了，T1 A 了一片，拉不开差距。</p>
<p>第二题果然是计算几何神仙题，什么凸包二分三分，什么半平面交，什么李超线段树。<br>完全不会，只能等我计算几何基础打好后再来重做这题了。</p>
<p>第三题出题人说打表找规律题？反正我是没看出什么规律，<br>然后出题人证明了一些结论，有这些结论就能 50 行内解决这题了，<br>正在试图独立证明这些结论。。。</p>
<h3 id="爆肝-Treap"><a href="#爆肝-Treap" class="headerlink" title="爆肝 Treap"></a>爆肝 Treap</h3><p>写完暴力自闭之后就滚去学无旋 Treap 了，<br>看懂后感觉这 split + merge 的操作很 6 。<br>然后自己写了写，过程中学到一个新操作： <strong>空指针调用成员函数</strong><br>woc 发现直接用空指针调函数就只要在函数里判一判，调用端省了无数个 if ，</p>
<p>方便死了，然后上午打完下午交了文艺平衡树，<br>woc 全部 RE ???<br>把数据下下来，本地跑了一下， AC 。。。<br>woc 玄学本地 AC 提交 RE ？<br>改了细节再交，还是全 RE ，<br>那到洛谷 IDE 上测一下？一测， AC 。。。<br>woc 玄学洛谷 IDE AC 提交 RE ？</p>
<p>然后 <a href="https://www.luogu.org/recordnew/lists?uid=Kewth?pid=P3391?status=?sort=0" target="_blank" rel="noopener">各种测试</a></p>
<p>最后肝到晚上，终于认识到空指针调成员函数是多么不安全的行为。。。</p>
<p>emm 最后发现 Treap 无论是速度还是码量上都没好到哪去（难道是我实现太烂？），<br>对于文艺平衡树来说，无旋 Treap 略慢，代码还略长，只是空间消耗略少。</p>
<h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><p>安徽芜湖 12 天，每天都很充实，虽然也有遗憾。</p>
<p>HNOI 2019, RP ++.</p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 II</title>
    <url>/2019/10/09/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20II/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p><p>Day5 to Day8.</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><p>Nice 大夫今天又 A 掉一题！</p><p>第一题是在 DAG 上 q 个询问，每次询问一个子图的路径数量（子图点数和 O(n) ），<br>我想了想部分分， DAG 上 DP 嘛，但是这样复杂度上界是 $ O(q m) $ ，<br>瓶颈在于边的枚举（菊花树卡爆），然而子图的点可能很少，<br>然后想到了更暴力的：邻接矩阵存图然后用枚举点代替枚举边，<br>事实上邻接矩阵存不下，那就开 set （map 也行）动态加，<br>这复杂度 $ O(q n^2 log(m)) $ 啊然而，然后我想了好久优化都没想出来，<br>最后想着得多骗点分，于是就把两个暴力结合在了一起：<br>每次询问比较 $ n^2 log(m) $ 和 $ m $ 哪个小就跑哪个。。。<br>看上去很鸡肋，然而我理性分析了一波复杂度卧槽好像是 $ O(q m \sqrt{m} log(m)) $ ，<br>应该能骗蛮多分，于是交了，然后 A 了。。。</p><a id="more"></a>



<p>第二题又是个计数，感觉像容斥，容斥之后怎么搞就有点迷，<br>于是写了个 dp ，手玩样例感觉没错，然而一测大样例就 WA 了，<br>于是手玩了几组数据，才发现 dp 错了，区间相交的情况没考虑好，<br>最后实在没思路，就打了个大暴力，有 30’, 还不错（ 10 倍于前面两天的暴力分 3’ ）。</p>
<p>第三题哇塞维护一棵树，一看就感觉是树剖 + 线段树或者 LCT 之类的数据结构题，<br>然而还是不会，又敲了一发大暴力 10’ 走人。。。</p>
<h3 id="讲题"><a href="#讲题" class="headerlink" title="讲题"></a>讲题</h3><p>下午讲题，一看 ppt 下面一行字：–Claris<br>woc 今天见到真人了，那位 bzoj 4000+ ac 的神仙！<br>第一题正解是按度数大小关系连边，出题人说数据难造所以有这种带 log 的算法卡过去了。<br>第二题果然是容斥，但是要通过一个奇妙的矩形构造转换为轮廓线 DP 。<br>第三题出题人说并不是数据结构题？blabla 讲了一堆奇妙的做法，<br>然而有 4 个人用动态 DP 搞过去了，出题人想到了这一点还特意去卡了但是没卡掉。</p>
<h3 id="颓废"><a href="#颓废" class="headerlink" title="颓废"></a>颓废</h3><p>昨天没吃成必胜客来着，今天再次尝试，又剁一波手。<br>晚上真是诸事不利，tmd 这笔记本真的让人心累，<br>要啥没啥，网连续断了好几次，还真就不是网的问题，众人不断就我断，<br>什么 u 盘硬盘全没用，放我电脑上就读不到，<br>蓝牙更是做梦，键盘只能插线就算了还一老读不到，<br>还什么显像管出问题？动不动一些地方就全是红色的跟看恐怖片似的，<br>说优点倒也有，用个电脑火炉都省了，贼发热，那电风扇的声音时刻提醒你它还活着，<br>它要是太烫了还会自动关机，把你烤热了再降降温，贴心，<br>放歌听也很棒，我听快歌，它就一卡一卡的，一个字一个字给你放，根本不用怕听不清。<br>还能智能存储电量，充电线一拔就晓得要存储电量直接断电，不插上充电线不给开机，保证电池里的电永远满的。<br>别的什么还有一堆，懒得喷了，难受。</p>
<h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><h3 id="考试-1"><a href="#考试-1" class="headerlink" title="考试"></a>考试</h3><p>前两天把 rp 用完了，今天全暴力都写挂。</p>
<p>第一题我一开始推出个错误的结论，然后一想可以离线排序询问再预处理 dist 根据询问不断删除，删除不好搞换成加边弄个并查集维护联通块，<br>然而代码打完后一跑样例， WA 了，手玩样例才发现结论错了，这时候已经 9:30 了，凉凉，后面两题还没看。<br>最后打了大暴力 10’。</p>
<p>第二题题读到一半就感觉是二分，读完题后推了一下发现可以转换成这样一个模型：<br>二维平面上给定 n 个点，每次将一条平行于 y 轴的直线右边的点都向上平移 dy 单位并回答所有点的斜率 (y / x) 的最大值。<br>然后就有了 $ o(n^2) $ 的暴力做法，这玩意一脸可以优化的样子，然而想了好久没思路，就交了 60’ 。</p>
<p>第三题网格图 DAG, 感觉像要 dp ？但是不会，就打了暴力，结果还打挂了 RE ，爆零。</p>
<h3 id="讲题-1"><a href="#讲题-1" class="headerlink" title="讲题"></a>讲题</h3><p>第一题什么神仙 dp $ O(n^4) $ 过 100 可还行，我太菜了没搞懂这个 dp ，<br>但是出题人提到有枚举端点 + 组合数的做法，我想去看看，一看哇塞简单多了，<br>而且复杂度优秀的 $ O(n^3) $ ，下午按照这个作法改了一段时间就 A 了（<del>期间没开 long long 一直爆炸</del>）。</p>
<p>第二题好像是可以从我那个模型再转换一下后分块 + 凸包维护，感觉很神仙。</p>
<p>第三题有个神奇的结论：<br>用两个不同的顺序得到的 dfs 后序，u 可以到 v 当且仅当 v 的两个 dfs 序都比 u 的小。<br>然后就可以将点按一个 dfs 序排序后按颜色设状态 dp, 把 dp 数组扔进树状数组后得出答案。</p>
<h3 id="颓废-1"><a href="#颓废-1" class="headerlink" title="颓废"></a>颓废</h3><p>晚饭兰州拉面，清真的店子就是讲究，还贼好吃。<br>晚上感觉屁事没干，教练发了一套题要我们做（考试的题都改不完啊），<br>实在不想做，反正明天收，晚上就几乎一直在颓，找歌听。</p>
<h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h3 id="考试-2"><a href="#考试-2" class="headerlink" title="考试"></a>考试</h3><p>100 % 纯暴力的一天。</p>
<p>第一题神仙计数题？好难啊感觉，于是想了想了 k 小于等于 3 会不会有什么规律可循，<br>发现 k = 1 的时候就是 $ 2^{n-1} $ ，就得到了 1 分的好成绩（这分给的真少）。<br>然后再手玩了一下 k = 2 和 k = 3 的情况，找到了一种计数方式，过了样例，就交了，<br>然并卵，k = 2 和 k = 3 的情况错了，只有 1’ 。</p>
<p>第二题感觉是什么 set 启发式合并，但是合并之后只能暴力搞答案，<br>没思路，打了暴力，5 分的好成绩。</p>
<p>第三题我靠麻将小模拟大搜索题？感觉很复杂，而且到第三题也没什么时间了，<br>于是打了一发只有字牌的特殊情况，20 分的好成绩。</p>
<h3 id="讲题-2"><a href="#讲题-2" class="headerlink" title="讲题"></a>讲题</h3><p>出题人说这个题目难度是 T1 &gt;= T2 &gt;= T3 。</p>
<p>T3 果然就是搜索，先算出最大答案（就是 9 ）统计面子搭子的数量再减答案。</p>
<p>T2 线段树合并，玄学，还不会。</p>
<p>T1 真有意思，标程生成函数加一大堆什么多项式的优化之类的，复杂，没懂。<br>但是有位大佬考试 27 分钟后就 A 了这题，出题人叫他上来讲讲，<br>然后他就开始秀操作：<br>“我的直觉告诉我 % n 等于 0 的方案和 % n 等于 x 的方案是一样的，然后就可以算出总方案数再除以 n 就可以……” ，<br>然后抄起笔写出一个式子，就是总方案数，<br>我靠这式子也贼好懂，全场都笑喷了，这大抵就是“爆踩标程”了吧，复杂度还更优秀。<br>出题人一脸懵逼，看了眼式子无奈的说了一句好吧那就这样吧。<br>做法就是考虑每个排列的贡献，枚举颜色的种类再用组合数和第二类斯特灵数算出这样的排列数再乘上贡献。<br>时间复杂度直接实现都是 $ O(k^2) $ （ k 只有 100 ，可见标程被爆踩），<br>把斯特灵数那部分的预处理用 NTT 优化复杂度就是 $ O(k logk) $ ，<br>听说还可以优化到 $ O(k) $ ，不会，但对这题来讲也没必要。</p>
<h3 id="额外肝题"><a href="#额外肝题" class="headerlink" title="额外肝题"></a>额外肝题</h3><p>教练还额外发了一套题来着。<br>扫了遍题目，感觉第二题比较友好：<br>交换 i, j 枚举顺序后就把那个斯特灵数求和的部分设为函数 g ，<br>根据斯特灵数的递推，g 这玩意也是可以递推的，中间需要用到一排斯特灵数。<br>根据斯特灵数的容斥意义 NTT 预处理一排斯特灵数即可（卧槽这不就是上午 t3 吗）。<br><del>代码实现中，还没打完，随时准备被打脸。</del></p>
<p><del>今天晚上竟然没有颓。</del></p>
<h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><p><del>咕掉了</del></p>
<h2 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h2><p><a href="/2019/03/29/安徽游记-iii/">Day9 to END</a></p>
]]></content>
  </entry>
  <entry>
    <title>多项式的运算</title>
    <url>/2019/10/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单来说，形如 $ a_0 + a_1X + a_2X^2 + … + a_nX^n $ 的代数表达式叫做多项式，<br>可以记作 $ P(X) = a_0 + a_1X + a_2X^2 + … + a_nX^n $ （系数表示法），<br>a 叫做多项式的系数，X 是一个不定元，不表示任何值，<br>不定元在多项式中最大项的次数称作多项式的次数。</p><a id="more"></a>
<h2 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h2><p>两个多项式 a, b 的和 a + b 是一个多项式 c ，满足：<br> $ \forall x, c(x) = a(x) + b(x) $</p>
<p>两个多项式 a, b 的差 a - b 是一个多项式 c ，满足：<br> $ \forall x, c(x) = a(x) - b(x) $</p>
<p>多项式的加减十分自然，实际运算中也只需要按定义 O(n) 枚举即可。</p>
<h2 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h2><p>两个多项式 a, b 的积 a * b 是一个多项式 c ，满足：<br> $ \forall x, c(x) = a(x)  \cdot  b(x) $</p>
<p>此时将 a, b 的系数按分配率展开求 c 的时间复杂度为 O(n *  m) ，<br> n, m 分别为 a, b 的次数，不难得出 c 的次数为 n + m 。</p>
<p>快速求多项式乘积的方法是 $ O(n \cdot log_2n) $ 的 <a href>FFT</a> 或 NTT 。</p>
<h2 id="除"><a href="#除" class="headerlink" title="除"></a>除</h2><p>两个多项式 a, b 的商 a / b 是一个多项式 c ，满足：<br> $ \forall x, c(x) = a(x) / b(x) $</p>
<p>众所周知多项式除法可以列竖式求解，<br>这样做与乘法一样复杂度为 O(n *  m) 。</p>
<h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>正如整数除法会有余数，多项式除法也不一定整除，<br>此时 a / b 会余一个多项式 c ，<br>正如整数除法中余数小于除数，<br>此处也要满足 c 的次数小于 b 的次数以保证唯一性。</p>
<p>具体来说，对于多项式 a, b 存在唯一的多项式 c, d 满足：<br> a = b *  d + c 且 c 的次数小于 b 的次数，<br>便称 c 是 b 除 a 的余数，即 a 模 b 的结果，<br> d 是 b 除 a 的商。</p>
<p>值得注意的是，当模数 b 可表示为 $ b(x) = x^k $ 时，<br> a 模 b 相当于将 a 舍弃所有次数大于等于 k 的单项式的结果。</p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>对于多项式 a ，其在 mod p 意义下的逆元 b 满足：<br> a *  b mod p = 1 且 b 的次数不比 a 大<br>（此处的 1 实际上是指只有常数项为 1 而次数为 0 的多项式），<br> a 的逆元通常记为 $ a^{-1} $ 或 inv(a) 。</p>
<p>那么在 mod p 意义下，有 $ a / b = a  \cdot  b^{-1} $ 。</p>
<h2 id="逆元的求解"><a href="#逆元的求解" class="headerlink" title="逆元的求解"></a>逆元的求解</h2><p>事实上模数一般是 $ x^n $ 。</p>
<p>此时可以用分治求多项式 a 的逆元 b。</p>
<p>假设已经分治求得了 a 模 $ x^{n/2} $ （此处及以下除法表示向上取整）的逆元 c 。<br>那么有：<br>$$ a  \cdot  c \equiv 1 (mod ; x^{n/2}) ;;;;; (1)$$<br>由 b 的定义可知：<br>$$ a  \cdot  b \equiv 1 (mod ; x^n) ;;;;; (2)$$<br>转换为：<br>$$ a  \cdot  b \equiv 1 (mod ; x^{n/2}) ;;;;; (3)$$<br>(3) - (1) 得：<br>$$ b - c \equiv 0 (mod ; x^{n/2}) ;;;;; (4)$$<br>两边同时平方得：<br>$$ b^2 - 2bc + c^2 \equiv 0 (mod ; x^n) ;;;;; (5)$$<br>两边同时乘 a 得：<br>$$ b - 2c + c^2a \equiv 0 (mod ; x^n) ;;;;; (6)$$<br>移项，整理：<br>$$ b = (2c - c^2a) ; mod ; x^n $$</p>
<p>(4) -&gt; (5) 中模数平方的原因：<br>左边多项式模 $ x^{n/2} $ 为 0 代表该多项式每一项最低次数为 n / 2 + 1 。<br>那么该多项平方后最低次数会是 n + 1 或 n + 2 ，<br>模 $ x^n $ 后仍为 0 。</p>
<p>于是乎分治，直到 n == 1 ，此时多项式的取模为一个常数，逆元也就是整数的逆元。</p>
<p>其中乘法使用 FFT ，则最终时间复杂度为 $ O(n \cdot log_2n) $ 。</p>
]]></content>
  </entry>
  <entry>
    <title>北京游记</title>
    <url>/2019/10/09/%E5%8C%97%E4%BA%AC%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>Q: 我天天盯着你高考 (gq) 怎么一直没更新啊？<br>A: 懒。</p><p>因此这实际是一篇事后回忆。</p><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>昨天晚上特意没去学校回了家，想着离高铁站近可以晚点起床，<br><del>真相是需要回家拿电脑</del><br>然而大早上 6 点就被叫了起来，早餐都没吃就直接送到了高铁站，<br>emm 还有大半个小时才检票，果断拿起颓书开始颓废，<br>不要问<a href>为什么不玩电脑</a>，心塞。</p><a id="more"></a>


<p>高铁上还是贼无聊，幸好准备了颓书，<br>而且还可以蹭旁边的人看《生活大爆炸》。<br>还行，比上次去安徽好得多。</p>
<p>出高铁再做地铁去北大，北京地铁线比长沙多得多，<br>全程没搞清往哪走，迷迷糊糊地跟别人跑。<br>下了地铁第一反应就是，热，真热，贼 NM 热，<br>地理菜狗还以为北京纬度高就会比较凉快来着。</p>
<p>至于住的酒店，我敢说这是我住过最差的酒店了，<br>整一偏僻平房（有点像四合院？），里面要啥没啥，<br>卫生条件极差，听隔壁德拉说他们床头粘了 10+ *** ，部分带红，估计是 **** 。<br>水龙头都 tm 生锈了，淋浴喷头竟然对着马桶。<br>之前住安徽时还喷了那宾馆来着，现在感觉那简直是天堂。</p>
<p>晚上还是很 nice 的，上一届北大的信息组学长们请我们吃饭，<br>特意选了一家比较符合湖南人口味的饭馆，<br>吃完饭后被拉到北大到处乱转，<br>北大确实很漂亮，晚上没什么灯，不是灯火通明的那种喧嚣繁华，比较安静，<br>还有未名湖，不敢随便形容，不过听说每年都有人不小心掉下去。</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>上午的开幕式已经忘了讲了什么了，<br>大概是大谈信息学发展，北大的优势和竞赛生在北大的学习方向。</p>
<p>北大食堂贼多，不过我们可以吃的只有三个，农园最近，大家就都去了农园，<br>还不错，至于消费我跟本没注意，反正看到还行的就拿了。。。发的 100 元的卡应该够用的。  </p>
<p>下午的考试，萎出天际，可能是没有找到状态吧，<br>三道题目一点思路都没有，真的就是只想得到暴力，还是最暴力的暴力，<br>结果暴力还打挂了，明明过了样例过了自测数据，但是就上去就是使劲 WA 。<br>正常考试处于崩溃和半放弃的状态，最后得到了 18’ 的好成绩。</p>
<p>本来挺乐观的，以为和省选一样，大众分就是几十分，<br>然而问了一波成绩发现某 Jian 200+ 。。。<br>好吧是我凉了。</p>
<p>于是颓了一晚上，打 generals ，看敖厂长，本来想打饥荒然而被我的 XP 折服了。</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>上午大师讲座 <del>master 牛逼</del> ，请的外国的一位教授，图灵奖获得者。<br>这次讲座我感触很深，受益匪浅，得到了一个教训和今后的一个小目标：<br>好好学英语。<br>woc 英语菜狗全程懵逼啊，除了黑板上画的图什么都搞不懂。<br>讲完后还有学生提问题的环节，看着别人和教授谈笑风生，对我就加密了一样。</p>
<p>《论常规课的重要性》</p>
<p>下午考试心态比较佛，已经清楚翻盘无望了，<br>看了三道题后只感觉有一题可做，题意大概是这样：</p>
<p>给定一颗 n 个点的树，将其放在 m 维空间里，<br>需要满足每两个点的曼哈顿距离与其在树上的距离相同。<br>求出一个使 m 最小的放置方案。</p>
<p>一个维度在树上只能管一条链，题目可以转换为最小链覆盖。<br>然而我考场上的转换方式不太一样，更复杂，每条链要去掉 lca,<br>于是我就搞了个 dfs 去求这玩意，交上去过了 subtask1 和 subtask3 。<br>woc? subtask3 是没有限制的，讲道理过了 subtask3 就一定可以过 subtask2 。<br>仔细分析发现 dfs 儿子的顺序会有影响，没想出来怎么去掉这个影响，于是开始操作。<br>我 dfs 的时候选择 size 最大的一个儿子去递归，再交，还是一样。<br>我 dfs 的时候选择叶子数最大的一个儿子去递归，再交，还是一样。<br>我 dfs 的时候随机选择一个儿子去递归，再交，过了 subtask1 和 subtask2 。<br>Nice 啊综合一下呗，根据输入数据特判一下，如果是 subtask2 就随机递归，subtask3 就自然递归。<br>成功 AC ，最后 122’ 。</p>
<p>晚上贼颓，因为明天不用考试嘛，于是爆肝小游戏，都是颓过的人，细节自己想都想得出。</p>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>闭幕式。</p>
<p>出题人出来讲题了，果然是吉司机（和另外一个不知名人士），<br>题面中全是“九条可怜是个爱…的女孩子”。<br>但正如他本人所说，这次的确没有什么麻将啊斗地主啊之类的题，<br>整体偏向思维，没有毒瘤数据结构，没有大模拟。<br>好吧回想起来比赛质量确实很好，可能在吉司机画的那个图像的最高点附近吧。</p>
<p>颁奖的时候就只能看着了，连个安慰奖都没摸到，自闭了。</p>
<p>中饭进哥请食堂，吃完后就回去了，<br>高铁上巨颓，拷了两季生活大爆炸后直接开始追剧，<br>除了中间吃泡面外就没停（包括教练过来查水表）。<br>感觉被带进坑了。</p>
<p>常规快乐。</p>
]]></content>
  </entry>
  <entry>
    <title>终端（娱乐）工具</title>
    <url>/2019/10/09/terminal-tool/</url>
    <content><![CDATA[<h2 id="sl-LS"><a href="#sl-LS" class="headerlink" title="sl / LS"></a>sl / LS</h2><p>在你 ls 打累的时候开小火车。</p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install sl</span><br></pre></td></tr></table></figure><h2 id="lolcat"><a href="#lolcat" class="headerlink" title="lolcat"></a>lolcat</h2><p>用彩虹为输出着色！</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://pic4.zhimg.com/v2-3bf6b7552162441dd638ac6d5fb3717b_r.jpg" alt="lolcat"></p><h3 id="安装方式-1"><a href="#安装方式-1" class="headerlink" title="安装方式"></a>安装方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install rubygems</span><br><span class="line">gem install lolcat</span><br></pre></td></tr></table></figure><h3 id="管道处理"><a href="#管道处理" class="headerlink" title="管道处理"></a>管道处理</h3><p>非常有意思的是，将大多数 ncurses 程序的输出通过管道用 lolcat 后仍然可以正常运行！</p><a id="more"></a>







<p>比如 <code>nano | lolcat</code> 可以打开一个彩虹编辑器；<br><code>ncdu | lolcat</code> 可以打开一个彩虹文件查看器；<br><code>sl | lolcat</code> 可以开彩虹火车；<br><code>nethack | lolcat</code> 可以玩彩虹游戏！</p>
<h2 id="cowsay"><a href="#cowsay" class="headerlink" title="cowsay"></a>cowsay</h2><p>让一只奶牛（或者其它乱七八糟的东西）说出一句话！</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>运行 <code>cowsay hiahiahia</code></p>
<p>然后你会得到像这样的输出：</p>
<pre><code> ___________
&lt; hiahiahia &gt;
 -----------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre><p>类似的你也可以用 <code>cowthink</code> 。</p>
<h3 id="安装方式-2"><a href="#安装方式-2" class="headerlink" title="安装方式"></a>安装方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install cowsay</span><br></pre></td></tr></table></figure>

<h2 id="chafa"><a href="#chafa" class="headerlink" title="chafa"></a>chafa</h2><p>在终端里面打印图片或者视频！</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><img src="https://pic4.zhimg.com/v2-91254499e2880bbe3068ce2a3e086977_b.gif" alt="chafa"></p>
<p>小诀窍：把终端字体调小并开全屏可以让图片更清晰（但是更慢）。<br>给你一图片自行意会（记住这张图是在终端上打印的！！！）：</p>
<p><img src="http://kewth.gq/wp-content/uploads/2019/03/%E9%80%89%E5%8C%BA_017.png" alt="chafabig"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hpjansson/chafa.git &amp;&amp; <span class="built_in">cd</span> chafa</span><br><span class="line">sudo aptitude install libmagickwand-dev</span><br><span class="line">./autogen.sh</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>这个安装过程相对比较麻烦，详细过程见 <a href="https://github.com/hpjansson/chafa" target="_blank" rel="noopener">Github</a> 。</p>
<h2 id="img2txt-cacaview"><a href="#img2txt-cacaview" class="headerlink" title="img2txt / cacaview"></a>img2txt / cacaview</h2><p>在终端里用 ASCII 打印图片！</p>
<p>或者用 cacaview 打开一个窗口查看。</p>
<p>upd:<br>后来我才知道 w3m 也可以查看图片，和 cacaview 的效果一模一样。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install caca-utils</span><br></pre></td></tr></table></figure>

<h2 id="w3m-lynx-browsh"><a href="#w3m-lynx-browsh" class="headerlink" title="w3m / lynx / browsh"></a>w3m / lynx / browsh</h2><p>在终端浏览网页！</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>w3m 和 lynx 大同小异，没有什么本质上的区别。<br>（别喷我，我这么说是拿 browsh 作参照）</p>
<p>但是， browsh 不同，它内部调用 Firefox 渲染网页并处理后打印在终端，<br>因此 browsh 几乎能 <strong>在终端</strong> 支持任何现代浏览器支持的！</p>
<p>只给出一张 browsh 浏览 youtubu 的图片：</p>
<p><img src="https://oscimg.oschina.net/oscnet/cc8d81d3c93d858a0a3f39e08293e4b6535.jpg" alt="browsh"></p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># w3m</span></span><br><span class="line">sudo aptitude install w3m</span><br><span class="line"><span class="comment"># lynx</span></span><br><span class="line">sudo aptitude install lynx</span><br><span class="line"><span class="comment"># browsh</span></span><br><span class="line">wget https://github.com/browsh-org/browsh/releases/download/v1.5.0/browsh_1.5.0_linux_amd64.deb</span><br><span class="line">sudo dpkg -i ./browsh_1.5.0_linux_amd64.deb</span><br></pre></td></tr></table></figure>

<h2 id="cmatrix"><a href="#cmatrix" class="headerlink" title="cmatrix"></a>cmatrix</h2><p>终端黑客风动画</p>
<p><code>cmatrix | lolcat</code> 简直可以来当屏保。</p>
<h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install cmatrix</span><br></pre></td></tr></table></figure>

<h2 id="typespeed"><a href="#typespeed" class="headerlink" title="typespeed"></a>typespeed</h2><p>在终端 <del>玩打字游戏</del> 测试打字速度！</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><img src="http://kewth.gq/wp-content/uploads/2019/03/%E9%80%89%E5%8C%BA_027.png" alt="typespeed"></p>
<h3 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install typespeed</span><br></pre></td></tr></table></figure>

<h3 id="自定义词库"><a href="#自定义词库" class="headerlink" title="自定义词库"></a>自定义词库</h3><p>我是真的爱折腾，竟然自己找出了 typespeed 的词库位置并且自己加了词库。。。</p>
<p>顺便夸一下 typespeed 的扩展性真的好，它考虑到了用户的自定义词库需求。</p>
<p>只需要在 /usr/share/typespeed/words/ 目录下添加 words.xxx 文件（ xxx 随意填），<br>文件第一行是这个词库的名称，接下来每行一个单词就可以了。</p>
<p>然后进入 typespeed 就能看到你自己的词库啦（ kewth’s xxx 就是我自己加的）：</p>
<p><img src="http://kewth.gq/wp-content/uploads/2019/03/%E9%80%89%E5%8C%BA_028.png" alt="mywords"></p>
<h2 id="nethack"><a href="#nethack" class="headerlink" title="nethack"></a>nethack</h2><p>世界上最棒的终端游戏（绝无夸大）！<br>nethack 太博大精深了，玩法不赘述。</p>
<p>另外： <code>nethack | lolcat</code> 的效果真的很棒。</p>
<h3 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install nethack</span><br></pre></td></tr></table></figure>

<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>全名 taskwarrior 。</p>
<p>个人认为终端上最好用的 todo list manager 。<br>功能十分强大，可以简单上手，<br>如果愿意折腾也可以深入挖掘它的各种功能，最精细地管理你的任务计划。</p>
<h3 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install taskwarrior</span><br></pre></td></tr></table></figure>

<h3 id="简单上手"><a href="#简单上手" class="headerlink" title="简单上手"></a>简单上手</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task add test1</span><br><span class="line">task add test2</span><br><span class="line">task start 1</span><br><span class="line">task long</span><br><span class="line">task <span class="keyword">done</span> 1</span><br><span class="line">task <span class="keyword">done</span> 2</span><br></pre></td></tr></table></figure>

<h3 id="tasksh"><a href="#tasksh" class="headerlink" title="tasksh"></a>tasksh</h3><p>整合 taskwarrior 的交互命令行，里面可以直接敲 <code>add ...</code> 或 <code>list</code> 等命令。</p>
]]></content>
  </entry>
  <entry>
    <title>NTT</title>
    <url>/2019/10/09/NTT/</url>
    <content><![CDATA[<p>NTT ，快速数论变换，功能与 <a href>FFT</a> 完全一致，用来求多项式卷积。<br>NTT 优点在于常数稍微小一点，没有精度误差。<br>但是 NTT 系数必须是取模意义下的整数，且对模数有特殊要求。</p><h2 id="FFT-的单位根"><a href="#FFT-的单位根" class="headerlink" title="FFT 的单位根"></a>FFT 的单位根</h2><p>建议前置 <a href>FFT</a> 。</p><p>FFT 可以分治优化复杂度的原因是用到了单位根的如下性质：<br>$$ W_{2n}^{2k} = W_n^k $$<br>$$ W_n^n = 1 $$<br>$$ W_n^{k + n/2} + W_n^k = 0 $$</p><a id="more"></a>


<p>可是用单位根做 FFT ，需要用到复数和浮点数，常数大而且有精度误差。<br>还有别的数有这样的性质来替换单位根吗？<br>遗憾的是，可以证明复数域下只有单位根有这样的性质。</p>
<h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>实际计算多项式卷积时，常常要求对系数取模以避免不必要的麻烦。<br>那么这时候系数实际上是在模意义下的， FFT 将它转到复数域上运算，似乎没有必要。<br>模意义下什么数可以有单位根那样的性质？<br>有的，那就是原根。</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>对于某些模数 P ，模 P 意义下的原根 g 满足：<br>对任意 $ 0 \leq k \leq P - 2 $ ， $ g^k $ 互不相同。<br>有些模数可能不存在原根，这里先假设模数都有原根。</p>
<p>假设系数是模 P 意义下的，P 是形如 $ 2^k + 1 $ 的质数，其原根为 g ，<br>设 $ G_n = g^{\frac{P-1}{n}} mod P $ ，其中 n 是小于 P 的 2 的整次幂 。<br>那么在模 P 意义下， G 满足：</p>
<p>$$ G_{2n}^{2k} = G_n^k $$</p>
<p>由 G 定义可证：<br>$ G_{2n}^{2k} = g^{\frac{P-1}{2n}2k} = g^{\frac{P-1}{n}k} = G_n^k$</p>
<p>$$ G_n^n = 1 $$</p>
<p>由 G 定义可得：<br>$ G_n^n = g^{\frac{P-1}{n}n} = g^{P-1}  $<br>由费马小定理：<br>$ G_n^n =  g^{P-1} = 1 $</p>
<p>$$ G_n^{k + n/2} + G_n^k = 0 $$</p>
<p>有第一条性质可得：<br>$ G_n^{n/2} = G_2^1 = g^{\frac{P-1}{2}} $<br>因为 $ (g^{\frac{P-1}{2}})^2 = g^{P-1} = 1 $<br>根据原根的性质：<br>$ g^{\frac{P-1}{2}} \neq g^{P-1} $<br>那么 $ g^{\frac{P-1}{2}} = -1 $ （即 P - 1）。<br>那么可以证得：<br>$ G_n^{k + n/2} = G_n^k G_n^{n/2} = G_n^k(-1) $<br>于是 $ G_n^{k + n/2} + G_n^k = 0 $</p>
<h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><p>于是 NTT 的算法思路就呼之欲出了：把 $ W_n $ 全部替换为 $ G_n $ 即可。<br>这样就可以算出模 P 意义下的多项式卷积了。<br>其中 n 必须是 2 的整次幂，不足的补零即可。</p>
<p>现在唯一的问题是，模数 P 要满足什么条件，以及如何求模 P 意义下的原根 g 。<br>然而我并不想深入展开，大多数情况下模数都是 998244353 ，其原根为 3 。<br>一般 NTT 只会用这个模数，不会有毒瘤出题人卡这个模数的（我不对这句话负责）。</p>
]]></content>
  </entry>
  <entry>
    <title>NOIP 2018</title>
    <url>/2019/10/09/NOIP%202018/</url>
    <content><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>一天普及一天省选，弄到一起就出成了一套提高组试题。</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>原题大作战。<br>然而我一题都没做过。</p><p>总的来说 Day1 比去年好像容易点（不然我也不会留出一个多小时给每道题造数据对拍）。</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>CCF 直接把 2013 的题原封不动搬到了 Day1T1 。</p><p>一开始想着递归，发现会被卡成 $O(n^2)$ ，<br>再想 DP 的时候简化一下式子就直接可以扫一遍出结果。</p><a id="more"></a>




<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>bzoj 权限题。</p>
<p>如果一种货币能被其它若干货币代替，就扔掉。<br>设 f[i] 表示价值为 i 的货币是否会被代替，做一遍完全背包就好了。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>bzoj 权限题。</p>
<p>听说可以二分加贪心，不过我考场想的比较复杂 <del>是二分答案再 DP ，DP 转移再套一层用链表维护的 DP</del> 。</p>
<p>首先容易想到二分答案，二分一个答案 mid 后求最多可以有多少条赛道满足长度不小于 mid ，<br>若有不少于 m 条，则答案可行。</p>
<p>求赛道数量可以 DP ，设 f[u] 为 u 的子树中满足条件的赛道的数量，<br>g[u] 表示在满足 f[u] 最大的前提下 u 向下不经过赛道的最长路径长。</p>
<p>转移的时候先把 u 的儿子 v 的 f[v] 累加，同时将所有 g[v]+w 存起来（w 表示 u 到 v 的长度）。</p>
<p>对于 g[v]+w 大于等于 mid 的直接把 f[u]++ 然后扔掉，于是只需要考虑小于 mid 的 g[v]+w 的贡献。</p>
<p>两个不同的 g[v]+w 若大于等于 mid 就同样可以作为一条赛道让 f[u]++ ，先排序然后再次 DP 统计这样的赛道数量，<br>然后若所有的 g[v]+w 都有另外一个构成赛道， g[u]=0 ，否则 g[u] 等于剩下的最大的 g[v]+w 。</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>Day1 的比赛对我造成了巨大的影响，Day1 考完后信心爆棚， <del>以 AKIOI 的自信</del> 走进 Day2 考场。</p>
<p>结果什么题都死磕正解，到最后连暴力都没打全。</p>
<p>看题，WTF?</p>
<p>看完 T1 我以为是个稠密无向图，想了好久感觉是要求一种特殊的生成树，感觉巨不可做。<br>顿时有点小慌，突然想到考前教练提醒要看完题，说不定后面的题反而简单。</p>
<p>嗯，有道理，直接翻到 T2 ，推了波结论认定是一道状压 DP，松了口气。</p>
<p>不急，再看 T3 ，哦，好像树形 DP ，但是 m 个询问难住了我。</p>
<p>于是认定 T2 比较容易，开始死磕 T2 ，打完状压后跑了遍 2,2 的样例，诶过了。<br>再跑一遍 3,3 ，输出 144 ，于是手推了 3,3 的样例发现还是 144 ,<br>意识到推的结论有误，瞬间慌的一批。<br>推了好久才发现了问题，得到正确的结论后发现对于新结论状压 DP 似乎变得不可行。</p>
<p>这个时候考试已经过了一个小时多了。慌。</p>
<p>换换思路吧，于是去做 T3 , 想了很久 DP 最后写了个平方复杂度的，<br>跑过了所有样例就没管了，没多少时间了，又回去看 T1 。</p>
<p>往回看了看 T1 里 m 的数据范围我才发现只有树和换套树两种情况。<br>那还求个鬼生成树，迅速打掉树的 60 部分分，n 看都没看只知道 $O(n)$ 稳了。<br>再去想换套树，感觉差不多，继续 $O(n)$做。</p>
<p>结果？一直死磕 T1 的 $O(n)$ 做法，直到最后考试结束都没写出来。</p>
<p>考试听别人说直接枚举删边 $O(n^2)$ 就可以过的时候我才意识到 n 只有 5000 ，整个人懵的。</p>
<p>结果 T1 还是 60’ ，T3 不晓得哪里炸掉了爆零，<br>有意思的是 T2 我错误的打法样例都没过在 ccf 的数据里水到了 45’ 。</p>
]]></content>
  </entry>
  <entry>
    <title>ncurses</title>
    <url>/2019/10/09/ncurses/</url>
    <content><![CDATA[<p>ncurses 是基于终端的十分强大的图形库。<br>Vim, screen, sl 等终端程序都用到了这个库（足以见其强大）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>部分系统默认安装了 ncurses ，手动安装的方式是： <code>sudo aptitude install ncurses-dev</code> 。</p><p>使用的程序需要 <code>#include &lt;ncurses.h&gt;</code>　。<br>编译时需要添加 <code>-lncurses</code> 参数进行链接。</p><a id="more"></a>


<h2 id="开始和结束"><a href="#开始和结束" class="headerlink" title="开始和结束"></a>开始和结束</h2><p>调用 initscr 初始化窗口，endwin 结束窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">WINDOW *<span class="title">initscr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endwin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>调用 initscr 后调用 endwin 前，printf, std::cout 等标准输出不会显示在屏幕上。<br>而输出到屏幕上需要 ncurses 提供的相应函数。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addch</span><span class="params">(<span class="keyword">const</span> chtype char_to_add)</span></span>;   <span class="comment">// 当前位置添加字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *string_to_add)</span></span>;    <span class="comment">// 当前位置添加字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printw</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>;   <span class="comment">// 类似于 printf</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">refresh</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">// 强制刷新物理屏幕</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beep</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">// 终端响铃</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flash</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">// 屏幕闪烁</span></span><br></pre></td></tr></table></figure>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>调用 scanf, getchar, cin 等标准输入函数同样无效。</p>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cbreak</span><span class="params">()</span></span>;   <span class="comment">// 字符一键入，直接传给程序（不用按下回车）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nocbreak</span><span class="params">()</span></span>;  <span class="comment">// 关闭 cbreak</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">echo</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 开启输入回显</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noecho</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 关闭输入回显</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 读入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanw</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">// 类似于 scanf</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure>

<p>输入函数通常是阻塞的，但是通过调用 nodelay(stdscr, TRUE); 可以关闭阻塞。<br>此时若输入函数未读取到内容会返回 ERR 。</p>
<h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><p>控制光标。<br>调用 initscr 后调用 endwin 前，输出终端控制符改变光标是无效的。</p>
<h3 id="函数及示例"><a href="#函数及示例" class="headerlink" title="函数及示例"></a>函数及示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// 将光标移动到 [x] 行 [y] 列，左上角为 0 行 0 列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">curs_set</span><span class="params">(<span class="keyword">int</span> visiblility)</span></span>; <span class="comment">// 参数为 0 表示隐藏光标，1 表示显示光标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getyx</span><span class="params">(WINDOW* win, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>; <span class="comment">// 获取指定窗口光标位置，示例如下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span> </span>&#123; <span class="comment">// 将光标上移</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	getyx(stdscr, x, y); <span class="comment">// stdscr 表示标准屏幕</span></span><br><span class="line">	move(x - <span class="number">1</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定位置输出"><a href="#指定位置输出" class="headerlink" title="指定位置输出"></a>指定位置输出</h3><p>在指定位置输出不必先 move 再 printw ，<br>ncurses 提供了 mv 函数前缀在指定位置输出。<br>例如 <code>mvprintw(1, 2, &quot;%d&quot;, 2)</code> 在 1 行 2 列输出 3 。<br>类似的有 mvaddch, mvaddstr 等。</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先需要调用 has_color() 查看当前运行环境是否支持彩色。<br>调用 start_color() 初始化颜色，成功则返回 OK 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_colors</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_color</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功后会初始化全局变量 COLORS 表示终端支持的颜色数量<br>还会有 COLOT_WHITE, COLOR_RED 等 8 个表示颜色的变量。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>例如希望打印白底黑字的信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *info)</span> </span>&#123;</span><br><span class="line">	init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_WHITE);</span><br><span class="line">		<span class="comment">// 的一个参数表示编号，后面两个分别表示字体和背景颜色</span></span><br><span class="line">	attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">// attron 是一个设置函数，COLOR_PAIR 返回指定编号的颜色信息</span></span><br><span class="line">	addstr(info);</span><br><span class="line">	attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">// attroff 关闭设置（若接下来需要用其他颜色可以不调用 attroff 而直接使用 attron 覆盖设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h3><p>值得注意的是，必须保证 init_pair 的编号不与其他已初始化的编号重复<br>一个错误的调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">"ERROR CODE"</span>;</span><br><span class="line">init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_WHITE);</span><br><span class="line">attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">addstr(info); <span class="comment">// 打印白底黑字</span></span><br><span class="line">init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_RED);</span><br><span class="line">attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">addstr(info); <span class="comment">// 打印白底红字</span></span><br></pre></td></tr></table></figure>

<p>上述代码的期望打印出白字和黑字两种不同的颜色，<br>但事实上只会打印出红色一种。<br>解决方案便是将白底红字的 pair 编号设为 2 。</p>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>ncurses 有窗口类 WINDOW 并提供了 stdscr 作为默认窗口。<br>有时一个窗口无法满足需要，此时需要自己新建窗口。</p>
<h3 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h3><p>调用 newwin 来新建窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 ([x], [y]) 开始新建 [line] 行 [column] 列的窗口。</span></span><br><span class="line"><span class="function">WINDOW *<span class="title">newwin</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>新建的窗口</p>
<h3 id="通用输出"><a href="#通用输出" class="headerlink" title="通用输出"></a>通用输出</h3><p>addch, printw 等输出方式只输出到 stdscr 。<br>ncurses 提供了 w 前缀来输出到指定窗口。<br>例如 <code>wprintw(win, &quot;%d&quot;, 1)</code> 在 [win] 窗口输出 1 。<br>但是自己新建的窗口与 stdscr 不同，<br>若想在屏幕上显示需要调用 <code>wrefresh(win)</code> 刷新窗口。</p>
<p>若想在窗口中指定位置输出，可以用 mvw 前缀函数。<br>例如 <code>mvwprintw(win, 1, 2, &quot;%d&quot;, 3)</code> 在 [win] 窗口的 1 行 2 列（ <strong>相对位置</strong> ）输出 3 。</p>
<h3 id="子窗口"><a href="#子窗口" class="headerlink" title="子窗口"></a>子窗口</h3><p>调用 subwin 创建子窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 ([x], [y]) 开始新建 [line] 行 [column] 列属于 [parent] 的子窗口。</span></span><br><span class="line"><span class="function">WINDOW *<span class="title">subwin</span><span class="params">(WINDOW *parent, <span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>子窗口与普通窗口的区别在于它与其父窗口共用屏幕储存空间，<br>子窗口修改时父窗口会直接受到影响。<br>比如新建了 stdscr 的子窗口 win ，<br>那么输出到 win 后想显示在屏幕不调用 wrefresh 而是调用 touchwin(stdscr) 。<br>touchwin 用于标记一个窗口被修改。</p>
<h3 id="销毁窗口"><a href="#销毁窗口" class="headerlink" title="销毁窗口"></a>销毁窗口</h3><p>调用 delwin 销毁窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delwin</span><span class="params">(WINDOW *win)</span></span>; <span class="comment">// 销毁 [win] 窗口</span></span><br></pre></td></tr></table></figure>

<p>窗口销毁后其在屏幕上对应的内容不会改变。</p>
<h2 id="离开"><a href="#离开" class="headerlink" title="离开"></a>离开</h2><p>有时候可能需要离开 ncurses 回到行缓冲模式做些事情而且需要在之后回到 ncurses 。<br>例如 Vim 里面输入 :!ls 就会退出 ncurses 运行 ls 命令，并在用户敲下回车后回到 ncurses。</p>
<p>调用 def_prog_mode 暂存，调用 reset_prog_mode 恢复。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initscr();</span><br><span class="line">	printw(<span class="string">"Hello World !!!\n"</span>);</span><br><span class="line">	getch(); <span class="comment">// 等待用户输入</span></span><br><span class="line">	def_prog_mode(); <span class="comment">// 存储当前tty 模式</span></span><br><span class="line">	endwin(); <span class="comment">// 退出 ncurses 模式</span></span><br><span class="line">	system(<span class="string">"sh"</span>); <span class="comment">// 返回普通的行缓冲模式</span></span><br><span class="line">	reset_prog_mode(); <span class="comment">// 返回到 def_prog_mode() 存储的 tty 模式</span></span><br><span class="line">	refresh(); <span class="comment">// 刷新屏幕（必须！）</span></span><br><span class="line">	getch(); <span class="comment">// 等待用户输入</span></span><br><span class="line">	endwin(); <span class="comment">// 退出 ncurses 模式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出中文等非-ASCII-字符"><a href="#输出中文等非-ASCII-字符" class="headerlink" title="输出中文等非 ASCII 字符"></a>输出中文等非 ASCII 字符</h2><p>事实上 ncurses 并不支持直接输出中文，<br>这意味着调用 printw(“中文”) 会是一堆乱码。<br>解决方案如下：</p>
<h3 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h3><p>这需要另一个库。<br>通过 <code>sudo aptitude install libncurses5 libncursesw5 libncursesw5-dbg libncursesw5-dev</code> 安装</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>一定是 <code>#include &lt;ncurses.h&gt;</code> 而不是 <code>#include &lt;curses.h&gt;</code> 。<br>另外在 main.cpp <code>#include &lt;locale.h&gt;</code> 。</p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>在调用 initscr() <strong>之前</strong> 调用 setlocale(LC_ALL, “”) 。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将 <code>-lncurses</code> 参数改为 <code>-lncursesw</code> 。</p>
]]></content>
  </entry>
  <entry>
    <title>Manjaro 搭建内网博客</title>
    <url>/2019/10/09/Manjaro%20%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%96%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>折腾了大半天，终于在本机搭了一个功能完备的服务器。<br>当然要记录一下啊。<br>不过这是搭建成功后的总结，可能有地方遗漏，有问题欢迎提出来。</p><h2 id="静态页面博客"><a href="#静态页面博客" class="headerlink" title="静态页面博客"></a>静态页面博客</h2><p>这个用 hexo 和 jekyll 直接就可以做到，本地跑 server 不成问题，<br>比较 easy ，不赘述，详见 hexo 或者 jekyll 的官网。</p><h2 id="动态页面博客"><a href="#动态页面博客" class="headerlink" title="动态页面博客"></a>动态页面博客</h2><a id="more"></a>

<p>动态页面要能跑 php ，有数据库。</p>
<h2 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h2><p>这里用 apache(httpd) 搭建服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S apache2</span><br></pre></td></tr></table></figure>

<p>执行 <code>sudo httpd</code> 后打开 localhost ，就有一个东西了（虽然是空的）。<br>在 /srv/http/ 下新建 index.html 随便写点东西，是可以显示的。<br>路径具体查看 <code>httpd -S</code> 。</p>
<p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start httpd</span><br></pre></td></tr></table></figure>

<h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><p>安装 php （ manjaro18.x 预装了 php7.x ，但还是要一些其他的东西）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S php php-apache php-fpm</span><br></pre></td></tr></table></figure>

<p>这时 apache 还是不支持 php 的，需要在配置里加上几行。<br>打开 /etc/httpd/conf/httpd.conf ，加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule php7_module modules/libphp7.so</span><br><span class="line">AddType application/x-httpd-php-source .phps</span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line">DirectoryIndex index.php index.html index.htm</span><br></pre></td></tr></table></figure>

<p>开启 php 服务：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start php-fpm</span><br></pre></td></tr></table></figure>

<p>编写 index.php 试试，也可以运行了。<br>如果出了问题，找到配置里的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mpm_event_module modules/mod_mpm_event.so</span><br></pre></td></tr></table></figure>

<p>改成（应该就在下面被注释了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mpm_prefork_module modules/mod_mpm_prefork.so</span><br></pre></td></tr></table></figure>

<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>我跑 mysql 的服务会卡死，不知道为什么，<br>所以我用 mariadb （mysql 的一个衍生似乎是）替代。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S mariadb mariadb-client</span><br></pre></td></tr></table></figure>

<p>初始化（注册一个账号）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p>试试能不能登上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u&lt;用户名&gt; -p</span><br></pre></td></tr></table></figure>

<p>让 php 支持 mysql 的调用，在 /etc/php/php.ini 找到 ;extension=mysqli 把分号去掉就行了。</p>
<h2 id="使用-wordpress"><a href="#使用-wordpress" class="headerlink" title="使用 wordpress"></a>使用 wordpress</h2><p>Typecho 用 php7.2 似乎安装会出问题，<br>还是建议用 wordpress ，更加成熟，<br>安装方式在 wordpress 官网上把包下下来解压到 /srv/http/ ，<br>回了正常运行，需要改变 /srv/http 的权限，让 wordpress 能够对其做出修改。<br>这里不赘述，嫌麻烦可以 <code>chmod 777 -R /srv/http</code> 。</p>
<p>然后进入 localhost 按照步骤来就行了。</p>
]]></content>
  </entry>
  <entry>
    <title>i3</title>
    <url>/2019/10/09/i3/</url>
    <content><![CDATA[<h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><ul>
<li>最先用的是 Ubuntu 16.04 自带的 Unity 。</li>
<li>更新 Ubuntu 后用的 Ubuntu 18.04 自带的 Gnome 。</li>
<li>用了 Gnome 后学会了折腾，各种配置堆上。</li>
<li>后来发现 Gnome 太卡太吃内存，并且才知道系统可以换桌面，<br>于是在 master 安利下换上 xfce 。</li>
<li>xfce 很稳定很流畅，但是太丑，可玩性太低，于是换上高大上的 KDE 。</li>
<li>中途还换过 enlightenment ，但是 enlightenment 的稳定性实在不敢恭维。</li>
<li>最后用上了 i3 ，原因不详。</li>
</ul><a id="more"></a>
<p>WARNING:<br>既然你打算尝试 i3 ，本文假设你有一定的动手能力（说白了就是能折腾）。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>sudo aptitude install i3-wm</code> 后注销重进选择 i3 即可。</p>
<p>然后你会发现弹出个窗口，接下来黑屏，没有动静。<br>WTF ?<br>其实 i3 已经开了，只是没背景而已，按 win+Enter 打开终端。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>弹出一个菜单给你设置？想多了，要配置就写 ~/.config/i3/config 去吧。</p>
<p>$mod 是 i3 的灵魂，每一个快捷键最好都以 $mod 开头，<br>一般 $mod 被设置成 Mod4 ，也就是 Win 键。<br>bindsym 是绑定快捷键，注释很详细，自己看，下面列出一些重要的配置。</p>
<h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>i3 默认把 jkl; 做方向键，也许你会更喜欢 hjkl ，自己替换掉就是了。<br>另外分号不是 ; 而是 semicolon 。</p>
<h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><p>i3 默认没有壁纸，因为它是个平铺式的窗口管理器。<br>但壁纸是第一生产力啊，不要壁纸怎么行。</p>
<p>下载 feh: <code>sudo aptitude install feh</code>.<br><code>feh --bg-fill (YOUR_IMG)</code> 就可以设置壁纸了，至于实现原理，你不会想知道的。</p>
<h3 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h3><p>i3 默认没有锁屏，为了防机惨，锁屏还是很有必要的。</p>
<p>下载 i3lock: <code>sudo aptitude install i3lock</code>.<br>直接 <code>i3lcok</code> 就可以锁屏，<code>i3lock -i (YOUR_PNG)</code> 还可以设置锁屏壁纸。<br>需要快捷键锁屏的话，加上一句配置就行了：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+Tab exec i3lock # Win+Tab 锁屏</span><br></pre></td></tr></table></figure>

<h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>i3 对工作区的数量没有限制，工作区的名字甚至可以有字母。<br>i3 默认配置里只提供了切换到 1 至 10 的快捷键，<br>但是有时候“切换到下一个工作区”和“切换到上一个工作区”可能更方便。<br>加上两句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+comma workspace prev # Win+逗号</span><br><span class="line">bindsym $mod+period workspace next # Win+句号</span><br></pre></td></tr></table></figure>

<p>另外，默认配置里，把一个窗口移动到某工作区的时候仍会停留在原工作区，<br>想改变这点，<br>把 <code>move container to workspace x</code> 后面加上 <code>; workspace x</code> 即可。</p>
<h3 id="i3bar"><a href="#i3bar" class="headerlink" title="i3bar"></a>i3bar</h3><p>个人超喜欢 i3bar ，因为它可以接受任何一个程序的输出。<br>这意味着你可以完全自由地定制 i3bar 。</p>
<p>找到 <code>bar {</code> 这行。<br>bar 的模式有三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mode hide # Auto display</span><br><span class="line">mode invisible # Never display</span><br><span class="line">mode dock # Alway display</span><br></pre></td></tr></table></figure>

<p>位置有两种：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position top</span><br><span class="line">position bottom</span><br></pre></td></tr></table></figure>

<p>重点来了，定义处理程序这一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_command i3status</span><br></pre></td></tr></table></figure>

<p>可以看到默认使用 i3status 作为处理，i3status 本身也可以配置，<br>但是如果想自由配置，你可以写个程序，输出一个 json ，接口比较复杂，<br>在此不赘述，你可以在 ~/.config/i3status/config 里加几行：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general &#123;</span><br><span class="line">	   output_format = &quot;i3bar&quot;</span><br><span class="line">	   colors = true</span><br><span class="line">	   interval = 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行 <code>i3status</code> 依葫芦画瓢就是了。</p>
<h3 id="i3-gaps"><a href="#i3-gaps" class="headerlink" title="i3-gaps"></a>i3-gaps</h3><p>如果你希望窗口平铺之间会有间隙，i3-gaps 会满足你。<br>如果你用 Debian, Ubuntu ，<br>去 github 上搜 i3-gaps-deb clone 下来后运行 i3-gaps-deb 就行了。<br>如果用 Arch ，软件包管理器里有，直接下。</p>
<h3 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h3><p>也许你给终端模拟器设置了透明度，很遗憾，在 i3 上没用。<br>解决方案是下载 compton ，运行 <code>compton -b</code> 即可。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>你可以很自由地向 i3 发送命令，<code>i3-msg</code> 提供了一系列接口，<br>足以帮助完成更复杂的定制。</p>
<p>使用 <code>i3-input</code> 可以直接向 i3 发送一条命令。</p>
]]></content>
  </entry>
  <entry>
    <title>HNOI2019</title>
    <url>/2019/10/09/HNOI2019/</url>
    <content><![CDATA[<p>先喷一句，没有大样例，差评。<br>再喷一句，数据水，好评。</p><p>预计 80’ ，实际 110’ 。</p><p>我真是个奇葩实际分比预计分高。。。</p><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0-"></a>Day0-</h2><p>省选前三天教练每天给我们推一道题，都是主席树应用（教练曰“线段树模板”）。<br>都是看了题解的思路才做出来的，自己想就找不到用主席树维护的地方。</p><p>不知道为什么这三天效率都挺高，这三天我 A 的题目估计有我平常一个星期的 A 题数。。。</p><a id="more"></a>




<p>然而还没来得及复习每个知识点，省选就来了。</p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>预计 70’ ，实际 40’ 。</p>
<h3 id="fish"><a href="#fish" class="headerlink" title="fish"></a>fish</h3><p>我看到这题的时候就意识到我只能打暴力了。<br>计算几何？我对这块一片空白。<br>好吧，硬要说思路我大概想得到枚举线段，按斜率搞个什么数据结构？<br>然后真的不会，敲暴力滚粗。</p>
<p>预计 20’ ，实际 20’ 。</p>
<h3 id="jojo"><a href="#jojo" class="headerlink" title="jojo"></a>jojo</h3><p>前缀和后缀相同？求 KMP 的 fail 数组嘛。<br>暴力求，一次加几个字符就求几次 fail, 全加起来就是答案。<br>可持久化？版本树像个 AC 自动机，但是没管这么多，无脑写了个可持久化数组。<br>因为是把每个字符暴力求的，只能过前 50’ 。<br>结果我后面 30’ tm TLE 了？ $ O(n log(n)) $ 的时空复杂度跑 1e5 要 6 秒？</p>
<p>预计 50’ ，实际 20’ 。</p>
<h3 id="polygon"><a href="#polygon" class="headerlink" title="polygon"></a>polygon</h3><p>什么鬼畜题啊，简化一波题意。<br>把线段看做一个区间，除 (x, x + 1) 外每个区间一定可以划分成两个子区间。<br>然后把每个区间看做一个点，相当于有了一个满二叉树。<br>然后旋转操作就相当于把一个点 blablabla 换一下位置。<br>旋转次数可以贪心，方案数不会，大概要 DP ？<br>然后想着就求旋转次数吧，看看数据范围。。。<br>沃日 90% 的数据都要求方案数？小 W 的心情得多差啊。。。<br>当时我还没打其他题，感觉比较亏，就先做前面的题了，结果最后都没打。</p>
<p>预计 0’ ，实际 0’ 。</p>
<h3 id="Watering"><a href="#Watering" class="headerlink" title="Watering"></a>Watering</h3><p>下午直接去机房颓废，死神 vs 火影真好玩。<br>还有被 lyy 安利太阳系争夺战，画风清新，内容硬核。</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>emm, 我是来测数据湿度的。。。<br>结果真被我水过去了。。。</p>
<p>预计 10’ ，实际 70’ 。</p>
<p>所以说有想法就要实现 <del>不然就没事干了</del> 2333 。</p>
<h3 id="tour"><a href="#tour" class="headerlink" title="tour"></a>tour</h3><p>u = v 或者 s[u] = s[v] 且 u, v 相邻的时候 (u, v) 一定是可行的。<br>其他点对 (u, v) 可行当且仅当 s[u] = s[v] 且存在 u -&gt; u2, v -&gt; v2 且 (u2, v2) 可行。<br>DP ？有环。<br>然后就只能把一个点对看做一个点，对于新的点建图，如果从初始的可行点能跑到 (u, v) 则 (u, v) 可行。<br>点数 $ O(n^2) $ ，边数 $ O(m^2) $ ，复杂度 $ O(n^2 + m^2 + q) $ 。<br>然而第一档暴力 m 就有 1e4 ， <strong>纯随机数据开O2</strong> 本地测了一下跑 5s, 真棒。</p>
<p>预计 0’ ，实际 30’ 。</p>
<h3 id="dance"><a href="#dance" class="headerlink" title="dance"></a>dance</h3><p>好迷啊，看了看 n = 1 有 40’ ，就去想 n = 1 怎么做，<br>推了推就是个式子： $ ans_i = \sum_{j=0} C_L^{i+j k} W^{i+j k} $ 。<br>把每个 $ C_L^x W^x $ 算一遍，快速幂复杂度 $ O(L log(L)) $ ，<br>然而 L 有 1e8 。。。<br>线性都跑不过去吧这，但我实在没别的思路，就想试试线性。<br>做法就是预处理，预处理 L 以内的逆元和 $ W_i $ ，再线性求一排的组合数。<br>时空复杂度都是 $ O(L) $ ， <strong>开 O2</strong> 本地测试 17s, 就算不 TLE 都得 MLE 。</p>
<p>预计 0’ ，实际 30’ （考完后再放本地测可以水 40’ woc）。</p>
<p>看了看实际的 L 只有 1e7 到 2e7 左右，真棒。<br>至于空间，我还算有点脑子搞了波动态开空间，不然直接开 1e8 的数组肯定得炸。</p>
<h3 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h3><p>b 是整数的话还能枚举枚举。分数？没救了感觉。<br>于是只打了 10’ 的整数 DP 。</p>
<p>预计 10’ ，实际 10’ 。</p>
<h3 id="Watering-1"><a href="#Watering-1" class="headerlink" title="Watering"></a>Watering</h3><p>下午本来打算去黄兴街打游戏的，先去麦克唐纳德吃中饭，吃完后发现就已经 3 点多了没什么时间。<br>于是放弃了 xbox 又回到机房颓废，死神 vs 火影昨天已经玩熟练了，打起来比较轻松。</p>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3+"></a>Day3+</h2><p>省选完了，结果并不想想象的那样，即使运气眷顾了我还是 wei 的一批。<br>实力不够啊，说啥都是扯淡。</p>
<p>常规欠下的帐也该还了，滚回去学文化课啦，接受作业的洗礼。</p>
]]></content>
  </entry>
  <entry>
    <title>i3lock</title>
    <url>/2019/10/09/i3lock/</url>
    <content><![CDATA[<p><img src="http://kewth.gq/wp-content/uploads/2019/07/2_054-1.png" alt="i3lock-fancy"></p><p>折腾了半天 i3lock ，不写篇博客可惜了。</p><p>i3lock 有啥好折腾的？不就是挂个壁纸锁屏嘛。<br>就是因为 i3lock 太鸡肋了折腾啊。<br>于是我试过了 i3lock 的各种民间 fork 版本，在此总结。</p><h2 id="i3lock"><a href="#i3lock" class="headerlink" title="i3lock"></a><a href="https://github.com/i3/i3lock" target="_blank" rel="noopener">i3lock</a></h2><p>官方版本 i3lock ，稳定可靠，但是鸡肋。</p><p>安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install i3lock</span><br></pre></td></tr></table></figure><a id="more"></a>






<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure>

<h2 id="i3lock-lixxia"><a href="#i3lock-lixxia" class="headerlink" title="i3lock-lixxia"></a><a href="https://github.com/Lixxia/i3lock" target="_blank" rel="noopener">i3lock-lixxia</a></h2><p>最友好，最简单的一个 i3lock fork ，<br>优化了中间显示的圆形框，并支持一些颜色自定义。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Lixxia/i3lock.git</span><br><span class="line"><span class="built_in">cd</span> i3lock</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>顺带一提，只有这个 fork 给出了靠谱的源码安装方式，<br>其他 fork 甚至 i3lock 本身的安装方式都给得很不靠谱。</p>
<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure>

<h2 id="i3lock-blur"><a href="#i3lock-blur" class="headerlink" title="i3lock-blur"></a><a href="https://github.com/karulont/i3lock-blur" target="_blank" rel="noopener">i3lock-blur</a></h2><p>支持模糊背景，毛玻璃特效。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/karulont/i3lock-blur.git</span><br><span class="line"><span class="built_in">cd</span> i3lock-blur</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>再顺带一提，只有这个 fork 直接给出了需要安装那些库。</p>
<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock --fuzzy</span><br></pre></td></tr></table></figure>

<h2 id="i3lockr"><a href="#i3lockr" class="headerlink" title="i3lockr"></a><a href="https://github.com/owenthewizard/i3lockr" target="_blank" rel="noopener">i3lockr</a></h2><p>支持模糊背景，毛玻璃特效。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/owenthewizard/i3lockr/releases/download/v1.0.0-final/i3lockr</span><br><span class="line">sudo mv i3lockr /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lockr --blur=25</span><br></pre></td></tr></table></figure>

<h2 id="i3lock-color"><a href="#i3lock-color" class="headerlink" title="i3lock-color"></a><a href="https://github.com/PandorasFox/i3lock-color" target="_blank" rel="noopener">i3lock-color</a></h2><p>对于颜色的自定义十分全面。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/PandorasFox/i3lock-color</span><br><span class="line"><span class="built_in">cd</span> i3lock-color</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure>

<h2 id="i3lock-fancy"><a href="#i3lock-fancy" class="headerlink" title="i3lock-fancy"></a><a href="https://github.com/meskarune/i3lock-fancy" target="_blank" rel="noopener">i3lock-fancy</a></h2><p>重头戏，star 最多的 fork ，甚至比 i3lock 本身更多，被广泛使用。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install i3lock-fancy</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i3lock-fancy</span><br></pre></td></tr></table></figure>

<p>依赖 i3lock ，实际上是产生了背景图片再调用 i3lock 。<br>默认使用模糊背景，用起来没什么问题，但是事实上，<br>圆形框的颜色并不是最正确的，而是兼容的。</p>
<p>源码里有这样一条：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to use a forked version of i3lock with prepared parameters</span></span><br><span class="line"><span class="keyword">if</span> ! i3lock -n <span class="string">"<span class="variable">$&#123;PARAM[@]&#125;</span>"</span> -i <span class="string">"<span class="variable">$IMAGE</span>"</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># We have failed, lets get back to stock one</span></span><br><span class="line">    i3lock -n -i <span class="string">"<span class="variable">$IMAGE</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>bash -x i3lock-fancy 就知道，<br>if 上的命令往往失败了，执行的是 if 里头的命令。</p>
<p>事实上这需要 i3lock-color 。<br>那么，安装 i3lock-color 代替 i3lock 后，执行 i3lock-fancy ，<br>会发现圆形框的颜色与背景更加配了。</p>
<h2 id="关于模糊背景"><a href="#关于模糊背景" class="headerlink" title="关于模糊背景"></a>关于模糊背景</h2><p>事实上，如果你用了 compton 再用 i3lock ，效果十分差劲。<br>解决这个方案，可以在调用 i3lock 前 kill compton ，结束后重新启动 compton 。</p>
<p>拿 i3lock-fancy 举例，把之前展示的代码改成这样：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to use a forked version of i3lock with prepared parameters</span></span><br><span class="line">pkill compton</span><br><span class="line"><span class="keyword">if</span> ! i3lock -n <span class="string">"<span class="variable">$&#123;PARAM[@]&#125;</span>"</span> -i <span class="string">"<span class="variable">$IMAGE</span>"</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># We have failed, lets get back to stock one</span></span><br><span class="line">    i3lock -n -i <span class="string">"<span class="variable">$IMAGE</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">compton -i 0.8 -b</span><br></pre></td></tr></table></figure>

<p>其次，用模糊背景通常会比较慢，尤其是 i3lock-fancy ，需等上 3 秒左右。<br>那么如果调用 i3lock-fancy 之后你又做了一些别的操作，比如关闭一个窗口，<br>这时锁屏了，你会发现背景和原来的不一样。 :)</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
