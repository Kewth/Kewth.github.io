<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一类不公平博弈总结</title>
    <url>/2020/05/09/%E4%B8%80%E7%B1%BB%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%8D%9A%E5%BC%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>以下简称超现实数 Surreal Numbers 为 SN 。</p><p>超现实数完整的理论很复杂，这里不详细给出。</p><p>不加证明的给出以下重要的性质，实践中往往将 SN 用普通的实数表示，当然不是所有 SN 都能对应到一个实数的，实数域只是超现实数域的一个子集。</p><ul>
<li>对于 SN <span class="math inline">\(P = \{|\}\)</span> ，有 <span class="math inline">\(P = 0\)</span> ，即加法单位元。</li>
<li>对于 SN <span class="math inline">\(P = \{S_L | S_R\}\)</span> ，如果集合 <span class="math inline">\(S_L\)</span> 存在最大值 <span class="math inline">\(P_L\)</span> ，则 <span class="math inline">\(P = \{P_L | S_R\}\)</span> 。</li>
<li>对于 SN <span class="math inline">\(P = \{S_L | S_R\}\)</span> ，如果集合 <span class="math inline">\(S_R\)</span> 存在最小值 <span class="math inline">\(P_R\)</span> ，则 <span class="math inline">\(P = \{S_L | P_R\}\)</span> 。</li>
<li>对于 SN <span class="math inline">\(P = \{P_L | P_R\}\)</span> ，<span class="math inline">\(P\)</span> 的值可以由一颗特殊的树确定，<span class="math inline">\(P\)</span> 是值在 <span class="math inline">\(P_L\)</span> 和 <span class="math inline">\(P_R\)</span> 之间的最浅的点（不包括 <span class="math inline">\(P_L, P_R\)</span> ），这棵树长这样：</li>
</ul><a id="more"></a>



<p><img src="/images/tree.png"></p>
<ul>
<li><p>对于 SN <span class="math inline">\(P = \{P_L |\}\)</span> ，<span class="math inline">\(P\)</span> 是值大于 <span class="math inline">\(P_L\)</span> 的最浅的点。</p></li>
<li><p>对于 SN <span class="math inline">\(P = \{| P_R\}\)</span> ，<span class="math inline">\(P\)</span> 是值小于 <span class="math inline">\(P_R\)</span> 的最浅的点。</p></li>
<li><p>对于 SN <span class="math inline">\(P = \{P_L | P_R\}\)</span> ，如果 <span class="math inline">\(P_L \ge P_R\)</span> ，这个 <span class="math inline">\(P\)</span> 实际上已经不满足超现实数的公理，但在不公平博弈论中仍然很重要，有时候需要用于确定先手的必胜性。</p></li>
</ul>
<p>而对于两个 SN <span class="math inline">\(\frac{a_1}{2^{k_1}}\)</span> 和 <span class="math inline">\(\frac{a_2}{2^{k_2}}\)</span> 的深度的比较，以 <span class="math inline">\(k\)</span> 为第一关键字 <span class="math inline">\(a\)</span> 的绝对值为第二关键字比较即可，特别的，<span class="math inline">\(0\)</span> 是深度最浅的点。</p>
<p>直观上，可以将一个能对应到实数的 SN 理解为左玩家可以自由操作的次数减去右玩家可以自由操作的次数。</p>
<p>一个游戏可以看做一个 SN <span class="math inline">\(P\)</span> ：</p>
<ul>
<li>如果 <span class="math inline">\(P &gt; 0\)</span> ，那么左玩家必胜。</li>
<li>如果 <span class="math inline">\(P &lt; 0\)</span> ，那么右玩家必胜。</li>
<li>如果 <span class="math inline">\(P = 0\)</span> ，那么先手必败。</li>
<li>如果 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(0\)</span> 没有偏序关系，那么先手必胜。</li>
</ul>
<p>如果一个游戏 <span class="math inline">\(P\)</span> 可以划分为若干互不影响的子游戏 <span class="math inline">\(P_1, P_2 ... P_n\)</span> ，那么 <span class="math inline">\(P = P_1 + P_2 + ... + P_n\)</span> 。</p>
<p>和 0 可以确定偏序关系的 <span class="math inline">\(P\)</span> 可以简单的加起来，但是和 0 没法确定偏序关系的一些 <span class="math inline">\(P\)</span> 的加法比较特殊。</p>
<p>例如公平博弈下的 SG 定理，子游戏的加是 SG 值的异或，事实上公平博弈的游戏对应的 SN 只能是 0 或者是与 0 没有偏序关系的数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>不公平博弈</tag>
        <tag>超现实数</tag>
      </tags>
  </entry>
  <entry>
    <title>集合幂级数</title>
    <url>/2020/05/06/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<p>对于两个集合幂级数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> ，定义其和 <span class="math inline">\(h\)</span> ：</p><p><span class="math display">\[ h_S = f_S + g_S \]</span></p><p>对于两个集合幂级数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> ，定义其乘积 <span class="math inline">\(h\)</span> ：</p><p><span class="math display">\[ h_S = \sum_{T \subseteq S} f_T \times g_{S \setminus T} \]</span></p><a id="more"></a>



<p>即常说的子集卷积。</p>
<p>那么定义了乘法和加法，就能进一步定义更多运算。</p>
<p>在这之前先引入集合占位幂级数。</p>
<h2 id="集合占位幂级数">集合占位幂级数</h2>
<p>对于集合幂级数 <span class="math inline">\(f\)</span> ，其占位幂级数 <span class="math inline">\(P(f)\)</span> 的每一位实际是一个多项式，满足：</p>
<p><span class="math display">\[ P(f)_S = f_S x^{|S|} \pmod{x^{|S|+1}} \]</span></p>
<p>有了占位幂级数，就可以很容易地把集合幂级数的乘法转换为并卷积，即通过莫比乌斯变换可以很好处理两个集合幂级数的乘法。</p>
<p>具体的，对于集合幂级数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> ，求出幂级数 <span class="math inline">\(p\)</span> 满足：</p>
<p><span class="math display">\[ P(h)_S = \sum_{A \cup B = S} P(f)_A \times P(g)_B \]</span></p>
<p>其中 <span class="math inline">\(P(f)_A \times P(g)_B\)</span> 就是多项式卷积。</p>
<p>那么根据集合并卷积的性质可以知道：</p>
<p><span class="math display">\[ FMT(P(h))_S = FMT(P(f))_S \times FMT(P(g))_S \]</span></p>
<p>暴力进行多项式卷积，一次乘法的复杂度为 <span class="math inline">\(O(2^n n^2)\)</span> ，其中 <span class="math inline">\(n\)</span> 是全集的大小。</p>
<h2 id="求逆">求逆</h2>
<p>对于集合幂级数 <span class="math inline">\(f\)</span> ，定义其逆元 <span class="math inline">\(g\)</span> 为满足 <span class="math inline">\(f \times g = e\)</span> 的集合幂级数。</p>
<p>其中 <span class="math inline">\(e\)</span> 是集合幂级数的单位元，满足 <span class="math inline">\(\forall f, f \times e = f\)</span> 。</p>
<p>可以知道 <span class="math inline">\(\forall S, FMT(P(e))_S = 1\)</span> 。</p>
<p>那么就有 <span class="math inline">\(\forall S, FMT(P(g))_S = FMT(P(f))_S^{-1} \pmod{x^{|S|+1}}\)</span> 。</p>
<p>暴力多项式求逆，复杂度 <span class="math inline">\(O(2^n n^2)\)</span> ，其中 <span class="math inline">\(n\)</span> 是全集的大小。</p>
<h2 id="开根">开根</h2>
<p>对于集合幂级数 <span class="math inline">\(f\)</span> ，定义其平方根 <span class="math inline">\(g\)</span> 为满足 <span class="math inline">\(g \times g = f\)</span> 的集合幂级数。</p>
<p>可以知道 <span class="math inline">\(\forall S, FMT(P(g))_S^2 = FMT(P(f))_S \pmod{x^{|S|+1}}\)</span> 。</p>
<p>暴力多项式开根，复杂度 <span class="math inline">\(O(2^n n^2)\)</span> ，其中 <span class="math inline">\(n\)</span> 是全集的大小。</p>
<h2 id="其他">其他</h2>
<p>类似的也可以定义 <span class="math inline">\(\exp\)</span> 和 <span class="math inline">\(\ln\)</span> 。</p>
<p>不难发现所有集合幂级数的运算都可以转换莫比乌斯变换后占位幂级数的多项式运算。</p>
<p>暴力做多项式运算，复杂度都是 <span class="math inline">\(O(2^n n^2)\)</span> ，理论上可以做到 <span class="math inline">\(O(2^n n \log n)\)</span> 。</p>
<p>但是考虑到对占位幂级数做莫比乌斯变换的复杂度就要 <span class="math inline">\(O(2^n n^2)\)</span> 。 且由于集合幂级数运算的运算的瓶颈主要在于 <span class="math inline">\(O(2^n)\)</span> ，<span class="math inline">\(n\)</span> 往往很小。 此时 <span class="math inline">\(O(n \log n)\)</span> 的多项式运算带来的常数因子影响是很大的，因此集合幂级数的运算往往使用 <span class="math inline">\(O(n^2)\)</span> 的暴力运算。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>多维卷积</title>
    <url>/2020/05/06/%E5%A4%9A%E7%BB%B4%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<p><del>异或卷积的本质就是 <span class="math inline">\(n\)</span> 维循环卷积。</del></p><h2 id="二维卷积">二维卷积</h2><p>可以理解为对于二维数组 <span class="math inline">\(f\)</span> 和二维数组 <span class="math inline">\(g\)</span> 求二维数组 <span class="math inline">\(h\)</span> ：</p><p><span class="math display">\[h_{i,j} = \sum_{a+b=i} \sum_{c+d=j} f_{a,c} \times g_{b,d}\]</span></p><p>这个 <span class="math inline">\(h\)</span> 就是 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 的二维卷积。</p><a id="more"></a>




<p>构造生成函数数组 <span class="math inline">\({F_i}, {G_i}, {H_i}\)</span> ，满足 <span class="math inline">\(F_i = \sum_{j} f_{i,j} x^j\)</span> ，类似地定义 <span class="math inline">\({G_i}\)</span> 和 <span class="math inline">\({H_i}\)</span> ，那么有：</p>
<p><span class="math display">\[H_i = \sum_{a+b=i} F_a \times G_b\]</span></p>
<p>其中 <span class="math inline">\(F_a \times G_b\)</span> 就是多项式卷积。</p>
<p>不妨把 <span class="math inline">\(F, G, H\)</span> 的每一位所对应的多项式看做普通的元素，那么 <span class="math inline">\(H\)</span> 就是 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(G\)</span> 的卷积，傅里叶变换在这里仍然是可以定义的。</p>
<h2 id="高维卷积">高维卷积</h2>
<p>二维卷积的做法完全可以推广到高维卷积，对于两个从向量到数的映射 <span class="math inline">\(F, G\)</span> ，定义其卷积 <span class="math inline">\(H\)</span> 满足：</p>
<p><span class="math display">\[H_c = \sum_{a+b=c} F_a \times G_b\]</span></p>
<p>其中 <span class="math inline">\(a, b, c\)</span> 都是高维向量。</p>
<p>事实上异或卷积就是一个高维卷积（循环卷积），每一维的长度都是二，根据异或卷积的实现不难推广到所有高维卷积的实现。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>卢卡斯定理</title>
    <url>/2020/04/29/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>简单来说就是快速计算 <span class="math inline">\(\binom{n}{m} \mod p\)</span> 。</p><h2 id="卢卡斯定理">卢卡斯定理</h2><p>如果 <span class="math inline">\(p\)</span> 是质数，有 <span class="math inline">\(\binom{n}{m} \equiv \binom{n \mod p}{m \mod p} \binom{n/p}{m/p} \pmod{p}\)</span> ，其中 <span class="math inline">\(n/p\)</span> 和 <span class="math inline">\(m/p\)</span> 表示整除。</p><a id="more"></a>


<p>直接递归调用，预处理阶乘，单次询问时间复杂度 <span class="math inline">\(O(p + \frac{\log n}{\log p})\)</span> 。</p>
<h2 id="扩展卢卡斯">扩展卢卡斯</h2>
<p>这已经不能算定理了，从头到尾就是一个算法。</p>
<p>对于 <span class="math inline">\(p\)</span> 不是质数的情况，考虑将 <span class="math inline">\(p\)</span> 质因数分解，对于每个质因子 <span class="math inline">\(x^k\)</span> ，求出 <span class="math inline">\(\binom{n}{m} \mod x^k\)</span> 后扩展中国剩余定理合并。</p>
<p>那么问题转换为对于质数 <span class="math inline">\(x\)</span> 和指数 <span class="math inline">\(k\)</span> 求 <span class="math inline">\(\binom{n}{m} \mod x^k\)</span> 。</p>
<p>考虑组合数的通项公式 <span class="math inline">\(\binom{n}{m} = \frac{n!}{m!(n-m)!}\)</span> ，分别求出 <span class="math inline">\(n!\)</span>, <span class="math inline">\(m!\)</span>, <span class="math inline">\((n-m)!\)</span> ，特别地，由于它们可能是 <span class="math inline">\(x\)</span> 的倍数，需要将 <span class="math inline">\(x\)</span> 单独提出来。 也就是要求 <span class="math inline">\(n! = x^a b\)</span> 中的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 。</p>
<p>将 <span class="math inline">\(n! = 1 \times 2 \times 3 ... \times n\)</span> 中 <span class="math inline">\(x\)</span> 的倍数单独提出来，这些部分都除掉一个 <span class="math inline">\(x\)</span> 就是 <span class="math inline">\(\lfloor \frac{n}{x} \rfloor!\)</span> ，递归计算。 对于其他部分，每 <span class="math inline">\(x^k\)</span> 分为一块，每一个完整的块的乘积相同，算出一个完整的块的乘积（也就是 <span class="math inline">\((x^k-1)!\)</span> ）后再算零散部分的乘积即可。</p>
<p>预处理阶乘，单次询问时间复杂度 <span class="math inline">\(O(p + \frac{\log n}{\log p})\)</span> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>卢卡斯定理</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>常系数齐次线性递推</title>
    <url>/2020/04/19/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p>问题是这样的：</p><p>对于一个无穷大的递推数列 <span class="math inline">\(\{h_i\}\)</span> 和长度为 <span class="math inline">\(k\)</span> 的已知数列 <span class="math inline">\(\{a_i\}\)</span>，满足<span class="math inline">\(\forall n, h_n = \sum_{i=1}^k a_i h_{n-i}\)</span> 。 已知 <span class="math inline">\(h_i (0 \le i &lt; k)\)</span> 求 <span class="math inline">\(h_n\)</span> 。</p><p>直接递推复杂度 <span class="math inline">\(O(nk)\)</span> ，矩阵快速幂可以做到 <span class="math inline">\(O(k^3 logn)\)</span> 的复杂度，这里介绍一个更优秀的做法。</p><a id="more"></a>


<h2 id="结论">结论</h2>
<p>便于以后复习，先给出结论。</p>
<ol type="1">
<li>构造多项式 <span class="math inline">\(F(x) = x^k - \sum_{i=1}^k a_i x^{k-i}\)</span> 。</li>
<li>求出多项式 <span class="math inline">\(G(x) = \sum_{i=0}^{k-1} c_i x^i = x^n \mod F(x)\)</span> 。</li>
<li>有 <span class="math inline">\(h_n = \sum_{i=0}^{k-1} c_i h_i\)</span> 。</li>
</ol>
<p>第一步和第三步都是 <span class="math inline">\(O(k)\)</span> 的，而第二步通过多项式快速幂和多项式取模可以做到 <span class="math inline">\(O(k\log k\log n)\)</span> 的复杂度。</p>
<h2 id="直观理解">直观理解</h2>
<p>不会线性代数也没关系，上面的做法其实有很简单的直观理解。</p>
<p>上述做法的关键在于第二部分，观察 <span class="math inline">\(H(x) = x^n\)</span> 在对 <span class="math inline">\(F(x)\)</span> 取模时的过程，<br>
可以发现任意时刻，都有 <span class="math inline">\(h_n = \sum_i [x^i]H(x) h_i\)</span> 。</p>
<p>也就是说总有以下命题成立，<span class="math inline">\(H(x)\)</span> 的 <span class="math inline">\(i\)</span> 次项系数就是 <span class="math inline">\(h_i\)</span> 对 <span class="math inline">\(h_n\)</span> 的贡献系数。<br>
这一点不会因减去了若干倍 <span class="math inline">\(F(x)\)</span> 发生改变。<br>
原因也很简单，每次将 <span class="math inline">\(H(x)\)</span> 减去 <span class="math inline">\(x^i F(x)\)</span> ，就相当于把 <span class="math inline">\(h_{k+i}\)</span> 换成了 <span class="math inline">\(\sum_{j=1}^k a_j h_{k+i-j}\)</span> 。<br>
本质上是由于 <span class="math inline">\(F(x) \equiv 0 \pmod{F(x)}\)</span> 等价于 <span class="math inline">\(x_k \equiv \sum_{i=1}^k a_i x^{k-i} \pmod{F(x)}\)</span> 。</p>
<p>其实自己列竖式算一算 <span class="math inline">\(x^n \mod F(x)\)</span> 就能很容易发现这一点。</p>
<h2 id="线代意义">线代意义</h2>
<p>线代基础不行，只能先行告退。🕊🕊🕊🕊🕊</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>code-trick</title>
    <url>/2020/01/16/code-trick/</url>
    <content><![CDATA[<p>总结一些 code-trick ，这种东西看看别人的代码，有时能够大开眼界。</p><h2 id="nttfft">NTT/FFT</h2><h4 id="预处理原根">预处理原根</h4><p>普通 NTT 每次长度改变都需要调用若干次快速幂来计算原根，差不多长这样：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll Gn = power(<span class="number">3</span>, (mod - <span class="number">1</span>) / (m &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m) &#123;</span><br><span class="line">			ll G = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">				ll a0 = a[k], a1 = a[k + m] * G;</span><br><span class="line">				a[k] = (a0 + a1) % mod;</span><br><span class="line">				a[k + m] = (a0 + mod - a1) % mod;</span><br><span class="line">				(G *= Gn) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>事实上可以预处理数组 <span class="math inline">\(G\)</span> 满足当前枚举的 <span class="math inline">\((m, k, i)\)</span> 需要用到的原根就是 <code>G[m + k - i]</code> ，<br>
每一层需要 <span class="math inline">\(m\)</span> 个位置，由于每次 <span class="math inline">\(m\)</span> 倍长，<span class="math inline">\(O(n)\)</span> 的空间是能存下的。<br>
而且只需要递推 <span class="math inline">\(m\)</span> 最大的一层，剩下的由于 <span class="math inline">\(W_m^k = W_{2m}^{2k}\)</span> ，可以知道 <code>G[m + k] = G[m * 2 + k * 2]</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll g = power(<span class="number">3</span>, (mod - <span class="number">1</span>) / maxl);</span><br><span class="line">	G[maxl &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = (maxl &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>; i &lt;= maxl; i ++)</span><br><span class="line">		G[i] = G[i - <span class="number">1</span>] * g % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = (maxl &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i; i --)</span><br><span class="line">		G[i] = G[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">				ll a0 = a[k], a1 = a[k + m] * G[m + k - i] % mod;</span><br><span class="line">				a[k] = (a0 + a1) % mod;</span><br><span class="line">				a[k + m] = (a0 + mod - a1) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的道理 rev 数组也是能预处理的。</p>
<h4 id="逆变换">逆变换</h4>
<p>逆变换实际只要 reverse 一遍做正变换然后除以 <span class="math inline">\(n\)</span> 即可。</p>
<p>除以 <span class="math inline">\(n\)</span> 往往需要计算逆元，但是由于 <span class="math inline">\(n\)</span> 是二的整次幂，且 NTT 模数必须是 <span class="math inline">\(2^k * s + 1\)</span> ，<br>
除了预处理以外 <span class="math inline">\(n\)</span> 的逆元有更好的 <span class="math inline">\(O(1)\)</span> 计算方法，因为找到一个满足 <span class="math inline">\(nx \equiv -1\)</span> 的数 <span class="math inline">\(x\)</span> 是很容易的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::reverse(a + <span class="number">1</span>, a + n);</span><br><span class="line">	DFT(a, n);</span><br><span class="line">	<span class="keyword">int</span> invn = mod - (mod - <span class="number">1</span>) / n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">		(a[i] *= invn) %= mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模数">模数</h4>
<p>当模数比较小以至于 <span class="math inline">\(p^2logn\)</span> 不会爆 <code>long long</code> 的时候，NTT 的蝴蝶变换可以在最后取模，实测会快很多。 比如 <code>167772161</code> 就是这样一个模数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __d(ll &amp;x) &#123; <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(ll *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m &lt;&lt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + m; k ++) &#123;</span><br><span class="line">				ll a0 = a[k], a1 = a[k + m] * G[m + k - i] % mod;</span><br><span class="line">				a[k] = a0 + a1;</span><br><span class="line">				a[k + m] = a0 - a1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) __d(a[i] %= mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fft-两次变一次-1">FFT 两次变一次 1</h4>
<p>这是 myy 提出的一个优秀的 FFT trick ，能够一次 FFT 处理两个多项式，但缺点是精度会进一步降低。</p>
<p>前提是两个多项式的系数在 FFT 前虚部为 0 ，这个条件在 DFT 中往往是能满足的。</p>
<p>例如要给两个多项式 <span class="math inline">\(A, B\)</span> 做 FFT ，考虑构造两个多项式：</p>
<p><span class="math display">\[P(x) = A(x) + i B(x)\]</span> <span class="math display">\[Q(x) = A(x) - i B(x)\]</span></p>
<p>那么由于 <span class="math inline">\(A, B\)</span> 的虚部都为 0 ，<span class="math inline">\(P, Q\)</span> 的每一项系数都互为共轭，同样 <span class="math inline">\(FFT(P), FFT(Q)\)</span> 的每一项系数都互为共轭。<br>
那么只需对 <span class="math inline">\(P\)</span> 做一次 FFT ，就可以通过共轭 <span class="math inline">\(O(n)\)</span> 求出 <span class="math inline">\(FFT(Q)\)</span> 的系数。<br>
然后通过 <span class="math inline">\(FFT(P), FFT(Q)\)</span> 求 <span class="math inline">\(FFT(A), FFT(B)\)</span> 就是解上面的二元一次方程组，也是可以 <span class="math inline">\(O(n)\)</span> 做到的。</p>
<h4 id="fft-两次变一次-2">FFT 两次变一次 2</h4>
<p>这是 myy 提出的一个优秀的 FFT trick ，能够一次 FFT 处理两个多项式，但缺点是精度会进一步降低。</p>
<p>前提是两个多项式的系数在 FFT 后虚部为 0 ，这个条件在 IDFT 中往往是能满足的。</p>
<p>例如要给两个多项式 <span class="math inline">\(A, B\)</span> 做 FFT ，构造多项式 <span class="math inline">\(P\)</span> 满足：</p>
<p><span class="math display">\[P(x) = A(x) + i B(x)\]</span></p>
<p>求出 <span class="math inline">\(FFT(P)\)</span> ，同样有 <span class="math inline">\(FFT(P)(x) = FFT(A)(x) + i FFT(B)(x)\)</span> ，而 <span class="math inline">\(FFT(A), FFT(B)\)</span> 系数的虚部都是 0 。</p>
<p>那么 <span class="math inline">\(FFT(P)\)</span> 的实部就是 <span class="math inline">\(FFT(A)\)</span> ，虚部就是 <span class="math inline">\(FFT(B)\)</span> 。</p>
<h2 id="线段树">线段树</h2>
<p>同时需要记录区间最大值 max 和区间取 min 标记 tag 时，直接用 max 代替掉 tag 即可。<br>
比如区间取 min 和区间求和的吉司机线段树（segment tree beats）。</p>
<h2 id="stl">STL</h2>
<p>将数组降序排序不需要写 <code>cmp</code> ，只需要 <code>std::sort(a, a + n, std::greater&lt;int&gt;());</code> 即可。<br>
<code>std::greater</code> 包含在头文件 <code>functional</code> 中，这同样适用于结构体排序。<br>
另外如果要用小根堆，可以使用 <code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt;</code> 。<br>
与 <code>std::greater</code> 对应的是 <code>std::less</code> 。</p>
<p><code>std::set</code> 插入后返回的迭代器可以直接获取：<code>auto iter = set.insert(x).second</code> 。</p>
<h2 id="位运算">位运算</h2>
<h4 id="预处理-bitcount">预处理 bitcount</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">	bitcount[i] = bitcount[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="预处理-highbit">预处理 highbit</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">	highbit[i] = highbit[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="语法">语法</h2>
<p>利用语法糖可以写出一些骚操作，比如下面这个快读模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inputer</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>], *p;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">int</span>(strtol(p, &amp;p, <span class="number">10</span>)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> strtoll(p, &amp;p, <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">operator</span> () (<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span> x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> ...<span class="title">A</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">operator</span> () (<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">A</span> &amp;...<span class="title">a</span>)</span></span><br><span class="line"><span class="class">	&#123;</span> x = *<span class="keyword">this</span>; <span class="keyword">this</span> -&gt; <span class="keyword">operator</span> ()(a...); &#125;</span><br><span class="line">	Inputer() &#123; fread(buffer, <span class="number">1</span>, <span class="keyword">sizeof</span> buffer, <span class="built_in">stdin</span>); &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"><span class="keyword">char</span> *Inputer::p = Inputer::buffer;</span><br><span class="line"><span class="keyword">char</span> Inputer::buffer[] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>它有多种用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = read;</span><br><span class="line"></span><br><span class="line">	ll b = read;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	read(c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line">	ll e, f;</span><br><span class="line">	read(d, e, f);</span><br><span class="line"></span><br><span class="line">	foo(read);</span><br><span class="line"></span><br><span class="line">	read.<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	ll g = <span class="keyword">int</span>(read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且可以自定义各种类型的读入，编译器能够根据类型正确调用对应的输入函数（在没有歧义的前提下），或者自己在调用时直接给出类型。</p>
<p>ps: 这个 trick 不是学的，是我自己原创的，也是我一直在使用的快读模板。:)</p>
<p>事实上由于大多时候不需要快读，我平时用的输入模板是这样子的（用法完全相同）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">ll</span> <span class="params">()</span> </span>&#123; ll x; <span class="keyword">return</span> <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x), x; &#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">operator</span> () (<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span> x = *<span class="keyword">this</span>; &#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> ...<span class="title">A</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">operator</span> () (<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">A</span> &amp;...<span class="title">a</span>)</span></span><br><span class="line"><span class="class">	&#123;</span> x = *<span class="keyword">this</span>; <span class="keyword">this</span> -&gt; <span class="keyword">operator</span> () (a...); &#125;</span><br><span class="line">&#125; read;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛57</title>
    <url>/2020/01/10/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B57/</url>
    <content><![CDATA[<p>咕咕咕我又来写总结啦。</p><p>第一次打牛客，一进牛客发现还有 30s 就有一场比赛，就报了名。<br>
一开始只是打算玩玩，看看牛客的题来着。</p><figure>
<img src="/images/nowcoder.com.png" alt><figcaption>牛客</figcaption>
</figure><p>一不小心上瘾了，可惜不计 rating 。<br>
（另外 %%% <span class="citation" data-cites="CYJian">@CYJian</span> 喜提 rank1 ）</p><p>先看 A 题挺签到的，花几分钟过了，然而交 WA 了一次，原因竟然是下标 0, 1 开头混用了，感觉自己很蠢。</p><a id="more"></a>




<p>然后想着玩玩嘛，就直接开 F 了。</p>
<p>嗯看着是道数学题？这个求和方式是个组合数嘛，询问就是一个这玩意：</p>
<p><span class="math display">\[\sum_{i=l}^r a_i C_{r-l}^{i-l}\]</span></p>
<p>我猜这个个组合数展开成阶乘然后配卷积，然后推式子，推了一年没有半点用，连个卷积的影子都没有。</p>
<p>然后打算根据组合意义算，就是在一个三角形上走的路径数，<br>
三角形有 <span class="math inline">\(O(n^2)\)</span> 个点，每个点可以 <span class="math inline">\(O(1)\)</span> 递推 (<span class="math inline">\(A_{i,j} = A_{i-1,j} + A_{i-1,j-1}\)</span>) ，<br>
询问就是询问一个点的值 (<span class="math inline">\(A_{r,r-l}\)</span>) 。<br>
但同时根据组合数的性质，每个点可以 <span class="math inline">\(O(k)\)</span> 地由该点底下 k 层的 k 个点递推出来。<br>
暴力预处理是 <span class="math inline">\(O(n^2+q)\)</span> 的，暴力询问是 <span class="math inline">\(O(n+qn)\)</span> 的，这看着就是要在两者之间求得平衡。</p>
<p>于是我想到了分块，只要预处理三角形若干排，然后询问就可以找到比较近的已经处理的一排暴力算。</p>
<p>如果两排的间距是 <span class="math inline">\(B\)</span> ，那么询问复杂度就是 <span class="math inline">\(O(B)\)</span> 的。</p>
<p>然而怎么预处理？每个点拿组合数直接算复杂度仍然是 <span class="math inline">\(O(n^2)\)</span> 的 🤔 。</p>
<p>然后卡这里又卡了一年，后来灵光一现发现两排之间的生成函数就是乘一个 <span class="math inline">\((1+x)\)</span> ，<br>
用 NTT 即可在两排之间快速预处理，乘一个 <span class="math inline">\((1+x)^B\)</span> 就行了。<br>
<del><span class="math inline">\((1+x)^B\)</span> 不就是是组合数的生成函数吗？这都没想到感觉自己很睿智。</del></p>
<p>那么预处理的复杂度为 <span class="math inline">\(O(nlogn\frac{n}{B})\)</span> 的，和询问的复杂度均衡一下就可以得到一个 <span class="math inline">\(O(n\sqrt{nlogn})\)</span> 的做法。<br>
（假定 <span class="math inline">\(n, q\)</span> 同阶）</p>
<p>然后就开始码，码完 T 了，T 了两次，经 <span class="citation" data-cites="CYJian">@CYJian</span> 指点发现 <span class="math inline">\(B\)</span> 设小了，导致带 log 的卷积部分跑得很慢。<br>
改完就 A 了，过了 1.5h 竟然还拿了一血。<br>
这个时候没记错是 rank140 左右。</p>
<p>然后开了一眼 D 感觉就是个马拉车，打完发现疯狂 WA ，仔细读题发现要求找两个子串，是恰好两个，用一个都不行 wdnmd 😡 。</p>
<p>A 掉 D 就开始飘了， B 题细节题屑的一批，C 题是个 FWT 。</p>
<p>结果 C 题也疯狂 WA ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">while</span>(T --) &#123;</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">			<span class="keyword">if</span>(w[i] &gt; W) &#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因竟然是这个特判，它的 continue 只对 for 有效。。。<br>
都打了两三年代码竟然犯这个错误。。。</p>
<p>最后打完就只有几分钟了，竟然上了 rank4 ，罚时高出天际。</p>
<p>没有被抽中 😭 😭 😭 😔 😔 😔 。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>miller-rabin 和 pollard-rho</title>
    <url>/2020/01/06/miller-rabin-%E5%92%8C-pollard-rho/</url>
    <content><![CDATA[<h2 id="miller-rabin">miller-rabin</h2><p>用于快速测试一个数 <span class="math inline">\(n\)</span> 是否为质数，有概率出错。</p><p>不妨假设 <span class="math inline">\(n\)</span> 是奇数，此外 miller-rabin 需要随意选取一个小质数 <span class="math inline">\(p\)</span> 。</p><h4 id="理论">理论</h4><p>miller-rabin 用到的两个基本定理：</p><ul>
<li><p>费马小定理：如果 <span class="math inline">\(n\)</span> 为质数，一定有 <span class="math inline">\(p^n \equiv p (mod \; n)\)</span> ，即 <span class="math inline">\(p^{n-1} \equiv 1\)</span> 。</p></li>
<li><p>二次探测定理：如果 <span class="math inline">\(n\)</span> 为质数，对于 <span class="math inline">\(a^2 \equiv 1 (mod \; n)\)</span> 一定有 <span class="math inline">\(a \equiv -1\)</span> 或 <span class="math inline">\(a \equiv n - 1\)</span> 。</p></li>
</ul><a id="more"></a>





<p>如果 <span class="math inline">\(p^{n-1} \equiv 1\)</span> 不成立，根据费马小定理， <span class="math inline">\(n\)</span> 一定不为质数，<br>
否则令 <span class="math inline">\(x = n - 1\)</span> ，<span class="math inline">\(x\)</span> 一定是偶数，那么可以计算 <span class="math inline">\(y = p^{\frac{x}{2}}\)</span> ，<br>
由于 <span class="math inline">\(p^x \equiv 1\)</span> ，那么根据二次探测定理，如果 <span class="math inline">\(y \equiv 1\)</span> 和 <span class="math inline">\(y \equiv n - 1\)</span> 都不成立，<span class="math inline">\(n\)</span> 一定不为质数。<br>
否则如果 <span class="math inline">\(y \equiv 1\)</span> ，令 <span class="math inline">\(x = \frac{x}{2}\)</span> 继续判断，<br>
直到 <span class="math inline">\(y \equiv n - 1\)</span> 或者 <span class="math inline">\(x\)</span> 为奇数，此时 <span class="math inline">\(n\)</span> 通过了测试，但无法保证 <span class="math inline">\(n\)</span> 是质数还是合数。</p>
<p>如果仅仅通过一次测试就认为 <span class="math inline">\(n\)</span> 是质数的话错误的概率很大，<br>
实践中往往选取多个质数 <span class="math inline">\(p\)</span> 测试多次，全部通过才认为 <span class="math inline">\(n\)</span> 是质数。<br>
实践证明，只要取前 9 个质数，就能准确判断 <span class="math inline">\(10^{18}\)</span> 内的所有数。</p>
<h4 id="实现">实现</h4>
<p>参考实现（经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll x, ll y, ll mod)</span> </span>&#123;</span><br><span class="line">    ll tmp = x * y - ll((<span class="keyword">long</span> <span class="keyword">double</span>)x / mod * y + <span class="number">0.5</span>) * mod;</span><br><span class="line">    <span class="keyword">return</span> tmp &lt; <span class="number">0</span> ? tmp + mod : tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">power</span><span class="params">(ll x, ll k, ll mod)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            res = mul(res, x, mod);</span><br><span class="line">        x = mul(x, x, mod);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller</span><span class="params">(ll n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (power(p, n - <span class="number">1</span>, n) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ll x = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">not</span>(x &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ll y = power(p, x, n);</span><br><span class="line">        <span class="keyword">if</span> (y == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> p[len] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (n == p[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> miller(n, p[i]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化">优化</h4>
<p>事实上 miller-rabin 中进行的多次快速幂是没有必要的。</p>
<p>将 <span class="math inline">\(n\)</span> 表示为 <span class="math inline">\(n=2^s t + 1\)</span> 的形式，其中 <span class="math inline">\(t\)</span> 为奇数，<br>
那么 miller-rabin 中可能用到的所有快速幂，都是 <span class="math inline">\(p^{2^it} (0 \leq i &lt; s)\)</span> 的形式。<br>
原本 <span class="math inline">\(x\)</span> 是从 <span class="math inline">\(2^s t\)</span> 到 <span class="math inline">\(t\)</span> ，考虑倒着进行，<span class="math inline">\(x\)</span> 从 <span class="math inline">\(t\)</span> 到 <span class="math inline">\(2^s t\)</span> ，<br>
这样只需要一次快速幂计算 <span class="math inline">\(y = p^t\)</span> ，每次 <span class="math inline">\(x\)</span> 扩大一倍时将 <span class="math inline">\(y\)</span> 平方即可。</p>
<p>参考实现（经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller</span><span class="params">(ll n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	ll t = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!(t &amp; <span class="number">1</span>)) t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	ll y = power(p, t, n), ny;</span><br><span class="line">	<span class="keyword">while</span>((t &lt;&lt; <span class="number">1</span>) &lt; n) &#123;</span><br><span class="line">		ny = mul(y, y, n);</span><br><span class="line">		<span class="keyword">if</span>(ny == <span class="number">1</span> <span class="keyword">and</span> !(y == <span class="number">1</span> <span class="keyword">or</span> y == n - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		y = ny;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">9</span>, p[len] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) <span class="keyword">if</span>(n == p[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) <span class="keyword">if</span>(!miller(n, p[i])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pollard-rho">pollard-rho</h2>
<p>用于快速找到一个数 <span class="math inline">\(n\)</span> 的一个非平凡因子，常应用于大数的质因数分解。</p>
<p>这玩意大家似乎都是背代码，很难找到关于原理以及复杂度的证明，学习资料很少，如果有误，还请指正。</p>
<h4 id="非平凡因子">非平凡因子</h4>
<p>关于非平凡因子：如果 <span class="math inline">\(d\)</span> 能整除 <span class="math inline">\(n\)</span> 且满足 <span class="math inline">\(1 &lt; d &lt; n\)</span> ，则称 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(n\)</span> 的非平凡因子。</p>
<p>从定义可以看出质数是没有非平凡因子的，事实上质数直接拿来做 pollard-rho 会陷入死循环，<br>
因此 pollard-rho 常常需要配合 miller-rabin 使用，在一个数为质数时停止分解。</p>
<p>因此以下讨论假定 <span class="math inline">\(n\)</span> 是合数。</p>
<h4 id="随机实验">随机实验</h4>
<p>随机一个正整数 <span class="math inline">\(d(d &lt; n)\)</span> ，如果 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(n\)</span> 的因子，那么就找到了 <span class="math inline">\(n\)</span> 的一个非平凡因子 <span class="math inline">\(d\)</span> 。<br>
然而这样的概率很小，最坏情况下是 <span class="math inline">\(\frac{1}{n}\)</span> 的。</p>
<p>随机一个正整数 <span class="math inline">\(v(v &lt; n)\)</span> ，求出 <span class="math inline">\(d = gcd(v, n)\)</span> ，如果 <span class="math inline">\(d &gt; 1\)</span> 那么就找到了 <span class="math inline">\(n\)</span> 的一个非平凡因子 <span class="math inline">\(d\)</span> 。<br>
这样成功的概率就大得多，最坏是 <span class="math inline">\(\frac{1}{\sqrt{n}}\)</span> 的。</p>
<p>证明：<br>
设 <span class="math inline">\(p = minp(n)\)</span> 是合数 <span class="math inline">\(n\)</span> 的最小质因子，那么 <span class="math inline">\(p \leq \sqrt{n}\)</span> ，而 <span class="math inline">\(p\)</span> 的倍数有 <span class="math inline">\(\lfloor\frac{n}{p}\rfloor\)</span> 个，<br>
因此概率的一个下界是 <span class="math inline">\(\frac{1}{p}\)</span> ，这是取到 <span class="math inline">\(p\)</span> 的倍数的概率。<br>
而这个下界是可以达到的，当 <span class="math inline">\(n = p^2\)</span> 且时，概率恰为 <span class="math inline">\(\frac{1}{p}\)</span> ，也就是 <span class="math inline">\(\frac{1}{\sqrt{n}}\)</span> 。</p>
<p>以下讨论中均有 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(n\)</span> 的最小质因子。</p>
<h4 id="生日悖论">生日悖论</h4>
<p>然而这个概率还是很小，期望下需要随机 <span class="math inline">\(O(p)\)</span> 次才能成功（这是个上界）。</p>
<p>根据生日悖论可以提供一个优化思路，<br>
随机 <span class="math inline">\(\sqrt{p}\)</span> 个数 <span class="math inline">\(v\)</span> ，其中有 <span class="math inline">\(\frac{1}{2}\)</span> 的概率存在两个数 <span class="math inline">\(v_1, v_2\)</span> 模 <span class="math inline">\(p\)</span> 同余，<br>
也就是说存在两个数的差是 <span class="math inline">\(p\)</span> 的倍数。<br>
但是如果两两作差与 <span class="math inline">\(n\)</span> 取 gcd ，期望复杂度仍然是 <span class="math inline">\(O(p)\)</span> 的。</p>
<!-- 算上 gcd 的复杂度，可以在期望复杂度 $O(\sqrt{p}logn)$ 的时间找到 $n$ 的一个非平凡因子。  
但事实上可以每次取 $O(\sqrt{p})$ 个数为一组，每次对求一组数的乘积 $k$ ，求 $gcd(n, k)$ 即可。  
而根据 $gcd(x, n) = gcd(x \% n, n)$ ，这个 $k$ 可以是模 $n$ 意义下的。  
这样期望复杂度 $O(\sqrt{p} + logn)$ 。 -->
<h4 id="rho">rho</h4>
<p>pollard-rho 用到了一个特殊的伪随机数列 <span class="math inline">\(\{a\}\)</span> ，对于参数 <span class="math inline">\(c\)</span> ，其满足：</p>
<p><span class="math display">\[ a_{i+1} = (a_i^2 + c) \mod n \]</span></p>
<p>这个数列是个 <span class="math inline">\(\rho\)</span>(rho) 形，这也是 pollard-rho 的名字由来。<br>
换言之，存在链长 <span class="math inline">\(T\)</span> 和环长 <span class="math inline">\(M\)</span> ，满足 <span class="math inline">\(\forall i,k&gt;0: a_{T+i} = a_{T+i+kM}\)</span> 。<br>
如果把 <span class="math inline">\(a\)</span> 两两不同的前缀部分近似看做真随机数列，那么根据生日悖论，这个长度 <span class="math inline">\(T + M\)</span> 是期望 <span class="math inline">\(O(\sqrt{n})\)</span> 的。<br>
也就是说 <span class="math inline">\(T\)</span> 和 <span class="math inline">\(M\)</span> 期望都是在 <span class="math inline">\(O(\sqrt{n})\)</span> 以内的。</p>
<p>令 <span class="math inline">\(b_i = a_i \mod p\)</span> ，当然由于 <span class="math inline">\(p\)</span> 未知，<span class="math inline">\(b\)</span> 这个数列实际上是未知的。<br>
那么同样的道理，<span class="math inline">\(b\)</span> 的链长和环长 <span class="math inline">\(t, m\)</span> 是期望 <span class="math inline">\(O(\sqrt{p})\)</span> 的。</p>
<p>现在要做的是通过对 <span class="math inline">\(a\)</span> 作差来间接对 <span class="math inline">\(b\)</span> 作差，目标是选到两个下标 <span class="math inline">\(i, j\)</span> 满足 <span class="math inline">\(b_i = b_j\)</span> ，<br>
这样的话，<span class="math inline">\(|a_i - a_j|\)</span> 就是 <span class="math inline">\(p\)</span> 的倍数，也就是说 <span class="math inline">\(gcd(n, |a_i - a_j|) \geq p\)</span> 。<br>
关键在于环长，如果只选取下标 <span class="math inline">\((i, 2i)\)</span> 作差，那么当 <span class="math inline">\(i \geq t\)</span> 且 <span class="math inline">\(i=km\)</span> 时，<br>
根据 <span class="math inline">\(b_i = b_{t+(i-t)} = b_{t+(i-t)+km} = b_{t+(i-t)+i} = b_{2i}\)</span> ，<br>
可以确定此时一定有 <span class="math inline">\(b_i = b_{2i}\)</span> ，<br>
而上面提到过 <span class="math inline">\(t, m\)</span> 期望都是 <span class="math inline">\(O(\sqrt{p})\)</span> 的，那么第一个这样的 <span class="math inline">\(i\)</span> 的大小也是期望 <span class="math inline">\(O(\sqrt{p})\)</span> 的。</p>
<p>一个期望复杂度 <span class="math inline">\(O(\sqrt{p})\)</span> 的 pollard-rho 基本思想大抵如此。</p>
<h4 id="实践">实践</h4>
<p>算法流程就是随机一个生成序列的参数 <span class="math inline">\(c\)</span> 。<br>
然后枚举 <span class="math inline">\(i\)</span> ，同时通过递推维护 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{2i}\)</span> ，<br>
当 <span class="math inline">\(gcd(n, |a_i - a_{2i}|) &gt; 1\)</span> 时就得到了一个非平凡因子。<br>
直接做考虑 gcd 期望复杂度 <span class="math inline">\(O(\sqrt{p}logn)\)</span> 。<br>
但这个 gcd 很好优化，设 <span class="math inline">\(v_i = |a_i - a_{2i}|\)</span> ，把 <span class="math inline">\(v\)</span> 相邻 <span class="math inline">\(k\)</span> 个乘起来再和 <span class="math inline">\(n\)</span> 做 gcd ，<br>
根据 <span class="math inline">\(gcd(x, n) = gcd(x \mod n, n)\)</span> ，乘积可以是模 <span class="math inline">\(n\)</span> 意义下的。<br>
理论上只要 <span class="math inline">\(k &gt; O(logn)\)</span> ，复杂度就能做到 <span class="math inline">\(O(\sqrt{p} + k + logn)\)</span> ，<br>
一般认为 <span class="math inline">\(p\)</span> 足够大，此时复杂度就是 <span class="math inline">\(O(\sqrt{p})\)</span> ，最坏情况下就是 <span class="math inline">\(O(n^{\frac{1}{4}})\)</span> 。<br>
实践中往往采用倍增的方式，起初 <span class="math inline">\(k\)</span> 不断成倍增大，增大到 128 时保持不变。<br>
这样可以保证在 <span class="math inline">\(p\)</span> 很小的时候不用算 <span class="math inline">\(logn\)</span> 次就能得到非平凡因子，减小常数。</p>
<p>有一些需要注意的地方：</p>
<ul>
<li><p>有小概率 <span class="math inline">\(M\)</span> 与 <span class="math inline">\(m\)</span> 恰好相等，在 <span class="math inline">\(b_i = b_{2i}\)</span> 的时候恰好有 <span class="math inline">\(a_i = a_{2i}\)</span> ，此时应该更换参数 <span class="math inline">\(c\)</span> 重新进行算法。</p></li>
<li><p>当 <span class="math inline">\(v\)</span> 的乘积模 <span class="math inline">\(n\)</span> 为 0 时需要及时退出，否则算法会返回 <span class="math inline">\(n\)</span> ，而 <span class="math inline">\(n\)</span> 不是 <span class="math inline">\(n\)</span> 的非平凡因子。</p></li>
</ul>
<p>参考实现（经过测试，上接 miller-rabin 的部分）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">nxt</span><span class="params">(ll x, ll c, ll n)</span> </span>&#123;</span><br><span class="line">	ll res = mul(x, x, n) + c;</span><br><span class="line">	<span class="keyword">return</span> res &gt;= n ? res - n : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pollard</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	ll c = <span class="number">1l</span>l * rand() * rand() % n;</span><br><span class="line">	ll a = nxt(rand(), c, n);</span><br><span class="line">	ll a2 = nxt(a, c, n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lim = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(a != a2) &#123;</span><br><span class="line">		ll v = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim <span class="keyword">and</span> a != a2; i ++) &#123;</span><br><span class="line">			ll tov = mul(v, <span class="built_in">std</span>::<span class="built_in">abs</span>(a - a2), n);</span><br><span class="line">			<span class="keyword">if</span>(!tov) <span class="keyword">return</span> <span class="built_in">std</span>::__gcd(v, n);</span><br><span class="line">			v = tov;</span><br><span class="line">			a = nxt(a, c, n);</span><br><span class="line">			a2 = nxt(nxt(a2, c, n), c, n);</span><br><span class="line">		&#125;</span><br><span class="line">		ll d = <span class="built_in">std</span>::__gcd(v, n);</span><br><span class="line">		<span class="keyword">if</span>(d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">		<span class="keyword">if</span>(lim &lt; <span class="number">128</span>) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pollard(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用">应用</h4>
<p>求最小质因数，最大质因数，质因数分解等，<br>
都只需要每次找到 <span class="math inline">\(n\)</span> 的非平凡因子 <span class="math inline">\(d\)</span> 然后不断令 <span class="math inline">\(n\)</span> 除以 <span class="math inline">\(d\)</span> 转换为子问题，<br>
需要注意的是 <span class="math inline">\(d\)</span> 不一定是质数，也要递归处理。<br>
终止条件是 <span class="math inline">\(n\)</span> 为质数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>miller-rabin</tag>
        <tag>pollard-rho</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学玄学操作</title>
    <url>/2020/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%8E%84%E5%AD%A6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>以下公式均不给出证明，目的是为了让结论一目了然。</p><h2 id="组合数相关">组合数相关</h2><p><span class="math display">\[ C_n^m C_m^k = C_n^k C_{n-k}^{m-k} \]</span></p><p>基本递推式 <span class="math display">\[ C_n^m = C_{n-1}^{m-1} + C_{n-1}^m \]</span></p><p>二项式定理 <span class="math display">\[ (a+b)^n = \sum_{i=0}^n C_n^i a^i b^{n-i} \]</span></p><a id="more"></a>




<p><span class="math display">\[ \sum_{i=0}^n (C_n^i)^2 = C_{2n}^n \]</span></p>
<p><span class="math display">\[ C_{n+m}^k = \sum_{i=0}^k C_n^i C_m^{k-i} \]</span></p>
<p>卢卡斯定理（要求 <span class="math inline">\(p\)</span> 是质数） <span class="math display">\[ C_n^m \% p = C_{n/p}^{m/p} C_{n \% p}^{m \% p} \% p \]</span></p>
<h2 id="第一类斯特林数相关">第一类斯特林数相关</h2>
<p><span class="math display">\[ s_n^m = s_{n-1}^{m-1} + (n-1) s_{n-1}^m \]</span></p>
<p><span class="math display">\[ x^{\overline{n}} = \sum_{m} s_n^m x^m \]</span></p>
<h2 id="第二类斯特林数相关">第二类斯特林数相关</h2>
<p><span class="math display">\[ S_n^m = S_{n-1}^{m-1} + m S_{n-1}^m \]</span></p>
<p><span class="math display">\[ n^m = \sum_{k=0}^m S_m^k C_n^k k! \]</span></p>
<p>上式的二项式反演，组合数拆开后可转换为卷积形式 <span class="math display">\[ S_n^m = \frac{1}{m!} \sum_{k=0}^m (-1)^{m-k} C_m^k k^n \]</span></p>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛</title>
    <url>/2020/01/02/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<p>杜教筛一般用于求一类数论函数的前缀和。</p><p>假设要求数论函数 <span class="math inline">\(f(x)\)</span> 的前缀和 <span class="math inline">\(S(n) = \sum_{i=1}^n f(i)\)</span> 。</p><p>杜教筛的关键在于构造两个合适的函数 <span class="math inline">\(g, h\)</span> 满足 <span class="math inline">\(h = f \cdot g\)</span> 。</p><p>这里的函数相乘指的是狄利克雷卷积。</p><h2 id="理论">理论</h2><p>则由 <span class="math inline">\(h = f \cdot g\)</span> 可得（以下除号表示整除）：</p><a id="more"></a>





<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\sum_{i=1}^n h(i) &amp;= \sum_{i=1}^n\sum_{d|i}f(\frac{i}{d})g(d) \\\\
&amp;= \sum_{d=1}^ng(d)\sum_{i=d}^nf(\frac{i}{d})[i|d] \\\\
&amp;= \sum_{d=1}^ng(d)\sum_{i=1}^{n/d}f(i) \\\\
&amp;= \sum_{d=1}^ng(d)S(\frac{n}{d}) \\\\
&amp;= g(1)S(n) + \sum_{d=2}^ng(d)S(\frac{n}{d}) \\\\
\end{aligned}
\end{equation}
\]</span></p>
<p>所以 <span class="math inline">\(S(n) = \sum_{i=1}^n h(i) - \sum_{d=2}^n g(d)S(\frac{n}{d})\)</span> 。</p>
<p>前提是每个 <span class="math inline">\(\sum_{i=1}^n h(i)\)</span> 很容易求，那么接下来不考虑 <span class="math inline">\(h\)</span> ，<br>
对于后面的部分可以整除分块，还需要快速求出 <span class="math inline">\(g\)</span> 的一段区间和，<br>
然后就可以递推，由于形如 <span class="math inline">\(\lfloor\frac{n}{d}\rfloor\)</span> 的数只有 <span class="math inline">\(O(\sqrt{n})\)</span> 个，<br>
可以只递推这 <span class="math inline">\(O(\sqrt{n})\)</span> 个 <span class="math inline">\(S\)</span> ，不考虑 <span class="math inline">\(g, h\)</span> 的计算复杂度，复杂度为 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 。</p>
<p>update: 根据 16 年的集训队论文，直接计算的复杂度是 <span class="math inline">\(O(n^{\frac{3}{4}})\)</span> ，<br>
要保证复杂度的话需要线性筛预处理 <span class="math inline">\(n^{\frac{2}{3}}\)</span> 以内的 <span class="math inline">\(S\)</span> 。<br>
证明后面有提到。</p>
<p>关于如何存储 <span class="math inline">\(S\)</span> ，直接用数组存需要 <span class="math inline">\(O(n)\)</span> 的空间，开 map 每次取用带一个 log ，<br>
普通的离散化也会带一个 log 。</p>
<p>观察 <span class="math inline">\(\frac{n}{d}\)</span> 的分布，当 <span class="math inline">\(d \leq \sqrt{n}\)</span> 时， <span class="math inline">\(\frac{n}{d}\)</span> 的值两两不同。<br>
而当 <span class="math inline">\(d &gt; \sqrt{n}\)</span> 时， <span class="math inline">\(\frac{n}{d}\)</span> 的值都不超过 <span class="math inline">\(\sqrt{n}\)</span> 。<br>
设 <span class="math inline">\(m\)</span> 是 <span class="math inline">\(\frac{n}{d}\)</span> 的不同取值个数，那么可以用如下的函数对 <span class="math inline">\(x = \frac{n}{d}\)</span> 进行离散化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt;= sqrt_of_n ? x : m - (n / x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实践">实践</h2>
<p>举个简单的栗子：求 <span class="math inline">\(\mu\)</span> 的前缀和。</p>
<p>首先根据 <span class="math inline">\(\mu\)</span> 的性质不难想到 <span class="math inline">\(\mu \cdot I = \epsilon\)</span> 。</p>
<p>那么就将 <span class="math inline">\(f = \mu, g = I, h = \epsilon\)</span> 代入上去，得到：</p>
<p><span class="math display">\[S(n) = \sum_{i=1}^n \mu(i) = \sum_{i=1}^n \epsilon(i) - \sum_{d=2}^n I(d) \cdot S(\frac{n}{d})\]</span></p>
<p>即</p>
<p><span class="math display">\[S(n) = 1 - \sum_{d=2}^n S(\frac{n}{d})\]</span></p>
<h2 id="扩展">扩展</h2>
<p>但有时候无法构造合适的 <span class="math inline">\(h = f \cdot g\)</span> 使得 <span class="math inline">\(g, h\)</span> 的前缀和可以 <span class="math inline">\(O(1)\)</span> 算出。<br>
这时候杜教筛是否就毫无用武之地呢？不见得。</p>
<p>观察递推式，利用整除分块，设 <span class="math inline">\(S_f, S_g, S_h\)</span> 分别表示 <span class="math inline">\(f, g, h\)</span> 的前缀和，那么：</p>
<p><span class="math display">\[S_f(n) = S_h(n) - \sum_{i=2}^m (S_g(r_i) - S_g(r_{i-1})) S_f(\frac{n}{r_i})\]</span></p>
<p>其中 <span class="math inline">\(m\)</span> 是 <span class="math inline">\(\frac{n}{d}\)</span> 的不同取值个数， <span class="math inline">\(r_i\)</span> 是整除分块后对应第 <span class="math inline">\(i\)</span> 块的右端点。</p>
<p>首先不难发现需要用到的 <span class="math inline">\(S_h\)</span> 也都是形如 <span class="math inline">\(\frac{n}{d}\)</span> 的数，<br>
那么只需要如果 <span class="math inline">\(S_h\)</span> 能够杜教筛（或者其他筛）筛出来就行了。</p>
<p>再考虑 <span class="math inline">\(S_g\)</span> 需要的取值，由整除分块中的 <span class="math inline">\(r = n / (n / l)\)</span> 可知，<span class="math inline">\(r_i\)</span> 的取值也都是形如 <span class="math inline">\(\frac{n}{d}\)</span> 的数，<br>
同理只要能筛 <span class="math inline">\(S_g\)</span> 就行了，不一定要 <span class="math inline">\(O(1)\)</span> 算。</p>
<h2 id="复杂度">复杂度</h2>
<p>发现之前对杜教筛的复杂度理解有问题。</p>
<p>假设已经预处理（或者可以 <span class="math inline">\(O(1)\)</span> 计算）需要的 <span class="math inline">\(S_g, S_h\)</span> ，<br>
那么需要计算的 <span class="math inline">\(S(\frac{n}{d})\)</span> 有 <span class="math inline">\(O(\sqrt{n})\)</span> 个。<br>
将他们分为两类：</p>
<ol type="1">
<li><span class="math inline">\(d \leq \sqrt{n}\)</span>: 这部分有 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
<li><span class="math inline">\(d \geq \sqrt{n}, \frac{n}{d} \leq \sqrt{n}\)</span>: 这部分同样有 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
</ol>
<p>计算单个 <span class="math inline">\(S(x)\)</span> 需要枚举 <span class="math inline">\(\frac{x}{d}\)</span> ，复杂度为 <span class="math inline">\(O(\sqrt{x})\)</span> 。</p>
<p>对于两部分分别计算复杂度，总复杂度就是：</p>
<p><span class="math display">\[ \sum_{i=1}^{\sqrt{n}} O(\sqrt{i}) + \sum_{i=1}^{\sqrt{n}} O(\sqrt{\frac{n}{i}}) \]</span></p>
<p>对于前者：</p>
<p><span class="math display">\[ \sum_{i=1}^{\sqrt{n}} O(\sqrt{i}) = O(\int_{0}^{\sqrt{n}}\sqrt{x}dx) = O(n^{\frac{3}{4}}) \]</span></p>
<p>对于后者：</p>
<p><span class="math display">\[ \sum_{i=1}^{\sqrt{n}} O(\sqrt{\frac{n}{i}}) = O(\int_{0}^{\sqrt{n}}\sqrt{\frac{n}{x}}dx) = O(n^{\frac{3}{4}}) \]</span></p>
<p>如果预处理 <span class="math inline">\(k\)</span> 以内的 <span class="math inline">\(S\)</span> 且 <span class="math inline">\(k \geq \sqrt{n}\)</span> ，预处理部分复杂度为 <span class="math inline">\(O(k)\)</span> ，杜教筛部分前者也可以被预处理。</p>
<p>对于后者：</p>
<p><span class="math display">\[ \sum_{i=1}^{\frac{n}{k}} O(\sqrt{\frac{n}{i}}) = O(\int_{0}^{\frac{n}{k}}\sqrt{\frac{n}{x}}dx) = O(\frac{n}{\sqrt{k}}) \]</span></p>
<p>当 <span class="math inline">\(k = \frac{n}{\sqrt{k}}\)</span> 时，总复杂度达到最优，<br>
此时 <span class="math inline">\(k = n^{\frac{2}{3}}\)</span> ，总复杂度 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值法</title>
    <url>/2019/12/27/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    <content><![CDATA[<p>这里只介绍关于多项式的拉格朗日插值法，对于一般函数的拟合当做一个多项式就好了。</p><h2 id="插点值">插点值</h2><p>已知多项式 <span class="math inline">\(f(x)\)</span> 的 <span class="math inline">\(n\)</span> 个点值 <span class="math inline">\((x_i, y_i = f(x_i))\)</span> ，求 <span class="math inline">\(f(k)\)</span> 。</p><p>拉格朗日插值法的思路在于： 对于每个 <span class="math inline">\((x_i, y_i)\)</span> 找到 <span class="math inline">\(L_i(x)\)</span> 使得 <span class="math inline">\(L_i(x_i) = y_i, L_i(x_j) = 0\)</span> ， 其中 <span class="math inline">\(x_j\)</span> 是已知的 <span class="math inline">\(x\)</span> 中任意一个不等于 <span class="math inline">\(x_i\)</span> 的 <span class="math inline">\(x\)</span> 。</p><a id="more"></a>



<p>而由 <span class="math inline">\(L\)</span> 的定义可知，<span class="math inline">\(f(k) = \sum_{i=1}^n L_i(k)\)</span> 。<br>
代入上式即可求解。</p>
<p>现在问题在于构造 <span class="math inline">\(L\)</span> 。 下面的 <span class="math inline">\(L\)</span> 可以满足定义：</p>
<p><span class="math display">\[ L_i(x) = y_i \cdot \prod\limits_{j \ne i}\frac{x_j-x}{x_j-x_i} \]</span></p>
<p>代入可得这对于任意 <span class="math inline">\(x_i\)</span> 可以使得 <span class="math inline">\(L_i(x_i) = y_i, L_i(x_j) = 0\)</span></p>
<p>复杂度 $ O(n^2) $ 。</p>
<h2 id="插系数">插系数</h2>
<p>已知多项式 <span class="math inline">\(f(x)\)</span> 的 <span class="math inline">\(n\)</span> 个点值，求 <span class="math inline">\(f(x)\)</span> 的第 <span class="math inline">\(k\)</span> 次项系数 。</p>
<p>先考虑插出一项 <span class="math inline">\(x^k\)</span> 的系数。</p>
<p>首先依次考虑每个 <span class="math inline">\(L_i(x)\)</span> 的 <span class="math inline">\(x^k\)</span> 系数，最后累加即可。</p>
<p>注意到分母和 <span class="math inline">\(y_i\)</span> 是常数可以直接算，考虑提出来，</p>
<p><span class="math display">\[ L_i(x) = (y_i \cdot \prod\limits_{j \ne i}\frac{1}{x_j-x_i})
    (\prod\limits_{j \ne i} (x_j - x)) \]</span></p>
<p>左边的常数是一堆逆元相乘再乘上 <span class="math inline">\(y_i\)</span> ，逆元往往不是 <span class="math inline">\(O(1)\)</span> 计算的，<br>
事实上可以先把分母中所有 <span class="math inline">\(x-x_j\)</span> 乘起来再一起求逆元，这样就只需要计算 1 次逆元，此时一般可以忽略逆元对复杂度的影响。</p>
<p>那么只需要算分子部分，即上式右边的 <span class="math inline">\(\prod\)</span> 的 <span class="math inline">\(x^k\)</span> 系数即可。</p>
<p>假设把这个连乘暴力拆开，其实 <span class="math inline">\(x^k\)</span> 的系数就是在之中选 <span class="math inline">\(n - k - 1\)</span> 个常数。<br>
DP 预处理 <span class="math inline">\(pre(i, k)\)</span> 表示在 <span class="math inline">\(\prod\limits_{j \leq i} (x - x_j)\)</span> 中选 k 个常数的系数和，<br>
同理 <span class="math inline">\(suf(i, k)\)</span> 表示在 <span class="math inline">\(\prod\limits_{j \geq i} (x - x_j)\)</span> 中选 k 个常数的系数和。<br>
那么枚举 <span class="math inline">\(p + q = n - k - 1\)</span> 求 <span class="math inline">\(pre(i - 1, p)\)</span> 乘 <span class="math inline">\(suf(i + 1, q)\)</span> 的和就是上式的 <span class="math inline">\(x^k\)</span> 系数了。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>参考实现（未经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插出 L_i(x) 的 x^k 系数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">la</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">		<span class="keyword">if</span>(i != j)</span><br><span class="line">			A *= X[i] - X[j];</span><br><span class="line">	<span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= n - k - <span class="number">1</span>; l ++)</span><br><span class="line">		B += pre[i - <span class="number">1</span>][l] * suf[i + <span class="number">1</span>][n - k - <span class="number">1</span> - l];</span><br><span class="line">	<span class="keyword">return</span> B / A * X[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 suf 和 pre */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		pre[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">			pre[i][j] = pre[i - <span class="number">1</span>][j] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i; i --) &#123;</span><br><span class="line">		suf[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i + <span class="number">1</span>; j ++)</span><br><span class="line">			suf[i][j] = suf[i + <span class="number">1</span>][j] - suf[i + <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插多项式">插多项式</h2>
<p>已知 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(f(x)\)</span> 的 <span class="math inline">\(n\)</span> 个点值，求 <span class="math inline">\(f(x)\)</span> 的所有系数 。</p>
<p>直接将所有暴力多项式相乘计算所有 <span class="math inline">\(L_i(x)\)</span> ，或者使用 <span class="math inline">\(n\)</span> 次上述的插系数，复杂度 <span class="math inline">\(O(n^3)\)</span> ，难以接受。</p>
<p>点值比较特殊的情况下可以使用 FFT 或者 NTT ，但有失一般性。</p>
<p>沿用上述分离常数的方法，考虑 <span class="math inline">\(O(n)\)</span> 求出每个 <span class="math inline">\(L_i(x)\)</span> 的所有系数：</p>
<p><span class="math display">\[ L_i(x) = (y_i \cdot \prod\limits_{j \ne i}\frac{1}{x_j-x_i})
    (\prod\limits_{j \ne i} (x_j - x)) \]</span></p>
<p>左边的常数还是同样地处理，不同的是对于右边的多项式现在要求的不是某一项的系数而是所有系数。</p>
<p>对于右边的多项式部分，可以看做：</p>
<p><span class="math display">\[ \frac{\prod_{j=1}^n (x_j - x)}{x_i - x} \]</span></p>
<p>其分子是个与 <span class="math inline">\(i\)</span> 无关的多项式，可以 <span class="math inline">\(O(n^2)\)</span> 暴力预处理，而其分母是个简单的一次二项式。<br>
那么可以用短除法来进行多项式除二项式，复杂度 <span class="math inline">\(O(n)\)</span> 。</p>
<p>总时间复杂度为 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>参考实现（未经过测试）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">la</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	tmp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// tmp 表示 n 个二项式相乘的多项式</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		tmp[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j; j --)</span><br><span class="line">			tmp[j] = tmp[j - <span class="number">1</span>] - X[i] * tmp[j];</span><br><span class="line">		tmp[<span class="number">0</span>] *= - X[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		ll A = <span class="number">1</span>; <span class="comment">// A 表示 L_i 的常数部分</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">			<span class="keyword">if</span>(i != j)</span><br><span class="line">				A *= X[i] - X[j];</span><br><span class="line">		A = Y[i] / A;</span><br><span class="line"></span><br><span class="line">		tmp2[n] = tmp[n]; <span class="comment">// tmp2 表示将 tmp 除以一个二项式的结果</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = n; j; j --) &#123;</span><br><span class="line">			ll t = tmp2[j];</span><br><span class="line">			get[j - <span class="number">1</span>] += t * A; <span class="comment">// get 表示 f(x) 的系数</span></span><br><span class="line">			tmp2[j - <span class="number">1</span>] = tmp[j - <span class="number">1</span>] + t * X[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此时应有 tmp2[0] = 0 ，否则说明除法有余数</span></span><br><span class="line">		assert(tmp2[<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>THUWC2020</title>
    <url>/2019/12/06/THUWC2020/</url>
    <content><![CDATA[<h2 id="day--inf-12.06">Day -inf (12.06)</h2><p>thuwc 的报名网站反应是真的慢，中午特意请假去机房填表，结果被这反应速度折服了，一中午还没填完。<br>
好事是，借着这个，我得以手动翘掉了下午的语文课，又跑去机房填表，<br>
网站太慢了，就趁着加载的间隙打了一道题，边听歌边填表边打题，十分舒适。<br>
然后实在是太慢了一节语文课还是不够，算上盖章一不小心把物理课也翘了一半，回来的时候正好全班人围在门口看老师做实验。<br>
目测今年分数线不高，就迷之自信地在 12.06 这个时候就开坑写游记了。</p><a id="more"></a>

<h2 id="day--1-12.19">Day -1 (12.19)</h2>
<p>上午突然搞模拟面试？</p>
<p>有点懵逼，随便准备了一下自我介绍，还是中英双份的。</p>
<p>英语面试简直全程懵逼，问的问题基本都是这样回答的：</p>
<p>Q: blablablabla ? A: emm...emm.. （沉默） maybe...emm...</p>
<p>然后被要求读短文，发现好多词不认识，就瞎读，好不容易读完了，突然问我：<br>
这篇文章讲了什么？<br>
卧槽我刚才一直在纠结这个单词那个单词怎么读压根就没有去看文章本身啊。<br>
然后 emm 了一下，就默默低下头又看了一遍。。。</p>
<h2 id="day-0-12.20">Day 0 (12.20)</h2>
<p>提前一天来到北京，说起来这是第 3 次了。</p>
<p>下午先去了 PKU 转了转（PKUWC 的同学今天下午报到），见到了学长，然后就回到宾馆快乐颓废。<br>
事实上并不是宾馆，西郊宾馆早没地了，住的是公寓楼。<br>
租了两个套间，一开始为了不与教练住分组猜拳，最后 3 个人跟教练住，4 个人跟家长住。<br>
我就是那 3 个人中的一个。<br>
但是超级奈斯啊，最后教练压根就不住这，这里 3 人住 3 个房间，另外一边 5 人住 3 房间。<br>
颓到 11:30 左右就睡了。</p>
<h2 id="day-1-12.21">Day 1 (12.21)</h2>
<p>报到，发了一个紫色的包（为啥 THU 如此钟情于紫色？）。</p>
<p>下午一试，汉堡没 ACM 的好吃，差评。</p>
<p>T1 是个签到题，对于每个维度离散化一下用个扫描线 + 树状数组就差不多了，1h 做了，</p>
<p>T2 不会，打暴力。</p>
<ul>
<li><span class="math inline">\(q \cdot s = 10^7\)</span> 以及 <span class="math inline">\(m \cdot w = 10^7\)</span> 意味着跳的次数是十分有限的，直接模拟就好了。 (16')</li>
<li>数据随机我不知道意味着什么，但是我的暴力莫名其妙就过了 pretest 。 (8')</li>
<li><span class="math inline">\(w=10^{18}\)</span> 意味着边永远不会断，直接倍增维护每个点走 <span class="math inline">\(2^k\)</span> 步后的点即可。 (12')</li>
<li><span class="math inline">\(m=n-1\)</span> 是颗根向树，只会往根上跳，树剖+线段树维护边权，当前重链无法跳到顶的时候倍增或者二分来确定跳的位置。 (13')</li>
</ul>
<p>T3 一开始看到题目名“某科学的动态仙人掌”就懵逼了，还好是标题党，可是还是不会，打暴力。</p>
<ul>
<li><span class="math inline">\(n, m, x\)</span> 极小的直接暴力搜。 (4')</li>
<li><span class="math inline">\(x=n-1\)</span> 说明任意两个点都是可以相连的，输出 1 。 (4')</li>
<li><span class="math inline">\(x=1\)</span> 的话就是计算联通块数量，大概离线下来然后扫描线+树状数组可做，但是没时间写。 (0')</li>
<li>树退化为链的情况我搞了一个莫队，复杂度 <span class="math inline">\(O(n\sqrt{n}logn)\)</span> ，跑极限数据 7s+ ，时限 6s ， 本来链是有 16' 的，但是实在卡不过，最后只过了 <span class="math inline">\(l=1\)</span> 的那一档，此时莫队复杂度为 <span class="math inline">\(O(nlogn)\)</span> 。 (4')</li>
</ul>
<p>pretest 100 + 49 + 20 = 169.</p>
<p>晚上快乐颓废，1 点才睡。</p>
<h2 id="day2-12.22">Day2 (12.22)</h2>
<h3 id="上">上</h3>
<p>上午二试。</p>
<p>T1 不会正解，打暴力。</p>
<ul>
<li><span class="math inline">\(n=10\)</span> 的直接阶乘爆搜。 (13')</li>
<li><span class="math inline">\(c=0\)</span> 以及 <span class="math inline">\(a=0\)</span> 的都可以状压集合中可以得到的最权值和最大值来求最后的答案。</li>
<li><span class="math inline">\(a=0\)</span> 时在确定顺序的前提下最后答案是关于 s 的一次函数，没有分段，因此 s 始终只需保留两个最值。 (19')</li>
<li><span class="math inline">\(c=0\)</span> 时最优决策只与 s 的绝对值有关，考场上我似乎是晓得为什么只需要保留最值的，但现在忘了。 (23')</li>
<li>正解不会，但是不知道为什么上面的状压做法能过所有 pretest 。 (45')</li>
</ul>
<p>T2 不会，打暴力。</p>
<ul>
<li><span class="math inline">\(n, q, m=10^3\)</span> 的直接暴力搜。 (20')</li>
<li><span class="math inline">\(m=n\)</span> 说明非树边是唯一的，询问只需要对这条唯一的非树边分类讨论来确定它带来的影响即可，没有非树边之间的相互影响。 (11')</li>
</ul>
<p>T3 推了好久，想了好几个假做法，然而还是只能打暴力。</p>
<ul>
<li><span class="math inline">\(k=0\)</span> 说明根本就不进行排序，直接输出 1 。 (1')</li>
<li><span class="math inline">\(n=10\)</span> 的直接阶乘枚举所有可能长度的所有全排列，然后用康拓展开把排列 hash 一下，处理出所有排列的答案即可。 (4'+3')</li>
</ul>
<p>pretest 100 + 31 + 8 = 139.</p>
<p>鉴于昨晚睡得太晚，本来打算下午补觉的。<br>
真香，饥荒真好玩。</p>
<h3 id="下">下</h3>
<p>晚上三试，学习题，身败名裂。</p>
<p>这次是要简单地模拟 Cache 的底层工作。</p>
<p>我 (wo) 带 (diao) 你 (ni) 们 (ma) 打 (de)。</p>
<p>学习手册看得我一脸懵逼，看了整整 1 个小时才大概看懂意思，到这时候还没开始打代码。</p>
<p>然后看 T1 直接就是 Cache 一致性协议，出现在学习手册的最后一页，好像还综合了只读、替换、读写一堆乱七八糟的。<br>
最骚的是不久后管理发了通知：</p>
<!-- ![通知](/images/thuwc.png) -->
<p>（数据已删除）</p>
<blockquote>
<h1 id="提示">提示</h1>
<p>请选手注意，题目顺序与作答难度并没有直接联系。</p>
<p>此外，请任何对第一题有疑问的选手认真阅读和理解学习手册。我们保证手册中对于状态转移的描述是正确的，涉及了<strong>所有可能</strong>的情况。</p>
</blockquote>
<p>这是暗示啊！这直接让我以为 T1 是最难的，果断弃掉，开始码 T2 。</p>
<p>码了前面 6 个子任务，把实现逻辑优化了一下，同样的逻辑用同样的调用，<br>
只有不同的逻辑（也就是使用的替换算法 R ）用 6 个不同的函数，<br>
框架打完后写起来就贼方便，敲完了 6 个子任务后就先弃了第 7 个去肝交互了。</p>
<p>T3 交互直接在 T2 的框架上魔改，然后 6 个函数加个参数照样用，过了两个样例然而不停 WA 。<br>
真的自闭了，后面一直在 debug 查错，肝到最后 5min 深感绝望，此时我还只有 T2 的 40' ，<br>
大概是凉了吧。</p>
<p>好在最后 3min 的时候通过静态差错发现魔改的时候漏了一个地方，T2 是没有 index 的，默认都是 0 ，<br>
而在 R = 1 的最简单的那个子任务上 index 仍然默认是 0 没有改过来，哇塞这 B 玩意害死我了，改成 index 后就成功过了 pretest 。</p>
<p>最后 pretest 40 + 32 = 72 。<br>
考完后一问，好像大家都 100+ ，高如韬神 150+ ，低如 master 都有 90+ （一脸不屑）。<br>
究其原因，是因为大家都只花了 1h 不到打了 T1 的 40' 。。。</p>
<p>好吧，我自闭了，整个 thuwc 就栽在这场学习题上了。</p>
<p>晚上快乐颓废，想着明天不考试，颓到了 1:30 ，饥荒真好玩，然而我活个 18d 就因为各种奇奇怪怪的东西狗带了。</p>
<h2 id="day3-12.24">Day3 (12.24)</h2>
<p>早上 6:40 就被家长的电话吵醒，说我进面试了，赶紧起来收拾行李直接去西郊宾馆。</p>
<p>我擦？我才睡 5h 诶？</p>
<p>没办法，昨晚的咖啡还没喝完，一口闷了下去，收拾收拾就出发了。</p>
<p>面试人好多啊，目测 100+ ，数座位就有 150 左右。</p>
<p>面试，自我介绍先理性自吹一波，感觉说自己的竞赛成绩太千篇一律了，比我强的人多了去了，<br>
于是我就有很大一部分讲了自己的辉煌的小程序历史，诸如 yzzl, pychat, retest ，还有折腾的 keoj, keblog 等等。<br>
还提到到了 tuna 。<br>
然后面试基本就是针对自我介绍问的，一开始问我文化课成绩，然后就问我写的小程序最满意的是哪一个，<br>
<del>都挺满意的</del>这时候不能犹豫，抱着情怀我说了 yzzl ，然后对于 yzzl 的整个游戏规划，<br>
包括已经实现的和有想法实现但是咕咕咕的侃侃而谈。<br>
然后有问我有没有 tuna 的线下活动，emm 我一草民只是平时用用镜像水水帖子刷刷聊天室，那谈得上线下活动？</p>
<p>最后还问我对于昨天学习题的看法。</p>
<p>这个我有话说！我可以说上一整天！<br>
时间少，题目多，分数设置得极其不合理。<br>
学习资料写得真是牛皮，尤其是给的那三张示意图我的天啊没有任何解释你还指望那这三张几乎一毛一样图来描述 cache 与主存的关系，<br>
这图让我误解一脸懵逼，本来对 index, tag, offset 的解释就是一句话带过，<br>
在图上就更迷了，直接就是 [x:y:z] 下面一排 tag, index, offset ，<br>
尤其是 offset 这个东西我至始至终不知道是个啥，盲猜是个可以忽略的东西，<br>
可以它又特么出现在输入数据中，占了两个二进制位啊你要我怎么办，<br>
我又只能通过盲猜输入的地址中保证 offset=0 并且找到学习手册的一句话“保证给出的地址已经对齐”来解释这个猜想。 等等等等。。。<br>
死在这上面真的让人非常不服气。</p>
<p>所以我最后的回答是：</p>
<p><strong>我觉得设置的很好，很考验选手的理解能力和实现能力。</strong></p>
<p>:joy:</p>
<p>最后阅读英语短文，还是懵逼，硬着头皮乱念。</p>
<p>颁奖，二等奖。<br>
<!--
然而这个奖严重缩水，进了面试的 100 来号人都有奖，没进的也有一部分有奖，目测一共发了 200 个左右，  
据我所知一等奖至少有 50 来个，按以往的标准来算，一等约似乎是无条件降一本的。  
我真是服了，现在我真的感觉我拿回去一张废纸，  
现在不是签约了，给你发奖大面积圈人，你要这个奖还是得向 tp 做出保证，  
然而 tp 并不会对你做出任何保证，只是发给你一张纸，上面半句没提到你会得到怎样的优惠政策。  
妙啊。
--> （数据已删除）</p>
<p>晚上回去，订 11 点多的机票不知道是怎么想的，到了凌晨 1 点多才到长沙，<br>
一个人回到寝室，大家都已经睡了，默默放下行李箱和背包，小心翼翼地走到床上，盖好被子，舒一口气。<br>
结束了。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>THU</tag>
        <tag>WC2020</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP2019</title>
    <url>/2019/11/17/CSP2019/</url>
    <content><![CDATA[<h2 id="day1">Day1</h2><p>体验极差，真的就是极差，做梦都没想到 Day1 竟然是这样的。</p><p>开考花 30min 交完前面两题，看看时间还剩 3h 。<br>
我觉得换谁在这个处境都会觉得稳得一批，我有三个小时你 Day1T3 能秒我？<br>
我时间都规划好了，花 2h 肝 T3 ，拿 1h 对拍测试检查细节。</p><ul>
<li>30min 后：我有一个贪心想法，似乎有理有据</li>
<li>1h 后：终于打完了，过了样例，nice 稳了，测测大样例， woc 怎么全 WA 了</li>
<li>1.5h 后：（写暴力造数据对拍）妈呀贪心假了，这个只需要怎么怎么随便就卡掉了，这也能过样例</li>
<li>2h 后：只剩一个小时了，我要不要写一写链和菊花的暴力啊？算了前面两题应该不会挂，继续肝</li>
<li>2.5h 后：（濒临崩溃）我一道联赛题只会 10 分怕不是不要混了，算了还是写暴力吧</li>
<li>考试结束 3min 前：（自闭）我 !@#@!%$!@%@@ 暴力怎么这么难打？链的数据怎么死循环啊</li>
</ul><a id="more"></a>



<p>考完还听别人说 T1 卡 long long ，我靠，凉凉。<br>
（话说回来考试前一天晚上我还在 OI-Wiki 上偶然翻到了格雷码，看着好复杂心想这玩意学了肯定没用就没看了）</p>
<h2 id="day2">Day2</h2>
<p>发现 Day1 普遍不会 T3 后心态稍微好了点，但是 T1 挂了还是影响很大的。</p>
<p>想着今天稳健一点，然后真就安心打了三题暴力。。。<br>
（其实是因为开场看了 30min 题意识到自己一题都不会做）</p>
<p>T1 看着就是要枚举超过一半的菜去容斥，而超过一半的菜最多只会同时有一个，用 dp 是很好处理的，<br>
写了个 <span class="math inline">\(O(n^3m)\)</span> 的 dp 交了，看着有 84 分，觉得先往后做比较妥，就没管了。<br>
（后来听说那个 dp 稍微对状态做个小优化就是 <span class="math inline">\(O(n^2m)\)</span> 的了。。）</p>
<p>T2 看着就是个 <span class="math inline">\(O(n^3)\)</span> 的大暴力 dp ，诶不行 36 分不太够啊，然后猜想 + 打表发现 dp 的决策点单调，<br>
然后这怎么优化到 <span class="math inline">\(O(n^2)\)</span> ？不会，只晓得搞分治 dp ，好像带一个不满的 log ，实测大数据 1.0 s 。<br>
（听别人说根据单调性可以直接优化到 <span class="math inline">\(O(n^2)\)</span> ？不懂，告辞）</p>
<p>T3 看着就是个枚举断边暴力算重心，想着今天的目标定为打满暴力算了，<br>
然后就认认真真地打了链的部分分（链上的重心可以 <span class="math inline">\(O(1)\)</span> 计算）和完全二叉树的部分分（本质不同的断边只有 <span class="math inline">\(O(logn)\)</span> 个）。<br>
前所未有地耐心打暴力，不知道怎么坚持下来的，可能是终于认识到自己实力弱菜吧。</p>
<h2 id="end">End</h2>
<p>12.01</p>
<p>两周没碰电脑了，今天补补总结。</p>
<p>洛谷自测 438 ，D1T3 水了 35 分。<br>
到牛客上就只有 408 了。</p>
<p>csp 数据还算良心吧，D1T1 没有太丧心病狂（像洛谷牛客那样没写 unsigned 就被卡二三十分是真的想死），<br>
只放在最后一个点卡了 5 分，这被卡了也服气，可以接受，权当买了个教训。<br>
但数据强度还是有的，D2T2 搞分治还是被卡了一个点 4 分（然而如果开 O2 就过了），也行，技不如人甘拜下风。<br>
最后的成绩拿官方数据自测就是 424 了，比去年高了一点点，没长进啊。</p>
<p>那么接下来就是冬令营了，坐标新华都，母校再会。</p>
<p><del>话说没进冬令营岂不身败名裂</del></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>csp</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-14</title>
    <url>/2019/11/08/cometoj-14/</url>
    <content><![CDATA[<p>万年卡 E 题系列。</p><p>这次 A 竟然不是字符串，<del>开始我已经准备了字符串的输入输出等一堆东西结果发现没卵用</del><br>
花 1min49 AC ，好像在这之前已经有 12 个人 A 了。</p><p>B 第一眼看上去是个 DP ，再看一眼（看成最小值最大）以为是二分，发现是让最大值最大而且还只有三个段后。。。<br>
<strong>大力分类讨论</strong>！<br>
果然是个分类讨论就巨多细节，判无解判边界判大小 blabla ，结果交 WA 了两发，在 16min AC 。<br>
（ B 最快的 6min 就 A 了，16min 这时候 C 的一血都被拿了的说）</p><a id="more"></a>


<p>C 维护一个序列？结果每次需要把所有序列复制一份并对复制的那一部分进行修改？<br>
一脸懵逼.jpg<br>
（然而水群的时候大佬们都说这题怎么怎么显然，和什么什么题一模一样）<br>
还好看清楚了数据范围只有 2000 ，就去想单独考虑序列上每个点，这样就很好维护，<br>
一个点每次复制就是权值翻倍，复制的位置被修改就是权值加上 修改值 乘 序列数量。<br>
好像花了和 B 差不多的时间，在 33min AC 。</p>
<p>D 题感觉很神，乍一看什么可追溯化数据结构，可一想哪有对线段树可追溯化的，还是追溯一段操作区间。<br>
然后就感觉很不可做，但<del>看了 E 发现是个图论更不可做</del>还是头铁硬肝。<br>
发现区间覆盖的性质还是很优秀的，然后 yy 了一个扫描线 + set + 树状数组的做法，<br>
树状数组维护每个操作对当前扫描线上的询问的影响，<br>
然后 set 维护一个蛇皮东西，扫描线扫过的操作执行后的区间覆盖长什么样子，<br>
每次区间覆盖就可以直接在 set 上 lower_bound 到位置再换掉旧的覆盖。<br>
（后来听人讲这就是 odt 。。。）</p>
<p>在 81min 打完过了样例，仔细检查了检查，一交，WA 了。<br>
懵逼，静态差错无果，对拍无果，查了半个小时，实在没发现什么错，<br>
还以为我题目读错了，读了四五遍题感觉实在是没有什么坑，<br>
抱着自闭的心态再交了一发， woc AC 了。<br>
一脸懵逼.jpg<br>
我感觉我什么地方都没改啊怎么突然从 WA 到 AC 啊！！！</p>
<p>比完后查了查，发现是这样一句话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d\n"</span>, i);</span><br><span class="line"><span class="comment">// 等价于 std::cerr &lt;&lt; i &lt;&lt; std::endl;</span></span><br></pre></td></tr></table></figure>
<p>神 tm 我输出到标准错误流竟然就 WA 了？！<br>
后面还 test 了一波，发现在 cometoj 上只要有标准错误流就会 WA/RE 。<br>
引以为戒，祭奠为此逝去的半个小时。</p>
<p>最后就在整个后半场卡 E 了，回头看了看每场 cometoj 常规赛都卡 E ，能 A 掉 ABCD ，<br>
发现唯一一次拿到奖是因为那次只有 8 个人 A 掉了 D 。。</p>
<p><del>写总结好累啊，以后打比赛就不写了吧。。</del></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/2019/11/05/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>relearn 了一遍 exCRT ，发现之前学的可能是假的（这种情况出现不止一次了 233 ）。</p><p>简单来说，中国剩余定理（以下简称 CRT ）主要用于解线性同余方程组：</p><p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
x \equiv a_1 \pmod{m_1} \\\\
x \equiv a_2 \pmod{m_2} \\\\
... \\\\
x \equiv a_n \pmod{m_n} \\\\
\end{aligned}
\right.
\end{equation}
\]</span></p><a id="more"></a>


<h2 id="crt">CRT</h2>
<p>普通的 CRT 用于解决模数两两互质的情况（这个条件比较苛刻，实践中往往需要 exCRT ）。</p>
<p>CRT 的主要思想是构造，对于每个方程组构造一个 <span class="math inline">\(b_i\)</span> 使得 <span class="math inline">\(b_i\)</span> 在其他所有模数下为 0 ，仅在模 <span class="math inline">\(m_i\)</span> 意义下为 1 。<br>
感觉这个构造思路有点想拉格朗日插值法，那么不难得出：</p>
<p><span class="math display">\[ b_i = \prod_{i \ne j} m_j (\prod_{i \ne j} m_j)_{m_i}^{-1} \]</span></p>
<p>其中 <span class="math inline">\((\prod_{i \ne j} m_j)_{m_i}^{-1}\)</span> 是 <span class="math inline">\(\prod_{i \ne j} m_j\)</span> 在模 <span class="math inline">\(m_i\)</span> 意义下的逆元。</p>
<p>那么整个方程组的一个解就是 <span class="math inline">\(\sum_{i=1}^n b_i a_i\)</span> ，通解就是：</p>
<p><span class="math display">\[ x \equiv \sum_{i=1}^n b_i a_i \pmod{\prod_{i=1}^n m_i} \]</span></p>
<h2 id="excrt">exCRT</h2>
<p>CRT 只适用于模数两两互质的情况，因为用到了模数之间的逆元，而模数不互质是没有逆元的。</p>
<p>exCRT 的主要思想是两两合并，考虑 <span class="math inline">\(n=2\)</span> 的情况：</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
x \equiv a_1 \pmod{m_1} \\\\
x \equiv a_2 \pmod{m_2} \\\\
\end{aligned}
\right.
\end{equation}
\]</span></p>
<p>那么此时方程组的解 <span class="math inline">\(x\)</span> 需要满足存在 <span class="math inline">\(i, j\)</span> 使得：</p>
<p><span class="math display">\[ x = a_1 + i m_1 = a_2 + j m_2 \]</span></p>
<p>对于右边的等式 <span class="math inline">\(a_1 + i m_1 = a_2 + j m_2\)</span> ，是关于 <span class="math inline">\(i, j\)</span> 的二元一次方程，<br>
那么用扩展欧几里得解出一组解 <span class="math inline">\(i=i_0, j=j_0\)</span> 再回代到等式中即可求得一个 <span class="math inline">\(x = x_0\)</span> 。<br>
而通解的话，根据 exgcd 的通解 <span class="math inline">\(i \equiv i_0 \pmod{\frac{m_2}{\gcd(m_1, m_2)}}\)</span> ，可以得到 <span class="math inline">\(x\)</span> 的通解：</p>
<p><span class="math display">\[ x \equiv x_0 \pmod{lcm(m_1, m_2)} \]</span></p>
<p>那么据此可以将任意两个同余方程合并为一个，也就可以通过两两合并的方式将整个同余方程组合并为一个方程。</p>
<p>无解的话，当且仅当 exgcd 解 <span class="math inline">\(i, j\)</span> 的时候无解，只要有两个方程无法合并那么整个方程组都无法合并。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>同余</tag>
        <tag>中国剩余定理</tag>
        <tag>CRT</tag>
        <tag>exCRT</tag>
      </tags>
  </entry>
  <entry>
    <title>快速沃尔什变换</title>
    <url>/2019/11/03/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>快速沃尔什变换，简称 FWT 。</p><h2 id="用处">用处</h2><p>多项式卷积一般是这样的：</p><p><span class="math display">\[ C_i = \sum_{j + k = i} A_j \cdot B_k \]</span></p><p>这个可以用 FFT 快速求解。</p><p>然而还有一个诡异的卷积：</p><p><span class="math display">\[ C_i = \sum_{j \oplus k = i} A_j \cdot B_k \]</span></p><p>其中 $ $ 是任意一种位运算。</p><a id="more"></a>







<p>FWT 便是求这类卷积的快速算法。</p>
<h2 id="构造">构造</h2>
<p>FFT 的思想是把多项式转换成可以线性相乘的点值表示法 (DFT) ，<br>
再把相乘的结果转换回系数表示法 (IDFT) 。</p>
<p>同样的道理可以用在 FWT 上，用 DWT 将多项式转换成可以线性相乘的形式，即：</p>
<p><span class="math display">\[ DWT(C)_i = DWT(A)_i \cdot DWT(B)_i \]</span></p>
<p>再用 IDWT 将相乘的结果转换回来。</p>
<h2 id="dwt">DWT</h2>
<p>目标是构造一个转移系数函数 f(i, j) ，满足：</p>
<p><span class="math display">\[ DWT(A)_i = \sum_j A_j \cdot f(i, j) \]</span></p>
<p>考虑 f(i, j) 应满足什么样的性质。</p>
<p>首先根据 DWT 的性质：</p>
<p><span class="math display">\[ DWT(C)_i = DWT(A)_i \cdot DWT(B)_i \]</span></p>
<p><span class="math display">\[ \sum_t C_t f(i, t) = \sum_j A_j f(i, j) \sum_k B_k f(i, k) \]</span></p>
<p><span class="math display">\[ \sum_t \sum_{j \oplus k = t} A_j B_k f(i, t) = \sum_j \sum_k A_j f(i, j) B_k f(i, k) \]</span></p>
<p><span class="math display">\[ \sum_t \sum_{j \oplus k = t} A_j B_k f(i, t) = \sum_t \sum_{j \oplus k = t} A_j f(i, j) B_k f(i, k) \]</span></p>
<p>由上式可得出：</p>
<p><span class="math display">\[ \forall i, j, k: f(i, j) f(i, k) = f(i, j \oplus k) \]</span></p>
<p>这样还不够，为了让 DWT 快速进行，f(i, j) 还应满足以下性质：</p>
<p><span class="math display">\[ f(i, j) = \prod_k f(i_k, j_k) \]</span></p>
<p>其中 $ i_k $ 表示 i 二进制下的第 k 位（ 0 或 1 ）。</p>
<p>有了这个性质，就可已通过 f(0, 0), f(0, 1), f(1, 0), f(1, 1) 的值相乘得出所有 f 。<br>
有了这个性质，就可以考虑分治求 DWT ：</p>
<p><span class="math display">\[DWT(A)_i = \sum_{j=0}^{n-1} A_j f(i, j)\]</span></p>
<p><span class="math display">\[ = \sum_{j=0}^{n/2-1} A_j f(i, j) + \sum_{j=n/2}^{n-1} A_j f(i, j) \]</span></p>
<p><span class="math display">\[ = \sum_{j=0}^{n/2-1} A_j \prod_k f(i_k, j_k) + \sum_{j=n/2}^{n-1} A_j \prod_k f(i_k, j_k) \]</span></p>
<p><span class="math display">\[ = \sum_{j=0}^{n/2-1} f(i_0, j_0) A_j \prod_{k \geq 1} f(i_k, j_k) + \sum_{j=n/2}^{n-1} A_j f(i_0, j_0) \prod_{k \geq 1} f(i_k, j_k)\]</span></p>
<p><span class="math display">\[ = f(i_0, 0) \sum_{j=0}^{n/2-1} A_j \prod_k f(i_k, j_k) + f(i_0, 1) \sum_{j=n/2}^{n-1} A_j \prod_k f(i_k, j_k) \]</span></p>
<p>规模减小了一半，递归或迭代地分治下去。<br>
每次将 A 分成左右两半 A0, A1 ：</p>
<p><span class="math display">\[ DWT(A)_i = f(0, 0) DWT(A0)_i + f(0, 1) DWT(A1)_i , i &lt; n / 2 \]</span></p>
<p><span class="math display">\[ DWT(A)_i = f(1, 0) DWT(A0)_i + f(1, 1) DWT(A1)_i , i \geq n / 2 \]</span></p>
<p>想到 FFT 的蝴蝶变换没有？ <del>答：没有</del><br>
迭代的 DWT 这里也有类似的蝴蝶变换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = A[i], y = A[i + k];</span><br><span class="line">A[i] = f00 * x + f01 * y;</span><br><span class="line">A[i + k] = f10 * x + f11 * y;</span><br></pre></td></tr></table></figure>
<p>DWT 的过程就是这样了，甚至不需要构造整个 f ，<br>
只需要 f(0, 0), f(0, 1), f(1, 0), f(1, 1) 即可，<br>
需要满足的就是 $ i, j, k: f(i, j) f(i, k) = f(i, j k) $ 。</p>
<h2 id="idwt">IDWT</h2>
<p>怎么将 DWT 的结果转换回来？ 观察 DWT 的蝴蝶变换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = f00 * x + f01 * y;</span><br><span class="line">b = f10 * x + f11 * y;</span><br></pre></td></tr></table></figure>
<p>DWT 通过 x, y 求出 a, b,<br>
IDWT 就是通过 a, b 求 x, y 。</p>
<p>解二元一次方程就好了：<br>
x = (f11 * a - f01 * b) / (f00 * f11 - f01 * f10)<br>
y = (f10 * a - f00 * b) / (f01 * f10 - f00 * f11)</p>
<p>就是这么简单...</p>
<p>个屁啊。</p>
<p>考虑 f 的构造，<br>
要满足 DWT 的性质把所有的 f 设为 0 不就可以了？<br>
要满足 DWT 的性质把所有的 f 设为 1 不就可以了？</p>
<p>这样且不是对于任何位运算都会有相同的结果？</p>
<p><del>Naive.</del></p>
<p>再看看 IDWT ，分母里边是不是有 (f01 * f11 - f01 * f10) ？<br>
不幸的是把 f 全部设为 0 或者全设为 1 这个分母都是 0 ，<br>
这意味着 IDWT 的二元一次方程无解，转过去就转不回来了。</p>
<p>因此 f 的构造还要满足一个条件： <code>f01 * f11 != f01 * f10</code> 。</p>
<h2 id="f-的构造">f 的构造</h2>
<p>f 需要满足的性质已经讲的很详细了。</p>
<p>这里给出常用位运算中 f 的构造：</p>
<ul>
<li>按位或： f00 = 1, f01 = 0, f10 = 1, f11 = 1</li>
<li>按位与： f00 = 1, f01 = 1, f10 = 0, f11 = 1</li>
<li>异或： f00 = 1, f01 = 1, f10 = 1, f11 = -1</li>
</ul>
<p>可以自行验证，这些 f 满足上述性质。</p>
<h2 id="实际意义">实际意义</h2>
<p>一个多项式 A DFT 后的 <span class="math inline">\(A2_x\)</span> 实际意义就是 A 在 $ W_n^x $ 上的值（点值表示）。</p>
<p>那么 A DWT 后的结果的现实意义呢？<br>
这得分类来说。</p>
<h3 id="按位或">按位或</h3>
<p>A 在做按位或的 DWT 之后得到的 A2 满足： <span class="math display">\[ A2_x = \sum_{i|x=x} A_i \]</span></p>
<p>也就是说 <span class="math inline">\(A2_x\)</span> 表示 x 的每个子集 i 的 <span class="math inline">\(A_i\)</span> 的和。<br>
不难得到，<span class="math inline">\(A2_x \cdot B2_x\)</span> 的结果 <span class="math inline">\(C2_x\)</span> 就是 A, B 卷积后的 C 的变换： <span class="math display">\[ A2_x \cdot B2_x = \sum_{i|x=x} A_i \sum_{j|x=x} B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{i|x=x} \sum_{j|x=x} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k|x=x} \sum_{i|j=k} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k|x=x} C_k \]</span> <span class="math display">\[ A2_x \cdot B2_x = C2_x \]</span></p>
<p>事实上，这也就是子集和变换 FMT （快速莫比乌斯变换） 。</p>
<p><del>感性理解一下</del></p>
<h3 id="按位与">按位与</h3>
<p>和按位或类似的，A 在做按位与的 DWT 之后得到的 A2 满足： <span class="math display">\[ A2_x = \sum_{i\&amp;x=x} A_i \]</span></p>
<p>也就是说 <span class="math inline">\(A2_x\)</span> 表示每个包含 x 的集合 i 的 <span class="math inline">\(A_i\)</span> 的和。<br>
不难得到，<span class="math inline">\(A2_x \cdot B2_x\)</span> 的结果 <span class="math inline">\(C2_x\)</span> 就是 A, B 卷积后的 C 的变换： <span class="math display">\[ A2_x \cdot B2_x = \sum_{i\&amp;x=x} A_i \sum_{j\&amp;x=x} B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{i\&amp;x=x} \sum_{j\&amp;x=x} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k\&amp;x=x} \sum_{i\&amp;j=k} A_i B_j \]</span> <span class="math display">\[ A2_x \cdot B2_x = \sum_{k\&amp;x=x} C_k \]</span> <span class="math display">\[ A2_x \cdot B2_x = C2_x \]</span></p>
<p><del>和按位或一个模子里刻出来的</del></p>
<h2 id="子集卷积">子集卷积</h2>
<p>两个多项式 A, B 的子集卷积 C 的意义如下：</p>
<p><span class="math display">\[ C(x) = \sum_{y|z=x, y\&amp;z=0} A(y) B(z) \]</span></p>
<p>也就是把 x 划分为两个子集 y, z 的 A(y) * B(z) 的和。</p>
<p>转换成 $ <em>{y|z=x} A(y) B(z) [y &amp; z = 0] $ ，似乎是一个按位或卷积。<br>
再转换成 $ </em>{y|z=x} A(y) B(z) [bitcount(y) + bitcount(z) = bitcount(x)] $ 。</p>
<p>此时需要考虑的就是 bitcount, 也就是集合大小，也就是二进制位中 1 的个数。<br>
集合大小是 $ O(log(n)) $ 的，可以考虑枚举大小，设： <span class="math display">\[ A_i(x) = A(x) [bitcount(x) = i] \]</span> <span class="math display">\[ B_j(x) = B(x) [bitcount(x) = j] \]</span> <span class="math display">\[ C_k(x) = C(x) [bitcount(x) = k] \]</span></p>
<p>那么有： <span class="math display">\[ C_k(x) = \sum_{y|z=x} A_i(y) B_j(z) [i + j = k] \]</span> <span class="math display">\[ C_k(x) = \sum_{i+j=k} \sum_{y|z=x} A_i(y) B_j(z) \]</span></p>
<p>那么枚举 i, j 的值，将 $ A_i $ 和 $ B_j $ 卷积后贡献到 $ C_{i+j} $ 即可。</p>
<p>这样复杂度似乎是 $ O(n log^3n) $ 的，<br>
但是事实上每个 $ A_i, B_j $ 都可以提前 FWT 后 $ O(n) $ 相乘，<br>
再贡献到 C 后不进行逆变换，而是确定了 C 的值后在进行逆变换。</p>
<p>复杂度 $ O(n log^2n) $</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卷积</tag>
        <tag>位运算</tag>
        <tag>FWT</tag>
        <tag>子集卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-13</title>
    <url>/2019/10/25/cometoj-13/</url>
    <content><![CDATA[<p>淦。</p><p>Skip 掉 A ，直接开 C1 。</p><p>一看卧槽搜索题，果然简单，然后码，然后码挂了，调了一波，在 8min AC 。</p><p>然后既然做了 C1 那就继续看 C2 嘛，</p><p>一看卧槽煞笔题，果然简单，然后码，然后没码挂，交了一波，<br>
TLE 了 4 个点。。。</p><p>回去看 A ，卧槽果然签到题，花 2min A 了。</p><p>然而对于 C2 还是一脸懵逼，后来理性分析了复杂度上界，发现用 set 多了个 log ，<br>
想着怎么撸掉这个 log ，卧槽并查集不就行了，几乎重构了一遍，在 41min AC 。</p><a id="more"></a>






<p>说起来我第一个想到的是用 set 的原因是做过策爷的“基础排序算法练习题”，<br>
那里维护有效点对的方式就是用 set + 二分。<br>
然而这里特殊一点，用过的点不会在出现，直接并查集就好了。</p>
<p><del>学傻了.jpg</del></p>
<p>开 B 。</p>
<p>一看卧槽模拟题，果然简单，然后码，然后交 WA 了，发现没清除头的位置（忘记测样例 3 了），<br>
改了后在 55min AC 。</p>
<p>看 D 。</p>
<p>一看卧槽二项式定理 + 单位根反演板子题，果然不难，然后码，然后犯煞笔错误，调到 1h21min 才 A 。</p>
<p>不过 D 的难点想必不在二项式定理和单位根反演<del>（因为这太裸了）</del>，<br>
难点在于给定的 a 在模数任意的情况下可能是非二次剩余，不能开根。<br>
然而只要会求二次剩余，就不难想到把 <span class="math inline">\(\sqrt{a}\)</span> 当做虚数单位进行扩域来做复数运算。</p>
<p><del>还好我前几天才学二次剩余</del></p>
<p>话说我一直调的一个错误竟然是复数乘法中的一个乘号打成了加号，一个字符调一年。</p>
<p>对于剩下的 E, F ，就彻底凉了。</p>
<p>剩下 1h40min 都在肝 E, F ，然而并没有什么卵用，<br>
E 题有想法，但是实现巨巨巨麻烦，况且我计算几何渣的一批，就弃了。<br>
F 题看上去是个神奇数据结构题，不会，告辞。</p>
<p>在 1h21min 的时候是 rank31 ，在最后比赛结束仍然狗在 rank33 <del>（可见 E, F 毒瘤）</del> 。</p>
<p><del>并没有拿到裙子，自闭了</del></p>
<p>update on 10.26:</p>
<p>E, F 都改完了， E 的正解在赛时其实就想到了，但是苦于没有实现思路，计几基础太差。<br>
F 分块好题，赛时也的确想到了分块，对于区间左移也想到了块内记偏移量，但是由于对于偏移量的维护没有思路就弃了。<br>
事实上这个偏移量其实很好搞，块内维护一个环状结构而不是普通的链状结构（我猜链状大概也能做，不过要动态增删点之类的？），<br>
这样在整个块左移的时候只需把头指针向右移一个就可以简单地做到整体左移。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余</title>
    <url>/2019/10/21/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
    <content><![CDATA[<p>二次剩余，<del>俗称模意义开根</del>。<br>
也就是对于常数 <span class="math inline">\(n\)</span> 解这样一个方程：</p><p><span class="math display">\[x^2 \equiv n \; (mod \; p)\]</span></p><p>这里只介绍模数 <span class="math inline">\(p\)</span> 为奇素数的解法，也就是 Cipolla 算法。</p><p>以下运算皆指模 <span class="math inline">\(p\)</span> 意义下的运算。</p><h2 id="解的数量">解的数量</h2><p>严格来讲，非 0 数 <span class="math inline">\(n\)</span> 是二次剩余当且仅当方程 <span class="math inline">\(x^2 \equiv n\)</span> 有解，也就是能开根。<br>
上述方程无解的非 0 数 <span class="math inline">\(n\)</span> 称作非二次剩余。</p><a id="more"></a>





<p>对于二次剩余 <span class="math inline">\(n\)</span> ，<span class="math inline">\(x^2 \equiv n\)</span> 有多少解？</p>
<p>假设有多组解，对于任意两个不相等的解 <span class="math inline">\(x_0, x_1\)</span> ，有 <span class="math inline">\(x_0^2 \equiv x_1^2\)</span> 。<br>
移项后平方差，得到 <span class="math inline">\((x_0 - x_1)(x_0 + x_1) \equiv 0\)</span> 。</p>
<p>由于 <span class="math inline">\(p\)</span> 是奇素数，且 <span class="math inline">\(x_0 \ne x_1\)</span> ， <span class="math inline">\(x_0 - x_1\)</span> 在模 <span class="math inline">\(p\)</span> 意义下是不会为 0 的。<br>
故有 <span class="math inline">\(x_0 + x_1 \equiv 0\)</span> ，也就是说两个不相等的解一定是相反数，<br>
换言之，该方程只有两个解，且它们互为相反数。<br>
而当 <span class="math inline">\(p\)</span> 为奇素数时模意义的两个相反数不会相等，因为奇偶性不同。</p>
<p>还可以知道，任意一对相反数都对应一个二次剩余，而且这些二次剩余是两两不同的。<br>
也就说二次剩余的数量恰为 <span class="math inline">\(\frac{p-1}{2}\)</span> ，其他的非 0 数都是非二次剩余，数量也是 <span class="math inline">\(\frac{p-1}{2}\)</span> 。</p>
<h2 id="欧拉准则">欧拉准则</h2>
<p>如何快速判断一个数 <span class="math inline">\(n\)</span> 是否为二次剩余？</p>
<p>以下讨论假定 n 不为 0 。</p>
<p>观察费马小定理 <span class="math inline">\(n^{p-1} \equiv 1\)</span> ，由于 <span class="math inline">\(p\)</span> 是奇素数，可以得到 <span class="math inline">\(n^{2(\frac{p-1}{2})} - 1\equiv 0\)</span> ，<br>
也就是说 <span class="math inline">\(n^{\frac{p-1}{2}}\)</span> 是 1 开根的结果，根据上面所说， 1 开根只有两个解 1 和 -1 。<br>
那么 <span class="math inline">\(n^{\frac{p-1}{2}}\)</span> 只能是 1 或 -1 。</p>
<p>若 <span class="math inline">\(n\)</span> 是二次剩余，则有 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv x^{p-1} \equiv 1\)</span> 。</p>
<p>若 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv 1\)</span> ，将 <span class="math inline">\(n\)</span> 表示为 <span class="math inline">\(g^k\)</span> ， 其中 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p\)</span> 意义下的原根。<br>
那么有 <span class="math inline">\(g^{k\frac{p-1}{2}} \equiv 1\)</span> 由于 <span class="math inline">\(g\)</span> 是原根，必有 <span class="math inline">\(p-1|k\frac{p-1}{2}\)</span> ，<br>
也就是说 <span class="math inline">\(k\)</span> 一定是偶数，那么令 <span class="math inline">\(x \equiv g^{\frac{k}{2}}\)</span> 即是 <span class="math inline">\(n\)</span> 开根的结果，这说明 <span class="math inline">\(n\)</span> 是二次剩余。</p>
<p>也就是说 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv 1\)</span> 与 <span class="math inline">\(n\)</span> 是二次剩余是等价的，<br>
由于 <span class="math inline">\(n^{\frac{p-1}{2}}\)</span> 不为 1 就只能是 -1 ，那么 <span class="math inline">\(n^{\frac{p-1}{2}} \equiv -1\)</span> 与 <span class="math inline">\(n\)</span> 是非二次剩余等价。</p>
<p><em>ps: 网上一堆伪证说若 <span class="math inline">\(n\)</span> 是非二次剩余，不存在 <span class="math inline">\(x\)</span> 使得上式为 1 ，但这只能说明上式为 -1 时 <span class="math inline">\(n\)</span> 是非二次剩余，并不能推翻“当 <span class="math inline">\(n\)</span> 是非二次剩余时上式为 1”</em></p>
<h2 id="cipolla">Cipolla</h2>
<p>对于二次剩余解方程 <span class="math inline">\(x^2 \equiv n\)</span> 。</p>
<p>找到一个 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(a^2 - n\)</span> 是非二次剩余，由于非二次剩余的数量接近 <span class="math inline">\(\frac{p}{2}\)</span> ，<br>
通过随机 + 检验的方式期望约 2 次可以找到这样一个 <span class="math inline">\(a\)</span> 。</p>
<p>接下来定义 <span class="math inline">\(i^2 \equiv a^2 - n\)</span> 。<br>
但是 <span class="math inline">\(a^2 - n\)</span> 不是二次剩余，怎么找得到这样一个 <span class="math inline">\(i\)</span> ？</p>
<p>类比实数域到复数域的推广，定义这样一个 <span class="math inline">\(i\)</span> ，然后可以将所有数表示为 <span class="math inline">\(A+Bi\)</span> 的形式，<br>
其中 <span class="math inline">\(A, B\)</span> 都是模 <span class="math inline">\(p\)</span> 意义下的数，类似于实部和虚部。</p>
<p>那么 <span class="math inline">\((a + i)^{p+1} \equiv n\)</span> ，考虑证明。</p>
<p><strong>引理 1</strong> ： <span class="math inline">\(i^p \equiv -i\)</span> 。</p>
<p>证明： $i^p i(i<sup>2)</sup>{} i(a^2 - n)^{} -i $</p>
<p><strong>引理 2</strong> ： <span class="math inline">\((A + B)^p \equiv A^p + B^p\)</span> 。</p>
<p>证明：二项式定理展开后，由于 <span class="math inline">\(p\)</span> 是质数，除了 <span class="math inline">\(C_p^0, C_p^p\)</span> 外的组合数分子上的阶乘没法消掉，模 <span class="math inline">\(p\)</span> 都会为 0 ，剩下来的就是 <span class="math inline">\(C_p^0 A^0 B^p + C_p^p A^p B^0\)</span> 。</p>
<p>现在证明上述结论：</p>
<p><span class="math display">\[(a + i)^{p+1} \equiv (a^p + i^p) (a + i) \equiv (a - i) (a + i) \equiv a^2 - i^2 \equiv n\]</span></p>
<p>那么 <span class="math inline">\((a + i)^{\frac{p+1}{2}}\)</span> 即是一个解，其相反数是另一个解。</p>
<p>然而还剩最后一个问题， <span class="math inline">\((a + i)^{\frac{p+1}{2}}\)</span> 的“虚部”一定为 0 吗？</p>
<p>幸运的是，的确如此，假设存在 <span class="math inline">\((A + Bi)^2 \equiv n\)</span> 且 <span class="math inline">\(B \ne 0\)</span> ，<br>
那么有 <span class="math inline">\(A^2 + B^2i^2 + 2ABi \equiv n\)</span> ，即 <span class="math inline">\(A^2 + B^2(a^2 - n) - n \equiv -2ABi\)</span> 。<br>
式子的左边“虚部”为 0 ，那么式子右边的“虚部”也一定为 0 ，也就是说 <span class="math inline">\(AB \equiv 0\)</span> 。<br>
既然假设了 <span class="math inline">\(B \ne 0\)</span> 那么一定是 <span class="math inline">\(A \equiv 0\)</span> ，也就是说 <span class="math inline">\((Bi)^2 \equiv n\)</span> 。<br>
也就是 <span class="math inline">\(i^2 \equiv nB^{-2}\)</span> ，由于 <span class="math inline">\(B^2\)</span> 是个二次剩余，其逆元 <span class="math inline">\(B^{-2}\)</span> 一定也是二次剩余，乘上二次剩余 <span class="math inline">\(n\)</span> 后一定还是二次剩余，这与 <span class="math inline">\(i^2\)</span> 是个非二次剩余产生矛盾。</p>
<h2 id="实现">实现</h2>
<p>实现的时候弄个“复数”类（据说也可以不用）即可。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line">lolong I_mul_I; <span class="comment">// 虚数单位的平方</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">	lolong real, imag;</span><br><span class="line">	<span class="keyword">complex</span>(lolong real = <span class="number">0</span>, lolong imag = <span class="number">0</span>): real(real), imag(imag) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">complex</span> x, <span class="keyword">complex</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.real == y.real <span class="keyword">and</span> x.imag == y.imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> x, <span class="keyword">complex</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">complex</span>((x.real * y.real + I_mul_I * x.imag % mod * y.imag) % mod,</span><br><span class="line">			(x.imag * y.real + x.real * y.imag) % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">complex</span> <span class="title">power</span><span class="params">(<span class="keyword">complex</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">complex</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">		x = x * x;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_if_residue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> power(x, (mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;x0, <span class="keyword">int</span> &amp;x1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">		x0 = x1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mod = p;</span><br><span class="line"></span><br><span class="line">	lolong a = rand() % mod;</span><br><span class="line">	<span class="keyword">while</span>(!a <span class="keyword">or</span> check_if_residue((a * a + mod - n) % mod))</span><br><span class="line">		a = rand() % mod;</span><br><span class="line">	I_mul_I = (a * a + mod - n) % mod;</span><br><span class="line"></span><br><span class="line">	x0 = <span class="keyword">int</span>(power(<span class="keyword">complex</span>(a, <span class="number">1</span>), (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).real);</span><br><span class="line">	x1 = mod - x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bsgs">BSGS</h2>
<p>值得一提的是，模意义开根（甚至可以推广到开 <span class="math inline">\(k\)</span> 次方根）是可以通过原根转换为求对数问题从而使用 BSGS 的。<br>
不过复杂度 <span class="math inline">\(O(\sqrt{p})\)</span> 远不如 Cipolla 的 <span class="math inline">\(O(logp)\)</span> 优秀，但很多情况下也足够了。</p>
<p>具体地，将 <span class="math inline">\(x\)</span> 表示为 <span class="math inline">\(g^y\)</span> ，其中 <span class="math inline">\(g\)</span> 是原根，方程变为 <span class="math inline">\((g^y)^k \equiv n\)</span> ，即 <span class="math inline">\((g^k)^y \equiv n\)</span> ，解出 <span class="math inline">\(y\)</span> 即可。</p>
<h2 id="非二次剩余开根">非二次剩余开根</h2>
<p>事实上，大多数情况需要开根的数并不是个二次剩余。</p>
<p>比如有一个递推式，为了化简需要开根，但是这时候被开根的数是个任意数。</p>
<p>比如 <a href="https://cometoj.com/contest/72/problem/Ｄ?problem_id=4033" target="_blank" rel="noopener">这个</a> 还有 <a href="http://www.51nod.com/Challenge/ProblemSubmitDetail.html#judgeId=826009" target="_blank" rel="noopener">这个</a> 。</p>
<p>其实很简单，像 Cipolla 那样直接扩域，把这个非二次剩余设为虚数单位即可。<br>
但当然这仅适用于对仅仅一个非二次剩余开根的情况，如果式子需要同时对若干非二次剩余开根，扩域的代价（大概）会呈指数级别增长，即每一次复数乘法的复杂度会很大。</p>
<h2 id="扩域后指数取模">扩域后指数取模</h2>
<p>（以下前提是模数是质数）</p>
<p>扩域后，费马小定理在复数上是不成立的，也就是说 <span class="math inline">\((A+Bi)^p\)</span> 不一定同余于 <span class="math inline">\(A+Bi\)</span> 。</p>
<p>但有时需要对一个幂的指数取模，还是扩域后的，或者有时候需要对一个扩域后的数求逆元，怎么办？</p>
<p>比如 <a href="http://www.51nod.com/Challenge/ProblemSubmitDetail.html#judgeId=826009" target="_blank" rel="noopener">这个</a> 。</p>
<p>根据 Cipolla 中提到的公式 <span class="math inline">\((a + i)^{p+1} \equiv n\)</span> ，推广一下可以得到 <span class="math inline">\((A+Bi)^{p+1} \equiv A^2-B^2i^2\)</span> 。</p>
<p>注意到此时 <span class="math inline">\(A^2 - B^2 i^2\)</span> 虚部为 0 ，设 <span class="math inline">\(x \equiv A^2 - B^2 i^2\)</span> 虚部为零的数是满足费马小定理的，<br>
也就是说 <span class="math inline">\(x^p \equiv x\)</span> ，即 <span class="math inline">\(x^{p-1} \equiv 1\)</span>，那么有 <span class="math inline">\(((A+Bi)^{p+1})^{p-1} \equiv 1\)</span> 。<br>
也就说指数对 <span class="math inline">\(p^2 - 1\)</span> 取模即可，换句话说，扩域后的复数 <span class="math inline">\(x\)</span> 满足：</p>
<p><span class="math display">\[ x^{p^2} \equiv x \]</span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二次剩余</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title>LGR-061&amp;XR-4</title>
    <url>/2019/10/20/LGR-061-XR-4/</url>
    <content><![CDATA[<p>开场 30min 才反应过来有场比赛。<br>
不知道哪来的自信就去报了 Div.1 。。。</p><p>第一次打 IOI 赛制的网络赛，感觉海星，不像 ACM 一样必须 A 题，<br>
打部分分的话就和平时训练的感觉一样，操作起来相对顺手。</p><p><del>但是打网络赛为什么要拿部分分呢，当然冲着 A 题去啊是吧</del></p><p>然而全场只能做出 A 题。并没有平时打 ACM 赛制的时候有签到题。<br>
不过还好，反正我不适合打手速题。</p><a id="more"></a>



<p>Skip 掉了 B （还好 Skip 掉了，后来全程肝 B 没肝出来），直接开 C 。<br>
发现 C 的 63' 巨水，打了个神奇剪枝交了一发，我一直感觉这玩意复杂度是 <span class="math inline">\(O(np)\)</span> 的，<br>
但是没用，TLE ，复杂度假了呗，虽然我并不知道原因，但觉得剩下的 37' 性价比不高，就 Skip 掉了。</p>
<p>提答题好评。</p>
<p>洛谷不支持提答题差评。</p>
<p>但是它给的输入文件的坐标都是有理数，小数点后面一堆数我 TM 怎么知道它的具体位置啊，在图里面标注坐标的无理数表示会死吗。。<br>
第一个点蛮简单的，然后第二个点就卡死了。</p>
<p>弃疗，回去肝 B 。</p>
<p>但是我觉得 B 真的难啊，好多细节？反正是没肝出来，最后 173' 狗到 rank21 。</p>
<p>然而这场比赛参加的人少，只有 300+ 个人打，而且好像很多流皮的人都不打洛谷月赛哦，<br>
所以不太理解为什么 XRound 为什么坚持在洛谷办<del>（难道是 py 交易？）</del>，<br>
平心而论对于 XR 这种比赛 CometOJ 应该是个更合适的平台。</p>
<p><span class="math inline">\(\color{white}{事实上，洛谷的确为办一场月赛出了不少钱，出题人的待遇比在 cf 等比赛要高}\)</span></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>洛谷</tag>
        <tag>XR</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队二次离线</title>
    <url>/2019/10/16/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>莫队算法可以通过单点增量的方式以 <span class="math inline">\(O(n\sqrt{n}K)\)</span> （认为 <span class="math inline">\(n, q\)</span> 同阶）的复杂度离线处理若干区间信息询问。<br>
其中每次单点增量，即每次端点移动的复杂度为 <span class="math inline">\(O(K)\)</span> 。<br>
大多数情况下端点移动的复杂度是 <span class="math inline">\(O(1)\)</span> 的，这样的问题一般是统计区间内的“数”。<br>
而统计区间内的“数对”这样的问题往往难以 <span class="math inline">\(O(1)\)</span> 处理端点移动。</p><a id="more"></a>
<p>莫队二次离线或许能处理这样的问题。</p>
<h2 id="什么用">什么用</h2>
<p>一般莫队有 <span class="math inline">\(O(n\sqrt{n})\)</span> 次端点移动，如果要用数据结构维护信息的话，<br>
就有 <span class="math inline">\(O(n\sqrt{n})\)</span> 次修改和 <span class="math inline">\(O(n\sqrt{n})\)</span> 次查询。</p>
<p>而莫队二次离线能够优化为成 <span class="math inline">\(O(n)\)</span> 次修改和 <span class="math inline">\(O(n\sqrt{n})\)</span> 次查询，<br>
从而允许使用一些修改复杂度大而查询复杂度小的方式来维护信息。<br>
例如分块，如果能 <span class="math inline">\(O(\sqrt{n})\)</span> 修改和 <span class="math inline">\(O(1)\)</span> 查询的话，总的复杂度就是 <span class="math inline">\(O(n\sqrt{n})\)</span> 。</p>
<p>但是有两个前提： - 维护的信息有一定可减性，换句话说必须保证每次询问 <span class="math inline">\([l, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献时，<br>
需要能够用 <span class="math inline">\([1, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献减去（或者其他方式）<span class="math inline">\([1, l)\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献代替。 - 维护的信息有一定可加性，换句话说在每次询问前在不知道当前的 Ans 的情况下可以得到 Ans 的改变量（或某种改变方式）。</p>
<h2 id="怎么用">怎么用</h2>
<p>考虑每次右端点右移的过程（右端点左移以及左端点移动是类似的）。</p>
<p>每次右端点 <span class="math inline">\(r\)</span> 从 <span class="math inline">\(r_0\)</span> 移动到 <span class="math inline">\(r_1\)</span> 时，对于其中的每一个 <span class="math inline">\(r\)</span> ，都需要查询 <span class="math inline">\([l, r - 1]\)</span> 与该点产生的贡献。<br>
考虑差分，利用上面提到过的可减性，查询 <span class="math inline">\([1, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献和 <span class="math inline">\([1, l)\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献。</p>
<h4 id="part-1">Part 1</h4>
<p><span class="math inline">\([1, r]\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献只与 <span class="math inline">\(r\)</span> 有关，可以记为 <span class="math inline">\(f_r\)</span> 。<br>
那么预处理 <span class="math inline">\(f_r\)</span> 只需从小到大一个个加点维护当前的 <span class="math inline">\([1, r]\)</span> 并询问出 <span class="math inline">\(f_r\)</span> 。<br>
这个过程需要 <span class="math inline">\(O(n)\)</span> 次修改和 <span class="math inline">\(O(n)\)</span> 次查询。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[i] 是第 i 个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	f[i] = Query(a[i]);</span><br><span class="line">	Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外如果需要卡常，可以将 <span class="math inline">\(f\)</span> 做一遍前缀和，这样后续查询 <span class="math inline">\([r_0, r_1]\)</span> 总的贡献就可以 <span class="math inline">\(O(1)\)</span> 计算了（不影响复杂度）。</p>
<h4 id="part-2">Part 2</h4>
<p><span class="math inline">\([1, l)\)</span> 与 <span class="math inline">\(r + 1\)</span> 产生的贡献可以二次离线，在 <span class="math inline">\(l\)</span> 处存下 <span class="math inline">\(r + 1\)</span> 之后再考虑计算。<br>
这样做的空间复杂度是 <span class="math inline">\(O(n\sqrt{n})\)</span> 的，<br>
但事实上每次只需把 <span class="math inline">\([r_0, r_1]\)</span> 这个区间存进 <span class="math inline">\(l\)</span> 处而不是把每个数存进去就可以做到 <span class="math inline">\(O(n)\)</span> 的空间复杂度了，<br>
这样询问的时候也只需求 <span class="math inline">\([r_0, r_1]\)</span> 整体的贡献，常数上还能少一个 <span class="math inline">\(O(n\sqrt{n})\)</span> 的瓶颈。 离线处理上述的贡献，也和求 <span class="math inline">\(f_r\)</span> 的过程类似，每次从小到大一个个加点维护当前的 <span class="math inline">\([1, l)\)</span> ，<br>
并对于 <span class="math inline">\(l\)</span> 处存下的每一个数逐个询问 <span class="math inline">\([1, l)\)</span> 与其产生的贡献即可。<br>
这个过程需要 <span class="math inline">\(O(n)\)</span> 次修改和 <span class="math inline">\(O(n\sqrt{n})\)</span> 次查询。</p>
<p>参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">	<span class="keyword">int</span> L = query[i].l, R = query[i].r; <span class="comment">// 排序后的询问</span></span><br><span class="line">	<span class="keyword">if</span>(r &lt; R) &#123;</span><br><span class="line">		<span class="built_in">vector</span>[l].push_back(<span class="built_in">std</span>::make_pair(r + <span class="number">1</span>, R));</span><br><span class="line">		r = R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> par : <span class="built_in">vector</span>[i])</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = par.first; k &lt;= par.second; k ++)</span><br><span class="line">			Query(a[k]); <span class="comment">// 这里用什么东西存一下结果就好了</span></span><br><span class="line">	Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>亚线性筛</title>
    <url>/2019/10/15/%E4%BA%9A%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>亚线性筛，就是以低于线性的复杂度预处理一些线性信息的筛法统称。</p><p>目前我会杜教筛和 min25 还有 powerful number。</p><h2 id="杜教筛">杜教筛</h2><p>篇幅过长，<a href="/2020/01/02/杜教筛">点击此处</a>。</p><h2 id="min25">min25</h2><p>min25 筛是扩展埃氏筛，也可以筛一类（更复杂的）<strong>积性函数</strong>的前缀和，并且通常是同类亚线性筛中最快的一个。<br>
而且灵活运用 min25 可以处理一些特殊的关于质因子的问题。</p><a id="more"></a>





<h4 id="理论">理论</h4>
<p>假设要求 <span class="math inline">\(S(n) = \sum_{i=1}^n f(i)\)</span> 。</p>
<p>min25 筛可大致分为两步。</p>
<h5 id="step-1">Step 1</h5>
<p>第一步处理的是 <span class="math inline">\(f\)</span> 在质数上的取值的和。<br>
令 <span class="math inline">\(F(x) = [x \in Prime] f(x)\)</span> ，那么这一步的目标是筛出 <span class="math inline">\(F\)</span> 的前缀和。<br>
准确地讲，是 <span class="math inline">\(F\)</span> 的前缀和函数 <span class="math inline">\(S_F\)</span> 在每个形如 <span class="math inline">\(\frac{n}{d}\)</span> 的数上的取值。</p>
<p>首先需要将 <span class="math inline">\(f(i)\)</span> 拆成若干完全积性函数的和，<br>
只需考虑 <span class="math inline">\(F\)</span> ，也就是 <span class="math inline">\(f(p^k)\)</span> 的取值。<br>
如果是关于 <span class="math inline">\(p\)</span> 的多项式，每个单项式对应的就是一个完全积性函数。</p>
<p>假设现在要筛一个完全积性函数 <span class="math inline">\(h\)</span> ，要能快速计算出 <span class="math inline">\(S_h = \sum_{i=1}^n h(i)\)</span> 。<br>
这一步的主要思想是，一个一个枚举质数 <span class="math inline">\(p\)</span> ，筛掉最小质因子为 <span class="math inline">\(p\)</span> 的合数的取值。<br>
而合数 <span class="math inline">\(x\)</span> 的最小质因子为 <span class="math inline">\(p\)</span> 的必要条件是 <span class="math inline">\(p^2 \leq x\)</span> ，即 <span class="math inline">\(p \leq \sqrt{x}\)</span> 。<br>
那么只需要枚举 <span class="math inline">\(\sqrt{n}\)</span> 以内的质数去筛即可。</p>
<p>假设现在筛掉了前 <span class="math inline">\(i - 1\)</span> 个质因子得到一个这个值：</p>
<p><span class="math display">\[g(n, i - 1) = \sum_{x=1}^n [x \in Prime \; or \; minp(x) &gt; P_{i-1}] h(x)\]</span></p>
<p>其中 <span class="math inline">\(P_i\)</span> 表示 <span class="math inline">\(\sqrt{n}\)</span> 以内第 <span class="math inline">\(i\)</span> 个质数。</p>
<p>那么接下来要筛最小质因子为 <span class="math inline">\(P_i\)</span> 的合数：</p>
<p><span class="math display">\[g(n, i) = g(n, i - 1) - \sum_{x=1}^n [minp(x) = P_i \; and \; x \notin Prime] h(x)\]</span></p>
<p>由于 <span class="math inline">\(h\)</span> 是完全积性函数，<span class="math inline">\(P_i\)</span> 可以直接提出来，得到（这里的除号表示整除）：</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
g(n, i) &amp;= g(n, i - 1) - h(P_i) \sum_{x=1}^{n/P_i} [minp(x) \geq P_i] h(x) \\\\
&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{x=1}^{n/P_i} [x \in Prime \; and \; minp(x) &lt; P_i] h(x)) \\\\
&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{j=1}^{i-1} h(P_j)) \\\\
&amp;= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - ph_{i - 1}) \\\\
\end{aligned}
\end{equation}
\]</span></p>
<p>其中 <span class="math inline">\(ph_i\)</span> 就是 <span class="math inline">\(h\)</span> 在前 <span class="math inline">\(i\)</span> 个质数上的取值和，注意 <span class="math inline">\(P_i \leq \sqrt{n}\)</span> ，这是可以直接筛的。</p>
<p>那么上面的式子就是 <span class="math inline">\(g\)</span> 的递推式，不难发现第一维的取值都是 <span class="math inline">\(\frac{n}{d}\)</span> 的形式，第二维可以滚动。<br>
直接按照递推式算，就可以在 <span class="math inline">\(O(\sqrt{n} |P|)\)</span> 的时间筛出需要的东西，也就是 <span class="math inline">\(g(n, |P|)\)</span> 。<br>
这还是不够的，需要优化，由于最小质因子的取值在根号以内，所以递推时只需考虑满足 <span class="math inline">\(n \geq P_i^2\)</span> 的 <span class="math inline">\(g(n, i)\)</span> 。<br>
当 <span class="math inline">\(n &lt; P_i^2\)</span> 时，随着 <span class="math inline">\(i\)</span> 的增大 <span class="math inline">\(g(n, i)\)</span> 的值不会改变，由于是滚动数组，直接 skip 掉就好了。</p>
<h5 id="step-2">Step 2</h5>
<p>上面将每个完全积性函数的 <span class="math inline">\(g(n, |P|)\)</span> 加起来，得到 <span class="math inline">\(S_F(n)\)</span> ，表示 <span class="math inline">\(f\)</span> 在质数上的取值 <span class="math inline">\(F\)</span> 的前缀和。</p>
<p>仍然利用最小质因子，不同的是，上一步从所有的取值开始从小到大把对应的最小质因子的合数的贡献给删掉的到质数的取值。<br>
那这一步能不能反过来，从质数的取值开始，从大到小把对应的最小质因子的合数的贡献给加上最后得到所有数的取值？</p>
<p>并不能，事实上是从空值开始，从大到小把对应的最小质因子的数的贡献加上最后得到所有数的取值，<br>
合数可以递推并类似地利用积性函数的性质提出一个因子，质数则直接用上一步预处理的来算。</p>
<p>那么假设现在以及算上了比第 <span class="math inline">\(i\)</span> 个更大的质数为最小质因子的数的值得到了这个：</p>
<p><span class="math display">\[S(n, i) = \sum_{x=1}^n [minp(x) &gt; P_i] f(x)\]</span></p>
<p>不难推导出：</p>
<p><span class="math display">\[S(n, i)=S_F(n) - pf_i + \sum_{P_j &lt; P_k \leq \sqrt{n}} \sum_{e&gt;0,P_k^e \leq n}f(P_k^e)(S(\frac{n}{P_k^e}, k) + [e&gt;1])\]</span></p>
<p>其中 <span class="math inline">\(pf_i\)</span> 就是 <span class="math inline">\(f\)</span> 在前 <span class="math inline">\(i\)</span> 个质数上的取值和，注意 <span class="math inline">\(P_i \leq \sqrt{n}\)</span> ，这是可以直接筛的。</p>
<p>同样地第一维的取值都是 <span class="math inline">\(\frac{n}{d}\)</span> 的形式，但是第二维无法滚动，<br>
但事实上后面的部分直接递归计算即可，以下是参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"><span class="function">lolong <span class="title">S</span><span class="params">(lolong i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prime[j] &gt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	lolong res = S_F[id(i)] - pf[j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= p <span class="keyword">and</span> <span class="number">1l</span>l * prime[k] * prime[k] &lt;= i; k ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> e = <span class="number">1</span>;</span><br><span class="line">		lolong pr = prime[k];</span><br><span class="line">		<span class="keyword">while</span>(pr &lt;= i) &#123;</span><br><span class="line">			res += (prime[k] ^ e) * (S(i / pr, k) + (e &gt; <span class="number">1</span>));</span><br><span class="line">			pr *= prime[k];</span><br><span class="line">			e ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度似乎是 <span class="math inline">\(O(\frac{n^{\frac{3}{4}}}{logn})\)</span> ，大概是能跑 <span class="math inline">\(10^{11}\)</span> 的。</p>
<p>另外 min25 筛还有个树状数组的优化版本，也是 min25 本人引入的，复杂度 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> ，<br>
大概能跑 <span class="math inline">\(10^{13}\)</span> ？<br>
但很不常见，网上可供学习的资料很少，有兴趣可以直接看 <a href="https://min-25.hatenablog.com/entry/2018/11/11/172216" target="_blank" rel="noopener">min25 的博客</a>。</p>
<h2 id="powerful-number">Powerful number</h2>
<p>这个在 OI 中用得少，我也只是做过两道题，大概提一下。</p>
<p>称 1 和每个质因子次数大于 1 的合数为 Powerful number 。<br>
首先有个性质就是 <span class="math inline">\(n\)</span> 以内的 Powerful number 数量是 <span class="math inline">\(O(\sqrt{n})\)</span> 的。</p>
<p>还是筛数论函数 <span class="math inline">\(f\)</span> 的前缀和 <span class="math inline">\(S\)</span> ，需要构造两个函数 <span class="math inline">\(g, h\)</span> 满足 <span class="math inline">\(f = g \cdot h\)</span> 。<br>
如果 <span class="math inline">\(g\)</span> 只在 Powerful number 上有值并且 <span class="math inline">\(h\)</span> 的前缀和 <span class="math inline">\(S_h\)</span> 容易求或者可以筛的话，<br>
由 <span class="math inline">\(S(n) = \sum_{i=1}^n \sum_{d|x} g(d) h(\frac{d}{x}) = \sum_{d=1}^n G(d) S_h(n/d)\)</span><br>
可以通过枚举 Powerful number 快速计算答案。</p>
<p>至于枚举 Powerful number 的方法，注意到 Powerful number 的质因子都是 <span class="math inline">\(\sqrt{n}\)</span> 以内的，<br>
这可以通过反证法证明，如果有大于 <span class="math inline">\(\sqrt{n}\)</span> 的质因子它的次数不可能超过 1 。<br>
那么筛出 <span class="math inline">\(\sqrt{n}\)</span> 以内的质数，再通过搜索枚举每个质数的次数即可。</p>
<p>复杂度似乎是 <span class="math inline">\(O(n^{\frac{2}{3}})\)</span> ，可以跑很快，5s 内 <span class="math inline">\(10^{13}\)</span> 不成问题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>杜教筛</tag>
        <tag>min25</tag>
        <tag>powerful number</tag>
      </tags>
  </entry>
  <entry>
    <title>cf-592div2</title>
    <url>/2019/10/13/cf-592div2/</url>
    <content><![CDATA[<p>自闭。<br>
这大概是我打过最失败的一场比赛。</p><p>A 签到题，然而我在 14min 才 A ，我是真的不适合做手速题。</p><p>B 行数开大点就是插头 DP ，然而行数只有 2 ，插头只有 3 种，<br>
随便 DP 一下就行了，中间少考虑一种插头 WA 了一发，在 25min AC 。</p><p>然后，就没有然后了。</p><p>C 题解二元一次方程的整除解，woc 这不扩欧板题嘛，没想太多，直接码上去。<br>
然后很轻松过了样例啊，交 WA 了，哦没判负数，又交 WA 了。。。<br>
静态查错无果，遂对拍，拍了 1000+ 组全是 AC 。</p><a id="more"></a>




<p>事情好像不太对劲.jpg</p>
<p>skip 掉，直接开 E ，发现了个单调性，没想太多，直接码上去。<br>
还是很轻松过了样例啊，交 WA 了。<br>
静态查错无果，遂回去调 C 。</p>
<p>冷静分析一波后发现 C 题神 tm 会爆 long long 。<br>
这简单，改 int128 ，结果交 CE 了。<br>
然后就到网上蒯 c++ 大整数模板，贴下来后，<br>
样例都过不去了我天，然后我就去调那个模板，也是醉了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Big n = <span class="number">10</span>, x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n - x + x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码第一行输出 10 ，第二行输出 20 。</p>
<p>当时我心态就炸了，简直想去问候那个把模板贴他博客上的祖宗十八代。<br>
写的这玩意连加减法都算不对心里没点 B 数吗也敢往网上放。</p>
<p>服了，还是乖乖想不爆 long long 的解法吧。</p>
<p>9102 年了还有人靠爆 long long 混饭吃。<br>
这样明显卡语言啊，对 c++ 选手毫无公平性可言。</p>
<p>至于正解，自然是没想出来。</p>
<p>最后获得了 rank3400+ 的好成绩，掉分预定。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
      </tags>
  </entry>
  <entry>
    <title>cometoj-12</title>
    <url>/2019/10/13/cometoj-12/</url>
    <content><![CDATA[<p>以后打比赛写总结。</p><p><del>话说今天打到短裙好开心啊</del></p><p>A 题签到题。</p><p>为什么我第一个想的就是 O(1) 的哈希？<br>
表示完全没有去想好写得多的排序，而是直接把三个字符用 int 表示去搞。<br>
然后本地测样例玄学错误，最后发现哈希的数组开小了。<br>
7min 做出 A 题表示自闭。</p><p><del>真是可怕交题的时候刷新就有 40+ AC 了</del></p><a id="more"></a>




<p>B 题还是签到题，以为能在 5min AC 结果打了 9min ，感觉我不适合这种手速题。</p>
<p>然后我 C 题看都没看一眼直接 skip 掉就去开了 D 题。<br>
看了 3min 哇这不数位 DP 吗，现在还没人交，我还有拿一血的想法。<br>
然后打了出来，测样例， woc 过了，这个时候还是 4 提交 0 通过。<br>
我在机房大呼卧槽我要拿一血了，然后自信满满地交了上去。</p>
<p>成功 WA 掉所有点。</p>
<p>再刷新 D 题一血就已经被拿了。</p>
<p>然后我的心路历程是这样的：</p>
<p>我要拿二血。</p>
<p>我要拿三血。</p>
<p>我要拿四血。</p>
<p>算了我凉了还是做好长期打算拿个十血什么的吧。。。</p>
<p>期间各种被 master 嘲讽，各种互怼。</p>
<p>master 走后没人跟我说话了，然后冷静分析了一波，发现限制条件搞错了，<br>
然后随便搓了几行代码就 A 了。</p>
<p><del>所以以后打比赛要远离 master</del><br>
所以以后打比赛还是要在快节奏中冷静下来。</p>
<p>A 完 D 已经是 2h 了，回去看 C ，<del>这 tm 不最短路板题嘛</del>。<br>
然而 C 题有坑，卡了好久，最后在比赛结束前 3min rush 了一发成功 AC 。</p>
<p>然后靠着 4 题 + 罚时 8h 狗进 rank8 <del>拿到短裙啦</del>。</p>
<p>这场比赛绝对是我打的最爽的一场网络赛，感觉 cometoj 的 ACM 比赛才是最刺激的，<br>
题目质量高，节奏快，竞争激烈，尤其是相对于 cf 和 atcoder 来说没有网速杀和题意杀。<br>
体验感极好。<br>
<del>最主要的还是有短裙拿</del></p>
<p>然而拿短裙又没人肯女装，我还是选择拿杯子吧。。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>cometoj</tag>
      </tags>
  </entry>
  <entry>
    <title>RMQ</title>
    <url>/2019/10/11/RMQ/</url>
    <content><![CDATA[<p>总结求各种 RMQ 的常用技巧和方法。<br>
RMQ 真是流皮，每次深入思考都会有新的发现，所以有了新的发现会更新。</p><p>以下 n 表示数列的大小，q 表示询问的次数，均以最大值为例。</p><h2 id="一般性普通做法">一般性普通做法</h2><p>线段树当然是可以在线维护的，复杂度 <span class="math inline">\(O(n + qlogn)\)</span> 。<br>
甚至还可以支持单点修改或区间修改。</p><p>但是如果只是静态询问的话，可以用 ST 表预处理后 <span class="math inline">\(O(1)\)</span> 在线处理询问，<br>
复杂度 <span class="math inline">\(O(nlogn + q)\)</span> 。</p><a id="more"></a>




<p>这两个做法烂大街了，是基础中的基础，不是本文讨论重点。</p>
<h2 id="区间定长特殊做法">区间定长特殊做法</h2>
<p>即所有的询问区间的长度都为与询问无关的定值 <span class="math inline">\(len\)</span> 。<br>
直接当做任意区间做，可以做到 <span class="math inline">\(O(n + qlogn)\)</span> 或 <span class="math inline">\(O(nloglen + q)\)</span> 。</p>
<p>这种情况下有更好理解的预处理方法，只需优先队列。<br>
先把 <span class="math inline">\([1, l]\)</span> 的数扔进优先队列里，之后不断把区间右移，<br>
<span class="math inline">\([l, r]\)</span> 右移的过程相当于加一个点 <span class="math inline">\(r + 1\)</span> 并删掉点 <span class="math inline">\(l\)</span> ，用优先队列维护即可。<br>
复杂度 <span class="math inline">\(O(nlogn + q)\)</span> 。</p>
<p>但这还不够，还有线性的预处理方法，用单调双端队列代替上面的优先队列。<br>
同样是让区间不断右移，单调双端队列中的值是单调不增的， 那么最左边的值一定是最大值。<br>
加点 <span class="math inline">\(r + 1\)</span> 前维护单调性，删点 <span class="math inline">\(l\)</span> 时判断是不是删的最大值， 如果是就删点最左边的点即可。<br>
复杂度 <span class="math inline">\(O(n + q)\)</span> 。</p>
<h2 id="随机询问期望做法">随机询问期望做法</h2>
<p>这种情况下有个 <span class="math inline">\(O(n + q)\)</span> 的在线做法。</p>
<p>考虑分块，设块的大小为 <span class="math inline">\(b\)</span> ， <span class="math inline">\(O(n)\)</span> 预处理每个块的最大值。</p>
<p>那么对于询问 <span class="math inline">\([l, r]\)</span> ，若该区间跨过了多个块，问题就分为两个部分：</p>
<ol type="1">
<li>求跨过的块区间的最大值。</li>
<li>求两端点所在零散的块的最大值。</li>
</ol>
<p>第一个问题就是个子问题，并且数据规模减小到了 <span class="math inline">\(O(\frac{n}{b})\)</span> ，<br>
为了保证询问 <span class="math inline">\(O(1)\)</span> ，可以用上面一般性的普通做法提到的 ST 表，<br>
就可以 <span class="math inline">\(O(\frac{n}{b} log\frac{n}{b})\)</span> 进行预处理然后 <span class="math inline">\(O(1)\)</span> 询问。</p>
<p>第二个问题端点所在零散的块是该块的一段前缀或者后缀，<br>
只需 <span class="math inline">\(O(n)\)</span> 对于每个块预处理前缀最大值和后缀最大值即可 <span class="math inline">\(O(1)\)</span> 询问。</p>
<p>那么若询问区间在同一个块内呢？<br>
自然是暴力扫，但是这样的复杂度是 <span class="math inline">\(O(b)\)</span> 的。<br>
但询问区间随机的情况下，不难得出两个端点在同一个块内的概率是 <span class="math inline">\(\frac{b}{n}\)</span> 。<br>
那么这种情况询问的期望复杂度是 <span class="math inline">\(O(\frac{b^2}{n})\)</span> 的。</p>
<p>总复杂度 <span class="math inline">\(O(n + \frac{n}{b} log\frac{n}{b} + q + q \frac{b^2}{n})\)</span> 。<br>
当 <span class="math inline">\(b\)</span> 至少为 <span class="math inline">\(O(logn)\)</span> 时，预处理的 <span class="math inline">\(O(\frac{n}{b} log\frac{n}{b})\)</span> 不超过 <span class="math inline">\(O(n)\)</span> 。<br>
当 <span class="math inline">\(b\)</span> 至多为 <span class="math inline">\(O(\sqrt{n})\)</span> 时，询问的 <span class="math inline">\(O(q \frac{b^2}{n})\)</span> 不超过 <span class="math inline">\(O(q)\)</span> 。<br>
因此 <span class="math inline">\(b\)</span> 的大小取 <span class="math inline">\(O(logn)\)</span> 到 <span class="math inline">\(O(\sqrt{n})\)</span> 之间即可。</p>
<p>另外，当 <span class="math inline">\(b = \sqrt{n}\)</span> 时，块的个数也是 <span class="math inline">\(O(\sqrt{n})\)</span> 的，<br>
此时根本不需要 ST 表，直接 <span class="math inline">\(O(\sqrt{n}^2)\)</span> 暴力预处理处理所有可能区间的最大值即可。<br>
这样复杂度不变，常数可能还能小一点。</p>
<h4 id="毒瘤活动">毒瘤活动</h4>
<p>值得注意的是，虽然这个做法的复杂度仅适用于询问区间随机的情况，但是一般不会卡。</p>
<p>来点有意思的娱乐活动，考虑怎么卡掉它，以及怎么防止被出题人卡。</p>
<p>想要卡这个做法就要尽量让询问区间在一个块内，卡成 <span class="math inline">\(O(b)\)</span> 的询问复杂度。<br>
但在不知道块的大小的情况下，假设给一个区间长 <span class="math inline">\(len\)</span> 的询问，实际块的大小为 <span class="math inline">\(b\)</span> ，<br>
那么两个端点在同一个块内的概率大概是 <span class="math inline">\(\frac{b-len+1}{b}\)</span> ，期望复杂度就是 <span class="math inline">\(O(\frac{(b-len+1)len}{b})\)</span> 。</p>
<p>现在出题人要在不知道 <span class="math inline">\(b\)</span> 的情况下希望上面的复杂度尽量大，选手要在不知道 <span class="math inline">\(len\)</span> 的情况下希望上面复杂度尽量小。<br>
<del>怎么感觉像博弈论</del></p>
<p>最坏的情况是 <span class="math inline">\(len = \frac{b}{2}\)</span> 的时候，此时询问的期望复杂度为 <span class="math inline">\(O(\frac{b}{4})\)</span> 。<br>
选手希望预处理和询问的复杂度最大值最小，也就是让它们相等，此时 <span class="math inline">\(b\)</span> 的最优取值大致为 <span class="math inline">\(2\sqrt{\frac{n}{q} logn}\)</span> ，<br>
这里说是“大致”，是因为为了方便计算将 <span class="math inline">\(O(log \frac{n}{b})\)</span> 看做了 <span class="math inline">\(O(logn)\)</span> 。<br>
将 <span class="math inline">\(n, q\)</span> 看做同阶的话，上述取值为 <span class="math inline">\(2\sqrt{logn}\)</span> ，此时复杂度为 <span class="math inline">\(O(\frac{n\sqrt{logn}}{2})\)</span> ，<br>
也就是 <span class="math inline">\(O(n\sqrt{logn})\)</span> ，得出结论，在询问区间非随机的情况下，该算法最优可以做到严格 <span class="math inline">\(O(n\sqrt{logn})\)</span> 。</p>
<p>关键这算法常数小，还好写，取 b 为 <span class="math inline">\(O(\sqrt{logn})\)</span> 的话，复杂度 <span class="math inline">\(O((n + q)\sqrt{logn})\)</span> 在绝大多数情况都足够了。</p>
<p>另外，此时没必要维护块内前缀后缀最大值，因为块足够小，询问的时候对零散的块暴力扫就好了，复杂度不变。</p>
<h2 id="一般性较优做法">一般性较优做法</h2>
<p>自己 yy 出来的，权当过渡吧。</p>
<p>上面提到的 <span class="math inline">\(O((n + q)\sqrt{logn})\)</span> 算法中，通过分块将问题规模缩小到了 <span class="math inline">\(\frac{n}{b}\)</span> ，<br>
然后对于这个规模的问题使用 ST 表，预处理复杂度近似看做 <span class="math inline">\(O(\frac{n}{b}logn)\)</span> 。<br>
而既然这是个子问题，为什么还要用 ST 表？能不能继续分块直到 ST 表的预处理复杂度在 <span class="math inline">\(O(n)\)</span> 以内？</p>
<p>当然是可以的，这个时候块的大小又要取多少呢？<br>
取 <span class="math inline">\(b = 2\)</span> 就够了，这个时候，相当于从底层向上建线段树，<br>
第一层有 <span class="math inline">\(n\)</span> 个节点，第二层有 <span class="math inline">\(\frac{n}{2}\)</span> 个节点，第三层有 <span class="math inline">\(\frac{n}{4}\)</span> 个节点，<br>
直到某一层只有 <span class="math inline">\(\frac{n}{logn}\)</span> 个节点时，不再向上建线段树，而是用 ST 表维护这 <span class="math inline">\(\frac{n}{logn}\)</span> 个点，<br>
这样 ST 表的预处理就是 <span class="math inline">\(O(n)\)</span> 的，而此时这个线段树的树高是 <span class="math inline">\(O(loglogn)\)</span> 的。</p>
<p>总时间复杂度 <span class="math inline">\(O(n + qloglogn)\)</span> ，事实上层数可以再少点，使得 ST 表预处理不严格 <span class="math inline">\(O(n)\)</span> 而是与询问复杂度相当，<br>
但这样的话最优的层数难以计算，在此不讨论。</p>
<h4 id="毒瘤活动-1">毒瘤活动</h4>
<p>从下向上建线段树太麻烦了，怕不是要写 zkw ，考虑从上向下建。<br>
由于最上面一层有 <span class="math inline">\(\frac{n}{logn}\)</span> 个节点，每个节点管辖的区间大小为 <span class="math inline">\(logn\)</span> ，<br>
继续考虑分块，以 <span class="math inline">\(b = logn\)</span> 为块大小分块，那么就是块内直接建满的线段树，块间维护 ST 表。</p>
<p><del>卧槽怎么又回到前面的做法了</del></p>
<p>那么这个算法事实上就是通过线段树保证了块间查询严格 <span class="math inline">\(logb\)</span> ，也就是 <span class="math inline">\(loglogn\)</span> 。</p>
<p>既然这样，为什么一定要用线段树呢？在每个块内依然维护 ST 表，复杂度就是 <span class="math inline">\(O(nloglogn + q)\)</span> 。</p>
<p>通过上面的各种讨论，相信读者已经明白分块 RMQ 的强大，以及线段树和 ST 表（尤其是后者）在 RMQ 的重要性。<br>
分块什么这么多东西目的基本就是去平衡 ST 表 / 线段树的询问和预处理的复杂度。</p>
<p>update: 后来知道这玩意叫四个俄罗斯人算法 (Four Russian) 。</p>
<h2 id="一般性标准做法">一般性标准做法</h2>
<p>标准的 <span class="math inline">\(O(n + q)\)</span> RMQ 。</p>
<p>离线的话可以建笛卡尔树将 RMQ 转换为 LCA ，然后用 Tarjan 处理。<br>
明显的缺点是离线，并且空间开销较大。</p>
<p>在线的话，有一个经典的常用做法，还是建笛卡尔树转 LCA ，然后求出树的欧拉序转为 +-1 RMQ 。<br>
而 +-1 RMQ 也是通过分块实现 <span class="math inline">\(O(n + q)\)</span> 复杂度的，<br>
利用的是 +-1 RMQ 的差分数组在每个块内只有 <span class="math inline">\(2^b\)</span> 中可能，其中 <span class="math inline">\(b\)</span> 是块大小，取 <span class="math inline">\(logn\)</span> 。<br>
整个过程较为复杂，在 OI 中实用性较低，具体做法留个坑，到时候再补。</p>
<p>这里重点介绍另一个同样能做到在线 + 线性的 RMQ 算法，并且相对于上面的做法更简单，常数也更优秀。</p>
<h4 id="线性-rmq">线性 RMQ</h4>
<p>该算法改进自之前在随机数据下的分块 RMQ ，<br>
注意到当块大小为 <span class="math inline">\(O(logn)\)</span> 时，该算法唯一的瓶颈在于询问端点在同一个块内时需要暴力 <span class="math inline">\(O(logn)\)</span> 扫。<br>
单独考虑每个块，考虑优化询问端点在该块的情况。<br>
其中块大小为 <span class="math inline">\(b = O(logn)\)</span> 。</p>
<p>利用之前提到的单调队列做法，如果对于每个点暴力存下块的左端点到该点的单调递减队列，<br>
那么对于询问 [l, r] ，拿出 r 上的单调队列，在单调队列上找到第一个不小于 l 的位置，该位置上的值即区间最大值。<br>
由于单调队列的大小是 <span class="math inline">\(O(b)\)</span> 即 <span class="math inline">\(O(logn)\)</span> 的，该做法复杂度 <span class="math inline">\(O((n + q)logn)\)</span> 。</p>
<p>但是该做法有很大优化空间，由于 <span class="math inline">\(b\)</span> 足够小（一般认为它不超过字长 <span class="math inline">\(w\)</span> ），完全可以将每个点的单调队列状压，<br>
这样预处理的时空复杂度就降到了 <span class="math inline">\(O(n)\)</span> 。<br>
然后对于询问一个单调队列上第一个不小于 l 的位置，就是在一个二进制数 <span class="math inline">\(x\)</span> 上询问第一个位数不小于 l 的 1 的位数。<br>
这通过位运算和内置函数可以很好实现，只需将 <span class="math inline">\(x\)</span> 右移 <span class="math inline">\(l mod b\)</span> 位来去掉单调队列上小于 l 的位置，<br>
然后通过 <code>__builtin_ctz</code> <span class="math inline">\(O(1)\)</span> 找到第一个 1 的位置即可。<br>
这样询问的复杂度就降到了 <span class="math inline">\(O(1)\)</span> ，总复杂度 <span class="math inline">\(O(n + q)\)</span> ，常数非常优秀。</p>
<h4 id="完整实现">完整实现</h4>
<p>以 bzoj1699 为例，该题的 rank1 就是用了这个线性 RMQ 做法，本人常数大，但还是狗到了 rank6 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> io &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> SIZE = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - <span class="number">1</span>, c, qu[<span class="number">55</span>]; <span class="keyword">int</span> f, qr, flg;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		fwrite (obuf, <span class="number">1</span>, <span class="keyword">size_t</span>(oS - obuf), <span class="built_in">stdout</span>);</span><br><span class="line">		oS = obuf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span> <span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">		*oS ++ = x;</span><br><span class="line">		<span class="keyword">if</span> (oS == oT) flush ();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">inline</span> <span class="title">int</span> <span class="title">gi</span> (<span class="title">I</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">		<span class="keyword">for</span> (f = <span class="number">1</span>, c = gc(); c != EOF &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>); c = gc()) <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (flg = x = <span class="number">0</span>; c != EOF &amp;&amp; c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>; c = gc()) flg = <span class="number">1</span>, x = x * <span class="number">10</span> + (c &amp; <span class="number">15</span>); x *= f;</span><br><span class="line">		<span class="keyword">return</span> flg || c != EOF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">inline</span> <span class="title">void</span> <span class="title">print</span> (<span class="title">I</span> <span class="title">x</span>) &#123;</span></span><br><span class="line">		<span class="keyword">if</span> (!x) pc (<span class="string">'0'</span>); <span class="keyword">if</span> (x &lt; <span class="number">0</span>) pc (<span class="string">'-'</span>), x = -x;</span><br><span class="line">		<span class="keyword">while</span> (x) qu[++ qr] = x % <span class="number">10</span> + <span class="string">'0'</span>,  x /= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">while</span> (qr) pc (qu[qr --]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Flusher_</span> &#123;</span>~Flusher_()&#123;flush();&#125;&#125;io_flusher_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">int</span> <span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="keyword">return</span> io::gi(x), x; &#125;</span><br><span class="line">&#125; read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>, maxs = <span class="number">20005</span>, maxb = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + maxb];</span><br><span class="line"><span class="keyword">int</span> highbit[maxs];</span><br><span class="line"><span class="keyword">int</span> stmax[maxs][maxb], stmin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> premax[maxs][maxb], premin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> sufmax[maxs][maxb], sufmin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> quemax[maxs][maxb], quemin[maxs][maxb];</span><br><span class="line"><span class="keyword">int</span> stackmax[maxb], stackmin[maxb];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y &gt; x) x = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y &lt; x) x = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = read, q = read;</span><br><span class="line">	<span class="keyword">int</span> B = <span class="keyword">int</span>(log2(n));</span><br><span class="line">	<span class="keyword">int</span> S = (n - <span class="number">1</span>) / B + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; S; b ++)</span><br><span class="line">		stmin[b][<span class="number">0</span>] = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">		a[i] = read;</span><br><span class="line">		chkmin(stmin[i / B][<span class="number">0</span>], a[i]);</span><br><span class="line">		chkmax(stmax[i / B][<span class="number">0</span>], a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> b = S - <span class="number">1</span>; b &gt;= <span class="number">0</span>; b --)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; b + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt; S; k ++) &#123;</span><br><span class="line">			stmin[b][k] = min(stmin[b][k - <span class="number">1</span>], stmin[b + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k - <span class="number">1</span>]);</span><br><span class="line">			stmax[b][k] = max(stmax[b][k - <span class="number">1</span>], stmax[b + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; S; b ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> be = b * B;</span><br><span class="line">		premin[b][<span class="number">0</span>] = premax[b][<span class="number">0</span>] = a[be];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; B; k ++) &#123;</span><br><span class="line">			premin[b][k] = min(premin[b][k - <span class="number">1</span>], a[be + k]);</span><br><span class="line">			premax[b][k] = max(premax[b][k - <span class="number">1</span>], a[be + k]);</span><br><span class="line">		&#125;</span><br><span class="line">		sufmin[b][B - <span class="number">1</span>] = sufmax[b][B - <span class="number">1</span>] = a[be + B - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = B - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k --) &#123;</span><br><span class="line">			sufmin[b][k] = min(sufmin[b][k + <span class="number">1</span>], a[be + k]);</span><br><span class="line">			sufmax[b][k] = max(sufmax[b][k + <span class="number">1</span>], a[be + k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; S; b ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> be = b * B;</span><br><span class="line">		<span class="keyword">int</span> spmin = <span class="number">0</span>, nowmin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> spmax = <span class="number">0</span>, nowmax = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B; i ++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(spmin <span class="keyword">and</span> a[be + stackmin[spmin]] &gt; a[be + i])</span><br><span class="line">				nowmin ^= <span class="number">1</span> &lt;&lt; stackmin[spmin --];</span><br><span class="line">			<span class="keyword">while</span>(spmax <span class="keyword">and</span> a[be + stackmax[spmax]] &lt; a[be + i])</span><br><span class="line">				nowmax ^= <span class="number">1</span> &lt;&lt; stackmax[spmax --];</span><br><span class="line">			quemin[b][i] = (nowmin ^= <span class="number">1</span> &lt;&lt; (stackmin[++ spmin] = i));</span><br><span class="line">			quemax[b][i] = (nowmax ^= <span class="number">1</span> &lt;&lt; (stackmax[++ spmax] = i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= S; i ++)</span><br><span class="line">		highbit[i] = highbit[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q --) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = read - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> r = read - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> L = l / B, R = r / B;</span><br><span class="line">		<span class="keyword">int</span> li = l % B, ri = r % B;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> min = <span class="number">1000000000</span>, max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(L == R) &#123;</span><br><span class="line">			chkmin(min, a[l + __builtin_ctz(quemin[R][ri] &gt;&gt; li)]);</span><br><span class="line">			chkmax(max, a[l + __builtin_ctz(quemax[R][ri] &gt;&gt; li)]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			chkmin(min, sufmin[L][li]);</span><br><span class="line">			chkmin(min, premin[R][ri]);</span><br><span class="line">			chkmax(max, sufmax[L][li]);</span><br><span class="line">			chkmax(max, premax[R][ri]);</span><br><span class="line">			<span class="keyword">int</span> len = R - L - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> k = highbit[len];</span><br><span class="line">			<span class="keyword">if</span>(len) &#123;</span><br><span class="line">				chkmin(min, stmin[L + <span class="number">1</span>][k]);</span><br><span class="line">				chkmin(min, stmin[R - (<span class="number">1</span> &lt;&lt; k)][k]);</span><br><span class="line">				chkmax(max, stmax[L + <span class="number">1</span>][k]);</span><br><span class="line">				chkmax(max, stmax[R - (<span class="number">1</span> &lt;&lt; k)][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* printf("%d\n", max - min); */</span></span><br><span class="line">		io::print(max - min);</span><br><span class="line">		io::pc(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>O(1)</tag>
        <tag>RMQ</tag>
        <tag>分块</tag>
        <tag>线段树</tag>
        <tag>ST 表</tag>
        <tag>算法扩展</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>搬迁</title>
    <url>/2019/10/10/%E6%90%AC%E8%BF%81/</url>
    <content><![CDATA[<p><strong>由于 github.io 实在太慢，搞了个<del>还是很慢的</del>镜像站：https://kewth.netlify.app/ 。</strong></p><p>没什么好说的，动态博客用烦了，搞了好多花里胡哨的东西，<br>
还是沉下心来，好好写博客，<br>
既然如此，就不打算做什么美化了，基本能用就行，勿喷。</p><p>另外 hexo 的公式渲染有点 shit ，哪里的公式挂了还请提醒。<br>
关于公式：如果公式渲染有问题，请右键公式，点击：math settings -&gt; math renderer -&gt; common html 。<br>
还有日期为 2019.10.01 的都是旧博客直接搬的，并非真实日期，越早期的文章格式可能越屑。</p><a id="more"></a>


<p><del>可是我控制不住我记几啊，总感觉不顺眼，实在忍不住去折腾 QwQ</del></p>
]]></content>
  </entry>
  <entry>
    <title>O(1)黑科技</title>
    <url>/2019/10/10/O(1)%E9%BB%91%E7%A7%91%E6%8A%80/</url>
    <content><![CDATA[<p><span class="citation" data-cites="CYJian">@CYJian</span> 出了一道黑科技二合一，我就顺便跟着学了学。</p><h2 id="o1-gcd">O(1) gcd</h2><p>在 O(V) 的预处理后可以做到 O(1) 查询 gcd ，其中 V 是权值的大小。</p><p>主要利用到的一个性质是可以将任意 x 分解为三个数 a * b * c ， a, b, c 分别满足以下两个条件之一：</p><ol type="1">
<li>不超过 <span class="math inline">\(\sqrt{x}\)</span> 。</li>
<li>是质数。</li>
</ol><a id="more"></a>




<p>update: 之前写假了，感谢 <span class="citation" data-cites="CYJian">@CYJian</span> 的 hack 。</p>
<p>zzq 把满足这个性质的分解称为“迷之分解”，那我也这么叫吧。</p>
<p>考虑证明一下，顺便构造一个“迷之分解”。</p>
<p>找到 x 的最小质因子 p ，然后假设已知 x / p 的“迷之分解” A, B, C (A &lt;= B &lt;= C) 。<br>
那么把 p 乘到 A 上就可以得到 x 的“迷之分解” A * p, B, C 。<br>
分类讨论，如果 p 不超过 <span class="math inline">\(\sqrt[4]{x}\)</span> ，由于 A 是 A, B, C 三者中最小的，<br>
一定满足 A 不超过 <span class="math inline">\(\sqrt[3]{x/p}\)</span> ，那么可得：</p>
<p><span class="math display">\[A \cdot p \leq \sqrt[3]{x/p} \cdot p = \sqrt[3]{xp^2} \leq \sqrt{x}\]</span></p>
<p>而如果 p 超过 <span class="math inline">\(\sqrt[4]{x}\)</span> ，由于 p 是最小质因子，<br>
那么如果 x 的“迷之分解”有合数 C ， C 至少是 <span class="math inline">\(p^2\)</span> ，超过 <span class="math inline">\(\sqrt{x}\)</span> ，<br>
那么 B 的大小就会比 p 小，与 p 是最小质因子矛盾，<br>
因而此时 x 的“迷之分解”全是质数。</p>
<p>“迷之分解”的分析就是这样，通过线性筛可以很好预处理出 O(V) 内的所有数的“迷之分解”。<br>
只需筛出每个数的最小质因子即可按上述方法递推出“迷之分解”。<br>
然后只需预处理出 <span class="math inline">\(O(\sqrt{V})\)</span> 内两两的 gcd ，为了不带 log ，需要递推预处理。<br>
此时求 gcd(x, y) 只需对于 x 的“迷之分解” A, B, C 依次对 y 求 gcd （每次求 gcd 后把 y 除以该 gcd ），<br>
以 A 为例，如果 A 不超过 <span class="math inline">\(\sqrt{x}\)</span> ，直接查表可以得到 gcd(A, y) （查的是 gcd(A mod y, A) ），<br>
否则 A 为质数，简单讨论一下就可以得到 gcd(A, y) 了。</p>
<p>关键部分参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> magic[maxv][<span class="number">3</span>]; <span class="comment">// 每个数的“迷之分解”</span></span><br><span class="line"><span class="keyword">int</span> gcd[maxb][maxb]; <span class="comment">// 预处理的 gcd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> X = magic[x][i];</span><br><span class="line">		<span class="keyword">int</span> d;</span><br><span class="line">		<span class="keyword">if</span>(X &lt; maxb)</span><br><span class="line">			d = gcd[X][y % X];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(y % X)</span><br><span class="line">			d = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			d = X;</span><br><span class="line">		res *= d;</span><br><span class="line">		y /= d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="o1-快速幂">O(1) 快速幂</h2>
<p>在 <span class="math inline">\(O(\sqrt{p})\)</span> 的预处理后可以做到对于一个固定的底数 O(1) 查询快速幂，<br>
其中 p 是模数（或者上式是 <span class="math inline">\(\sqrt{\phi(p)}\)</span> ），或者是指数的范围。</p>
<p>这个就简单得多，对于每个 <span class="math inline">\(a^k\)</span> 的指数 k 都可以表示为 <span class="math inline">\(a \sqrt{p} + b\)</span> 的形式，<br>
满足 <span class="math inline">\(a, b &lt; \sqrt{p}\)</span> ，分别预处理即可，<br>
即预处理 <span class="math inline">\(a^0, a^1, a^2 ... a^{\sqrt{p}}, a^{2\sqrt{p}}, a^{3\sqrt{p}} ... a^p\)</span> 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>gcd/lcm</tag>
        <tag>快速幂</tag>
        <tag>黑科技</tag>
        <tag>O(1)</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分</title>
    <url>/2019/10/10/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>不久前学了整体二分，做了几道题，还在考试上派上用场过几次。<br>
觉得自己大概懂了整体二分，直到一次碰上了强制在线的毒瘤题。。。</p><p><del>整体二分：从离线到强制在线</del></p><h2 id="基础">基础</h2><p>大概讲讲整体二分吧。</p><p>整体二分大概用于这样一个场景：<br>
有多组询问，每个询问可以二分，但是每个询问二分的时间不能接受，<br>
而不同询问的二分有共同点，这时就可以用整体二分把多个询问一起二分。<br>
所以这是个离线算法。</p><a id="more"></a>




<p>流程大概是这样的：<br>
对于当前确定的区间 [L, R] ，取 M 为区间中点，<br>
对于当前在确定在这个区间的每个询问进行 check ，<br>
然后判断每个询问接下来是到 [L, M] 还是 [M + 1, R] 。<br>
当 L = R 时，就得到了处理到这个区间的询问的答案。</p>
<p>每个询问还是进行了 O(logV) 次 check ，<br>
但是和直接二分不同的是，一般在每个区间内进行预处理后 check 可以做到 O(1) 或者 O(logn) 等，<br>
一般需要数据结构维护（常见的有并查集，树状数组，线段树）。</p>
<h2 id="栗子">栗子</h2>
<p>就说静态区间第 k 大吧，当然可以用主席树搞，但是此处讨论整体二分。</p>
<p>对于每个询问 [l, r] ，可以二分答案 x ，<br>
然后 check 不超过 x 的数量，与 k 进行比较即可得出接下来该询问的答案区间。</p>
<p>直接 check 是 O(V) 的，当然可以直接用数据结构维护，但是此处讨论整体二分。</p>
<p>当前的答案区间是 [L, R] ，有若干询问的答案已经确定在这个区间内，<br>
取中点 M ，维护值在 [L, M] 的每个数，对于每个询问就可以 O(logn) check 了，<br>
然后如果询问 k 的答案在 [M + 1, R] ，那么 k 要减去当前 check 的值，以消去 [L, M] 的影响。<br>
另外处理后要清空 [L, M] 的影响。</p>
<p>这样做复杂度是 <span class="math inline">\(O(q logV logn)\)</span> 的。</p>
<p>另一个实现是维护值在 [1, M] 的每个数，<br>
二分到 [L, M] 前先把 [L, M] 的影响撤销掉，<br>
二分到 [M + 1, R] 前只需在二分 [L, M] 时保证算上了 [L, M] 的贡献即可。<br>
这样做的好处是避开了删除，有些用并查集的操作就可以实现了。</p>
<p>这样做复杂度同样是 <span class="math inline">\(O(q logV logn)\)</span> 的。</p>
<h2 id="带修">带修</h2>
<p>就说带修区间第 k 大。</p>
<p>将修改和查询统称为操作，只需保证操作在二分中的相对顺序，<br>
处理答案在 [L, R] 的区间时按顺序做，碰到修改就修改，碰到查询就 check 。<br>
但是修改哪来的答案？对于修改操作，只需将它放到它能影响的答案区间即可。<br>
例如修改 <span class="math inline">\(a_i = x\)</span> ，分为两个操作：删除 <span class="math inline">\(a_i\)</span> 和添加 <span class="math inline">\(a_i = x\)</span> 。<br>
前者的影响的区间需要包括 <span class="math inline">\(a_i\)</span> ，后者影响的区间需要包括 <span class="math inline">\(x\)</span> 。</p>
<p>同样有两个实现，复杂度都是 <span class="math inline">\(O(q logV logn)\)</span> 。</p>
<h2 id="在线">在线</h2>
<p>毒瘤的地方来了，整体二分做强制在线。<br>
这也是本文的真正讨论重点。</p>
<p>还是拿静态区间第 k 大分别讨论上述的两种实现。</p>
<h3 id="实现-1">实现 1</h3>
<p>单独考虑一个询问 q ，观察它在整体二分中答案区间的移动过程。<br>
假设当前二分到区间 [L, R] ，<br>
q 能在整体二分中 O(logn) check 是因为权值在 [L, R] 的数被维护进了一个数据结构。<br>
那如果 q 到达的所有可能答案区间的数据结构都提前构造好了，<br>
q 就不需要整体二分，而可以直接在线询问。</p>
<p>而所有可能的答案区间事实上形成了一个线段树的结构。<br>
上面已经说到要求每个可能的答案区间的数据结构已经提前维护。<br>
对应在线段树中就是线段树的每个节点都有数据结构维护该节点对应的答案区间。<br>
在本题中就是要权值线段树套区间树状数组，<br>
而为了节省空间开销，需要换成权值线段树套区间线段树。<br>
这样把每个数先按取值找到对应的外层线段树，再按位置加到对应的内层线段树，<br>
每个询问 (l, r, k) 就在外层线段树上二分，在内层线段树查询区间 [l, r] 的数的个数。</p>
<p>时间复杂度依然是 <span class="math inline">\(O(q logV logn)\)</span> 的，但是空间复杂度为 <span class="math inline">\(O(V + n logV logn)\)</span> 。</p>
<p>不难推广到更一般的情况，所有不带修的<strong>整体二分实现 1 + 数据结构 A</strong>， 都可以用<strong>线段树套数据结构 A</strong> 做到在线询问。<br>
时间复杂度不变，但是空间开销会乘上 <span class="math inline">\(O(n)\)</span> ，<br>
而当<strong>数据结构 A</strong> 支持动态开空间，即空间开销与修改次数 <span class="math inline">\(q\)</span> 成函数关系 <span class="math inline">\(O(qk)\)</span> 时，<br>
这样就只会带来 <span class="math inline">\(O(n logV k)\)</span> 的额外空间开销。</p>
<p>另外，这是可以支持带修的，对于修改操作，在线段树上找到影响的节点，<br>
然后直接去修改节点上的<strong>数据结构 A</strong> 即可。</p>
<h3 id="实现-2">实现 2</h3>
<p>还是单独考虑一个询问 q ，此时它在整体二分中答案区间的移动过程固然还是线段树的形式。<br>
但是不同的是，此时线段树的每个节点 [L, R] 需要保存维护 [1, R] 的数据结构，<br>
换言之，不同节点之间相互不独立。<br>
但既然所有需要的数据结构都是维护 [1, K] 这样的前缀形式，<br>
不难想到可持久化，每个维护 [1, K] 的数据结构在维护 [1, K - 1] 的数据结构上修改即可。</p>
<p>具体到静态区间第 k 大，按权值递增的顺序建可持久化区间线段树（树状数组难以可持久化）。<br>
对于每个询问 (l, r, k) 二分答案 x 时只需要在第 x 颗区间线段树上查询 [l, r] 的数的个数。</p>
<p>时间复杂度自然还是 <span class="math inline">\(O(q logV logn)\)</span> 的，空间复杂度为 <span class="math inline">\(O(V + n logn)\)</span> 。</p>
<p>同样可以推广到更一般的情况，所有不带修的<strong>整体二分实现 2 + 数据结构 A</strong>， 都可以用<strong>可持久化数据结构 A</strong> 做到在线询问。<br>
在可持久没有额外时间开销的前提下，时间复杂度不变，<br>
否则若可持久化会带来 <span class="math inline">\(O(k)\)</span> 的额外时间复杂度，这样做的时间复杂度同样需要乘上 <span class="math inline">\(O(k)\)</span> 。<br>
可持久化并查集就是个典型的例子。<br>
同样空间复杂度也要乘上可持久化带来的额外开销。</p>
<p>可惜的是，这不能很好的支持修改，因为每个修改影响到的历史版本是 <span class="math inline">\(O(V)\)</span> 级别的。</p>
<h2 id="总结">总结</h2>
<p>事实上做到在线后，干脆抛弃了整体二分的“整体查询”的思想，其实就和整体二分没什么关系了。<br>
那么整体二分究竟是个什么玩意？<br>
事实上绝大多数整体二分都无法做到比直接数据结构的时间复杂度优秀，<br>
而且经过上述的讨论不难发现绝大多数整体二分都能直接被数据结构替代，<br>
也因此整体二分往往被归在“骗分”，“非正解”一类。</p>
<p>不过整体二分明显的优势在于空间复杂度和实现难度。 不过有时经过整体二分的转换后，就可以使用无法可持久化，或者空间开销大的数据结构，<br>
上面的树状数组就是很好的例子，无论是实现 1 还是实现 2 ，做到在线都必须换成线段树。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法扩展</tag>
        <tag>二分</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>整除分块</title>
    <url>/2019/10/10/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>（以下的除号皆表示整除）</p><p>用数论函数计算的时候，总会遇到这样一种问题： <span class="math inline">\(\sum_{i=1}^n f(\frac{n}{i})\)</span> 。 <span class="math inline">\(O(n)\)</span> 求往往无法满足需要。</p><p>但是<del>打表</del>可以发现， n/i 的取值对于一段连续的 i 是一致的， 那么可以考虑一块一块求。</p><p>设已知当前块的左端点为 l ，如果知道右端点 r（左闭右开），意味着 <span class="math inline">\(\forall l&lt;=i&lt;r, \frac{n}{i} = \frac{n}{l}\)</span> ， 这一块对答案的贡献就是 <span class="math inline">\((r-l) \times f(\frac{n}{l})\)</span> 。</p><a id="more"></a>



<p>结论是 <span class="math inline">\(r = n / (n / l) + 1\)</span> 。</p>
<p>证明：</p>
<ul>
<li>对于 l 设 <span class="math inline">\(n / l = x\)</span></li>
<li>那么由 <span class="math inline">\(n \mod l = n - n / l \cdot l = n - l \cdot x\)</span> 可知 $ n - l x  $</li>
<li>那么若 <span class="math inline">\(l + 1\)</span> 满足 <span class="math inline">\(n / (l + 1) = n / l\)</span> ，可知也有 <span class="math inline">\(n - (l + 1) \cdot x \geq 0\)</span></li>
<li>即 <span class="math inline">\(n - l \cdot x \geq x\)</span></li>
<li>对于 k 若 <span class="math inline">\(n / k = n / l\)</span> 而 <span class="math inline">\(n / (k + 1) != n / l\)</span></li>
<li>那么根据上式可得 k 满足 $ 0 n - k x &lt; x$</li>
<li>所以 <span class="math inline">\(n - k \cdot x = n \mod x = n - n / x \cdot x\)</span></li>
<li>所以 <span class="math inline">\(k = n / x = n / (n / l)\)</span></li>
<li>由 k 的定义 <span class="math inline">\(n / k = n / l \&amp; n / (k + 1) != n / l\)</span> 可知 k+1 即是要求的 r</li>
</ul>
<p>那么可以枚举块，当前 l,r 可以求得，下一个块的 l 显然是当前 r。</p>
<p>有时候会有点变化：</p>
<p>要求 <span class="math inline">\(\sum_{i=1}^{min(n, m)} f(\frac{n}{i}) \cdot f(\frac{m}{i})\)</span> 。</p>
<p>还是会存在 <span class="math inline">\(\forall l \le i &lt; r, \frac{n}{i} = \frac{n}{l} \&amp; \frac{m}{i} = \frac{m}{l}\)</span> 。</p>
<p>所以这样的区间的右端点为：<span class="math inline">\(r = min(n / (n / l), m / (m / l)) + 1\)</span> 。</p>
<p>所以还是可以一块一块的枚举求和。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>类欧几里得</title>
    <url>/2019/10/10/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    <content><![CDATA[<p>这里只是类欧几里得的一种：<br>
快速求下式： <span class="math display">\[f(a, b, c, n) = \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor\]</span></p><p>其中 a, b, c, n 都是正整数。</p><h2 id="缩小-a-b-规模">缩小 a, b 规模</h2><p>首先的目标是让 a, b 小于 c 。</p><p>结论 1 ：<br>
<span class="math display">\[\lfloor \frac{Ax+B}{y} \rfloor =
\lfloor \frac{A(x\%y)+B}{y} \rfloor + A\lfloor \frac{x}{y} \rfloor\]</span></p><a id="more"></a>




<p>证明：<br>
首先用到整除与取模的转换： <span class="math inline">\(\lfloor \frac{x}{y} \rfloor = \frac{x-x\%y}{y}\)</span> 。<br>
得到原命题等价于：<br>
<span class="math display">\[\frac{Ax+B-(Ax+B)\%y}{y} =
\frac{A(x\%y)+B-(Ax+B)\%y}{y} + A\frac{x-x\%y}{y}\]</span> <span class="math display">\[Ax + B - (Ax+B)\%y = A(x\%y) + B - (Ax+B)\%y + A(x-x\%y)\]</span> <span class="math display">\[Ax - (Ax+B)\%y = A(x\%y) - (Ax+B)\%y + A(x-x\%y)\]</span> <span class="math display">\[Ax = A(x\%y) + A(x-x\%y)\]</span> <span class="math display">\[Ax = A(x\%y) + Ax - A(x\%y)\]</span><br>
得证。</p>
<p>那么通过这个结论可以得知：<br>
<span class="math display">\[
\begin{equation}
\begin{aligned}
f(a, b, c, n) &amp;= \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\\\
&amp;= \sum_{i=0}^n (\lfloor \frac{(a\%c)i+b\%c}{c} \rfloor +
i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor) \\\\
&amp;= f(a\%c, b\%c, c, n) + \sum_{i=0}^n (
i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor) \\\\
\end{aligned}
\end{equation}
\]</span></p>
<p>后面那一段就是一个等差数列求和，于是 a, b 被转换为小于 c 。</p>
<h2 id="转换成子问题减小规模">转换成子问题减小规模</h2>
<p>整除除了用取模代替外，还有一种方法。</p>
<p>结论 2 ：<br>
<span class="math display">\[\lfloor \frac{x}{y} \rfloor = \sum_{i=1}^{MAX} [i \leq \frac{x}{y}]\]</span><br>
其中 MAX 是任意一个足够大的值。<br>
证明？相当于从 1 开始数，感性理解即可。</p>
<p>那么通过这个结论可以得知：<br>
<span class="math display">\[
\begin{equation}
\begin{aligned}
f(a, b, c, n) &amp;= \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor \\\\
&amp;= \sum_{i=0}^n \sum_{j=1}^{(an+b)/c} [j \leq \frac{ai+b}{c}] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [j + 1 \leq \frac{ai+b}{c}] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [cj + c \leq ai+b] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [cj + c - 1 &lt; ai+b] \\\\
&amp;= \sum_{i=0}^n \sum_{j=0}^{(an+b)/c-1} [\frac{cj+c-b-1}{a} &lt; i] \\\\
&amp;= \sum_{j=0}^{(an+b)/c-1} \sum_{i=0}^n [\frac{cj+c-b-1}{a} &lt; i] \\\\
&amp;= \sum_{j=0}^{(an+b)/c-1}
(n + 1 - \sum_{i=0}^n [i \leq \frac{cj+c-b-1}{a}]) \\\\
&amp;= \sum_{j=0}^{(an+b)/c-1}
(n - \lfloor \frac{cj+c-b-1}{a} \rfloor) \\\\
&amp;= n \lfloor \frac{an+b}{c} \rfloor -
\sum_{j=0}^{(an+b)/c-1} (\lfloor \frac{cj+c-b-1}{a} \rfloor) \\\\
&amp;= n \lfloor \frac{an+b}{c} \rfloor - f(c, c-b-1, a, (an+b)/c-1)
\end{aligned}
\end{equation}
\]</span></p>
<p>那么就得到了一个递归计算 f(a, b, c, n) 的算法，<br>
a = 0 时上式不成立，因为上面的推导有除以 a 的步骤。<br>
因此将 a = 0 作为终止状态，此时 f 的计算是常数数列求和。<br>
复杂度是对数复杂度 log(a)，因为上面的过程规模的减小速度相当于 gcd 。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树分治</title>
    <url>/2019/10/10/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="作用">作用</h2><p>线段树通过维护序列，可以维护一个承载各种操作的时间轴。</p><p>通常用于辅助一些不支持删除操作的数据结构（线性基，并查集），<br>
这种情况可以用线段树分治维护操作影响的时间来巧妙地避开删除。</p><h2 id="线段树结构">线段树结构</h2><p>线段树分治用到的线段树（以下简称线段树）是以询问的时间为键值，<br>
没有权值只有标记的线段树。</p><p>也就是线段树的一段区间对应的是一段询问（一段时间）。</p><a id="more"></a>





<p>这样的线段树只需要支持区间修改（打标记）。<br>
每一个操作都会影响一段时间，对应于线段树的区间修改。</p>
<h2 id="例题">例题</h2>
<p>这玩意需要一个例题才讲的清。<br>
（由于线段树分治用于辅助其他数据结构，再看例题前得先会线性基）</p>
<p>维护一个集合，每次操作可以加入一个数或删除一个已经存在与集合的数。<br>
每次操作后要回答这个集合的最大异或和。<br>
操作次数 1e5 。</p>
<h3 id="暴力线性基">暴力线性基</h3>
<p>如果只有插入没有删除，这题就是一遍线性基。</p>
<p>但是不巧线性基不支持删除，所以只能在每次删除后重构线性基。<br>
复杂度平方带对数，稳 T 。</p>
<h3 id="时间轴">时间轴</h3>
<p>将每次操作看做时间点，假设数 x 在时刻 l 被插入， r 被删除，<br>
那么 x 只存在于 [l, r) 这段时间，<br>
假如每个时刻开一个线性基，那么将 x 插入 [l, r) 的每个线性基，<br>
这样就可以在最后通过线性基询问得到每个时刻的答案，<br>
复杂度还是平方带对数，稳 T 的离线算法。</p>
<h3 id="线段树优化">线段树优化</h3>
<p>比较上述两种算法，<br>
第一种复杂度瓶颈在于重构线性基，实在是没有什么优化空间，<br>
但是第二种算法中，复杂度瓶颈在于将 x 插入到 [l, r) 的每个线性基，<br>
这个操作相当于一个区间修改，可以用线段树优化。</p>
<p>那么一个优秀的算法就出来了：<br>
线段树每个节点维护一个 vector （相当于懒标记），插入 x 将直接加在线段树对应区间的 vector　内。<br>
所有操作过后会得到一个只有懒标记的线段树，<br>
然后考虑如何通过这样一颗线段树得出所有答案。</p>
<h4 id="处理懒标记">处理懒标记</h4>
<p>懒标记下传？<br>
不存在的，因为懒标记是一个 vector, 下传的复杂度并不是 O(1) ，<br>
不难验证下传所有懒标记会使复杂度重回 n 方。</p>
<p>既然不能下传，那就进行 n 次单点查询？<br>
一个道理，单点查询的复杂度并不是 log(n), 这样做同样对复杂度没有优化。</p>
<p><del>那就没救了</del></p>
<h4 id="分治">分治</h4>
<p>线段树分治，不能只有线段树，还要分治啊。</p>
<p>现在需要只把每个懒标记访问一遍就得出所有答案。</p>
<p>dfs 整颗线段树（实际上就是分治），深度是 log 级别的，那么对每一个深度开一个线性基。<br>
如能能让 dfs 每个节点时该深度线性基维护的是这个节点到根的所有懒标记，<br>
最后 dfs 到每个叶子节点就可以得到该叶子节点到根的懒标记的线性基，也就可以求出这个叶子节点的答案。</p>
<p>假设当前 dfs 到 u, 深度为 d, 深度对应的线性基已经是维护其到根的懒标记。<br>
dfs 到一个新点 v 一定会使深度 + 1 ，将当前深度 d 的线性基拷贝到下个深度 d + 1 中。<br>
那么 dfs 到 v 后再将 v 的懒标记加到 d + 1 的线性基中，d + 1 的线性基也就满足了要求。<br>
通过这样的过程就能够做到只访问每个懒标记一遍。</p>
<p>这就是线段树分治了。</p>
<h2 id="真---例题">真 - 例题</h2>
<p>这两道题就没有这么裸了。</p>
<p><a href="https://www.luogu.org/problemnew/show/P3733" target="_blank" rel="noopener">洛谷八纵八横</a> （线段树分治 + 线性基）</p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4025" target="_blank" rel="noopener">BZOJ 二分图</a> （线段树分治 + 并查集）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>组合数公式</title>
    <url>/2019/10/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>$ C_n^m $ 在组合数学中的意义：在 n 个元素选 m 个元素的方案数。</p><h2 id="公式">公式</h2><h3 id="公式-1">公式 1</h3><p><span class="math display">\[ C_n^m = \frac{n!}{m! * (n-m)!} \]</span></p><p>组合数的通项公式。</p><p><strong>当要求组合数模一般模数时</strong> ，通项公式的分母可能没有逆元导致不可行。</p><h3 id="公式-2">公式 2</h3><p><span class="math display">\[ C_n^m = C_n^{n-m} \]</span></p><p>基本性质，可以由通项公式得出。</p><a id="more"></a>








<h3 id="公式-3">公式 3</h3>
<p><span class="math display">\[ C_n^m * C_m^k = C_n^k * C_{n-k}^{m-k} \]</span></p>
<h3 id="公式-4">公式 4</h3>
<p><span class="math display">\[ C_n^m = C_{n-1}^{m-1} + C_{n-1}^m \]</span></p>
<p>组合数的基本递推式。</p>
<p><strong>当要求组合数模一般模数时</strong> ，常用这种方法预处理组合数。</p>
<h3 id="公式-5">公式 5</h3>
<p><span class="math display">\[ \sum_{i=0}^n C_n^i = 2^n \]</span></p>
<p>组合意义： n 个元素选任意元素的方案数。 每个数都可以选或不选，所以方案数为 $ 2^n $ 。</p>
<p>同样可以由二项式定理： $ (x + 1)^n = _{i=0}^n C_n^i * x^i $ 得出。</p>
<h3 id="公式-6">公式 6</h3>
<p><span class="math display">\[ \sum_{i=0}^n (C_n^i)^2 = C_{2n}^n \]</span></p>
<h3 id="公式-7">公式 7</h3>
<p><span class="math display">\[ C_{n+m}^k = \sum_{i=0}^k C_n^i * C_m^{k-i} \]</span></p>
<p>从组合数学上的定义出发，在 n + m 个元素中选 k 个， 相当于先在前 n 个元素中选 i 个再在后 m 个元素中选 k - i 个。 枚举这个 i 把方案数相加就能得到最终方案数。</p>
<h3 id="公式-8">公式 8</h3>
<p><span class="math display">\[ \sum_{i=0}^n C_{k+i}^k = C_{k+n+1}^n \]</span></p>
<p>进一步可以得到下式：</p>
<p><span class="math display">\[ \sum_{i=0}^n \sum_{j=0}^m C_{i+j}^i = C_{n+m+2}^{m+1} - 1 \]</span></p>
<p>类似的还有：</p>
<p><span class="math display">\[ \sum_{i=0}^n C_{i}^k = C_{n+1}^{k+1} \]</span></p>
<h3 id="lucas-定理">Lucas 定理</h3>
<p><span class="math display">\[ C_n^m \% p = C_{n/p}^{m/p} * C_{n \% p}^{m \% p} \% p \]</span></p>
<p>常用于模数较小的组合数取模。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2019/10/10/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>（以下除号皆表示整除）<br>
对于一些式子复杂度大的数论题，或许用莫比乌斯反演可以高效解决问题。</p><p>前置技能：</p><ul>
<li><p>基本数论函数</p></li>
<li><p>狄利克雷卷积</p></li>
</ul><p>莫比乌斯函数满足 <span class="math inline">\(\mu \times I = \epsilon\)</span></p><p>即 <span class="math inline">\(\sum_{d|n}\mu(d) = [n = 1]\)</span></p><p>表达式为：</p><p><span class="math display">\[ n = 0 : \mu(n) = 1 \]</span> <span class="math display">\[ n = \prod_{p|n\,and\,p\,is\,prime} p : \mu(n)=(-1)^k \]</span> <span class="math display">\[ otherwise : \mu(n)=0 \]</span></p><a id="more"></a>






<p>证明：<br>
<del>暂时不会</del></p>
<p>莫比乌斯反演：<br>
对于数论函数 <span class="math inline">\(f(n)\)</span> ，设 <span class="math inline">\(F(n) = \sum_{d|n}f(d)\)</span><br>
即 <span class="math inline">\(F = f \times I\)</span><br>
则有 <span class="math inline">\(f(n) = \sum_{d|n}F(d)\cdot\mu(\frac{n}{d})\)</span><br>
即 <span class="math inline">\(f = F \times \mu\)</span></p>
<p>证明：</p>
<p><span class="math display">\[ \because \; F = f\cdot I \]</span> <span class="math display">\[ \therefore \; F\cdot \mu = f\cdot I\cdot \mu \]</span> <span class="math display">\[ \because \; I\cdot \mu = \epsilon \]</span> <span class="math display">\[ \therefore \; F\cdot \mu = f\cdot \epsilon \]</span> <span class="math display">\[ \therefore \; f = F\cdot \mu \]</span></p>
<p>莫比乌斯反演好像主要是用来推式子，F 比 f 好做的话，就可以试试莫比乌斯反演。</p>
<p>另外事实上只需要熟知 <span class="math inline">\(\mu\)</span> 函数的性质，直接推式子就行了，<br>
绝大多数情况下（至少是我遇到的所有情况下）并不需要莫比乌斯反演。</p>
<p>另外莫比乌斯反演有个很简单的 <span class="math inline">\(O(nlogn)\)</span> 实现，不需要筛 <span class="math inline">\(\mu\)</span> ，直接按定义枚举每个数的倍数去筛即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>FFT</title>
    <url>/2019/10/09/FFT/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2><p>首先要知道关于 <a href="https://kewth.github.io/blog/2019/01/24/多项式的运算/">多项式</a> 的一些知识。</p><p>其次要对复数有一些了解。</p><h2 id="点值表示法">点值表示法</h2><p>从 <a href="https://kewth.github.io/blog/2019/01/24/多项式的运算/">多项式</a> 中， 已经知道了多项式乘法的朴素算法时间复杂度为 $ O(n^2) $ 。 原因在于多项式是用系数表示法定义的。</p><p>重新定义 n 次多项式 a 为满足 $ k (http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform) 。</p><a id="more"></a>





<h2 id="迭代实现">迭代实现</h2>
<p>上述过程用递归实现常数较大，因而有一个迭代实现 FFT 的快速版本。</p>
<h3 id="蝴蝶操作">蝴蝶操作</h3>
<p>FFT 的每个值都是由子问题的两个值转化而来，且这两个值可以转换成两个需要的值（ FFT 复杂度的保证）。 若用一个数组 a 表示多项式。 那么蝴蝶操作形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">complex</span> Wn; <span class="comment">// 单位根的幂</span></span><br><span class="line"><span class="keyword">complex</span> a0 = a[x], a1 = a[y];</span><br><span class="line">a[x] = a0 + a1 * Wn;</span><br><span class="line">a[y] = a1 + a0 * Wn;</span><br></pre></td></tr></table></figure>
<p>这样取出了数组中两个值后再修改相应位置的两个值，就是蝴蝶操作。</p>
<h3 id="rader-排序">Rader 排序</h3>
<p>Rader 排序的目的是让表示多项式的数组可以进行蝴蝶操作。</p>
<p>盗图一张： <img src="https://cdn.luogu.org/upload/pic/23926.png" alt="luogu"></p>
<p>摘自洛谷：</p>
<pre><code>剩下的问题就是把初始的数组变成最后一层的样子了。
先别急着写一个递归函数暴力把位置换过去。
来观察一下最后序列的编号的二进制表示000, 100, 010, 110, 001, 101, 011, 111，
是不是与原来 000, 001, 010, 011, 100, 101, 110, 111 相比，
每个位置上的二进制位都反过来了？
这样的变化叫做 Rader 排序。</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>逆序对</title>
    <url>/2019/10/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>在数列 a 中,逆序对即是满足 <span class="math inline">\(i &lt; j\)</span> 且 <span class="math inline">\(a_i &gt; a_j\)</span> 的数对。 许多情况下你推式子推着推着就推出个 <span class="math inline">\(\sum_{i=1}^n \sum_{j=i+1}^n a_i&gt; a_j\)</span>， 这就是逆序对的数量。</p><h2 id="暴力">暴力</h2><p>朴素的求法自然是 <span class="math inline">\(O(n^2)\)</span> 地枚举 <span class="math inline">\(i, j\)</span> 统计，这里不再赘述。</p><a id="more"></a>


<h2 id="归并">归并</h2>
<p>前置技能：归并排序。</p>
<p>这应该是最主流的求逆序对的方法了。</p>
<p>要求一个区间内的逆序对数，假设已经递归求出两个子区间的逆序对数， 接下来要做的就是求一个在左区间，一个在右区间的逆序对数。</p>
<p>考虑归并排序的过程，在两个指针比较大小时进行统计。</p>
<p>设左右区间的当前比较指针（下标）为 p1, p2, 当找到第一个 p2 使 <span class="math inline">\(a_{p1}&lt; a_{p2}\)</span> 时，可知 <span class="math inline">\(\forall i\in [p1max+1, p2),\;a_{p1}&gt; a_{p2}\)</span> 。 那么横跨两个子区间的以 p1 为左端点的逆序对就有 p2-p1max-1 个。 对所有 p1 统计和即可。</p>
<p>值得注意的是，p2&gt;r（区间右端点）退出时， 此时左区间未处理的数对答案都有 r-p1max 的贡献因为此时左区间剩下的数都比右区间所有数大。</p>
<p>复杂度 <span class="math inline">\(O(n \cdot log_2n)\)</span> 。</p>
<h2 id="线段树树状数组">线段树/树状数组：</h2>
<p>前置技能：线段树（或树状数组）。</p>
<p>以线段树为例。</p>
<h3 id="做法-1">做法 1</h3>
<p>用线段树维护区间内有效数的个数。 之所以是有效的数，是因为要从小到大删数。 如果一个数 <span class="math inline">\(a_i\)</span> 是最小的，那么以其为右端点的逆序对就是 1 至 i-1 的数的个数。</p>
<p>接下来呢？ 在线段树中删掉最小的数（单点修改 -1）， 那么第二小的数 <span class="math inline">\(a_j\)</span> 在此时就是最小的数，同样有 1 至 j-1 的数的个数（区间查询）的贡献。 以此类推从小到大一个个删数即可。</p>
<p>复杂度<span class="math inline">\(O(n \cdot log_2n)\)</span>。</p>
<h3 id="做法-2">做法 2</h3>
<p>离散化后用线段树维护一个桶。</p>
<p>从左到右依次计算每个数为右端点的逆序对并加入桶，即对每个数求该数左边比该数大的数的个数。 设第 i 个数左边有 <span class="math inline">\(f_i\)</span> 个比 <span class="math inline">\(a_i\)</span> 大的数，那么 <span class="math inline">\(f_i\)</span> 的值即是当前线段树上 <span class="math inline">\(a_i+1~a_{max}\)</span> 的询问。</p>
<p>同样复杂度是 <span class="math inline">\(O(n \cdot log_2n)\)</span>。</p>
<p>这种做法稍稍改变可以高效解决一种特殊的问题：</p>
<p>对于 01 串求串中 1 的数量比 0 的数量大的区间的数量。</p>
<p>比较容易想到的做法是将 0 看成 -1，区间中 1 比 0(-1) 多等价于区间和大于 0 。 区间和可以转换为前缀和 s，那么 l,r 这一区间和大于 0 等价于 <span class="math inline">\(s_r - s_{l-1} &gt; 0 (r &gt;= l)\)</span>。 移项后即是 <span class="math inline">\(s_r &gt; s_{l-1} (r &gt; l-1)\)</span>，所以题目可以转换为求前缀和的逆序对， 复杂度 <span class="math inline">\(O(n \cdot log_2n)\)</span> 。</p>
<p><strong>但是</strong> 这个问题有特殊性，由 01 串的至可知相邻两个前缀和的差值一定是 1 ， 利用这一个性质可以有更高效的方法。</p>
<p>用做法 2 求逆序对，从左到右依次扫，对于当前 <span class="math inline">\(a_i\)</span> 一定比 <span class="math inline">\(a_{i-1}\)</span> 大 1 或者小 1， 利用到这个差值，比 <span class="math inline">\(a_i\)</span> 大的数相当于当前线段树 <span class="math inline">\(a_i+1\)</span> 到 <span class="math inline">\(a_{max}\)</span> 的询问， 若 <span class="math inline">\(a_i = a_{i-1}+1\)</span> ，那么 <span class="math inline">\(f_{i-1}\)</span> 就是 <span class="math inline">\(a_i\)</span> 到 <span class="math inline">\(a_{maxn}\)</span> 的询问，否则就是 <span class="math inline">\(a_i+2\)</span> 到 <span class="math inline">\(a_{max}\)</span> 的询问。 那么 <span class="math inline">\(f_i\)</span> 与 <span class="math inline">\(f_{i-1}\)</span> 的差只在 <span class="math inline">\(a_i\)</span> 或 <span class="math inline">\(a_i+2\)</span> 中，长度为一， 完全没必要用线段树，用数组维护桶即可。</p>
<p>复杂度 <span class="math inline">\(O(n)\)</span>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>数论函数玄学操作</title>
    <url>/2019/10/09/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%8E%84%E5%AD%A6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>数论函数推式子是真的玄学， 乱七八糟的一脸懵逼， 好不容易看懂了转身又 <del>tm</del> 忘了， 这里列出一些我见过的。</p><p>持续更新。</p><p>update: 证明都删掉了，这是篇整理，目的是让结论更一目了然。<del>需要证明联系我我免费讲解</del></p><h2 id="常见数论函数卷积">常见数论函数卷积</h2><p><span class="math display">\[ \mu \cdot I = \epsilon \]</span></p><p><span class="math display">\[ \phi \cdot I = id \]</span></p><a id="more"></a>





<p><span class="math display">\[ \mu \cdot id = \phi \]</span></p>
<p><span class="math display">\[ id \cdot I = \sigma \]</span></p>
<h2 id="常见数论函数-fij-化简">常见数论函数 f(ij) 化简</h2>
<p><span class="math display">\[ d(i \cdot j) = \sum_{x|i} \sum_{y|j} [gcd(x, y) = 1] \]</span></p>
<p><span class="math display">\[ \phi(i \cdot j) = \phi(i) \phi(j) \frac{gcd(i, j)}{\phi(gcd(i, j))} \]</span></p>
<h2 id="常见数论函数求和">常见数论函数求和</h2>
<p><span class="math display">\[ \sum_{i=1}^n d(i) = \sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \]</span></p>
<h2 id="互质条件转换">互质条件转换</h2>
<p><span class="math display">\[ [gcd(i, j) = 1] = \sum_{d|i,d|j} \mu(d) \]</span></p>
<p><span class="math display">\[ \sum_{i=1}^n \sum_{j=1}^m f(i, j) [gcd(i, j) = 1]
 = \sum_{d=1}^{min(n, m)} \mu(d) \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} f(id, jd) \]</span></p>
]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro 搭建内网博客</title>
    <url>/2019/10/01/Manjaro%20%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%96%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>折腾了大半天，终于在本机搭了一个功能完备的服务器。<br>
当然要记录一下啊。<br>
不过这是搭建成功后的总结，可能有地方遗漏，有问题欢迎提出来。</p><h2 id="静态页面博客">静态页面博客</h2><p>这个用 hexo 和 jekyll 直接就可以做到，本地跑 server 不成问题，<br>
比较 easy ，不赘述，详见 hexo 或者 jekyll 的官网。</p><h2 id="动态页面博客">动态页面博客</h2><a id="more"></a>



<p>动态页面要能跑 php ，有数据库。</p>
<h2 id="apache">apache</h2>
<p>这里用 apache(httpd) 搭建服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S apache2</span><br></pre></td></tr></table></figure>
<p>执行 <code>sudo httpd</code> 后打开 localhost ，就有一个东西了（虽然是空的）。<br>
在 /srv/http/ 下新建 index.html 随便写点东西，是可以显示的。<br>
路径具体查看 <code>httpd -S</code> 。</p>
<p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start httpd</span><br></pre></td></tr></table></figure>
<h2 id="php">php</h2>
<p>安装 php （ manjaro18.x 预装了 php7.x ，但还是要一些其他的东西）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S php php-apache php-fpm</span><br></pre></td></tr></table></figure>
<p>这时 apache 还是不支持 php 的，需要在配置里加上几行。<br>
打开 /etc/httpd/conf/httpd.conf ，加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule php7_module modules/libphp7.so</span><br><span class="line">AddType application/x-httpd-php-source .phps</span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line">DirectoryIndex index.php index.html index.htm</span><br></pre></td></tr></table></figure>
<p>开启 php 服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start php-fpm</span><br></pre></td></tr></table></figure>
<p>编写 index.php 试试，也可以运行了。 如果出了问题，找到配置里的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mpm_event_module modules/mod_mpm_event.so</span><br></pre></td></tr></table></figure>
<p>改成（应该就在下面被注释了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadModule mpm_prefork_module modules/mod_mpm_prefork.so</span><br></pre></td></tr></table></figure>
<h2 id="mysql">mysql</h2>
<p>我跑 mysql 的服务会卡死，不知道为什么，<br>
所以我用 mariadb （mysql 的一个衍生似乎是）替代。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S mariadb mariadb-client</span><br></pre></td></tr></table></figure>
<p>初始化（注册一个账号）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>启动服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure>
<p>试试能不能登上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u&lt;用户名&gt; -p</span><br></pre></td></tr></table></figure>
<p>让 php 支持 mysql 的调用，在 /etc/php/php.ini 找到 ;extension=mysqli 把分号去掉就行了。</p>
<h2 id="使用-wordpress">使用 wordpress</h2>
<p>Typecho 用 php7.2 似乎安装会出问题，<br>
还是建议用 wordpress ，更加成熟，<br>
安装方式在 wordpress 官网上把包下下来解压到 /srv/http/ ，<br>
回了正常运行，需要改变 /srv/http 的权限，让 wordpress 能够对其做出修改。<br>
这里不赘述，嫌麻烦可以 <code>chmod 777 -R /srv/http</code> 。</p>
<p>然后进入 localhost 按照步骤来就行了。</p>
]]></content>
  </entry>
  <entry>
    <title>NOIP 2018</title>
    <url>/2019/10/01/NOIP%202018/</url>
    <content><![CDATA[<h2 id="吐槽">吐槽</h2><p>一天普及一天省选，弄到一起就出成了一套提高组试题。</p><h2 id="day1">Day1</h2><p>原题大作战。 然而我一题都没做过。</p><p>总的来说 Day1 比去年好像容易点（不然我也不会留出一个多小时给每道题造数据对拍）。</p><h3 id="t1">T1</h3><p>CCF 直接把 2013 的题原封不动搬到了 Day1T1 。</p><p>一开始想着递归，发现会被卡成 <span class="math inline">\(O(n^2)\)</span> ， 再想 DP 的时候简化一下式子就直接可以扫一遍出结果。</p><a id="more"></a>







<h3 id="t2">T2</h3>
<p>bzoj 权限题。</p>
<p>如果一种货币能被其它若干货币代替，就扔掉。 设 f[i] 表示价值为 i 的货币是否会被代替，做一遍完全背包就好了。</p>
<h3 id="t3">T3</h3>
<p>bzoj 权限题。</p>
<p>听说可以二分加贪心，不过我考场想的比较复杂 <del>是二分答案再 DP ，DP 转移再套一层用链表维护的 DP</del> 。</p>
<p>首先容易想到二分答案，二分一个答案 mid 后求最多可以有多少条赛道满足长度不小于 mid ， 若有不少于 m 条，则答案可行。</p>
<p>求赛道数量可以 DP ，设 f[u] 为 u 的子树中满足条件的赛道的数量， g[u] 表示在满足 f[u] 最大的前提下 u 向下不经过赛道的最长路径长。</p>
<p>转移的时候先把 u 的儿子 v 的 f[v] 累加，同时将所有 g[v]+w 存起来（w 表示 u 到 v 的长度）。</p>
<p>对于 g[v]+w 大于等于 mid 的直接把 f[u]++ 然后扔掉，于是只需要考虑小于 mid 的 g[v]+w 的贡献。</p>
<p>两个不同的 g[v]+w 若大于等于 mid 就同样可以作为一条赛道让 f[u]++ ，先排序然后再次 DP 统计这样的赛道数量， 然后若所有的 g[v]+w 都有另外一个构成赛道， g[u]=0 ，否则 g[u] 等于剩下的最大的 g[v]+w 。</p>
<h2 id="day2">Day2</h2>
<p>Day1 的比赛对我造成了巨大的影响，Day1 考完后信心爆棚， <del>以 AKIOI 的自信</del> 走进 Day2 考场。</p>
<p>结果什么题都死磕正解，到最后连暴力都没打全。</p>
<p>看题，WTF?</p>
<p>看完 T1 我以为是个稠密无向图，想了好久感觉是要求一种特殊的生成树，感觉巨不可做。 顿时有点小慌，突然想到考前教练提醒要看完题，说不定后面的题反而简单。</p>
<p>嗯，有道理，直接翻到 T2 ，推了波结论认定是一道状压 DP，松了口气。</p>
<p>不急，再看 T3 ，哦，好像树形 DP ，但是 m 个询问难住了我。</p>
<p>于是认定 T2 比较容易，开始死磕 T2 ，打完状压后跑了遍 2,2 的样例，诶过了。 再跑一遍 3,3 ，输出 144 ，于是手推了 3,3 的样例发现还是 144 , 意识到推的结论有误，瞬间慌的一批。 推了好久才发现了问题，得到正确的结论后发现对于新结论状压 DP 似乎变得不可行。</p>
<p>这个时候考试已经过了一个小时多了。慌。</p>
<p>换换思路吧，于是去做 T3 , 想了很久 DP 最后写了个平方复杂度的， 跑过了所有样例就没管了，没多少时间了，又回去看 T1 。</p>
<p>往回看了看 T1 里 m 的数据范围我才发现只有树和换套树两种情况。 那还求个鬼生成树，迅速打掉树的 60 部分分，n 看都没看只知道 <span class="math inline">\(O(n)\)</span> 稳了。 再去想换套树，感觉差不多，继续 <span class="math inline">\(O(n)\)</span>做。</p>
<p>结果？一直死磕 T1 的 <span class="math inline">\(O(n)\)</span> 做法，直到最后考试结束都没写出来。</p>
<p>考试听别人说直接枚举删边 <span class="math inline">\(O(n^2)\)</span> 就可以过的时候我才意识到 n 只有 5000 ，整个人懵的。</p>
<p>结果 T1 还是 60' ，T3 不晓得哪里炸掉了爆零， 有意思的是 T2 我错误的打法样例都没过在 ccf 的数据里水到了 45' 。</p>
]]></content>
  </entry>
  <entry>
    <title>NTT</title>
    <url>/2019/10/01/NTT/</url>
    <content><![CDATA[<p>NTT ，快速数论变换，功能与 <a href>FFT</a> 完全一致，用来求多项式卷积。<br>
NTT 优点在于常数稍微小一点，没有精度误差。<br>
但是 NTT 系数必须是取模意义下的整数，且对模数有特殊要求。</p><h2 id="fft-的单位根">FFT 的单位根</h2><p>建议前置 <a href>FFT</a> 。</p><p>FFT 可以分治优化复杂度的原因是用到了单位根的如下性质：<br>
<span class="math display">\[ W_{2n}^{2k} = W_n^k \]</span> <span class="math display">\[ W_n^n = 1 \]</span> <span class="math display">\[ W_n^{k + n/2} + W_n^k = 0 \]</span></p><a id="more"></a>



<p>可是用单位根做 FFT ，需要用到复数和浮点数，常数大而且有精度误差。<br>
还有别的数有这样的性质来替换单位根吗？<br>
遗憾的是，可以证明复数域下只有单位根有这样的性质。</p>
<h2 id="取模">取模</h2>
<p>实际计算多项式卷积时，常常要求对系数取模以避免不必要的麻烦。<br>
那么这时候系数实际上是在模意义下的， FFT 将它转到复数域上运算，似乎没有必要。<br>
模意义下什么数可以有单位根那样的性质？<br>
有的，那就是原根。</p>
<h2 id="原根">原根</h2>
<p>对于某些模数 P ，模 P 意义下的原根 g 满足：<br>
对任意 $ 0 k P - 2 $ ， $ g^k $ 互不相同。 有些模数可能不存在原根，这里先假设模数都有原根。</p>
<p>假设系数是模 P 意义下的，P 是形如 $ 2^k + 1 $ 的质数，其原根为 g ，<br>
设 $ G_n = g^{} mod P $ ，其中 n 是小于 P 的 2 的整次幂 。<br>
那么在模 P 意义下， G 满足：</p>
<p><span class="math display">\[ G_{2n}^{2k} = G_n^k \]</span></p>
<p>由 G 定义可证：<br>
$ G_{2n}^{2k} = g^{2k} = g^{k} = G_n^k$</p>
<p><span class="math display">\[ G_n^n = 1 \]</span></p>
<p>由 G 定义可得：<br>
$ G_n^n = g^{n} = g^{P-1} $<br>
由费马小定理：<br>
$ G_n^n = g^{P-1} = 1 $</p>
<p><span class="math display">\[ G_n^{k + n/2} + G_n^k = 0 \]</span></p>
<p>有第一条性质可得：<br>
$ G_n^{n/2} = G_2^1 = g^{} $<br>
因为 $ (g<sup>{})</sup>2 = g^{P-1} = 1 $<br>
根据原根的性质：<br>
$ g^{} g^{P-1} $<br>
那么 $ g^{} = -1 $ （即 P - 1）。<br>
那么可以证得：<br>
$ G_n^{k + n/2} = G_n^k G_n^{n/2} = G_n^k(-1) $<br>
于是 $ G_n^{k + n/2} + G_n^k = 0 $</p>
<h2 id="ntt">NTT</h2>
<p>于是 NTT 的算法思路就呼之欲出了：把 $ W_n $ 全部替换为 $ G_n $ 即可。<br>
这样就可以算出模 P 意义下的多项式卷积了。<br>
其中 n 必须是 2 的整次幂，不足的补零即可。</p>
<p>现在唯一的问题是，模数 P 要满足什么条件，以及如何求模 P 意义下的原根 g 。<br>
然而我并不想深入展开，大多数情况下模数都是 998244353 ，其原根为 3 。<br>
一般 NTT 只会用这个模数，不会有毒瘤出题人卡这个模数的（我不对这句话负责）。</p>
]]></content>
  </entry>
  <entry>
    <title>HNOI2019</title>
    <url>/2019/10/01/HNOI2019/</url>
    <content><![CDATA[<p>先喷一句，没有大样例，差评。<br>
再喷一句，数据水，好评。</p><p>预计 80' ，实际 110' 。</p><p>我真是个奇葩实际分比预计分高。。。</p><h2 id="day0-">Day0-</h2><p>省选前三天教练每天给我们推一道题，都是主席树应用（教练曰“线段树模板”）。<br>
都是看了题解的思路才做出来的，自己想就找不到用主席树维护的地方。</p><p>不知道为什么这三天效率都挺高，这三天我 A 的题目估计有我平常一个星期的 A 题数。。。</p><a id="more"></a>





<p>然而还没来得及复习每个知识点，省选就来了。</p>
<h2 id="day1">Day1</h2>
<p>预计 70' ，实际 40' 。</p>
<h3 id="fish">fish</h3>
<p>我看到这题的时候就意识到我只能打暴力了。<br>
计算几何？我对这块一片空白。<br>
好吧，硬要说思路我大概想得到枚举线段，按斜率搞个什么数据结构？<br>
然后真的不会，敲暴力滚粗。</p>
<p>预计 20' ，实际 20' 。</p>
<h3 id="jojo">jojo</h3>
<p>前缀和后缀相同？求 KMP 的 fail 数组嘛。<br>
暴力求，一次加几个字符就求几次 fail, 全加起来就是答案。<br>
可持久化？版本树像个 AC 自动机，但是没管这么多，无脑写了个可持久化数组。<br>
因为是把每个字符暴力求的，只能过前 50' 。 结果我后面 30' tm TLE 了？ $ O(n log(n)) $ 的时空复杂度跑 1e5 要 6 秒？</p>
<p>预计 50' ，实际 20' 。</p>
<h3 id="polygon">polygon</h3>
<p>什么鬼畜题啊，简化一波题意。<br>
把线段看做一个区间，除 (x, x + 1) 外每个区间一定可以划分成两个子区间。<br>
然后把每个区间看做一个点，相当于有了一个满二叉树。<br>
然后旋转操作就相当于把一个点 blablabla 换一下位置。<br>
旋转次数可以贪心，方案数不会，大概要 DP ？<br>
然后想着就求旋转次数吧，看看数据范围。。。<br>
沃日 90% 的数据都要求方案数？小 W 的心情得多差啊。。。<br>
当时我还没打其他题，感觉比较亏，就先做前面的题了，结果最后都没打。</p>
<p>预计 0' ，实际 0' 。</p>
<h3 id="watering">Watering</h3>
<p>下午直接去机房颓废，死神 vs 火影真好玩。<br>
还有被 lyy 安利太阳系争夺战，画风清新，内容硬核。</p>
<h2 id="day2">Day2</h2>
<p>emm, 我是来测数据湿度的。。。<br>
结果真被我水过去了。。。</p>
<p>预计 10' ，实际 70' 。</p>
<p>所以说有想法就要实现 <del>不然就没事干了</del> 2333 。</p>
<h3 id="tour">tour</h3>
<p>u = v 或者 s[u] = s[v] 且 u, v 相邻的时候 (u, v) 一定是可行的。<br>
其他点对 (u, v) 可行当且仅当 s[u] = s[v] 且存在 u -&gt; u2, v -&gt; v2 且 (u2, v2) 可行。<br>
DP ？有环。<br>
然后就只能把一个点对看做一个点，对于新的点建图，如果从初始的可行点能跑到 (u, v) 则 (u, v) 可行。<br>
点数 $ O(n^2) $ ，边数 $ O(m^2) $ ，复杂度 $ O(n^2 + m^2 + q) $ 。<br>
然而第一档暴力 m 就有 1e4 ， <strong>纯随机数据开O2</strong> 本地测了一下跑 5s, 真棒。</p>
<p>预计 0' ，实际 30' 。</p>
<h3 id="dance">dance</h3>
<p>好迷啊，看了看 n = 1 有 40' ，就去想 n = 1 怎么做，<br>
推了推就是个式子： $ ans_i = _{j=0} C_L^{i+j k} W^{i+j k} $ 。 把每个 $ C_L^x W^x $ 算一遍，快速幂复杂度 $ O(L log(L)) $ ，<br>
然而 L 有 1e8 。。。<br>
线性都跑不过去吧这，但我实在没别的思路，就想试试线性。<br>
做法就是预处理，预处理 L 以内的逆元和 $ W_i $ ，再线性求一排的组合数。<br>
时空复杂度都是 $ O(L) $ ， <strong>开 O2</strong> 本地测试 17s, 就算不 TLE 都得 MLE 。</p>
<p>预计 0' ，实际 30' （考完后再放本地测可以水 40' woc）。</p>
<p>看了看实际的 L 只有 1e7 到 2e7 左右，真棒。 至于空间，我还算有点脑子搞了波动态开空间，不然直接开 1e8 的数组肯定得炸。</p>
<h3 id="sequence">sequence</h3>
<p>b 是整数的话还能枚举枚举。分数？没救了感觉。<br>
于是只打了 10' 的整数 DP 。</p>
<p>预计 10' ，实际 10' 。</p>
<h3 id="watering-1">Watering</h3>
<p>下午本来打算去黄兴街打游戏的，先去麦克唐纳德吃中饭，吃完后发现就已经 3 点多了没什么时间。<br>
于是放弃了 xbox 又回到机房颓废，死神 vs 火影昨天已经玩熟练了，打起来比较轻松。</p>
<h2 id="day3">Day3+</h2>
<p>省选完了，结果并不想想象的那样，即使运气眷顾了我还是 wei 的一批。<br>
实力不够啊，说啥都是扯淡。</p>
<p>常规欠下的帐也该还了，滚回去学文化课啦，接受作业的洗礼。</p>
<h2 id="one-year-later">One Year Later</h2>
<p>update on 2020.04.08</p>
<p>一年过去了，重新审视了去年的 HNOI ，再次分别总结一下吧。 （从去年省选到现在，这些题碰都没有碰过）</p>
<p>新一轮省选不远了。</p>
<h3 id="fish-1">fish</h3>
<p>咕咕咕。</p>
<h3 id="jojo-1">jojo</h3>
<p>去年，我甚至不知道均摊数据结构是不能可持久化的，打了一个主席树满以为复杂度一个 log 。<br>
可事实上 KMP 的最坏复杂度是 <span class="math inline">\(O(n)\)</span> ，可持久化后复杂度可以到 <span class="math inline">\(O(n^2)\)</span> 。</p>
<p>可是现在我还是不会做 jojo ，甚至看题解也看不懂，现在上考场估计也还是 20pts 。</p>
<h3 id="polygon-1">polygon</h3>
<p>这题不难的啊，至少现在我看来如此。<br>
不考虑修改的话就可以分治处理这个问题，考虑上修改就动态维护分治的树状形态即可。<br>
而方案数就是分治树的拓扑序数量。</p>
<p>A 了，现在上考场有信心拿到 100pts ，只不过可能得花上至少 2h 的时间。</p>
<h3 id="tour-1">tour</h3>
<p>思路很妙，同类型的边的偶环是没有意义的，可以删边使得同类型的边偶环不存在进而把边数控制在 <span class="math inline">\(O(n)\)</span> 。<br>
可惜我没能独自得到这个结论，还是看了题解的，看了后有一种恍然大悟的感觉。</p>
<p>现在上考场也许还是只会 <span class="math inline">\(O(m^2)\)</span> 暴力吧，说实话时间足够的话我觉得应该能想到，但按低的算，30pts 。</p>
<h3 id="dance-1">dance</h3>
<p>现在看来这个式子并不难推，推完后就是对一个多项式求单位根上的点值。<br>
但是在直到看题解前我都完全没听说过 bluestein ，算是技不如人，只能拿 60pts 。</p>
<h3 id="sequence-1">sequence</h3>
<p>花了 30min 打了个 50pts 的暴力 <span class="math inline">\(O(nm)\)</span> ，发现简直白给。<br>
不过 100pts 确实难了不少，我觉得就算考场想到了也无法在考试时间内写对。</p>
]]></content>
  </entry>
  <entry>
    <title>i3</title>
    <url>/2019/10/01/i3/</url>
    <content><![CDATA[<h2 id="历程">历程</h2><ul>
<li>最先用的是 Ubuntu 16.04 自带的 Unity 。</li>
<li>更新 Ubuntu 后用的 Ubuntu 18.04 自带的 Gnome 。</li>
<li>用了 Gnome 后学会了折腾，各种配置堆上。</li>
<li>后来发现 Gnome 太卡太吃内存，并且才知道系统可以换桌面， 于是在 master 安利下换上 xfce 。</li>
<li>xfce 很稳定很流畅，但是太丑，可玩性太低，于是换上高大上的 KDE 。</li>
<li>中途还换过 enlightenment ，但是 enlightenment 的稳定性实在不敢恭维。</li>
<li>最后用上了 i3 ，原因不详。</li>
</ul><a id="more"></a>

<p>WARNING:<br>
既然你打算尝试 i3 ，本文假设你有一定的动手能力（说白了就是能折腾）。</p>
<h2 id="安装">安装</h2>
<p><code>sudo aptitude install i3-wm</code> 后注销重进选择 i3 即可。</p>
<p>然后你会发现弹出个窗口，接下来黑屏，没有动静。<br>
WTF ?<br>
其实 i3 已经开了，只是没背景而已，按 win+Enter 打开终端。</p>
<h2 id="配置">配置</h2>
<p>弹出一个菜单给你设置？想多了，要配置就写 ~/.config/i3/config 去吧。</p>
<p>$mod 是 i3 的灵魂，每一个快捷键最好都以 $mod 开头，<br>
一般 $mod 被设置成 Mod4 ，也就是 Win 键。<br>
bindsym 是绑定快捷键，注释很详细，自己看，下面列出一些重要的配置。</p>
<h3 id="方向">方向</h3>
<p>i3 默认把 jkl; 做方向键，也许你会更喜欢 hjkl ，自己替换掉就是了。<br>
另外分号不是 ; 而是 semicolon 。</p>
<h3 id="壁纸">壁纸</h3>
<p>i3 默认没有壁纸，因为它是个平铺式的窗口管理器。<br>
但壁纸是第一生产力啊，不要壁纸怎么行。</p>
<p>下载 feh: <code>sudo aptitude install feh</code>.<br>
<code>feh --bg-fill (YOUR_IMG)</code> 就可以设置壁纸了，至于实现原理，你不会想知道的。</p>
<h3 id="锁屏">锁屏</h3>
<p>i3 默认没有锁屏，为了防机惨，锁屏还是很有必要的。</p>
<p>下载 i3lock: <code>sudo aptitude install i3lock</code>.<br>
直接 <code>i3lcok</code> 就可以锁屏，<code>i3lock -i (YOUR_PNG)</code> 还可以设置锁屏壁纸。<br>
需要快捷键锁屏的话，加上一句配置就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+Tab exec i3lock # Win+Tab 锁屏</span><br></pre></td></tr></table></figure>
<h3 id="工作区">工作区</h3>
<p>i3 对工作区的数量没有限制，工作区的名字甚至可以有字母。<br>
i3 默认配置里只提供了切换到 1 至 10 的快捷键，<br>
但是有时候“切换到下一个工作区”和“切换到上一个工作区”可能更方便。<br>
加上两句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+comma workspace prev # Win+逗号</span><br><span class="line">bindsym $mod+period workspace next # Win+句号</span><br></pre></td></tr></table></figure>
<p>另外，默认配置里，把一个窗口移动到某工作区的时候仍会停留在原工作区，<br>
想改变这点， 把 <code>move container to workspace x</code> 后面加上 <code>; workspace x</code> 即可。</p>
<h3 id="i3bar">i3bar</h3>
<p>个人超喜欢 i3bar ，因为它可以接受任何一个程序的输出。<br>
这意味着你可以完全自由地定制 i3bar 。</p>
<p>找到 <code>bar {</code> 这行。<br>
bar 的模式有三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mode hide # Auto display</span><br><span class="line">mode invisible # Never display</span><br><span class="line">mode dock # Alway display</span><br></pre></td></tr></table></figure>
<p>位置有两种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position top</span><br><span class="line">position bottom</span><br></pre></td></tr></table></figure>
<p>重点来了，定义处理程序这一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_command i3status</span><br></pre></td></tr></table></figure>
<p>可以看到默认使用 i3status 作为处理，i3status 本身也可以配置，<br>
但是如果想自由配置，你可以写个程序，输出一个 json ，接口比较复杂，<br>
在此不赘述，你可以在 ~/.config/i3status/config 里加几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general &#123;</span><br><span class="line">	   output_format = &quot;i3bar&quot;</span><br><span class="line">	   colors = true</span><br><span class="line">	   interval = 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再运行 <code>i3status</code> 依葫芦画瓢就是了。</p>
<h3 id="i3-gaps">i3-gaps</h3>
<p>如果你希望窗口平铺之间会有间隙，i3-gaps 会满足你。<br>
如果你用 Debian, Ubuntu ， 去 github 上搜 i3-gaps-deb clone 下来后运行 i3-gaps-deb 就行了。<br>
如果用 Arch ，软件包管理器里有，直接下。</p>
<h3 id="透明">透明</h3>
<p>也许你给终端模拟器设置了透明度，很遗憾，在 i3 上没用。<br>
解决方案是下载 compton ，运行 <code>compton -b</code> 即可。</p>
<h2 id="接口">接口</h2>
<p>你可以很自由地向 i3 发送命令，<code>i3-msg</code> 提供了一系列接口，<br>
足以帮助完成更复杂的定制。</p>
<p>使用 <code>i3-input</code> 可以直接向 i3 发送一条命令。</p>
]]></content>
  </entry>
  <entry>
    <title>i3lock</title>
    <url>/2019/10/01/i3lock/</url>
    <content><![CDATA[<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/07/2_054-1.png" alt><figcaption>i3lock-fancy</figcaption>
</figure><p>折腾了半天 i3lock ，不写篇博客可惜了。</p><p>i3lock 有啥好折腾的？不就是挂个壁纸锁屏嘛。<br>
就是因为 i3lock 太鸡肋了折腾啊。<br>
于是我试过了 i3lock 的各种民间 fork 版本，在此总结。</p><h2 id="i3lock"><a href="https://github.com/i3/i3lock" target="_blank" rel="noopener">i3lock</a></h2><p>官方版本 i3lock ，稳定可靠，但是鸡肋。</p><p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install i3lock</span><br></pre></td></tr></table></figure></p><a id="more"></a>





<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-lixxia"><a href="https://github.com/Lixxia/i3lock" target="_blank" rel="noopener">i3lock-lixxia</a></h2>
<p>最友好，最简单的一个 i3lock fork ，<br>
优化了中间显示的圆形框，并支持一些颜色自定义。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Lixxia/i3lock.git</span><br><span class="line"><span class="built_in">cd</span> i3lock</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<p>顺带一提，只有这个 fork 给出了靠谱的源码安装方式，<br>
其他 fork 甚至 i3lock 本身的安装方式都给得很不靠谱。</p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-blur"><a href="https://github.com/karulont/i3lock-blur" target="_blank" rel="noopener">i3lock-blur</a></h2>
<p>支持模糊背景，毛玻璃特效。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/karulont/i3lock-blur.git</span><br><span class="line"><span class="built_in">cd</span> i3lock-blur</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<p>再顺带一提，只有这个 fork 直接给出了需要安装那些库。</p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lock --fuzzy</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lockr"><a href="https://github.com/owenthewizard/i3lockr" target="_blank" rel="noopener">i3lockr</a></h2>
<p>支持模糊背景，毛玻璃特效。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/owenthewizard/i3lockr/releases/download/v1.0.0-final/i3lockr</span><br><span class="line">sudo mv i3lockr /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i3lockr --blur=25</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-color"><a href="https://github.com/PandorasFox/i3lock-color" target="_blank" rel="noopener">i3lock-color</a></h2>
<p>对于颜色的自定义十分全面。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude remove i3lock</span><br><span class="line">sudo aptitude install pkg-config libxcb1-dev libxcb1 libgl2ps-dev libx11-dev libglc0 libglc-dev libcairo2-dev libcairo-gobject2 libcairo2-dev libxkbfile-dev libxkbfile1 libxkbcommon-dev libxkbcommon-x11-dev libxcb-xkb-dev libxcb-dpms0-dev libxcb-damage0-dev libpam0g-dev libev-dev libxcb-image0-dev libxcb-util0-dev libxcb-composite0-dev libxcb-xinerama0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/PandorasFox/i3lock-color</span><br><span class="line"><span class="built_in">cd</span> i3lock-color</span><br><span class="line">autoreconf -<span class="keyword">fi</span></span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i3lock</span><br></pre></td></tr></table></figure></p>
<h2 id="i3lock-fancy"><a href="https://github.com/meskarune/i3lock-fancy" target="_blank" rel="noopener">i3lock-fancy</a></h2>
<p>重头戏，star 最多的 fork ，甚至比 i3lock 本身更多，被广泛使用。</p>
<p>安装： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install i3lock-fancy</span><br></pre></td></tr></table></figure></p>
<p>使用： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i3lock-fancy</span><br></pre></td></tr></table></figure></p>
<p>依赖 i3lock ，实际上是产生了背景图片再调用 i3lock 。<br>
默认使用模糊背景，用起来没什么问题，但是事实上，<br>
圆形框的颜色并不是最正确的，而是兼容的。</p>
<p>源码里有这样一条： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to use a forked version of i3lock with prepared parameters</span></span><br><span class="line"><span class="keyword">if</span> ! i3lock -n <span class="string">"<span class="variable">$&#123;PARAM[@]&#125;</span>"</span> -i <span class="string">"<span class="variable">$IMAGE</span>"</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># We have failed, lets get back to stock one</span></span><br><span class="line">    i3lock -n -i <span class="string">"<span class="variable">$IMAGE</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>bash -x i3lock-fancy 就知道，<br>
if 上的命令往往失败了，执行的是 if 里头的命令。</p>
<p>事实上这需要 i3lock-color 。<br>
那么，安装 i3lock-color 代替 i3lock 后，执行 i3lock-fancy ，<br>
会发现圆形框的颜色与背景更加配了。</p>
<h2 id="关于模糊背景">关于模糊背景</h2>
<p>事实上，如果你用了 compton 再用 i3lock ，效果十分差劲。<br>
解决这个方案，可以在调用 i3lock 前 kill compton ，结束后重新启动 compton 。</p>
<p>拿 i3lock-fancy 举例，把之前展示的代码改成这样： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to use a forked version of i3lock with prepared parameters</span></span><br><span class="line">pkill compton</span><br><span class="line"><span class="keyword">if</span> ! i3lock -n <span class="string">"<span class="variable">$&#123;PARAM[@]&#125;</span>"</span> -i <span class="string">"<span class="variable">$IMAGE</span>"</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># We have failed, lets get back to stock one</span></span><br><span class="line">    i3lock -n -i <span class="string">"<span class="variable">$IMAGE</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">compton -i 0.8 -b</span><br></pre></td></tr></table></figure></p>
<p>其次，用模糊背景通常会比较慢，尤其是 i3lock-fancy ，需等上 3 秒左右。<br>
那么如果调用 i3lock-fancy 之后你又做了一些别的操作，比如关闭一个窗口，<br>
这时锁屏了，你会发现背景和原来的不一样。 :)</p>
]]></content>
  </entry>
  <entry>
    <title>ncurses</title>
    <url>/2019/10/01/ncurses/</url>
    <content><![CDATA[<p>ncurses 是基于终端的十分强大的图形库。 Vim, screen, sl 等终端程序都用到了这个库（足以见其强大）。</p><h2 id="安装">安装</h2><p>部分系统默认安装了 ncurses ，手动安装的方式是： <code>sudo aptitude install ncurses-dev</code> 。</p><p>使用的程序需要 <code>#include &lt;ncurses.h&gt;</code>　。 编译时需要添加 <code>-lncurses</code> 参数进行链接。</p><a id="more"></a>



<h2 id="开始和结束">开始和结束</h2>
<p>调用 initscr 初始化窗口，endwin 结束窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">WINDOW *<span class="title">initscr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">endwin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<p>调用 initscr 后调用 endwin 前，printf, std::cout 等标准输出不会显示在屏幕上。 而输出到屏幕上需要 ncurses 提供的相应函数。</p>
<h3 id="函数">函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addch</span><span class="params">(<span class="keyword">const</span> chtype char_to_add)</span></span>;   <span class="comment">// 当前位置添加字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *string_to_add)</span></span>;    <span class="comment">// 当前位置添加字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printw</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>;   <span class="comment">// 类似于 printf</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">refresh</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">// 强制刷新物理屏幕</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beep</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">// 终端响铃</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flash</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">// 屏幕闪烁</span></span><br></pre></td></tr></table></figure>
<h2 id="输入">输入</h2>
<p>调用 scanf, getchar, cin 等标准输入函数同样无效。</p>
<h3 id="函数-1">函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cbreak</span><span class="params">()</span></span>;   <span class="comment">// 字符一键入，直接传给程序（不用按下回车）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nocbreak</span><span class="params">()</span></span>;  <span class="comment">// 关闭 cbreak</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">echo</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 开启输入回显</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noecho</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 关闭输入回显</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getch</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 读入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanw</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">// 类似于 scanf</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure>
<p>输入函数通常是阻塞的，但是通过调用 nodelay(stdscr, TRUE); 可以关闭阻塞。 此时若输入函数未读取到内容会返回 ERR 。</p>
<h2 id="光标">光标</h2>
<p>控制光标。 调用 initscr 后调用 endwin 前，输出终端控制符改变光标是无效的。</p>
<h3 id="函数及示例">函数及示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// 将光标移动到 [x] 行 [y] 列，左上角为 0 行 0 列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">curs_set</span><span class="params">(<span class="keyword">int</span> visiblility)</span></span>; <span class="comment">// 参数为 0 表示隐藏光标，1 表示显示光标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getyx</span><span class="params">(WINDOW* win, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>; <span class="comment">// 获取指定窗口光标位置，示例如下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span> </span>&#123; <span class="comment">// 将光标上移</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	getyx(stdscr, x, y); <span class="comment">// stdscr 表示标准屏幕</span></span><br><span class="line">	move(x - <span class="number">1</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定位置输出">指定位置输出</h3>
<p>在指定位置输出不必先 move 再 printw ， ncurses 提供了 mv 函数前缀在指定位置输出。 例如 <code>mvprintw(1, 2, "%d", 2)</code> 在 1 行 2 列输出 3 。 类似的有 mvaddch, mvaddstr 等。</p>
<h2 id="颜色">颜色</h2>
<h3 id="初始化">初始化</h3>
<p>首先需要调用 has_color() 查看当前运行环境是否支持彩色。 调用 start_color() 初始化颜色，成功则返回 OK 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_colors</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_color</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>成功后会初始化全局变量 COLORS 表示终端支持的颜色数量 还会有 COLOT_WHITE, COLOR_RED 等 8 个表示颜色的变量。</p>
<h3 id="使用">使用</h3>
<p>例如希望打印白底黑字的信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *info)</span> </span>&#123;</span><br><span class="line">	init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_WHITE);</span><br><span class="line">		<span class="comment">// 的一个参数表示编号，后面两个分别表示字体和背景颜色</span></span><br><span class="line">	attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">// attron 是一个设置函数，COLOR_PAIR 返回指定编号的颜色信息</span></span><br><span class="line">	addstr(info);</span><br><span class="line">	attroff(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">// attroff 关闭设置（若接下来需要用其他颜色可以不调用 attroff 而直接使用 attron 覆盖设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误示例">错误示例</h3>
<p>值得注意的是，必须保证 init_pair 的编号不与其他已初始化的编号重复 一个错误的调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">"ERROR CODE"</span>;</span><br><span class="line">init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_WHITE);</span><br><span class="line">attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">addstr(info); <span class="comment">// 打印白底黑字</span></span><br><span class="line">init_pair(<span class="number">1</span>, COLOR_BLACK, COLOR_RED);</span><br><span class="line">attron(COLOR_PAIR(<span class="number">1</span>));</span><br><span class="line">addstr(info); <span class="comment">// 打印白底红字</span></span><br></pre></td></tr></table></figure>
<p>上述代码的期望打印出白字和黑字两种不同的颜色， 但事实上只会打印出红色一种。 解决方案便是将白底红字的 pair 编号设为 2 。</p>
<h2 id="窗口">窗口</h2>
<p>ncurses 有窗口类 WINDOW 并提供了 stdscr 作为默认窗口。 有时一个窗口无法满足需要，此时需要自己新建窗口。</p>
<h3 id="新建窗口">新建窗口</h3>
<p>调用 newwin 来新建窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 ([x], [y]) 开始新建 [line] 行 [column] 列的窗口。</span></span><br><span class="line"><span class="function">WINDOW *<span class="title">newwin</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>新建的窗口</p>
<h3 id="通用输出">通用输出</h3>
<p>addch, printw 等输出方式只输出到 stdscr 。 ncurses 提供了 w 前缀来输出到指定窗口。 例如 <code>wprintw(win, "%d", 1)</code> 在 [win] 窗口输出 1 。 但是自己新建的窗口与 stdscr 不同， 若想在屏幕上显示需要调用 <code>wrefresh(win)</code> 刷新窗口。</p>
<p>若想在窗口中指定位置输出，可以用 mvw 前缀函数。 例如 <code>mvwprintw(win, 1, 2, "%d", 3)</code> 在 [win] 窗口的 1 行 2 列（ <strong>相对位置</strong> ）输出 3 。</p>
<h3 id="子窗口">子窗口</h3>
<p>调用 subwin 创建子窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 ([x], [y]) 开始新建 [line] 行 [column] 列属于 [parent] 的子窗口。</span></span><br><span class="line"><span class="function">WINDOW *<span class="title">subwin</span><span class="params">(WINDOW *parent, <span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>子窗口与普通窗口的区别在于它与其父窗口共用屏幕储存空间， 子窗口修改时父窗口会直接受到影响。 比如新建了 stdscr 的子窗口 win ， 那么输出到 win 后想显示在屏幕不调用 wrefresh 而是调用 touchwin(stdscr) 。 touchwin 用于标记一个窗口被修改。</p>
<h3 id="销毁窗口">销毁窗口</h3>
<p>调用 delwin 销毁窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delwin</span><span class="params">(WINDOW *win)</span></span>; <span class="comment">// 销毁 [win] 窗口</span></span><br></pre></td></tr></table></figure>
<p>窗口销毁后其在屏幕上对应的内容不会改变。</p>
<h2 id="离开">离开</h2>
<p>有时候可能需要离开 ncurses 回到行缓冲模式做些事情而且需要在之后回到 ncurses 。 例如 Vim 里面输入 :!ls 就会退出 ncurses 运行 ls 命令，并在用户敲下回车后回到 ncurses。</p>
<p>调用 def_prog_mode 暂存，调用 reset_prog_mode 恢复。</p>
<h3 id="示例">示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initscr();</span><br><span class="line">	printw(<span class="string">"Hello World !!!\n"</span>);</span><br><span class="line">	getch(); <span class="comment">// 等待用户输入</span></span><br><span class="line">	def_prog_mode(); <span class="comment">// 存储当前tty 模式</span></span><br><span class="line">	endwin(); <span class="comment">// 退出 ncurses 模式</span></span><br><span class="line">	system(<span class="string">"sh"</span>); <span class="comment">// 返回普通的行缓冲模式</span></span><br><span class="line">	reset_prog_mode(); <span class="comment">// 返回到 def_prog_mode() 存储的 tty 模式</span></span><br><span class="line">	refresh(); <span class="comment">// 刷新屏幕（必须！）</span></span><br><span class="line">	getch(); <span class="comment">// 等待用户输入</span></span><br><span class="line">	endwin(); <span class="comment">// 退出 ncurses 模式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出中文等非-ascii-字符">输出中文等非 ASCII 字符</h2>
<p>事实上 ncurses 并不支持直接输出中文， 这意味着调用 printw("中文") 会是一堆乱码。 解决方案如下：</p>
<h3 id="安装库">安装库</h3>
<p>这需要另一个库。 通过 <code>sudo aptitude install libncurses5 libncursesw5 libncursesw5-dbg libncursesw5-dev</code> 安装</p>
<h3 id="头文件">头文件</h3>
<p>一定是 <code>#include &lt;ncurses.h&gt;</code> 而不是 <code>#include &lt;curses.h&gt;</code> 。 另外在 main.cpp <code>#include &lt;locale.h&gt;</code> 。</p>
<h3 id="调用">调用</h3>
<p>在调用 initscr() <strong>之前</strong> 调用 setlocale(LC_ALL, "") 。</p>
<h3 id="编译">编译</h3>
<p>将 <code>-lncurses</code> 参数改为 <code>-lncursesw</code> 。</p>
]]></content>
  </entry>
  <entry>
    <title>终端（娱乐）工具</title>
    <url>/2019/10/01/terminal-tool/</url>
    <content><![CDATA[<h2 id="sl-ls">sl / LS</h2><p>在你 ls 打累的时候开小火车。</p><h3 id="安装方式">安装方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install sl</span><br></pre></td></tr></table></figure><h2 id="lolcat">lolcat</h2><p>用彩虹为输出着色！</p><h3 id="示例">示例</h3><figure>
<img src="https://pic4.zhimg.com/v2-3bf6b7552162441dd638ac6d5fb3717b_r.jpg" alt><figcaption>lolcat</figcaption>
</figure><h3 id="安装方式-1">安装方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install rubygems</span><br><span class="line">gem install lolcat</span><br></pre></td></tr></table></figure><h3 id="管道处理">管道处理</h3><p>非常有意思的是，将大多数 ncurses 程序的输出通过管道用 lolcat 后仍然可以正常运行！</p><a id="more"></a>











<p>比如 <code>nano | lolcat</code> 可以打开一个彩虹编辑器；<br>
<code>ncdu | lolcat</code> 可以打开一个彩虹文件查看器；<br>
<code>sl | lolcat</code> 可以开彩虹火车；<br>
<code>nethack | lolcat</code> 可以玩彩虹游戏！</p>
<h2 id="cowsay">cowsay</h2>
<p>让一只奶牛（或者其它乱七八糟的东西）说出一句话！</p>
<h3 id="示例-1">示例</h3>
<p>运行 <code>cowsay hiahiahia</code></p>
<p>然后你会得到像这样的输出：</p>
<pre><code> ___________
&lt; hiahiahia &gt;
 -----------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre>
<p>类似的你也可以用 <code>cowthink</code> 。</p>
<h3 id="安装方式-2">安装方式</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install cowsay</span><br></pre></td></tr></table></figure>
<h2 id="chafa">chafa</h2>
<p>在终端里面打印图片或者视频！</p>
<h3 id="示例-2">示例</h3>
<figure>
<img src="https://pic4.zhimg.com/v2-91254499e2880bbe3068ce2a3e086977_b.gif" alt><figcaption>chafa</figcaption>
</figure>
<p>小诀窍：把终端字体调小并开全屏可以让图片更清晰（但是更慢）。<br>
给你一图片自行意会（记住这张图是在终端上打印的！！！）：</p>
<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/03/选区_017.png" alt><figcaption>chafabig</figcaption>
</figure>
<h3 id="安装">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hpjansson/chafa.git &amp;&amp; <span class="built_in">cd</span> chafa</span><br><span class="line">sudo aptitude install libmagickwand-dev</span><br><span class="line">./autogen.sh</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>这个安装过程相对比较麻烦，详细过程见 <a href="https://github.com/hpjansson/chafa" target="_blank" rel="noopener">Github</a> 。</p>
<h2 id="img2txt-cacaview">img2txt / cacaview</h2>
<p>在终端里用 ASCII 打印图片！</p>
<p>或者用 cacaview 打开一个窗口查看。</p>
<p>upd: 后来我才知道 w3m 也可以查看图片，和 cacaview 的效果一模一样。</p>
<h3 id="安装-1">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install caca-utils</span><br></pre></td></tr></table></figure>
<h2 id="w3m-lynx-browsh">w3m / lynx / browsh</h2>
<p>在终端浏览网页！</p>
<h3 id="示例-3">示例</h3>
<p>w3m 和 lynx 大同小异，没有什么本质上的区别。 （别喷我，我这么说是拿 browsh 作参照）</p>
<p>但是， browsh 不同，它内部调用 Firefox 渲染网页并处理后打印在终端， 因此 browsh 几乎能 <strong>在终端</strong> 支持任何现代浏览器支持的！</p>
<p>只给出一张 browsh 浏览 youtubu 的图片：</p>
<figure>
<img src="https://oscimg.oschina.net/oscnet/cc8d81d3c93d858a0a3f39e08293e4b6535.jpg" alt><figcaption>browsh</figcaption>
</figure>
<h3 id="安装-2">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># w3m</span></span><br><span class="line">sudo aptitude install w3m</span><br><span class="line"><span class="comment"># lynx</span></span><br><span class="line">sudo aptitude install lynx</span><br><span class="line"><span class="comment"># browsh</span></span><br><span class="line">wget https://github.com/browsh-org/browsh/releases/download/v1.5.0/browsh_1.5.0_linux_amd64.deb</span><br><span class="line">sudo dpkg -i ./browsh_1.5.0_linux_amd64.deb</span><br></pre></td></tr></table></figure>
<h2 id="cmatrix">cmatrix</h2>
<p>终端黑客风动画</p>
<p><code>cmatrix | lolcat</code> 简直可以来当屏保。</p>
<h3 id="安装-3">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install cmatrix</span><br></pre></td></tr></table></figure>
<h2 id="typespeed">typespeed</h2>
<p>在终端 <del>玩打字游戏</del> 测试打字速度！</p>
<h3 id="示例-4">示例</h3>
<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/03/选区_027.png" alt><figcaption>typespeed</figcaption>
</figure>
<h3 id="安装-4">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install typespeed</span><br></pre></td></tr></table></figure>
<h3 id="自定义词库">自定义词库</h3>
<p>我是真的爱折腾，竟然自己找出了 typespeed 的词库位置并且自己加了词库。。。</p>
<p>顺便夸一下 typespeed 的扩展性真的好，它考虑到了用户的自定义词库需求。</p>
<p>只需要在 /usr/share/typespeed/words/ 目录下添加 words.xxx 文件（ xxx 随意填），<br>
文件第一行是这个词库的名称，接下来每行一个单词就可以了。</p>
<p>然后进入 typespeed 就能看到你自己的词库啦（ kewth's xxx 就是我自己加的）：</p>
<figure>
<img src="http://kewth.gq/wp-content/uploads/2019/03/选区_028.png" alt><figcaption>mywords</figcaption>
</figure>
<h2 id="nethack">nethack</h2>
<p>世界上最棒的终端游戏（绝无夸大）！<br>
nethack 太博大精深了，玩法不赘述。</p>
<p>另外： <code>nethack | lolcat</code> 的效果真的很棒。</p>
<h3 id="安装-5">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo aptitude install nethack</span><br></pre></td></tr></table></figure>
<h2 id="task">task</h2>
<p>全名 taskwarrior 。</p>
<p>个人认为终端上最好用的 todo list manager 。<br>
功能十分强大，可以简单上手，<br>
如果愿意折腾也可以深入挖掘它的各种功能，最精细地管理你的任务计划。</p>
<h3 id="安装-6">安装</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo aptitude install taskwarrior</span><br></pre></td></tr></table></figure>
<h3 id="简单上手">简单上手</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">task add test1</span><br><span class="line">task add test2</span><br><span class="line">task start 1</span><br><span class="line">task long</span><br><span class="line">task <span class="keyword">done</span> 1</span><br><span class="line">task <span class="keyword">done</span> 2</span><br></pre></td></tr></table></figure>
<h3 id="tasksh">tasksh</h3>
<p>整合 taskwarrior 的交互命令行，里面可以直接敲 <code>add ...</code> 或 <code>list</code> 等命令。</p>
]]></content>
  </entry>
  <entry>
    <title>北京游记</title>
    <url>/2019/10/01/%E5%8C%97%E4%BA%AC%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>Q: 我天天盯着你高考 (gq) 怎么一直没更新啊？<br>
A: 懒。</p><p>因此这实际是一篇事后回忆。</p><h2 id="day0">Day0</h2><p>昨天晚上特意没去学校回了家，想着离高铁站近可以晚点起床，<br>
<del>真相是需要回家拿电脑</del><br>
然而大早上 6 点就被叫了起来，早餐都没吃就直接送到了高铁站，<br>
emm 还有大半个小时才检票，果断拿起颓书开始颓废，<br>
不要问<a href>为什么不玩电脑</a>，心塞。</p><a id="more"></a>



<p>高铁上还是贼无聊，幸好准备了颓书，<br>
而且还可以蹭旁边的人看《生活大爆炸》。<br>
还行，比上次去安徽好得多。</p>
<p>出高铁再做地铁去北大，北京地铁线比长沙多得多，<br>
全程没搞清往哪走，迷迷糊糊地跟别人跑。<br>
下了地铁第一反应就是，热，真热，贼 NM 热，<br>
地理菜狗还以为北京纬度高就会比较凉快来着。</p>
<p>至于住的酒店，我敢说这是我住过最差的酒店了，<br>
整一偏僻平房（有点像四合院？），里面要啥没啥，<br>
卫生条件极差，听隔壁德拉说他们床头粘了 10+ *** ，部分带红，估计是 **** 。<br>
水龙头都 tm 生锈了，淋浴喷头竟然对着马桶。<br>
之前住安徽时还喷了那宾馆来着，现在感觉那简直是天堂。</p>
<p>晚上还是很 nice 的，上一届北大的信息组学长们请我们吃饭，<br>
特意选了一家比较符合湖南人口味的饭馆，<br>
吃完饭后被拉到北大到处乱转，<br>
北大确实很漂亮，晚上没什么灯，不是灯火通明的那种喧嚣繁华，比较安静，<br>
还有未名湖，不敢随便形容，不过听说每年都有人不小心掉下去。</p>
<h2 id="day1">Day1</h2>
<p>上午的开幕式已经忘了讲了什么了，<br>
大概是大谈信息学发展，北大的优势和竞赛生在北大的学习方向。</p>
<p>北大食堂贼多，不过我们可以吃的只有三个，农园最近，大家就都去了农园，<br>
还不错，至于消费我跟本没注意，反正看到还行的就拿了。。。发的 100 元的卡应该够用的。</p>
<p>下午的考试，萎出天际，可能是没有找到状态吧，<br>
三道题目一点思路都没有，真的就是只想得到暴力，还是最暴力的暴力，<br>
结果暴力还打挂了，明明过了样例过了自测数据，但是就上去就是使劲 WA 。<br>
正常考试处于崩溃和半放弃的状态，最后得到了 18' 的好成绩。</p>
<p>本来挺乐观的，以为和省选一样，大众分就是几十分，<br>
然而问了一波成绩发现某 Jian 200+ 。。。<br>
好吧是我凉了。</p>
<p>于是颓了一晚上，打 generals ，看敖厂长，本来想打饥荒然而被我的 XP 折服了。</p>
<h2 id="day2">Day2</h2>
<p>上午大师讲座 <del>master 牛逼</del> ，请的外国的一位教授，图灵奖获得者。<br>
这次讲座我感触很深，受益匪浅，得到了一个教训和今后的一个小目标：<br>
好好学英语。<br>
woc 英语菜狗全程懵逼啊，除了黑板上画的图什么都搞不懂。<br>
讲完后还有学生提问题的环节，看着别人和教授谈笑风生，对我就加密了一样。</p>
<p>《论常规课的重要性》</p>
<p>下午考试心态比较佛，已经清楚翻盘无望了，<br>
看了三道题后只感觉有一题可做，题意大概是这样：</p>
<p>给定一颗 n 个点的树，将其放在 m 维空间里，<br>
需要满足每两个点的曼哈顿距离与其在树上的距离相同。<br>
求出一个使 m 最小的放置方案。</p>
<p>一个维度在树上只能管一条链，题目可以转换为最小链覆盖。<br>
然而我考场上的转换方式不太一样，更复杂，每条链要去掉 lca,<br>
于是我就搞了个 dfs 去求这玩意，交上去过了 subtask1 和 subtask3 。<br>
woc? subtask3 是没有限制的，讲道理过了 subtask3 就一定可以过 subtask2 。<br>
仔细分析发现 dfs 儿子的顺序会有影响，没想出来怎么去掉这个影响，于是开始操作。<br>
我 dfs 的时候选择 size 最大的一个儿子去递归，再交，还是一样。<br>
我 dfs 的时候选择叶子数最大的一个儿子去递归，再交，还是一样。<br>
我 dfs 的时候随机选择一个儿子去递归，再交，过了 subtask1 和 subtask2 。<br>
Nice 啊综合一下呗，根据输入数据特判一下，如果是 subtask2 就随机递归，subtask3 就自然递归。<br>
成功 AC ，最后 122' 。</p>
<p>晚上贼颓，因为明天不用考试嘛，于是爆肝小游戏，都是颓过的人，细节自己想都想得出。</p>
<h2 id="day3">Day3</h2>
<p>闭幕式。</p>
<p>出题人出来讲题了，果然是吉司机（和另外一个不知名人士），<br>
题面中全是“九条可怜是个爱...的女孩子”。<br>
但正如他本人所说，这次的确没有什么麻将啊斗地主啊之类的题，<br>
整体偏向思维，没有毒瘤数据结构，没有大模拟。<br>
好吧回想起来比赛质量确实很好，可能在吉司机画的那个图像的最高点附近吧。</p>
<p>颁奖的时候就只能看着了，连个安慰奖都没摸到，自闭了。</p>
<p>中饭进哥请食堂，吃完后就回去了，<br>
高铁上巨颓，拷了两季生活大爆炸后直接开始追剧，<br>
除了中间吃泡面外就没停（包括教练过来查水表）。<br>
感觉被带进坑了。</p>
<p>常规快乐。</p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 II</title>
    <url>/2019/10/01/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20II/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p><p>Day5 to Day8.</p><h2 id="day5">Day5</h2><h3 id="考试">考试</h3><p>Nice 大夫今天又 A 掉一题！</p><p>第一题是在 DAG 上 q 个询问，每次询问一个子图的路径数量（子图点数和 O(n) ），<br>
我想了想部分分， DAG 上 DP 嘛，但是这样复杂度上界是 $ O(q m) $ ，<br>
瓶颈在于边的枚举（菊花树卡爆），然而子图的点可能很少，<br>
然后想到了更暴力的：邻接矩阵存图然后用枚举点代替枚举边，<br>
事实上邻接矩阵存不下，那就开 set （map 也行）动态加，<br>
这复杂度 $ O(q n^2 log(m)) $ 啊然而，然后我想了好久优化都没想出来，<br>
最后想着得多骗点分，于是就把两个暴力结合在了一起：<br>
每次询问比较 $ n^2 log(m) $ 和 $ m $ 哪个小就跑哪个。。。<br>
看上去很鸡肋，然而我理性分析了一波复杂度卧槽好像是 $ O(q m  log(m)) $ ，<br>
应该能骗蛮多分，于是交了，然后 A 了。。。</p><a id="more"></a>





<p>第二题又是个计数，感觉像容斥，容斥之后怎么搞就有点迷，<br>
于是写了个 dp ，手玩样例感觉没错，然而一测大样例就 WA 了，<br>
于是手玩了几组数据，才发现 dp 错了，区间相交的情况没考虑好，<br>
最后实在没思路，就打了个大暴力，有 30', 还不错（ 10 倍于前面两天的暴力分 3' ）。</p>
<p>第三题哇塞维护一棵树，一看就感觉是树剖 + 线段树或者 LCT 之类的数据结构题，<br>
然而还是不会，又敲了一发大暴力 10' 走人。。。</p>
<h3 id="讲题">讲题</h3>
<p>下午讲题，一看 ppt 下面一行字：--Claris<br>
woc 今天见到真人了，那位 bzoj 4000+ ac 的神仙！<br>
第一题正解是按度数大小关系连边，出题人说数据难造所以有这种带 log 的算法卡过去了。<br>
第二题果然是容斥，但是要通过一个奇妙的矩形构造转换为轮廓线 DP 。<br>
第三题出题人说并不是数据结构题？blabla 讲了一堆奇妙的做法，<br>
然而有 4 个人用动态 DP 搞过去了，出题人想到了这一点还特意去卡了但是没卡掉。</p>
<h3 id="颓废">颓废</h3>
<p>昨天没吃成必胜客来着，今天再次尝试，又剁一波手。<br>
晚上真是诸事不利，tmd 这笔记本真的让人心累，<br>
要啥没啥，网连续断了好几次，还真就不是网的问题，众人不断就我断，<br>
什么 u 盘硬盘全没用，放我电脑上就读不到，<br>
蓝牙更是做梦，键盘只能插线就算了还一老读不到，<br>
还什么显像管出问题？动不动一些地方就全是红色的跟看恐怖片似的，<br>
说优点倒也有，用个电脑火炉都省了，贼发热，那电风扇的声音时刻提醒你它还活着，<br>
它要是太烫了还会自动关机，把你烤热了再降降温，贴心，<br>
放歌听也很棒，我听快歌，它就一卡一卡的，一个字一个字给你放，根本不用怕听不清。<br>
还能智能存储电量，充电线一拔就晓得要存储电量直接断电，不插上充电线不给开机，保证电池里的电永远满的。<br>
别的什么还有一堆，懒得喷了，难受。</p>
<h2 id="day6">Day6</h2>
<h3 id="考试-1">考试</h3>
<p>前两天把 rp 用完了，今天全暴力都写挂。</p>
<p>第一题我一开始推出个错误的结论，然后一想可以离线排序询问再预处理 dist 根据询问不断删除，删除不好搞换成加边弄个并查集维护联通块，<br>
然而代码打完后一跑样例， WA 了，手玩样例才发现结论错了，这时候已经 9:30 了，凉凉，后面两题还没看。<br>
最后打了大暴力 10'。</p>
<p>第二题题读到一半就感觉是二分，读完题后推了一下发现可以转换成这样一个模型：<br>
二维平面上给定 n 个点，每次将一条平行于 y 轴的直线右边的点都向上平移 dy 单位并回答所有点的斜率 (y / x) 的最大值。<br>
然后就有了 $ o(n^2) $ 的暴力做法，这玩意一脸可以优化的样子，然而想了好久没思路，就交了 60' 。</p>
<p>第三题网格图 DAG, 感觉像要 dp ？但是不会，就打了暴力，结果还打挂了 RE ，爆零。</p>
<h3 id="讲题-1">讲题</h3>
<p>第一题什么神仙 dp $ O(n^4) $ 过 100 可还行，我太菜了没搞懂这个 dp ，<br>
但是出题人提到有枚举端点 + 组合数的做法，我想去看看，一看哇塞简单多了，<br>
而且复杂度优秀的 $ O(n^3) $ ，下午按照这个作法改了一段时间就 A 了（<del>期间没开 long long 一直爆炸</del>）。</p>
<p>第二题好像是可以从我那个模型再转换一下后分块 + 凸包维护，感觉很神仙。</p>
<p>第三题有个神奇的结论：<br>
用两个不同的顺序得到的 dfs 后序，u 可以到 v 当且仅当 v 的两个 dfs 序都比 u 的小。<br>
然后就可以将点按一个 dfs 序排序后按颜色设状态 dp, 把 dp 数组扔进树状数组后得出答案。</p>
<h3 id="颓废-1">颓废</h3>
<p>晚饭兰州拉面，清真的店子就是讲究，还贼好吃。 晚上感觉屁事没干，教练发了一套题要我们做（考试的题都改不完啊），<br>
实在不想做，反正明天收，晚上就几乎一直在颓，找歌听。</p>
<h2 id="day7">Day7</h2>
<h3 id="考试-2">考试</h3>
<p>100 % 纯暴力的一天。</p>
<p>第一题神仙计数题？好难啊感觉，于是想了想了 k 小于等于 3 会不会有什么规律可循，<br>
发现 k = 1 的时候就是 $ 2^{n-1} $ ，就得到了 1 分的好成绩（这分给的真少）。<br>
然后再手玩了一下 k = 2 和 k = 3 的情况，找到了一种计数方式，过了样例，就交了，<br>
然并卵，k = 2 和 k = 3 的情况错了，只有 1' 。</p>
<p>第二题感觉是什么 set 启发式合并，但是合并之后只能暴力搞答案，<br>
没思路，打了暴力，5 分的好成绩。</p>
<p>第三题我靠麻将小模拟大搜索题？感觉很复杂，而且到第三题也没什么时间了，<br>
于是打了一发只有字牌的特殊情况，20 分的好成绩。</p>
<h3 id="讲题-2">讲题</h3>
<p>出题人说这个题目难度是 T1 &gt;= T2 &gt;= T3 。</p>
<p>T3 果然就是搜索，先算出最大答案（就是 9 ）统计面子搭子的数量再减答案。</p>
<p>T2 线段树合并，玄学，还不会。</p>
<p>T1 真有意思，标程生成函数加一大堆什么多项式的优化之类的，复杂，没懂。<br>
但是有位大佬考试 27 分钟后就 A 了这题，出题人叫他上来讲讲，<br>
然后他就开始秀操作：<br>
“我的直觉告诉我 % n 等于 0 的方案和 % n 等于 x 的方案是一样的，然后就可以算出总方案数再除以 n 就可以......” ，<br>
然后抄起笔写出一个式子，就是总方案数，<br>
我靠这式子也贼好懂，全场都笑喷了，这大抵就是“爆踩标程”了吧，复杂度还更优秀。<br>
出题人一脸懵逼，看了眼式子无奈的说了一句好吧那就这样吧。 做法就是考虑每个排列的贡献，枚举颜色的种类再用组合数和第二类斯特灵数算出这样的排列数再乘上贡献。 时间复杂度直接实现都是 $ O(k^2) $ （ k 只有 100 ，可见标程被爆踩），<br>
把斯特灵数那部分的预处理用 NTT 优化复杂度就是 $ O(k logk) $ ，<br>
听说还可以优化到 $ O(k) $ ，不会，但对这题来讲也没必要。</p>
<h3 id="额外肝题">额外肝题</h3>
<p>教练还额外发了一套题来着。<br>
扫了遍题目，感觉第二题比较友好：<br>
交换 i, j 枚举顺序后就把那个斯特灵数求和的部分设为函数 g ，<br>
根据斯特灵数的递推，g 这玩意也是可以递推的，中间需要用到一排斯特灵数。<br>
根据斯特灵数的容斥意义 NTT 预处理一排斯特灵数即可（卧槽这不就是上午 t3 吗）。<br>
<del>代码实现中，还没打完，随时准备被打脸。</del></p>
<p><del>今天晚上竟然没有颓。</del></p>
<h2 id="day8">Day8</h2>
<p><del>咕掉了</del></p>
<h2 id="next">NEXT</h2>
<p><a href="/2019/03/29/安徽游记-iii/">Day9 to END</a></p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 I</title>
    <url>/2019/10/01/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20I/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p><p>Day0 to Day4.</p><h2 id="day0">Day0</h2><p>大清早的就出发了，地铁还是那么挤。<br>
先从长沙坐到南京，高铁上干坐 6 个小时贼贼贼贼贼无聊。</p><p>中午幸好提前买了泡面，随便应付一下，坐了一上午不动也不会感觉饿。<br>
%%% 在高铁上一餐吃 70rmb 的 lzk 。</p><p>到了南京还得等 1 小时转到芜湖，期间 UNO 现学现玩，<br>
第一把就赢了，一定是传说中的新手的欧气附体，<br>
但是这欧气来得快去的也飞快，后面再也没赢过 ，并且一度成为全场最富（一次拿了 20 张牌也是没谁了）。</p><a id="more"></a>





<p>再到动车上就累了，睡了一觉。</p>
<p>宾馆感觉一般但也还行，位置不错，旁边就是美食街，<br>
逛一遍发现芜湖的物价似乎比长沙要便宜得多？<br>
这里奶茶只有长沙一半多的价格还巨好喝，还有木桶饭最便宜 8rmb, 最贵也 16rmb, 吃得相当饱，提供的辣椒酱好评。</p>
<p>晚上宾馆自习，我的笔记本实在实在实在是太 tm 旧了 windows xp 实在实在实在是忍不了啊。<br>
宾馆的 wifi 都连不上去我怎么怎么打（kan）代（dian）码（ying）啊？？？<br>
还有我早已练就一身折腾本领，小事，关掉 XP 的沙雕代理轻松解决。<br>
但是网络实在是 suo （也许是我电脑不行？），努力了一晚上都没能成功看上电影。</p>
<h2 id="day1">Day1</h2>
<p>第一天考试，凄惨爆 0 。<br>
考试的时候想不出题啊（<del>我太菜了</del>），比较心不在焉，<br>
才发现打满暴力都是一种困难，水平不够。<br>
%　一 % 成功拿满暴力的 CZZ, orz 。</p>
<p>第一题维护区间历史最小和，玄学转换到二维平面 KD-Tree, 这玩意前几天刚考但是没去学，<br>
<del>我发现冷门算法一考就会连续考几次</del>。</p>
<p>第二题一脸不可做，题目名叫因式分解，我也就真的只会因式分解了。<br>
讲题的时候满分做法爆搜？？？好吧正解还是要个 DP 的。</p>
<p>第三题式子题妙啊妙啊，这什么用 $ _{i=0}^{n-1} A^i =  $ 把 $ A^n $ 换掉的清奇思路谁想得到啊。<br>
还有把 f(i) O(1) 一路推到 f(n) 再用组合数的奇技淫巧把 k 到 n 的枚举换成 1 到 k 谁想得到啊。</p>
<p>还有吐槽一下这套题部分分好少，几乎只有两档：暴力 -&gt; 正解。</p>
<p>然后就是晚上的 <del>自由欢乐时光</del> 认真自习。<br>
终于成功把昨天的电影看了一半。<br>
然后颓了一晚上也是没救了，没办法 T3 被卡常心态爆炸（这就是你颓废的理由？）。</p>
<h2 id="day2">Day2</h2>
<p><del>成功拿到预期的暴力分 30，一大进步。</del></p>
<p>第一题图染色，考场上脑子不清醒，很快想到 $ O(n^2) $ 的建图方式后，<br>
竟然完全没有想到怎么计数，最后 $ O(n^n) $ 枚举染色方案可还行。<br>
于是 40' -&gt; 10'</p>
<p>第二题又是一个计数，AC 自动机？我完全没想到，<br>
我还以为是容斥，但是发现有有 5 种情况，容斥起来要 5 + 10 + 10 + 5 种情况加加减减，<br>
没敢打，不过这次这题部分分给的挺全的，分了 10 个 subtask 还是不错的 ~~虽然我只拿了 20 ~~ 。</p>
<p>第三题玄学最短路，要用最短路树（我想到了但是没啥用），这玩意前几天 czz 才讲，<br>
<del>果然又应验了我昨天说的，一考就连续考几次</del><br>
暴力都很难打啊这题，到最后只能 <code>puts("-1")</code> 了，然而 subtask 数据捆绑。</p>
<p>一考完就被 *** 拉去吃什么网红烤冷面（然而是热的），very nice but 量有点少。<br>
然后 *** 就拉了一堆人去星巴克 666 ，讲真这是我第一次在星巴克喝咖啡，忍痛剁手。<br>
晚上到宾馆就开始颓，终于看完了昨天的电影 <del>壮哉我大火影</del> 。</p>
<h2 id="day3">Day3</h2>
<p>今天的题目巨难，听出题人说是因为他明天赶时间所以把明天的 <del>毒瘤</del> 题全放今天就有更多时间讲。</p>
<p>第一题在 2 * n 的网格图上求一个生成树，我想到有个类似的题（求 2n 的网格图上放一颗树的方案数），<br>
但是那道题我已经忘记怎么做了，而且那是计数，而这题是要求一个最优方案，<br>
反正就是以为可做然而 Naive, 浪费了很多时间最后打了枚举生成树的大暴力。<br>
考场上有一个线性计算当前方案的算法，枚举的时候加一点小剪枝，总复杂度应该是 $ O(6^n n) $ ， 预计 20' ，但是实际上还是只有 10' 。</p>
<p>第二题感觉是什么数据结构题，我按照一种贪心思路敲了线段树，<br>
估摸着有 23' 就没管了，后来出题人放了三个大样例，我一测，第一个就 WA 了，改了一点细节后过掉了，<br>
再测第二个，又 WA 了，然后 debug 了好久才意识到贪心的思路不对，这个时候离考试结束只有 5min, 弃疗。<br>
然后和预计的一样，3' 。</p>
<p>第三题是在一个很奇怪的图上面求最短路为 x 的点对（怎么又是最短路），<br>
大暴力就是跑出每个点对的最短路再统计嘛，这个图发现了一些性质，但是还是不会做，<br>
想着应该不难打就去打 T2 了，然后 T2 打到结束前 5min 所以这题的暴力也没打， 0' 。</p>
<p>今天的部分分还是很少，T2 T3 的暴力都只有 3' ，难受。</p>
<p>中午去一个东北菜馆吃饭，菜上的k慢但是挺好吃，很有特色，<br>
最抢眼的是收银台前面的冰箱，里面一条<strong>巨大</strong>的鱼（完整一条的可能比我还大？）。</p>
<p>下午有洛谷月赛，于是冠冕堂皇地不改题打月赛，洛谷月赛一如既往，除了签到题都只能打暴力。</p>
<p>晚上险些被查水表，我正在听歌教练突然敲门，我当时就以迅雷不及掩耳盗铃儿响叮当仁不让世界感受痛楚汉相争之势拔掉了耳机。<br>
没错，拔掉了耳机，然后 tm 就变成外放了声音贼大，当时就感觉自己真是沙雕了我去，<br>
然后我又以迅雷不及掩耳盗铃儿响叮当仁不让世界感受痛楚汉相争之势插上了耳机（被自己秀死了），这个时候教练已经差不多进来了，然后交代一些事，我耳机就插在笔记本上光明正大地摆桌上，有点小可怕，还好教练没有说什么。。。</p>
<p>从今天开始教练晚上要强制收电脑，于是 10:30 电脑被收后无所事事，<br>
这时候大家都要睡了（比如柠檬 9:30 就交电脑睡了），可是<del>万恶的</del> *** 以睡不着的名义把我拉过去打 UNO,<br>
然后我<del>只能被逼无奈地</del>去打 UNO, 到 11:30 才睡可还行。</p>
<h2 id="day4">Day4</h2>
<p>今天终于 A 了一题，今天终于 A 了一题，今天终于 A 了一题。<br>
还有 % 一 % 全场 rank1 的柠檬。</p>
<p>第一题我手玩了一下得出了一个十分精简的结论，按照这个结论三四十行代码就能解决，<br>
自己都不敢相信啊，今天终于有一道良心签到题了？<br>
于是打出来后不停地调试，手造各种情况的数据都跑一遍，把之前的结论完善一些漏洞之后就交了，<br>
交了之后还是有点慌，生怕哪里出锅。<br>
最后还是成功 AC （四天来唯一一次）。</p>
<p>第二题刚开始看题还觉得可做，感觉像扫描线加线段树那种，<br>
但是看到可能有一面墙回塌后就不这么觉得了。<br>
而且我还看错了样例，这直接导致我误解题意，本来是先选点再有墙塌（考虑方案的时候不知道哪个墙会塌），<br>
我看样例这样跑出来不对（其实是我手玩玩错了），就以为是先塌墙再选点（提前知道哪面墙会塌后考虑方案），<br>
于是 blablabla 后交上去，预计至少有个二三十来分，结果只有大暴力 3' （还好大暴力的数据没卡掉我）。</p>
<p>第三题就感觉完全不可做了，最后暴力都没打， 0' 。<br>
下午讲题的时候才发现这题 25' 的部分分贼容易，就是个排序加贪心。<br>
另外 75' 正解好像是用 dp 做前面 25' 在对后面 75' 的求和用 dp 套 dp, 好巧啊之前朱哥才讲过。</p>
<p>A 了一题心里比较舒服，于是下午就颓了好久，打 Nazo 自力更生到 level 8 就不会了，<br>
在网上找提示后玩到 level 11 后再次卡关。</p>
<p>另外碰到一件玄学的事，我那显示器一碰就断电，然后要不断地调那根线，<br>
直到调到某个位置才可以打开，大概是因为接触不良，<br>
然后一次又黑了，我调了贼久试遍了各种姿势还是然并卵，<br>
没法子了，去找老师实在不行换个位置，<br>
老师了解状况后过来随手一拨，真的是 <strong>随手一拨</strong> ，那显示屏就开了，就开了，开了，了，<br>
emm 不愧是金牌教练，真的 6 。</p>
<p>晚上本来去吃必胜客的，但是没注意到今天周日，人巨多，排队等座位都要半个小时，<br>
几经周折最后去了 KFC ，也还不错。<br>
旁边一家奶茶店搞活动，把一个计时器按到刚好 10s 就能领两大杯奶茶，然而大概是我脸黑，按了 3 次都差的蛮远。 晚上又是 UNO, 和 tyr 无意间相互精准放炮，<br>
连续两次 tyr （下家）只剩一张牌，我掐指一算，猜到了那张牌的颜色，<br>
自信地打出一张其它颜色牌，结果和他数字相同。。。</p>
<h2 id="next">NEXT</h2>
<p><a href="/2019/03/26/安徽游记-ii/">Day5 to Day8</a></p>
]]></content>
  </entry>
  <entry>
    <title>多项式的运算</title>
    <url>/2019/10/01/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="定义">定义</h2><p>简单来说，形如 $ a_0 + a_1X + a_2X^2 + ... + a_nX^n $ 的代数表达式叫做多项式， 可以记作 $ P(X) = a_0 + a_1X + a_2X^2 + ... + a_nX^n $ （系数表示法）， a 叫做多项式的系数，X 是一个不定元，不表示任何值， 不定元在多项式中最大项的次数称作多项式的次数。</p><a id="more"></a>

<h2 id="加减">加减</h2>
<p>两个多项式 a, b 的和 a + b 是一个多项式 c ，满足： $ x, c(x) = a(x) + b(x) $</p>
<p>两个多项式 a, b 的差 a - b 是一个多项式 c ，满足： $ x, c(x) = a(x) - b(x) $</p>
<p>多项式的加减十分自然，实际运算中也只需要按定义 O(n) 枚举即可。</p>
<h2 id="乘">乘</h2>
<p>两个多项式 a, b 的积 a * b 是一个多项式 c ，满足： $ x, c(x) = a(x) b(x) $</p>
<p>此时将 a, b 的系数按分配率展开求 c 的时间复杂度为 O(n * m) ， n, m 分别为 a, b 的次数，不难得出 c 的次数为 n + m 。</p>
<p>快速求多项式乘积的方法是 $ O(n log_2n) $ 的 <a href>FFT</a> 或 NTT 。</p>
<h2 id="除">除</h2>
<p>两个多项式 a, b 的商 a / b 是一个多项式 c ，满足： $ x, c(x) = a(x) / b(x) $</p>
<p>众所周知多项式除法可以列竖式求解， 这样做与乘法一样复杂度为 O(n * m) 。</p>
<h2 id="取模">取模</h2>
<p>正如整数除法会有余数，多项式除法也不一定整除， 此时 a / b 会余一个多项式 c ， 正如整数除法中余数小于除数， 此处也要满足 c 的次数小于 b 的次数以保证唯一性。</p>
<p>具体来说，对于多项式 a, b 存在唯一的多项式 c, d 满足： a = b * d + c 且 c 的次数小于 b 的次数， 便称 c 是 b 除 a 的余数，即 a 模 b 的结果， d 是 b 除 a 的商。</p>
<p>值得注意的是，当模数 b 可表示为 $ b(x) = x^k $ 时， a 模 b 相当于将 a 舍弃所有次数大于等于 k 的单项式的结果。</p>
<h2 id="逆元">逆元</h2>
<p>对于多项式 a ，其在 mod p 意义下的逆元 b 满足： a * b mod p = 1 且 b 的次数不比 a 大 （此处的 1 实际上是指只有常数项为 1 而次数为 0 的多项式）， a 的逆元通常记为 $ a^{-1} $ 或 inv(a) 。</p>
<p>那么在 mod p 意义下，有 $ a / b = a b^{-1} $ 。</p>
<h2 id="逆元的求解">逆元的求解</h2>
<p>事实上模数一般是 $ x^n $ 。</p>
<p>此时可以用分治求多项式 a 的逆元 b。</p>
<p>假设已经分治求得了 a 模 $ x^{n/2} $ （此处及以下除法表示向上取整）的逆元 c 。 那么有： <span class="math display">\[ a  \cdot  c \equiv 1 (mod \; x^{n/2}) \;\;\;\;\; (1)\]</span> 由 b 的定义可知： <span class="math display">\[ a  \cdot  b \equiv 1 (mod \; x^n) \;\;\;\;\; (2)\]</span> 转换为： <span class="math display">\[ a  \cdot  b \equiv 1 (mod \; x^{n/2}) \;\;\;\;\; (3)\]</span> (3) - (1) 得： <span class="math display">\[ b - c \equiv 0 (mod \; x^{n/2}) \;\;\;\;\; (4)\]</span> 两边同时平方得： <span class="math display">\[ b^2 - 2bc + c^2 \equiv 0 (mod \; x^n) \;\;\;\;\; (5)\]</span> 两边同时乘 a 得： <span class="math display">\[ b - 2c + c^2a \equiv 0 (mod \; x^n) \;\;\;\;\; (6)\]</span> 移项，整理： <span class="math display">\[ b = (2c - c^2a) \; mod \; x^n \]</span></p>
<ol start="4" type="1">
<li>-&gt; (5) 中模数平方的原因： 左边多项式模 $ x^{n/2} $ 为 0 代表该多项式每一项最低次数为 n / 2 + 1 。 那么该多项平方后最低次数会是 n + 1 或 n + 2 ， 模 $ x^n $ 后仍为 0 。</li>
</ol>
<p>于是乎分治，直到 n == 1 ，此时多项式的取模为一个常数，逆元也就是整数的逆元。</p>
<p>其中乘法使用 FFT ，则最终时间复杂度为 $ O(n log_2n) $ 。</p>
]]></content>
  </entry>
  <entry>
    <title>最长反链长</title>
    <url>/2019/10/01/%E6%9C%80%E9%95%BF%E5%8F%8D%E9%93%BE%E9%95%BF/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2><p>首先得知道链和反链是什么。</p><p>在 <strong>有向无环图（ DAG ）</strong> 中，<br>
链是满足任意两点 x, y 要么 x 可以到达 y 要么 y 可以到达 x 的<strong>点集</strong> （即使只有一个点），<br>
反链是任意两点没有路径的 <strong>点集</strong> 。</p><p>那么最长反链，就是点的个数最多的反链。</p><h2 id="定理">定理</h2><p>不加证明地丢出两个定理：</p><ol type="1">
<li>最长反链长度 = 最小链覆盖（用最少的链覆盖所有顶点）</li>
<li>最长链长度 = 最小反链覆盖（用最少的反链覆盖所有顶点）</li>
</ol><a id="more"></a>






<p>那么要求的其实是最小链覆盖。</p>
<h2 id="不相交">不相交</h2>
<p>假设最小链覆盖不会相交，怎么求出这个最小链覆盖？</p>
<p>把每个点 i 拆成 i1 和 i2 ，考虑建立二分图。<br>
如果存在一条边 (x, y) ，那么就在二分图中建立 (x1, y2) 的边。<br>
这样建立二分图之后，原图的点数 - 二分图最大匹配 = 原图的最小链覆盖<br>
（链不相交）。</p>
<p>这样为什么是对的呢？<br>
一个点也可以看作是一个链，因此可以将每个点独立来看做初始状态。<br>
然后每次在二分图中选出一条边，就是将两条链连接成一条链，<br>
使用的链数就减少一个。</p>
<p>而链不会相交，所以在二分图中选出的边也是不相交的，也就是二分图的最大匹配。</p>
<h2 id="栗子">栗子</h2>
<p>如果链可以相交呢？</p>
<p>举个栗子：</p>
<pre><code>5 4 // 五个点四条边
1 3 // 1 连向 3
2 3 // 2 连向 3
3 4 // 3 连向 4
3 5 // 3 连向 5</code></pre>
<p>这里不相交的最小链覆盖是 3 ，而实际的最小链覆盖是 2 。</p>
<p>观察不相交的最小链覆盖 {1-3-5, 2, 4} 与最小链覆盖 {1-3-5, 2-3-4} 。</p>
<p>发现由于不能相交， 1-3-5 这条链把 2-3-4 这条链切断了，<br>
分成 2 和 4 两条链，因此比最小链覆盖多了一条链。</p>
<p>如果可以让 2 跨过 1-3-5 与 4 相连呢？</p>
<h2 id="相交">相交</h2>
<p>将原图做一次 Floyd ，<br>
之后就可以知道任意两点 x, y ，x 是否能到达 y 。</p>
<p>把建立二分图的方法改造了一下，只要 x 能到达 y ，<br>
就直接连一条边 (x, y)，这样就可以“跨过”其它链来连接两条链了。</p>
<p>这个时候，原图最长反链长度 = 最小链覆盖 = 二分图最大匹配。</p>
]]></content>
  </entry>
  <entry>
    <title>安徽游记 III</title>
    <url>/2019/10/01/%E5%AE%89%E5%BE%BD%E6%B8%B8%E8%AE%B0%20III/</url>
    <content><![CDATA[<p>12 天的培（kao）训（shi），坚持每日总结。</p><p>Day9 to Day12.</p><h2 id="day9">Day9</h2><h3 id="考试">考试</h3><p>炸了，今天出的题好诡异。</p><p>第一题一道博弈论，题意好迷，没太看懂就去做后面的题了，<br>
到后面离考试只有 5min 了再回来看 T1, 暴力都好难打，<br>
于是信仰一波 <code>std::cout &lt;&lt; 0 &lt;&lt; std::endl</code> ，水到了 12' 。</p><a id="more"></a>





<p>第二题是给出将数组 a 变换到 b 的方式，要求用 b 求 a ，<br>
式子里面有按位或、异或、bicount 什么的，莫非是 FWT ?<br>
于是推式子，如果真的是 FWT 的话求出 a 到 b 的变换应该可以推出 b 到 a 的逆变换。<br>
于是乎我花了一个小时搞来搞去，重新推了一遍 FWT （这个式子真的 6 没办法套用常用的位运算卷积），<br>
果然可以从 a 用分治 3 个 for $ O(n log(n)) $ 变换到 b 。<br>
但是和普通的 FWT 最不一样的就是这玩意不能“蝴蝶变换”，仅从 x, y 两个数推不到新的 x, y 。<br>
woc 那我怎么解方程求逆变换？当时有点绝望了开始怀疑 FWT 做不了，<br>
又去看了看 T3 ，不可做啊似乎，于是决定爆肝 T2 。<br>
我就手玩小数据，推推式子再找找规律，搞了大概 1h 发现把 b 做一遍异或逆变换再乘二再把 b[0] 减去原来的 b[0] 好像就是 a ！<br>
我还证明了它在 n 小于 8 的正确性，然后手玩了 n = 8 时的情况，错了。。。<br>
再次绝望，想了好久大概又过了 30min 吧突然发现之前手玩算错了，我靠重新手玩，完全符合规律。<br>
<del>好嗨哟，感觉人生达到了高潮</del><br>
快速敲完 KET （ kewth 变换可还行）交了上去，结果最后爆 long long 了，爆 long long 了， long long 了，了。。。<br>
100' -&gt; 60'</p>
<p>第三题交互题，实在没思路就想着能不能卡掉他的交互器来玄学 AC ，<br>
（以下玄学操作，请勿模仿） 为此我研究了大约 40min 的 syzoj 交互原理。<br>
考场上的提交得不到反馈，我就去同样用 syzoj 的 LOJ 上试着提交一下尝试尝试。<br>
然后第一波提交， CE 。。。<br>
改了一下再次提交， wating, wating, wating....<br>
woc 无限 wating? 感觉不对经，看了看 LOJ 的评测记录，然后。。。<br>
woc 自我 CE 代码后的所有评测全是 wating 不动，当时就懵逼了 loj 被我卡爆了？<br>
事实证明只是 loj 卡了一下，过个 3min 的样子就恢复了。。。<br>
我还读了下下发的交互器，于是我搞懂了这玩意的交互原理，<br>
但是实际的交互程序是另一个程序，下发的交互器只是和你的代码一起编译后和交互程序交互，<br>
看了看交互器最后 AC 的输出，然后在 solve 函数里打了份一样的就 exit(0) ，交了。<br>
结果。。。没过，实际评测的交互器和下发的交互器完全不同。。。（但是确实可以卡，后面会说）</p>
<h3 id="讲题">讲题</h3>
<p>今天的讲题真欢乐，一位大佬屡次上台嘲讽出题人。</p>
<p>T1 就是 dp 啊，加个启发式合并状态，如果不把时间浪费在 T3 说不定能想出来的。</p>
<p>T2 不想说了，心累，在变换过程中做除法就不会爆 long long ， AC 。</p>
<p>T3 随机分治？感觉挺 6 但是没懂。<br>
但是我还是通过奇技淫巧 AC 了。。。</p>
<h3 id="爆掉这辣鸡交互">爆掉这辣鸡交互</h3>
<p>我还真不信这交互器天衣无缝，再次看交互器，<br>
交了几个错误的程序，发现我能得到的信息只有交互程序给出的信息，<br>
再蠢也不会把重要信息放提示信息里头嘛，感觉似乎没办法了。<br>
又交了一次， CE 了。。。<br>
这时转机出现了，我看了眼编译信息， woc nice 大夫 g++ 给的编译信息真详细：</p>
<pre><code>/sandbox/1/a.cpp:5:6: error: &#39;QCNT&#39; was not declared in this scope
out,QCNT,&#39;\n&#39;;
  ^
/sandbox/1/a.cpp:5:6: note: suggested alternative:
In file included from /sandbox/1/a.cpp:2:0:
/sandbox/1/c.h:74:5: note:   &#39;lkjjhkfdlhgkjdfgf5454::QCNT&#39;
int QCNT;</code></pre>
<p>note 那一排暴露啦，这命名空间 lkjjhkfdlhgkjdfgf5454 也是没谁了（另外还发现了源码的位置 /sandbox/ ）。<br>
但是出题人以为套一个乱七八糟的 namespace 就没事了？<br>
然而还是被我发现了哈，于是通过这个 namespace 直接获取了交互器里存的答案，<br>
成功 AC ，辣鸡交互器。</p>
<p>看了看提交记录，我是第二个玄学 AC 的，第一个的 AC 代码提交时还没有那 sb namespace ，<br>
所以说，我是第一个发现这鬼畜 namespace 并通过它 AC 的 :)<br>
然后从我 AC 后就陆续有人玄学 AC, 代码我都看了一遍，大同小异，全是用这 sb namespace 过的（变量名、注释都跟我的长一个样），<br>
开创先河哈。</p>
<p>后面再改改就是 65B 全场最短 AC 代码。</p>
<p>后来又看了看，还有一名大佬用另一种方式爆掉了这辣鸡交互器。<br>
比我 6 多了，竟然直接搞到了交互器判 AC 的方式给写 solve 函数上了， %%% 。</p>
<p>声明：<br>
交互器确实是可以做到无法被爆破的，<br>
我今天成功爆掉交互主要原因是交互的封装方式漏洞百出，<br>
把交互的主要部分直接给 include 进来了，<br>
正确的方式是将交互的关键部分写在真正处理交互的通过输入输出交互的程序里面。<br>
去看看 loj 的交互题，把附加文件下下来，<br>
那附加文件就是封装了一下和交互器的交互方式，你不用都没关系。</p>
<h2 id="day10">Day10</h2>
<h3 id="考试-1">考试</h3>
<p>第一题乍一看要动态维护逆序对？感觉不太可做，后面直接交了暴力， 30 分。</p>
<p>第二题字符串，感觉像是贪心，但是有一些情况不好判断，<br>
最后打了字符串做状态的暴力 DP ，我估摸着复杂度是 $ O(n^3) $ ，<br>
于是就只开了 30' 的部分分的数据的大小的数组 n = 100 ，交了，果然是 30' ，<br>
然而我把数组开到 2000 （ 60' 的范围）后就过了 60' ，这。。。<br>
60' -&gt; 30' <del>论复杂度分析的重要性。</del></p>
<p>第三题式子题，乍一看似乎可做，然后简化简化简化，简化成了这样一个题意：</p>
<pre><code>在正整数范围内解方程 x * phi(x) = 2m ，m 已知。</code></pre>
<p>我一看这么简洁的式子，枚举一下 2m 的因子应该差不多了，<br>
一看数据范围： $ m ^{18} $ ，第一档暴力 10' 范围： $ m ^9 $ 。。。<br>
还多组数据，一共 100000 组。。。<br>
连暴力都过不去啊我去。<br>
最后实在没思路，就预处理了一部分 phi 再暴力去搞，结果爆零。。。</p>
<h3 id="讲题-1">讲题</h3>
<p>第一题其实真的容易，根本不要动态维护逆序对，<br>
题目要求的只是使逆序对最小的一个循环的位置，<br>
考虑一个数从最左边被扔到最右边后对逆序对数量的影响，其实是不会变的，<br>
维护这个影响的数列，那么就是要求一个最小前缀和的位置，<br>
每次修改就是交换两段区间，虽然逆序对数量会改变，但是根本不用管，相对的影响还是不变的，<br>
那这玩意一个平衡树搞上去就好了。</p>
<p>第二题我似乎摸到正解的前一半了，<br>
贪心把能直接求的字母搞出来后对于剩下的求一个字典序最大后缀好像是，<br>
<del>那这玩意一个后缀数组搞上去就好了。</del><br>
然而似乎还是要考虑一些情况，还没改出来。</p>
<p>第三题数论神仙题（我竟然以为 T3 可做），<br>
正解复杂度 $ O(log(m)) $ ，神仙做法，<br>
什么二次剩余什么欧拉定理什么质因数玄学分解都用上了，<br>
好难，出题人讲了两遍都没听懂。</p>
<h2 id="day11">Day11</h2>
<p>倒计时两天。</p>
<h2 id="考试-2">考试</h2>
<p>第一题平面图上随机游走求到 n 的期望路径？<br>
30' 高斯消元暴力分比较容易想到，其他的就没思路了，想着先去打后面的题。<br>
最后回来打 T1 的时候连高斯消元都没打出来（我太菜了）。。<del>其实是改昨天的题去了</del></p>
<p>第二题博弈题？乍一看似乎可做，然后简化简化简化，简化成了这样一个题意：</p>
<p>给定数列 a, b, c, 选 a 中的 x 个数替换成任意数使得 $ i: a_{i-1} + b_{i-1} a_i a_{i-1} + c_{i-1} $ 求最小的 x 。</p>
<p>然后这玩意 $ O(n^2) $ DP 嘛 $ O(n) $ 状态 $ O(n) $ 转移，<br>
我以为可以得 10' + 20' + 30' 三个子任务的分，<br>
结果 subtask2 的数据范围比 subtask3 大，但是是一个特殊情况，判掉就好了，我没打。。。<br>
60' -&gt; 40'</p>
<p>第三题没思路，暴力枚举行枚举列枚举每个位置 24k 纯暴力，拿到了 40' 的好成绩。</p>
<h2 id="讲题-2">讲题</h2>
<p>第一题解方程线性代数 blabla, 但是看了看 Rank1 的代码，<br>
发现就是一个矩阵乘法，卧槽 $ O(n^3) $ 过 3000 ？<br>
经 *** 分析，平面图上的边数是 $ O(n) $ （最大是 3n - 6 ），<br>
所以高斯消元里的矩阵的点数是 $ O(n）$ 的，<br>
然后就可以根据之前 pics 讲过的方法 $ O(n) $ 做矩阵乘法（ n * n 的矩阵与列向量相乘），<br>
做 n 遍，复杂度 $ O(n^2) $ 。</p>
<p>第二题似乎是最难的，我挂到 40' 都能是全场 rank1 。。。<br>
难点主要在简化题意上，简化后出题人说这就是个普及题了（ woc 我是不是不适合学信息），<br>
DP 可以优化，设一些坐标搞到平面上后将转移用线段树维护优化到 $ O(log(n)) $ ，<br>
但是把所有点对应到平面后，还有种更简单的做法就是求出最长下降子序列 x, 答案就是 n - x 。<br>
这个结论的证明折腾了一下午，还是很妙的。</p>
<p>第三题暴力优化 dfs 可以水 90 分？<br>
正解先枚举行再筛选列将单调性用桶存起来再转移大概是，正在改。</p>
<h2 id="爆肝-splay">爆肝 Splay</h2>
<p>这三天都在爆肝 Splay, 突然又对 Splay 的翻转操作有了更深的理解，<br>
也发现 Splay 真不是那么万能的，许多操作用 Splay 做会多一些不必要的麻烦，<br>
尤其是维护不对称信息还要带区间翻转的时候，似乎根本做不了？<br>
硬要做的话就必须强制让维护的信息对称，<br>
比如要是维护最大前缀和，要支持区间翻转就得还同时维护个最大后缀和。<br>
不说了，去他的信仰，正在学无旋 Treap 。</p>
<h2 id="day12">Day12</h2>
<p>最后一天。</p>
<h3 id="考试-3">考试</h3>
<p>第一题已看完题 woc 这不就解方程嘛，手动消消元什么的就行了，<br>
出题人这么良心？于是就开始打，打完后测了测样例， woc 过了。<br>
再把大样例下下来一看， woc 出题人这么良心每道题 5 组大样例？<br>
全都测了一遍，全过了，交了，这个时候考试开始 59min 12s 。。。<br>
但是还是很荒，担心会写炸，然后就对着代码检查检查改了几个细节，<br>
改着改着又测了测时间， woc 要跑 0.9s+ ，这不会被卡常吧？<br>
又慌了起来，但是出题人说不会卡常，还下发了 io 模板，<br>
套上 io 模板后再测 0.2s+ ，松了口气，最后交了一次，<br>
这时候考试开始 101min 15s 。。。<br>
考完后看了下，其实我第一次交就 AC 了，白折腾这么久。。。</p>
<p>第二题神奇题，打了个暴力，期望 60' ，<br>
感觉可以把状态放平面上通过单调性什么之类的优化，<br>
但是没有具体的优化方案（我的计算几何真的是一片空白），<br>
结果最后暴力挂了？只有 10' 啊后面 50' 全 WA 了我一脸懵逼。<br>
还在找错。</p>
<p>第三题哇神仙题，一看就不可做的那种，打完暴力后挣扎了一下，<br>
得到了 30' 的好成绩。</p>
<h3 id="讲题-3">讲题</h3>
<p>今天又被爆踩了，T1 A 了一片，拉不开差距。</p>
<p>第二题果然是计算几何神仙题，什么凸包二分三分，什么半平面交，什么李超线段树。<br>
完全不会，只能等我计算几何基础打好后再来重做这题了。</p>
<p>第三题出题人说打表找规律题？反正我是没看出什么规律，<br>
然后出题人证明了一些结论，有这些结论就能 50 行内解决这题了，<br>
正在试图独立证明这些结论。。。</p>
<h3 id="爆肝-treap">爆肝 Treap</h3>
<p>写完暴力自闭之后就滚去学无旋 Treap 了， 看懂后感觉这 split + merge 的操作很 6 。<br>
然后自己写了写，过程中学到一个新操作： <strong>空指针调用成员函数</strong><br>
woc 发现直接用空指针调函数就只要在函数里判一判，调用端省了无数个 if ，</p>
<p>方便死了，然后上午打完下午交了文艺平衡树，<br>
woc 全部 RE ???<br>
把数据下下来，本地跑了一下， AC 。。。<br>
woc 玄学本地 AC 提交 RE ？<br>
改了细节再交，还是全 RE ，<br>
那到洛谷 IDE 上测一下？一测， AC 。。。<br>
woc 玄学洛谷 IDE AC 提交 RE ？</p>
<p>然后 <a href="https://www.luogu.org/recordnew/lists?uid=Kewth?pid=P3391?status=?sort=0" target="_blank" rel="noopener">各种测试</a></p>
<p>最后肝到晚上，终于认识到空指针调成员函数是多么不安全的行为。。。</p>
<p>emm 最后发现 Treap 无论是速度还是码量上都没好到哪去（难道是我实现太烂？），<br>
对于文艺平衡树来说，无旋 Treap 略慢，代码还略长，只是空间消耗略少。</p>
<h2 id="the-end">THE END</h2>
<p>安徽芜湖 12 天，每天都很充实，虽然也有遗憾。</p>
<p>HNOI 2019, RP ++.</p>
]]></content>
  </entry>
</search>
