<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <link rel="alternate" href="/atom.xml" title="KeBlog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="HNFMS 现役 OIer">
<meta property="og:type" content="website">
<meta property="og:title" content="KeBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KeBlog">
<meta property="og:description" content="HNFMS 现役 OIer">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KeBlog">
<meta name="twitter:description" content="HNFMS 现役 OIer">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>KeBlog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KeBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">The OI Blog of Kewth</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-about">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    
      
      
        
      
        
      
        
          
        
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">26</span></a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    
      
      
        
      
        
          
        
      
        
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">2</span></a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    
      
      
        
          
        
      
        
      
        
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">35</span></a>

  </li>
      
    
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/搬迁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/10/搬迁/" class="post-title-link" itemprop="url">搬迁</a>
          
        </h2>

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-10 19:00:00" itemprop="dateCreated datePublished" datetime="2019-10-10T19:00:00+08:00">2019-10-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-13 20:25:12" itemprop="dateModified" datetime="2019-10-13T20:25:12+08:00">2019-10-13</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
没什么好说的，动态博客用烦了，搞了好多花里胡哨的东西，  
还是沉下心来，好好写博客，  
既然如此，就不打算做什么美化了，基本能用就行，勿喷。

另外 hexo 的公式渲染有点 shit ，哪里的公式挂了还请提醒。

~~可是我控制不住我记几啊，总感觉不顺眼，实在忍不住去折腾 QwQ~~

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/二次剩余/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/21/二次剩余/" class="post-title-link" itemprop="url">二次剩余</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-21 20:10:01" itemprop="dateCreated datePublished" datetime="2019-10-21T20:10:01+08:00">2019-10-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-23 19:18:31" itemprop="dateModified" datetime="2019-10-23T19:18:31+08:00">2019-10-23</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
二次剩余，~~俗称模意义开根~~。  
也就是对于常数 $n$ 解这样一个方程：

$$x^2 \equiv n \\; (mod \\; p)$$

这里只介绍模数 $p$ 为奇素数的解法，也就是 Cipolla 算法。

以下运算皆指模 $p$ 意义下的运算。

## 解的数量

严格来讲，非 0 数 $n$ 是二次剩余当且仅当方程 $x^2 \equiv n$ 有解，也就是能开根。  
上述方程无解的非 0 数 $n$ 称作非二次剩余。

对于二次剩余 $n$ ，$x^2 \equiv n$ 有多少解？

假设有多组解，对于任意两个不相等的解 $x_0, x_1$ ，有 $x_0^2 \equiv x_1^2$ 。  
移项后平方差，得到 $(x_0 - x_1)(x_0 + x_1) \equiv 0$ 。

由于 $p$ 是奇素数，且 $x_0 \ne x_1$ ， $x_0 - x_1$ 在模 $p$ 意义下是不会为 0 的。  
故有 $x_0 + x_1 \equiv 0$ ，也就是说两个不相等的解一定是相反数，  
换言之，该方程只有两个解，且它们互为相反数。  
而当 $p$ 为奇素数时模意义的两个相反数不会相等，因为奇偶性不同。

还可以知道，任意一对相反数都对应一个二次剩余，而且这些二次剩余是两两不同的。  
也就说二次剩余的数量恰为 $\frac{p-1}{2}$ ，其他的非 0 数都是非二次剩余，数量也是 $\frac{p-1}{2}$ 。

## 欧拉准则

如何快速判断一个数 $n$ 是否为二次剩余？

以下讨论假定 n 不为 0 。

观察费马小定理 $n^{p-1} \equiv 1$ ，由于 $p$ 是奇素数，可以得到 $n^{2(\frac{p-1}{2})} - 1\equiv 0$ ，  
也就是说 $n^{\frac{p-1}{2}}$ 是 1 开根的结果，根据上面所说， 1 开根只有两个解 1 和 -1 。  
那么 $n^{\frac{p-1}{2}}$ 只能是 1 或 -1 。

若 $n$ 是二次剩余，则有 $n^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv x^{p-1} \equiv 1$ 。

若 $n^{\frac{p-1}{2}} \equiv 1$ ，将 $n$ 表示为 $g^k$ ， 其中 $g$ 是模 $p$ 意义下的原根。  
那么有 $g^{k\frac{p-1}{2}} \equiv 1$ 由于 $g$ 是原根，必有 $p-1|k\frac{p-1}{2}$ ，  
也就是说 $k$ 一定是偶数，那么令 $x \equiv g^{\frac{k}{2}}$ 即是 $n$ 开根的结果，这说明 $n$ 是二次剩余。

也就是说 $n^{\frac{p-1}{2}} \equiv 1$ 与 $n$ 是二次剩余是等价的，  
由于 $n^{\frac{p-1}{2}}$ 不为 1 是只能是 -1 ，那么 $n^{frac{p-1}{2}} \equiv -1$ 与 $n$ 是非二次剩余等价。

*ps: 网上一堆伪证说若 $n$ 是非二次剩余，不存在 $x$ 使得上式为 1 ，但这只能说明上式为 -1 时 $n$ 是非二次剩余，并不能推翻“当 $n$ 是非二次剩余时上式为 1”*

## Cipolla

对于二次剩余解方程 $x^2 \equiv n$ 。

找到一个 $a$ 满足 $a^2 - n$ 是非二次剩余，由于非二次剩余的数量接近 $\frac{p}{2}$ ，  
通过随机 + 检验的方式期望约 2 次可以找到这样一个 $a$ 。

接下来定义 $i^2 \equiv a^2 - n$ 。  
但是 $a^2 - n$ 不是二次剩余，怎么找得到这样一个 $i$ ？

类比实数域到复数域的推广，定义这样一个 $i$ ，然后可以将所有数表示为 $A+Bi$ 的形式，  
其中 $A, B$ 都是模 $p$ 意义下的数，类似于实部和虚部。

那么 $(a + i)^{p+1} \equiv n$ ，考虑证明。

**引理 1** ： $i^p \equiv -i$ 。

证明： $i^p \equiv i(i^2)^{\frac{p-1}{2}} \equiv i(a^2 - n)^{\frac{p-1}{2}} \equiv -i $

**引理 2** ： $(A + B)^p \equiv A^p + B^p$ 。

证明：二项式定理展开后，由于 $p$ 是质数，除了 $C_p^0, C_p^p$ 外的组合数分子上的阶乘没法消掉，模 $p$ 都会为 0 ，剩下来的就是 $C_p^0 A^0 B^p + C_p^p A^p B^0$ 。

现在证明上述结论：

$$(a + i)^{p+1} \equiv (a^p + i^p) (a + i) \equiv (a - i) (a + i) \equiv a^2 - i^2 \equiv n$$

那么 $(a + i)^{\frac{p+1}{2}}$ 即是一个解，其相反数是另一个解。

然而还剩最后一个问题， $(a + i)^{\frac{p+1}{2}}$ 的“虚部”一定为 0 吗？

幸运的是，的确如此，假设存在 $(A + Bi)^2 \equiv n$ 且 $B \ne 0$ ，  
那么有 $A^2 + B^2i^2 + 2ABi \equiv n$ ，即 $A^2 + B^2(a^2 - n) - n \equiv -2ABi$ 。  
式子的左边“虚部”为 0 ，那么式子右边的虚部也一定为 0 ，也就是说 $AB \equiv 0$ 。  
既然假设了 $B \ne 0$ 那么一定是 $A \equiv 0$ ，也就是说 $(Bi)^2 \equiv n$ 。  
也就是 $i^2 \equiv nB^{-2}$ ，由于 $B^2$ 是个二次剩余，其逆元 $B^{-2}$ 一定也是二次剩余，乘上二次剩余 $n$ 后一定还是二次剩余，这与 $i^2$ 是个非二次剩余产生矛盾。

## 实现

实现的时候弄个“复数”类（据说也可以不用）即可。

参考实现：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line">lolong I_mul_I; <span class="comment">// 虚数单位的平方</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">	lolong real, imag;</span><br><span class="line">	<span class="keyword">complex</span>(lolong real = <span class="number">0</span>, lolong imag = <span class="number">0</span>): real(real), imag(imag) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">complex</span> x, <span class="keyword">complex</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.real == y.real <span class="keyword">and</span> x.imag == y.imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span> * (<span class="keyword">complex</span> x, <span class="keyword">complex</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">complex</span>((x.real * y.real + I_mul_I * x.imag % mod * y.imag) % mod,</span><br><span class="line">			(x.imag * y.real + x.real * y.imag) % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">complex</span> <span class="title">power</span><span class="params">(<span class="keyword">complex</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">complex</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">		x = x * x;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_if_residue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> power(x, (mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;x0, <span class="keyword">int</span> &amp;x1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">		x0 = x1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mod = p;</span><br><span class="line"></span><br><span class="line">	lolong a = rand() % mod;</span><br><span class="line">	<span class="keyword">while</span>(!a <span class="keyword">or</span> check_if_residue((a * a + mod - n) % mod))</span><br><span class="line">		a = rand() % mod;</span><br><span class="line">	I_mul_I = (a * a + mod - n) % mod;</span><br><span class="line"></span><br><span class="line">	x0 = <span class="keyword">int</span>(power(<span class="keyword">complex</span>(a, <span class="number">1</span>), (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).real);</span><br><span class="line">	x1 = mod - x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## BSGS

值得一提的是，模意义开根（甚至可以推广到开 $k$ 次方根）是可以通过原根转换为求对数问题从而使用 BSGS 的。  
不过复杂度 $O(\sqrt{p})$ 远不如 Cipolla 的 $O(logp)$ 优秀，但很多情况下也足够了。

具体地，将 $x$ 表示为 $g^y$ ，其中 $g$ 是原根，方程变为 $(g^y)^k \equiv n$ ，即 $(g^k)^y \equiv n$ ，解出 $y$ 即可。

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/LGR-061-XR-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/20/LGR-061-XR-4/" class="post-title-link" itemprop="url">LGR-061&XR-4</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-20 18:46:05 / 修改时间：19:12:28" itemprop="dateCreated datePublished" datetime="2019-10-20T18:46:05+08:00">2019-10-20</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
开场 30min 才反应过来有场比赛。  
不知道哪来的自信就去报了 Div.1 。。。

第一次打 IOI 赛制的网络赛，感觉海星，不像 ACM 一样必须 A 题，  
打部分分的话就和平时训练的感觉一样，操作起来相对顺手。

~~但是打网络赛为什么要拿部分分呢，当然冲着 A 题去啊是吧~~

然而全场只能做出 A 题。并没有平时打 ACM 赛制的时候有签到题。  
不过还好，反正我不适合打手速题。

Skip 掉了 B （还好 Skip 掉了，后来全程肝 B 没肝出来），直接开 C 。  
发现 C 的 63' 巨水，打了个神奇剪枝交了一发，我一直感觉这玩意复杂度是 $O(np)$ 的，  
但是没用，TLE ，复杂度假了呗，虽然我并不知道原因，但觉得剩下的 37' 性价比不高，就 Skip 掉了。

提答题好评。

洛谷不支持提答题差评。

但是它给的输入文件的坐标都是有理数，小数点后面一堆数我 TM 怎么知道它的具体位置啊，在图里面标注坐标的无理数表示会死吗。。  
第一个点蛮简单的，然后第二个点就卡死了。

弃疗，回去肝 B 。

但是我觉得 B 真的难啊，好多细节？反正是没肝出来，最后 173' 狗到 rank21 。

然而这场比赛参加的人少，只有 300+ 个人打，而且好像很多流皮的人都不打洛谷月赛哦，  
所以不太理解为什么 XRound 为什么坚持在洛谷办~~（难道是 py 交易？）~~，  
平心而论对于 XR 这种比赛 CometOJ 应该是个更合适的平台。

$\color{white}{事实上，洛谷的确为办一场月赛出了不少钱，出题人的待遇比在 cf 等比赛要高}$

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/莫队二次离线/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/16/莫队二次离线/" class="post-title-link" itemprop="url">莫队二次离线</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-16 19:55:40 / 修改时间：20:42:54" itemprop="dateCreated datePublished" datetime="2019-10-16T19:55:40+08:00">2019-10-16</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
莫队算法可以通过单点增量的方式以 $O(n\sqrt{n}K)$ （认为 $n, q$ 同阶）的复杂度离线处理若干区间信息询问。  
其中每次单点增量，即每次端点移动的复杂度为 $O(K)$ 。  
大多数情况下端点移动的复杂度是 $O(1)$ 的，这样的问题一般是统计区间内的“数”。  
而统计区间内的“数对”这样的问题往往难以 $O(1)$ 处理端点移动。

莫队二次离线或许能处理这样的问题。

## 什么用

一般莫队有 $O(n\sqrt{n})$ 次端点移动，如果要用数据结构维护信息的话，  
就有 $O(n\sqrt{n})$ 次修改和 $O(n\sqrt{n})$ 次查询。

而莫队二次离线能够优化为成 $O(n)$ 次修改和 $O(n\sqrt{n})$ 次查询，  
从而允许使用一些修改复杂度大而查询复杂度小的方式来维护信息。  
例如分块，如果能 $O(\sqrt{n})$ 修改和 $O(1)$ 查询的话，总的复杂度就是 $O(n\sqrt{n})$ 。

但是有两个前提：
- 维护的信息有一定可减性，换句话说必须保证每次询问 $[l, r]$ 与 $r + 1$ 产生的贡献时，  
需要能够用 $[1, r]$ 与 $r + 1$ 产生的贡献减去（或者其他方式）$[1, l)$ 与 $r + 1$ 产生的贡献代替。
- 维护的信息有一定可加性，换句话说在每次询问前在不知道当前的 Ans 的情况下可以得到 Ans 的改变量（或某种改变方式）。


## 怎么用

考虑每次右端点右移的过程（右端点左移以及左端点移动是类似的）。

每次右端点 $r$ 从 $r_0$ 移动到 $r_1$ 时，对于其中的每一个 $r$ ，都需要查询 $[l, r - 1]$ 与该点产生的贡献。  
考虑差分，利用上面提到过的可减性，查询 $[1, r]$ 与 $r + 1$ 产生的贡献和 $[1, l)$ 与 $r + 1$ 产生的贡献。

#### Part 1

$[1, r]$ 与 $r + 1$ 产生的贡献只与 $r$ 有关，可以记为 $f_r$ 。  
那么预处理 $f_r$ 只需从小到大一个个加点维护当前的 $[1, r]$ 并询问出 $f_r$ 。  
这个过程需要 $O(n)$ 次修改和 $O(n)$ 次查询。

参考实现：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[i] 是第 i 个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	f[i] = Query(a[i]);</span><br><span class="line">	Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

另外如果需要卡常，可以将 $f$ 做一遍前缀和，这样后续查询 $[r_0, r_1]$ 总的贡献就可以 $O(1)$ 计算了（不影响复杂度）。

#### Part 2

$[1, l)$ 与 $r + 1$ 产生的贡献可以二次离线，在 $l$ 处存下 $r + 1$ 之后再考虑计算。  
这样做的空间复杂度是 $O(n\sqrt{n})$ 的，  
但事实上每次只需把 $[r_0, r_1]$ 这个区间存进 $l$ 处而不是把每个数存进去就可以做到 $O(n)$ 的空间复杂度了，  
这样询问的时候也只需求 $[r_0, r_1]$ 整体的贡献，常数上还能少一个 $O(n\sqrt{n})$ 的瓶颈。
离线处理上述的贡献，也和求 $f_r$ 的过程类似，每次从小到大一个个加点维护当前的 $[1, l)$ ，  
并对于 $l$ 处存下的每一个数逐个询问 $[1, l)$ 与其产生的贡献即可。  
这个过程需要 $O(n)$ 次修改和 $O(n\sqrt{n})$ 次查询。

参考实现：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">	<span class="keyword">int</span> L = query[i].l, R = query[i].r; <span class="comment">// 排序后的询问</span></span><br><span class="line">	<span class="keyword">if</span>(r &lt; R) &#123;</span><br><span class="line">		<span class="built_in">vector</span>[l].push_back(<span class="built_in">std</span>::make_pair(r + <span class="number">1</span>, R));</span><br><span class="line">		r = R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> par : <span class="built_in">vector</span>[i])</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = par.first; k &lt;= par.second; k ++)</span><br><span class="line">			Query(a[k]); <span class="comment">// 这里用什么东西存一下结果就好了</span></span><br><span class="line">	Modify(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/15/亚线性筛/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/15/亚线性筛/" class="post-title-link" itemprop="url">亚线性筛</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-15 17:24:07" itemprop="dateCreated datePublished" datetime="2019-10-15T17:24:07+08:00">2019-10-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-16 14:51:47" itemprop="dateModified" datetime="2019-10-16T14:51:47+08:00">2019-10-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
亚线性筛，就是以低于线性的复杂度预处理一些线性信息的筛法统称。

目前我会杜教筛和 min25 还有 powerful number。

## 杜教筛

杜教筛一般用于求一类数论函数的前缀和。

假设要求数论函数 $f(x)$ 的前缀和 $S(n) = \sum_{i=1}^n f(i)$ 。

杜教筛的关键在于构造两个合适的函数 $g, h$ 满足 $h = f \cdot g$ 。

这里的函数相乘指的是狄利克雷卷积。

#### 理论

则由 $h = f \cdot g$ 可得（以下除号表示整除）：

$$
\begin{equation}
\begin{aligned}
\sum_{i=1}^n h(i) &= \sum_{i=1}^n\sum_{d|i}f(\frac{i}{d})g(d) \\\\
&= \sum_{d=1}^ng(d)\sum_{i=d}^nf(\frac{i}{d})[i|d] \\\\
&= \sum_{d=1}^ng(d)\sum_{i=1}^{n/d}f(i) \\\\
&= \sum_{d=1}^ng(d)S(\frac{n}{d}) \\\\
&= g(1)S(n) + \sum_{d=2}^ng(d)S(\frac{n}{d}) \\\\
\end{aligned}
\end{equation}
$$

所以 $S(n) = \sum_{i=1}^n h(i) - \sum_{d=2}^n g(d)S(\frac{n}{d})$ 。

前提是每个 $\sum_{i=1}^n h(i)$ 很容易求，那么接下来不考虑 $h$ ，  
对于后面的部分可以整除分块，还需要快速求出 $g$ 的一段区间和，  
然后就可以递推，由于形如 $\lfloor\frac{n}{d}\rfloor$ 的数只有 $O(\sqrt{n})$ 个，  
可以只递推这 $O(\sqrt{n})$ 个 $S$ ，不考虑 $g, h$ 的计算复杂度，复杂度为 $O(n^{\frac{2}{3}})$ 。

关于如何存储 $S$ ，直接用数组存需要 $O(n)$ 的空间，开 map 每次取用带一个 log ，  
普通的离散化也会带一个 log 。

观察 $\frac{n}{d}$ 的分布，当 $d \leq \sqrt{n}$ 时， $\frac{n}{d}$ 的值两两不同。  
而当 $d > \sqrt{n}$ 时， $\frac{n}{d}$ 的值都不超过 $\sqrt{n}$ 。  
设 $m$ 是 $\frac{n}{d}$ 的不同取值个数，那么可以用如下的函数对 $x = \frac{n}{d}$ 进行离散化：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt;= sqrt_of_n ? x : m - (n / x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 实践

举个简单的栗子：求 $\mu$ 的前缀和。

首先根据 $\mu$ 的性质不难想到 $\mu \cdot I = \epsilon$ 。

那么就将 $f = \mu, g = I, h = \epsilon$ 代入上去，得到：

$$S(n) = \sum_{i=1}^n \mu(i) = \sum_{i=1}^n \epsilon(i) - \sum_{d=2}^n I \cdot S(\frac{n}{d})$$

即

$$S(n) = 1 - \sum_{d=2}^n S(\frac{n}{d})$$

#### 扩展

但有时候无法构造合适的 $h = f \cdot g$ 使得 $g, h$ 的前缀和可以 $O(1)$ 算出。  
这时候杜教筛是否就毫无用武之地呢？不见得。

观察递推式，利用整除分块，设 $S_f, S_g, S_h$ 分别表示 $f, g, h$ 的前缀和，那么：

$$S_f(n) = S_h(n) - \sum_{i=2}^m (S_g(r_i) - S_g(r_{i-1})) S_f(\frac{n}{r_i})$$

其中 $m$ 是 $\frac{n}{d}$ 的不同取值个数， $r_i$ 是整除分块后对应第 $i$ 块的右端点。

首先不难发现需要用到的 $S_h$ 也都是形如 $\frac{n}{d}$ 的数，  
那么只需要如果 $S_h$ 能够杜教筛（或者其他筛）筛出来就行了。

再考虑 $S_g$ 需要的取值，由整除分块中的 $r = n / (n / l)$ 可知，$r_i$ 的取值也都是形如 $\frac{n}{d}$ 的数，  
同理只要能筛 $S_g$ 就行了，不一定要 $O(1)$ 算。

## min25

min25 筛是扩展埃氏筛，也可以筛一类（更复杂的）**积性函数**的前缀和，并且通常是同类亚线性筛中最快的一个。  
而且灵活运用 min25 可以处理一些特殊的关于质因子的问题。

#### 理论

假设要求 $S(n) = \sum_{i=1}^n f(i)$ 。

min25 筛可大致分为两步。

##### Step 1

第一步处理的是 $f$ 在质数上的取值的和。  
令 $F(x) = [x \in Prime] f(x)$ ，那么这一步的目标是筛出 $F$ 的前缀和。  
准确地讲，是 $F$ 的前缀和函数 $S_F$ 在每个形如 $\frac{n}{d}$ 的数上的取值。

首先需要将 $f(i)$ 拆成若干完全积性函数的和，  
只需考虑 $F$ ，也就是 $f(p^k)$ 的取值。  
如果是关于 $p$ 的多项式，每个单项式对应的就是一个完全积性函数。

假设现在要筛一个完全积性函数 $h$ ，要能快速计算出 $S_h = \sum_{i=1}^n h(i)$ 。  
这一步的主要思想是，一个一个枚举质数 $p$ ，筛掉最小值因子为 $p$ 的合数的取值。  
而合数 $x$ 的最小质因子为 $p$ 的必要条件是 $p^2 \leq x$ ，即 $p \leq \sqrt{x}$ 。  
那么只需要枚举 $\sqrt{n}$ 以内的质数去筛即可。

假设现在筛掉了前 $i - 1$ 个质因子得到一个这个值：

$$g(n, i - 1) = \sum_{x=1}^n [x \in Prime \\; or \\; minp(x) > P_{i-1}] h(x)$$

其中 $P_i$ 表示 $\sqrt{n}$ 以内第 $i$ 个质数。

那么接下来要筛最小值因子为 $P_i$ 的数：

$$g(n, i) = g(n, i - 1) - \sum_{x=1}^n [minp(x) = P_i] h(x)$$

由于 $h$ 是完全积性函数，$P_i$ 可以直接提出来，得到：

$$
\begin{equation}
\begin{aligned}
g(n, i) &= g(n, i - 1) - h(P_i) \sum_{x=1}^{n/P_i} [minp(x) \geq P_i] h(x) \\\\
&= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{x=1}^{n/P_i} [x \in Prime \\; and \\; minp(x) < P_i] h(x)) \\\\
&= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - \sum_{j=1}^{i-1} h(P_j)) \\\\
&= g(n, i - 1) - h(P_i) (g(\frac{n}{P_i}, i - 1) - ph_{i - 1}) \\\\
\end{aligned}
\end{equation}
$$

其中 $ph_i$ 就是 $h$ 在前 $i$ 个质数上的取值和，注意 $P_i \leq \sqrt{n}$ ，这是可以直接筛的。

那么上面的式子就是 $g$ 的递推式，不难发现第一维的取值都是 $\frac{n}{d}$ 的形式，第二维可以滚动。  
直接按照递推式算，就可以在 $O(\sqrt{n} |P|)$ 的时间筛出需要的东西，也就是 $g(n, |P|)$ 。  
这还是不够的，需要优化，由于最小质因子的取值在根号以内，所以递推时只需考虑满足 $n \geq P_i^2$ 的 $g(n, i)$ 。  
当 $n < P_i^2$ 时，随着 $i$ 的增大 $g(n, i)$ 的值不会改变，由于是滚动数组，直接 skip 掉就好了。

##### Step 2

上面将每个完全积性函数的 $g(n, |P|)$ 加起来，得到 $S_F(n)$ ，表示 $f$ 在质数上的取值 $F$ 的前缀和。

仍然利用最小质因子，不同的是，上一步从所有的取值开始从小到大把对应的最小质因子的合数的贡献给删掉的到质数的取值。  
那这一步能不能反过来，从质数的取值开始，从大到小把对应的最小质因子的合数的贡献给加上最后得到所有数的取值？

并不能，事实上是从空值开始，从大到小把对应的最小质因子的数的贡献加上最后得到所有数的取值，  
合数可以递推并类似地利用积性函数的性质提出一个因子，质数则直接用上一步预处理的来算。

那么假设现在以及算上了比第 $i$ 个更大的质数为最小质因子的数的值得到了这个：

$$S(n, i) = \sum_{x=1}^n [minp(x) > P_i] f(x)$$

不难推导出：

$$S(n, i)=S_F(n) - pf_i + \sum_{P_j < P_k \leq \sqrt{n}} \sum_{e>0,P_k^e \leq n}f(P_k^e)(S(\frac{n}{P_k^e}, k) + [e>1])$$

其中 $pf_i$ 就是 $f$ 在前 $i$ 个质数上的取值和，注意 $P_i \leq \sqrt{n}$ ，这是可以直接筛的。

同样地第一维的取值都是 $\frac{n}{d}$ 的形式，但是第二维无法滚动，   
但事实上后面的部分直接递归计算即可，以下是参考实现：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lolong;</span><br><span class="line"><span class="function">lolong <span class="title">S</span><span class="params">(lolong i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(prime[j] &gt; i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	lolong res = S_F[id(i)] - pf[j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= p <span class="keyword">and</span> <span class="number">1l</span>l * prime[k] * prime[k] &lt;= i; k ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> e = <span class="number">1</span>;</span><br><span class="line">		lolong pr = prime[k];</span><br><span class="line">		<span class="keyword">while</span>(pr &lt;= i) &#123;</span><br><span class="line">			res += (prime[k] ^ e) * (S(i / pr, k) + (e &gt; <span class="number">1</span>));</span><br><span class="line">			pr *= prime[k];</span><br><span class="line">			e ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

复杂度似乎是 $O(\frac{n^{\frac{3}{4}}}{logn})$ 。

## Powerful number

这个在 OI 中用得少，我也只是做过一道题，大概提一下。

称 1 和每个质因子次数大于 1 的合数为 Powerful number 。  
首先有个性质就是 $n$ 以内的 Powerful number 数量是 $O(\sqrt{n})$ 的。

还是筛数论函数 $f$ 的前缀和 $S$ ，需要构造两个函数 $g, h$ 满足 $f = g \cdot h$ 。  
如果 $g$ 只在 Powerful number 上有值并且 $h$ 的前缀和 $S_h$ 容易求或者可以筛的话，  
由 $S(n) = \sum_{i=1}^n \sum_{d|x} g(d) h(\frac{d}{x}) = \sum_{d=1}^n G(d) S_h(n/d)$  
可以通过枚举 Powerful number 快速计算答案。

至于枚举 Powerful number 的方法，注意到 Powerful number 的质因子都是 $\sqrt{n}$ 以内的，  
这可以通过反证法证明，如果有大于 $\sqrt{n}$ 的质因子它的次数不可能超过 1 。  
那么筛出 $\sqrt{n}$ 以内的质数，再通过搜索枚举每个质数的次数即可。

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/13/cf-592div2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/13/cf-592div2/" class="post-title-link" itemprop="url">cf-592div2</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-13 21:07:10" itemprop="dateCreated datePublished" datetime="2019-10-13T21:07:10+08:00">2019-10-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-20 19:12:16" itemprop="dateModified" datetime="2019-10-20T19:12:16+08:00">2019-10-20</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
自闭。  
这大概是我打过最失败的一场比赛。

A 签到题，然而我在 14min 才 A ，我是真的不适合做手速题。

B 行数开大点就是插头 DP ，然而行数只有 2 ，插头只有 3 种，  
随便 DP 一下就行了，中间少考虑一种插头 WA 了一发，在 25min AC 。

然后，就没有然后了。

C 题解二元一次方程的整除解，woc 这不扩欧板题嘛，没想太多，直接码上去。  
然后很轻松过了样例啊，交 WA 了，哦没判负数，又交 WA 了。。。  
静态查错无果，遂对拍，拍了 1000+ 组全是 AC 。

事情好像不太对劲.jpg

skip 掉，直接开 E ，发现了个单调性，没想太多，直接码上去。  
还是很轻松过了样例啊，交 WA 了。  
静态查错无果，遂回去调 C 。

冷静分析一波后发现 C 题神 tm 会爆 long long 。  
这简单，改 int128 ，结果交 CE 了。  
然后就到网上蒯 c++ 大整数模板，贴下来后，  
样例都过不去了我天，然后我就去调那个模板，也是醉了。

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Big n = <span class="number">10</span>, x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">clog</span> &lt;&lt; n - x + x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

上面代码第一行输出 10 ，第二行输出 20 。

当时我心态就炸了，简直想去问候那个把模板贴他博客上的祖宗十八代。  
写的这玩意连加减法都算不对心里没点 B 数吗也敢往网上放。

服了，还是乖乖想不爆 long long 的解法吧。

9102 年了还有人靠爆 long long 混饭吃。  
这样明显卡语言啊，对 c++ 选手毫无公平性可言。

至于正解，自然是没想出来。

最后获得了 rank3400+ 的好成绩，掉分预定。

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/13/cometoj-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/13/cometoj-12/" class="post-title-link" itemprop="url">cometoj-12</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-13 20:27:30 / 修改时间：21:00:31" itemprop="dateCreated datePublished" datetime="2019-10-13T20:27:30+08:00">2019-10-13</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
以后打比赛写总结。

~~话说今天打到短裙好开心啊~~

A 题签到题。

为什么我第一个想的就是 O(1) 的哈希？  
表示完全没有去想好写得多的排序，而是直接把三个字符用 int 表示去搞。  
然后本地测样例玄学错误，最后发现哈希的数组开小了。  
7min 做出 A 题表示自闭。

~~真是可怕交题的时候刷新就有 40+ AC 了~~

B 题还是签到题，以为能在 5min AC 结果打了 9min ，感觉我不适合这种手速题。

然后我 C 题看都没看一眼直接 skip 掉就去开了 D 题。  
看了 3min 哇这不数位 DP 吗，现在还没人交，我还有拿一血的想法。  
然后打了出来，测样例， woc 过了，这个时候还是 4 提交 0 通过。  
我在机房大呼卧槽我要拿一血了，然后自信满满地交了上去。

成功 WA 掉所有点。

再刷新 D 题一血就已经被拿了。

然后我的心路历程是这样的：

我要拿二血。

我要拿三血。

我要拿四血。

算了我凉了还是做好长期打算拿个十血什么的吧。。。

期间各种被 master 嘲讽，各种互怼。

master 走后没人跟我说话了，然后冷静分析了一波，发现限制条件搞错了，  
然后随便搓了几行代码就 A 了。

~~所以以后打比赛要远离 master~~  
所以以后打比赛还是要在快节奏中冷静下来。

A 完 D 已经是 2h 了，回去看 C ，~~这 tm 不最短路板题嘛~~。  
然而 C 题有坑，卡了好久，最后在比赛结束前 3min rush 了一发成功 AC 。

然后靠着 4 题 + 罚时 8h 狗进 rank8 ~~拿到短裙啦~~。

这场比赛绝对是我打的最爽的一场网络赛，感觉 cometoj 的 ACM 比赛才是最刺激的，  
题目质量高，节奏快，竞争激烈，尤其是相对于 cf 和 atcoder 来说没有网速杀和题意杀。  
体验感极好。  
~~最主要的还是有短裙拿~~

然而拿短裙又没人肯女装，我还是选择拿杯子吧。。

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/11/RMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/11/RMQ/" class="post-title-link" itemprop="url">RMQ</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-11 19:00:00" itemprop="dateCreated datePublished" datetime="2019-10-11T19:00:00+08:00">2019-10-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-24 17:11:46" itemprop="dateModified" datetime="2019-10-24T17:11:46+08:00">2019-10-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
总结求各种 RMQ 的常用技巧和方法。  
RMQ 真是流皮，每次深入思考都会有新的发现，所以有了新的发现会更新。

以下 n 表示数列的大小，q 表示询问的次数，均以最大值为例。

## 一般性普通做法

线段树当然是可以在线维护的，复杂度 $O(n + qlogn)$ 。  
甚至还可以支持单点修改或区间修改。

但是如果只是静态询问的话，可以用 ST 表预处理后 $O(1)$ 在线处理询问，  
复杂度 $O(nlogn + q)$ 。

这两个做法烂大街了，是基础中的基础，不是本文讨论重点。

## 区间定长特殊做法

即所有的询问区间的长度都为与询问无关的定值 $len$ 。  
直接当做任意区间做，可以做到 $O(n + qlogn)$ 或 $O(nloglen + q)$ 。

这种情况下有更好理解的预处理方法，只需优先队列。  
先把 $[1, l]$ 的数扔进优先队列里，之后不断把区间右移，  
$[l, r]$ 右移的过程相当于加一个点 $r + 1$ 并删掉点 $l$ ，用优先队列维护即可。  
复杂度 $O(nlogn + q)$ 。

但这还不够，还有线性的预处理方法，用单调双端队列代替上面的优先队列。  
同样是让区间不断右移，单调双端队列中的值是单调不增的，
那么最左边的值一定是最大值。  
加点 $r + 1$ 前维护单调性，删点 $l$ 时判断是不是删的最大值，
如果是就删点最左边的点即可。  
复杂度 $O(n + q)$ 。

## 随机询问期望做法

这种情况下有个 $O(n + q)$ 的在线做法。

考虑分块，设块的大小为 $b$ ， $O(n)$ 预处理每个块的最大值。

那么对于询问 $[l, r]$ ，若该区间跨过了多个块，问题就分为两个部分：

1. 求跨过的块区间的最大值。
2. 求两端点所在零散的块的最大值。

第一个问题就是个子问题，并且数据规模减小到了 $O(\frac{n}{b})$ ，  
为了保证询问 $O(1)$ ，可以用上面一般性的普通做法提到的 ST 表，  
就可以 $O(\frac{n}{b} log\frac{n}{b})$ 进行预处理然后 $O(1)$ 询问。

第二个问题端点所在零散的块是该块的一段前缀或者后缀，  
只需 $O(n)$ 对于每个块预处理前缀最大值和后缀最大值即可 $O(1)$ 询问。

那么若询问区间在同一个块内呢？  
自然是暴力扫，但是这样的复杂度是 $O(b)$ 的。  
但询问区间随机的情况下，不难得出两个端点在同一个块内的概率是 $\frac{b}{n}$ 。  
那么这种情况询问的期望复杂度是 $O(\frac{b^2}{n})$ 的。

总复杂度 $O(n + \frac{n}{b} log\frac{n}{b} + q + q \frac{b^2}{n})$ 。  
当 $b$ 至少为 $O(logn)$ 时，预处理的 $O(\frac{n}{b} log\frac{n}{b})$ 不超过 $O(n)$ 。  
当 $b$ 至多为 $O(\sqrt{n})$ 时，询问的 $O(q \frac{b^2}{n})$ 不超过 $O(q)$ 。  
因此 $b$ 的大小取 $O(logn)$ 到 $O(\sqrt{n})$ 之间即可。

另外，当 $b = \sqrt{n}$ 时，块的个数也是 $O(\sqrt{n})$ 的，  
此时根本不需要 ST 表，直接 $O(\sqrt{n}^2)$ 暴力预处理处理所有可能区间的最大值即可。  
这样复杂度不变，常数可能还能小一点。

#### 毒瘤活动

值得注意的是，虽然这个做法的复杂度仅适用于询问区间随机的情况，但是一般不会卡。

来点有意思的娱乐活动，考虑怎么卡掉它，以及怎么防止被出题人卡。

想要卡这个做法就要尽量让询问区间在一个块内，卡成 $O(b)$ 的询问复杂度。  
但在不知道块的大小的情况下，假设给一个区间长 $len$ 的询问，实际块的大小为 $b$ ，  
那么两个端点在同一个块内的概率大概是 $\frac{b-len+1}{b}$ ，期望复杂度就是 $O(\frac{(b-len+1)len}{b})$ 。

现在出题人要在不知道 $b$ 的情况下希望上面的复杂度尽量大，选手要在不知道 $len$ 的情况下希望上面复杂度尽量小。  
~~怎么感觉像博弈论~~

最坏的情况是 $len = \frac{b}{2}$ 的时候，此时询问的期望复杂度为 $O(\frac{b}{4})$ 。  
选手希望预处理和询问的复杂度最大值最小，也就是让它们相等，此时 $b$ 的最优取值大致为 $2\sqrt{\frac{n}{q} logn}$ ，  
这里说是“大致”，是因为为了方便计算将 $O(log \frac{n}{b})$ 看做了 $O(logn)$ 。  
将 $n, q$ 看做同阶的话，上述取值为 $2\sqrt{logn}$ ，此时复杂度为 $O(\frac{n\sqrt{logn}}{2})$ ，  
也就是 $O(n\sqrt{logn})$ ，得出结论，在询问区间非随机的情况下，该算法最优可以做到严格 $O(n\sqrt{logn})$ 。

关键这算法常数小，还好写，取 b 为 $O(\sqrt{logn})$ 的话，复杂度 $O((n + q)\sqrt{logn})$ 在绝大多数情况都足够了。

另外，此时没必要维护块内前缀后缀最大值，因为块足够小，询问的时候对零散的块暴力扫就好了，复杂度不变。

## 一般性较优做法

自己 yy 出来的，权当过渡吧。

上面提到的 $O((n + q)\sqrt{logn})$ 算法中，通过分块将问题规模缩小到了 $\frac{n}{b}$ ，  
然后对于这个规模的问题使用 ST 表，预处理复杂度近似看做 $O(\frac{n}{b}logn)$ 。  
而既然这是个子问题，为什么还要用 ST 表？能不能继续分块直到 ST 表的预处理复杂度在 $O(n)$ 以内？

当然是可以的，这个时候块的大小又要取多少呢？  
取 $b = 2$ 就够了，这个时候，相当于从底层向上建线段树，  
第一层有 $n$ 个节点，第二层有 $\frac{n}{2}$ 个节点，第三层有 $\frac{n}{4}$ 个节点，  
直到某一层只有 $\frac{n}{logn}$ 个节点时，不再向上建线段树，而是用 ST 表维护这 $\frac{n}{logn}$ 个点，  
这样 ST 表的预处理就是 $O(n)$ 的，而此时这个线段树的树高是 $O(loglogn)$ 的。

总时间复杂度 $O(n + qloglogn)$ ，事实上层数可以再少点，使得 ST 表预处理不严格 $O(n)$ 而是与询问复杂度相当，  
但这样的话最优的层数难以计算，在此不讨论。

#### 毒瘤活动

从下向上建线段树太麻烦了，怕不是要写 zkw ，考虑从上向下建。  
由于最上面一层有 $\frac{n}{logn}$ 个节点，每个节点管辖的区间大小为 $logn$ ，  
继续考虑分块，以 $b = logn$ 为块大小分块，那么就是块内直接建满的线段树，块间维护 ST 表。

~~卧槽怎么又回到前面的做法了~~

那么这个算法事实上就是通过线段树保证了块间查询严格 $logb$ ，也就是 $loglogn$ 。

既然这样，为什么一定要用线段树呢？在每个块内依然维护 ST 表，复杂度就是 $O(nloglogn + q)$ 。

通过上面的各种讨论，相信读者已经明白分块 RMQ 的强大，以及线段树和 ST 表（尤其是后者）在 RMQ 的重要性。  
分块什么这么多东西目的基本就是去平衡 ST 表 / 线段树的询问和预处理的复杂度。

## 一般性标准做法

标准的 $O(n + q)$ RMQ 。

离线的话可以建笛卡尔树将 RMQ 转换为 LCA ，然后用 Tarjan 处理。  
明显的缺点是离线，并且空间开销较大。

在线的话，大致提一下，还是建笛卡尔树转 LCA ，然后求出树的欧拉序转为 +-1 RMQ 。  
而 +-1 RMQ 也是通过分块实现 $O(n + q)$ 复杂度的。  
整个过程较为复杂，在 OI 中实用性较低，具体做法留个坑，到时候再补。

        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/拉格朗日插值法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/10/拉格朗日插值法/" class="post-title-link" itemprop="url">拉格朗日插值法</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-10 18:00:02" itemprop="dateCreated datePublished" datetime="2019-10-10T18:00:02+08:00">2019-10-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-14 11:48:43" itemprop="dateModified" datetime="2019-10-14T11:48:43+08:00">2019-10-14</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
原来拉格朗日插值不仅能插点值，还能插系数。

## 插点值

已知函数 f(x) 上 n 个点 $(x_i, y_i)$ ，求 f(k) 。

拉格朗日插值法的思路在于：
对于每个 $(x_i, y_i)$ 找到 $L_i(x)$ 使得 $L_i(x_i) = y_i, L_i(x_j) = 0$ ，
其中 $ x_j $ 是已知的 x 中任意一个不等于 $ x_i $ 的 x 。

n 个点无法求出 f 这个函数，
但可以求出一个 n - 1 次多项式，
可以认为这个多项式近似于 f 。

而由 L 的定义可知，
这个多项式 g 满足 $ g(x) = \sum_{i=1}^n L_i(x) $ 。
那么 f(k) 就可以近似地认为是 g(k) ，
代入上式即可 $ O(n^2) $ 求解。

现在问题在于求 L 。
下面的 L 可以满足定义：

$$ L_i(x) = y_i \cdot \prod\limits_{j≠i}\frac{x_j-x}{x_j-x_i} $$

代入可得这对于任意 $ x_i $
可以使得 $ L_i(x_i)=y_i,L_i(x_j) = 0 $

## 插系数

已知多项式 f(x) 的 n 个点值，求 f(x) 。

点值比较特殊的情况下可以使用 FFT 或者 NTT ，但有失一般性。

先考虑插出一项 $x^k$ 的系数。

首先依次考虑每个 $L_i(x)$ 的 $x^k$ 系数，最后累加即可。

注意到分母和 $y_i$ 是常数可以直接算，考虑提出来，

$$ L_i(x) = (y_i \cdot \prod\limits_{j≠i}\frac{1}{x_j-x_i})
	(\prod\limits_{j≠i} (x_j - x)) $$

那么只需要算分子部分，即上式右边的 $\prod$ 的 $x^k$ 系数即可。

假设把这个连乘暴力拆开，其实 $x^k$ 的系数就是在之中选 $n - k - 1$ 个常数。  
DP 预处理 $pre(i, j)$ 表示在 $\prod\limits_{j \leq i} (x - x_j)$ 中选 k 个常数的系数和，  
同理 $suf(i, j)$ 表示在 $\prod\limits_{j \geq i} (x - x_j)$ 中选 k 个常数的系数和。  
那么把 $pre(i - 1, k)$ 和 $suf(i + 1, k)$ 相乘就是上式的 $x^k$ 系数了。

参考实现（未经过测试）：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插出 L_i(x) 的 x^k 系数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">la</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">		<span class="keyword">if</span>(i != j)</span><br><span class="line">			A *= X[i] - X[j];</span><br><span class="line">	<span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= n - k - <span class="number">1</span>; l ++)</span><br><span class="line">		B += pre[i - <span class="number">1</span>][l] * suf[i + <span class="number">1</span>][n - k - <span class="number">1</span> - l];</span><br><span class="line">	<span class="keyword">return</span> B / A * X[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 suf 和 pre */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		pre[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">			pre[i][j] = pre[i - <span class="number">1</span>][j] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i; i --) &#123;</span><br><span class="line">		suf[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i + <span class="number">1</span>; j ++)</span><br><span class="line">			suf[i][j] = suf[i + <span class="number">1</span>][j] - suf[i + <span class="number">1</span>][j - <span class="number">1</span>] * X[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/O(1)黑科技/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kewth">
      <meta itemprop="description" content="HNFMS 现役 OIer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            
            <a href="/2019/10/10/O(1)黑科技/" class="post-title-link" itemprop="url">O(1)黑科技</a>
          
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-10 18:00:01" itemprop="dateCreated datePublished" datetime="2019-10-10T18:00:01+08:00">2019-10-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-14 19:42:50" itemprop="dateModified" datetime="2019-10-14T19:42:50+08:00">2019-10-14</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
@CYJian 出了一道黑科技二合一，我就顺便跟着学了学。

## O(1) gcd

在 O(V) 的预处理后可以做到 O(1) 查询 gcd ，其中 V 是权值的大小。

主要利用到的一个性质是可以将任意 x 分解为三个数 a \* b \* c ， a, b, c 分别满足以下两个条件之一：

1. 不超过 $\sqrt{x}$ 。
2. 是质数。

update: 之前写假了，感谢 @CYJian 的 hack 。

zzq 把满足这个性质的分解称为“迷之分解”，那我也这么叫吧。

考虑证明一下，顺便构造一个“迷之分解”。

找到 x 的最小质因子 p ，然后假设已知 x / p 的“迷之分解” A, B, C (A <= b <="C)" 。 那么把 p 乘到 a 上就可以得到 x 的“迷之分解” \* p, b, c 分类讨论，如果 不超过 $\sqrt[4]{x}$ ，由于 是 a, 三者中最小的， 一定满足 $\sqrt[3]{x p}$ ，那么可得： $$a \cdot \leq \sqrt[3]{x p} \sqrt{x}$$ 而如果 超过 是最小质因子， 那么如果 的“迷之分解”有合数 ， 至少是 $p^2$ ，超过 $\sqrt{x}$ 那么 的大小就会比 小，与 是最小质因子矛盾， 因而此时 的“迷之分解”全是质数。 “迷之分解”的分析就是这样，通过线性筛可以很好预处理出 o(v) 内的所有数的“迷之分解”。 只需筛出每个数的最小质因子即可按上述方法递推出“迷之分解”。 然后只需预处理出 $o(\sqrt{v})$ 内两两的 gcd ，为了不带 log ，需要递推预处理。 此时求 gcd(x, y) 只需对于 依次对 y 求 （每次求 后把 除以该 ）， 以 为例，如果 ，直接查表可以得到 gcd(a, （查的是 gcd(a mod y, a) 否则 为质数，简单讨论一下就可以得到 了。 关键部分参考实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> magic[maxv][<span class="number">3</span>]; <span class="comment">// 每个数的“迷之分解”</span></span><br><span class="line"><span class="keyword">int</span> gcd[maxb][maxb]; <span class="comment">// 预处理的 gcd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> X = magic[x][i];</span><br><span class="line">		<span class="keyword">int</span> d;</span><br><span class="line">		<span class="keyword">if</span>(X &lt; maxb)</span><br><span class="line">			d = gcd[X][y % X];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(y % X)</span><br><span class="line">			d = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			d = X;</span><br><span class="line">		res *= d;</span><br><span class="line">		y /= d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table>

## O(1) 快速幂

在 $O(\sqrt{p})$ 的预处理后可以做到对于一个固定的底数 O(1) 查询快速幂，  
其中 p 是模数（或者上式是 $\sqrt{\phi(p)}$ ），或者是指数的范围。

这个就简单得多，对于每个 $a^k$ 的指数 k 都可以表示为 $a \sqrt{p} + b$ 的形式，  
满足 $a, b < \sqrt{p}$ ，分别预处理即可，  
即预处理 $a^0, a^1, a^2 ... a^{\sqrt{p}}, a^{2\sqrt{p}}, a^{3\sqrt{p}} ... a^p$ 。
</=>
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpeg"
      alt="Kewth">
  <p class="site-author-name" itemprop="name">Kewth</p>
  <div class="site-description" itemprop="description">HNFMS 现役 OIer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Kewth" title="GitHub &rarr; https://github.com/Kewth" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:Kewth.K.D@outlook.com" title="E-Mail &rarr; mailto:Kewth.K.D@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="qq:1344205350" title="QQ &rarr; qq:1344205350" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.luogu.org/space/show?uid=52232" title="Luogu &rarr; https://www.luogu.org/space/show?uid=52232" rel="noopener" target="_blank"><i class="fa fa-fw fa-code-fork"></i>Luogu</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links | 友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://ricardoships.github.io" title="https://ricardoships.github.io" rel="noopener" target="_blank">Ricardoships</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://luoyuyang.cf" title="https://luoyuyang.cf" rel="noopener" target="_blank">lyy</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://zrz-orz.github.io" title="https://zrz-orz.github.io" rel="noopener" target="_blank">zrz_orz</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kewth</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/muse.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  

  

  


</body>
</html>
